# id;timestamp;commentText;codeText;commentWords;codeWords
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnNonInheritedAnnotationInterface();1429829748;@since 4.2;@Test_	public void findAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnNonInheritedAnnotationInterface();1429909529;@since 4.2;@Test_	public void findAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnNonInheritedAnnotationInterface();1430075599;@since 4.2;@Test_	public void findAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnNonInheritedAnnotationInterface();1430861700;@since 4.2;@Test_	public void findAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnNonInheritedAnnotationInterface();1430864232;@since 4.2;@Test_	public void findAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnNonInheritedAnnotationInterface();1430914027;@since 4.2;@Test_	public void findAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnClassWithMetaAndLocalTxConfig();1430861700;@since 4.2;@Test_	public void findAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {_		AnnotationAttributes attributes = findAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class)__		assertNotNull("Should find @Transactional on MetaAndLocalTxConfigClass", attributes)__		assertEquals("TX qualifier for MetaAndLocalTxConfigClass.", "localTxMgr", attributes.getString("qualifier"))__	};since,4,2;test,public,void,find,annotation,attributes,on,class,with,meta,and,local,tx,config,annotation,attributes,attributes,find,annotation,attributes,meta,and,local,tx,config,class,class,transactional,class,assert,not,null,should,find,transactional,on,meta,and,local,tx,config,class,attributes,assert,equals,tx,qualifier,for,meta,and,local,tx,config,class,local,tx,mgr,attributes,get,string,qualifier
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnClassWithMetaAndLocalTxConfig();1430864232;@since 4.2;@Test_	public void findAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {_		AnnotationAttributes attributes = findAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class)__		assertNotNull("Should find @Transactional on MetaAndLocalTxConfigClass", attributes)__		assertEquals("TX qualifier for MetaAndLocalTxConfigClass.", "localTxMgr", attributes.getString("qualifier"))__	};since,4,2;test,public,void,find,annotation,attributes,on,class,with,meta,and,local,tx,config,annotation,attributes,attributes,find,annotation,attributes,meta,and,local,tx,config,class,class,transactional,class,assert,not,null,should,find,transactional,on,meta,and,local,tx,config,class,attributes,assert,equals,tx,qualifier,for,meta,and,local,tx,config,class,local,tx,mgr,attributes,get,string,qualifier
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnClassWithMetaAndLocalTxConfig();1430914027;@since 4.2;@Test_	public void findAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {_		AnnotationAttributes attributes = findAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class)__		assertNotNull("Should find @Transactional on MetaAndLocalTxConfigClass", attributes)__		assertEquals("TX qualifier for MetaAndLocalTxConfigClass.", "localTxMgr", attributes.getString("qualifier"))__	};since,4,2;test,public,void,find,annotation,attributes,on,class,with,meta,and,local,tx,config,annotation,attributes,attributes,find,annotation,attributes,meta,and,local,tx,config,class,class,transactional,class,assert,not,null,should,find,transactional,on,meta,and,local,tx,config,class,attributes,assert,equals,tx,qualifier,for,meta,and,local,tx,config,class,local,tx,mgr,attributes,get,string,qualifier
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubInheritedAnnotationInterface();1429829748;@since 4.2;@Test_	public void findAnnotationAttributesOnSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubInheritedAnnotationInterface();1429909529;@since 4.2;@Test_	public void findAnnotationAttributesOnSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubInheritedAnnotationInterface();1430075599;@since 4.2;@Test_	public void findAnnotationAttributesOnSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubInheritedAnnotationInterface();1430861700;@since 4.2;@Test_	public void findAnnotationAttributesOnSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubInheritedAnnotationInterface();1430864232;@since 4.2;@Test_	public void findAnnotationAttributesOnSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubInheritedAnnotationInterface();1430914027;@since 4.2;@Test_	public void findAnnotationAttributesOnSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException;1429829748;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handle")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNotNull("Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,abstract,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,not,null,should,find,transactional,on,concrete,class,with,inherited,annotation,handle,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException;1429909529;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handle")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNotNull("Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,abstract,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,not,null,should,find,transactional,on,concrete,class,with,inherited,annotation,handle,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException;1430075599;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handle")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNotNull("Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,abstract,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,not,null,should,find,transactional,on,concrete,class,with,inherited,annotation,handle,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException;1430861700;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handle")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNotNull("Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,abstract,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,not,null,should,find,transactional,on,concrete,class,with,inherited,annotation,handle,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException;1430864232;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handle")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNotNull("Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,abstract,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,not,null,should,find,transactional,on,concrete,class,with,inherited,annotation,handle,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException;1430914027;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handle")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNotNull("Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,abstract,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,not,null,should,find,transactional,on,concrete,class,with,inherited,annotation,handle,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1393427369;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1395766086;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1413848647;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1422118903;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1424456355;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1429745617;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1429829748;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1429909529;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1430075599;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1430861700;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1430864232;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1430914027;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1430920537;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1430930906;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", Arrays.asList("TxComposed1", "TxComposed2"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,arrays,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1431525996;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxComposed1", "TxComposed2"), attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,composed1,tx,composed2,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1432246071;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1432309594;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1432323470;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1432742110;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1432856630;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1432928160;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1432929850;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1434234880;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1438880648;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1439383081;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1440781118;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1441028924;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1444422229;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1444423887;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1444777208;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1446723029;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_			attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1446737707;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1449506174;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1456179870;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1457360547;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1458244432;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1458311365;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1458402176;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1458415324;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1458844052;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1458917994;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1459427895;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1460469837;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1472736647;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1487586848;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1487773714;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1496837955;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1497341594;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1533765167;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations();1542613849;Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}._@see org.springframework.core.env.EnvironmentSystemIntegrationTests;@Test_	public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes)__		assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"),_				attributes.get("value"))__	};note,this,functionality,is,required,by,link,org,springframework,context,annotation,profile,condition,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,multiple,composed,annotations,multi,value,map,string,object,attributes,get,all,annotation,attributes,tx,from,multiple,composed,annotations,class,assert,not,null,annotation,attributes,map,for,transactional,on,tx,from,multiple,composed,annotations,attributes,assert,equals,value,for,tx,from,multiple,composed,annotations,as,list,tx,inherited,composed,tx,composed,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnInheritedAnnotationInterface();1429745617;@since 4.2;@Test_	public void getAnnotationAttributesOnInheritedAnnotationInterface() {_		String name = Transactional.class.getName()__		AnnotationAttributes attributes = getAnnotationAttributes(InheritedAnnotationInterface.class, name)__		assertNotNull("Should find @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,inherited,annotation,interface,string,name,transactional,class,get,name,annotation,attributes,attributes,get,annotation,attributes,inherited,annotation,interface,class,name,assert,not,null,should,find,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnInheritedAnnotationInterface();1429829748;@since 4.2;@Test_	public void getAnnotationAttributesOnInheritedAnnotationInterface() {_		String name = Transactional.class.getName()__		AnnotationAttributes attributes = getAnnotationAttributes(InheritedAnnotationInterface.class, name)__		assertNotNull("Should get @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,inherited,annotation,interface,string,name,transactional,class,get,name,annotation,attributes,attributes,get,annotation,attributes,inherited,annotation,interface,class,name,assert,not,null,should,get,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnInheritedAnnotationInterface();1429909529;@since 4.2;@Test_	public void getAnnotationAttributesOnInheritedAnnotationInterface() {_		String name = Transactional.class.getName()__		AnnotationAttributes attributes = getAnnotationAttributes(InheritedAnnotationInterface.class, name)__		assertNotNull("Should get @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,inherited,annotation,interface,string,name,transactional,class,get,name,annotation,attributes,attributes,get,annotation,attributes,inherited,annotation,interface,class,name,assert,not,null,should,get,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnInheritedAnnotationInterface();1430075599;@since 4.2;@Test_	public void getAnnotationAttributesOnInheritedAnnotationInterface() {_		String name = Transactional.class.getName()__		AnnotationAttributes attributes = getAnnotationAttributes(InheritedAnnotationInterface.class, name)__		assertNotNull("Should get @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,inherited,annotation,interface,string,name,transactional,class,get,name,annotation,attributes,attributes,get,annotation,attributes,inherited,annotation,interface,class,name,assert,not,null,should,get,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnInheritedAnnotationInterface();1430861700;@since 4.2;@Test_	public void getAnnotationAttributesOnInheritedAnnotationInterface() {_		String name = Transactional.class.getName()__		AnnotationAttributes attributes = getAnnotationAttributes(InheritedAnnotationInterface.class, name)__		assertNotNull("Should get @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,inherited,annotation,interface,string,name,transactional,class,get,name,annotation,attributes,attributes,get,annotation,attributes,inherited,annotation,interface,class,name,assert,not,null,should,get,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnInheritedAnnotationInterface();1430864232;@since 4.2;@Test_	public void getAnnotationAttributesOnInheritedAnnotationInterface() {_		String name = Transactional.class.getName()__		AnnotationAttributes attributes = getAnnotationAttributes(InheritedAnnotationInterface.class, name)__		assertNotNull("Should get @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,inherited,annotation,interface,string,name,transactional,class,get,name,annotation,attributes,attributes,get,annotation,attributes,inherited,annotation,interface,class,name,assert,not,null,should,get,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnInheritedAnnotationInterface();1430914027;@since 4.2;@Test_	public void getAnnotationAttributesOnInheritedAnnotationInterface() {_		String name = Transactional.class.getName()__		AnnotationAttributes attributes = getAnnotationAttributes(InheritedAnnotationInterface.class, name)__		assertNotNull("Should get @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,inherited,annotation,interface,string,name,transactional,class,get,name,annotation,attributes,attributes,get,annotation,attributes,inherited,annotation,interface,class,name,assert,not,null,should,get,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1440781118;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		String[] expected = new String[] { "com.example.app.test" }__		Class<?> element = ComponentScanWithBasePackagesAndValueAliasClass.class__		AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class)___		assertNotNull("Should find @ComponentScan on " + element, attributes)__		assertArrayEquals("value: ", expected, attributes.getStringArray("value"))__		assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages"))__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,string,expected,new,string,com,example,app,test,class,element,component,scan,with,base,packages,and,value,alias,class,class,annotation,attributes,attributes,find,merged,annotation,attributes,element,component,scan,class,assert,not,null,should,find,component,scan,on,element,attributes,assert,array,equals,value,expected,attributes,get,string,array,value,assert,array,equals,base,packages,expected,attributes,get,string,array,base,packages
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1441028924;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		String[] expected = new String[] { "com.example.app.test" }__		Class<?> element = ComponentScanWithBasePackagesAndValueAliasClass.class__		AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class)___		assertNotNull("Should find @ComponentScan on " + element, attributes)__		assertArrayEquals("value: ", expected, attributes.getStringArray("value"))__		assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages"))__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,string,expected,new,string,com,example,app,test,class,element,component,scan,with,base,packages,and,value,alias,class,class,annotation,attributes,attributes,find,merged,annotation,attributes,element,component,scan,class,assert,not,null,should,find,component,scan,on,element,attributes,assert,array,equals,value,expected,attributes,get,string,array,value,assert,array,equals,base,packages,expected,attributes,get,string,array,base,packages
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1444422229;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		String[] expected = new String[] { "com.example.app.test" }__		Class<?> element = ComponentScanWithBasePackagesAndValueAliasClass.class__		AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class)___		assertNotNull("Should find @ComponentScan on " + element, attributes)__		assertArrayEquals("value: ", expected, attributes.getStringArray("value"))__		assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages"))__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,string,expected,new,string,com,example,app,test,class,element,component,scan,with,base,packages,and,value,alias,class,class,annotation,attributes,attributes,find,merged,annotation,attributes,element,component,scan,class,assert,not,null,should,find,component,scan,on,element,attributes,assert,array,equals,value,expected,attributes,get,string,array,value,assert,array,equals,base,packages,expected,attributes,get,string,array,base,packages
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1444423887;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		String[] expected = asArray("com.example.app.test")__		Class<?> element = ComponentScanWithBasePackagesAndValueAliasClass.class__		AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class)___		assertNotNull("Should find @ComponentScan on " + element, attributes)__		assertArrayEquals("value: ", expected, attributes.getStringArray("value"))__		assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages"))__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,string,expected,as,array,com,example,app,test,class,element,component,scan,with,base,packages,and,value,alias,class,class,annotation,attributes,attributes,find,merged,annotation,attributes,element,component,scan,class,assert,not,null,should,find,component,scan,on,element,attributes,assert,array,equals,value,expected,attributes,get,string,array,value,assert,array,equals,base,packages,expected,attributes,get,string,array,base,packages
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1444777208;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		String[] expected = asArray("com.example.app.test")__		Class<?> element = ComponentScanWithBasePackagesAndValueAliasClass.class__		AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class)___		assertNotNull("Should find @ComponentScan on " + element, attributes)__		assertArrayEquals("value: ", expected, attributes.getStringArray("value"))__		assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages"))__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,string,expected,as,array,com,example,app,test,class,element,component,scan,with,base,packages,and,value,alias,class,class,annotation,attributes,attributes,find,merged,annotation,attributes,element,component,scan,class,assert,not,null,should,find,component,scan,on,element,attributes,assert,array,equals,value,expected,attributes,get,string,array,value,assert,array,equals,base,packages,expected,attributes,get,string,array,base,packages
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1446723029;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		String[] expected = asArray("com.example.app.test")__		Class<?> element = ComponentScanWithBasePackagesAndValueAliasClass.class__		AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class)___		assertNotNull("Should find @ComponentScan on " + element, attributes)__		assertArrayEquals("value: ", expected, attributes.getStringArray("value"))__		assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages"))__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,string,expected,as,array,com,example,app,test,class,element,component,scan,with,base,packages,and,value,alias,class,class,annotation,attributes,attributes,find,merged,annotation,attributes,element,component,scan,class,assert,not,null,should,find,component,scan,on,element,attributes,assert,array,equals,value,expected,attributes,get,string,array,value,assert,array,equals,base,packages,expected,attributes,get,string,array,base,packages
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1446737707;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		String[] expected = asArray("com.example.app.test")__		Class<?> element = ComponentScanWithBasePackagesAndValueAliasClass.class__		AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class)___		assertNotNull("Should find @ComponentScan on " + element, attributes)__		assertArrayEquals("value: ", expected, attributes.getStringArray("value"))__		assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages"))__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,string,expected,as,array,com,example,app,test,class,element,component,scan,with,base,packages,and,value,alias,class,class,annotation,attributes,attributes,find,merged,annotation,attributes,element,component,scan,class,assert,not,null,should,find,component,scan,on,element,attributes,assert,array,equals,value,expected,attributes,get,string,array,value,assert,array,equals,base,packages,expected,attributes,get,string,array,base,packages
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1449506174;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		String[] expected = asArray("com.example.app.test")__		Class<?> element = ComponentScanWithBasePackagesAndValueAliasClass.class__		AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class)___		assertNotNull("Should find @ComponentScan on " + element, attributes)__		assertArrayEquals("value: ", expected, attributes.getStringArray("value"))__		assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages"))__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,string,expected,as,array,com,example,app,test,class,element,component,scan,with,base,packages,and,value,alias,class,class,annotation,attributes,attributes,find,merged,annotation,attributes,element,component,scan,class,assert,not,null,should,find,component,scan,on,element,attributes,assert,array,equals,value,expected,attributes,get,string,array,value,assert,array,equals,base,packages,expected,attributes,get,string,array,base,packages
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1456179870;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		String[] expected = asArray("com.example.app.test")__		Class<?> element = ComponentScanWithBasePackagesAndValueAliasClass.class__		AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class)___		assertNotNull("Should find @ComponentScan on " + element, attributes)__		assertArrayEquals("value: ", expected, attributes.getStringArray("value"))__		assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages"))__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,string,expected,as,array,com,example,app,test,class,element,component,scan,with,base,packages,and,value,alias,class,class,annotation,attributes,attributes,find,merged,annotation,attributes,element,component,scan,class,assert,not,null,should,find,component,scan,on,element,attributes,assert,array,equals,value,expected,attributes,get,string,array,value,assert,array,equals,base,packages,expected,attributes,get,string,array,base,packages
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1457360547;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1458244432;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1458311365;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1458402176;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1458415324;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1458844052;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1458917994;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1459427895;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1460469837;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1472736647;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1487586848;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1487773714;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1496837955;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1497341594;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1533765167;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared();1542613849;This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}_uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation_attributes since attributes may be arrays.;@Test_	public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {_		assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test")__	};this,test,ensures,that,link,annotation,utils,post,process,annotation,attributes,uses,code,object,utils,null,safe,equals,to,check,for,equality,between,annotation,attributes,since,attributes,may,be,arrays;test,public,void,find,merged,annotation,attributes,on,class,with,both,attributes,of,an,alias,pair,declared,assert,component,scan,attributes,component,scan,with,base,packages,and,value,alias,class,class,com,example,app,test
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod();1533765167;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod();1542613849;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface();1429829748;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubSubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface();1429909529;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubSubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface();1430075599;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubSubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface();1430861700;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubSubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface();1430864232;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubSubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface();1430914027;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on SubSubInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,sub,sub,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface();1429829748;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubSubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface();1429909529;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubSubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface();1430075599;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubSubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface();1430861700;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubSubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface();1430864232;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubSubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface();1430914027;@since 4.2;@Test_	public void findAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubSubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException;1429829748;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleFromInterface")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Order.class)__		assertNotNull("Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,interface,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,from,interface,annotation,attributes,attributes,find,annotation,attributes,method,order,class,assert,not,null,should,find,order,on,concrete,class,with,inherited,annotation,handle,from,interface,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException;1429909529;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleFromInterface")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Order.class)__		assertNotNull("Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,interface,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,from,interface,annotation,attributes,attributes,find,annotation,attributes,method,order,class,assert,not,null,should,find,order,on,concrete,class,with,inherited,annotation,handle,from,interface,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException;1430075599;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleFromInterface")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Order.class)__		assertNotNull("Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,interface,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,from,interface,annotation,attributes,attributes,find,annotation,attributes,method,order,class,assert,not,null,should,find,order,on,concrete,class,with,inherited,annotation,handle,from,interface,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException;1430861700;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleFromInterface")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Order.class)__		assertNotNull("Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,interface,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,from,interface,annotation,attributes,attributes,find,annotation,attributes,method,order,class,assert,not,null,should,find,order,on,concrete,class,with,inherited,annotation,handle,from,interface,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException;1430864232;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleFromInterface")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Order.class)__		assertNotNull("Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,interface,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,from,interface,annotation,attributes,attributes,find,annotation,attributes,method,order,class,assert,not,null,should,find,order,on,concrete,class,with,inherited,annotation,handle,from,interface,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException;1430914027;@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleFromInterface")__		AnnotationAttributes attributes = findAnnotationAttributes(method, Order.class)__		assertNotNull("Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,inherited,from,interface,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,from,interface,annotation,attributes,attributes,find,annotation,attributes,method,order,class,assert,not,null,should,find,order,on,concrete,class,with,inherited,annotation,handle,from,interface,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface();1429829748;@since 4.2;@Test_	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface();1429909529;@since 4.2;@Test_	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface();1430075599;@since 4.2;@Test_	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface();1430861700;@since 4.2;@Test_	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface();1430864232;@since 4.2;@Test_	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface();1430914027;@since 4.2;@Test_	public void findAnnotationAttributesOnSubNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class)__		assertNotNull("Should find @Order on SubNonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,sub,non,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,sub,non,inherited,annotation,interface,class,order,class,assert,not,null,should,find,order,on,sub,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1434234880;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1438880648;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1439383081;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1440781118;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1441028924;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1444422229;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1444423887;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1444777208;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1446723029;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1446737707;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1449506174;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1456179870;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1457360547;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1458244432;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1458311365;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1458402176;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1458415324;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1458844052;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1458917994;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1459427895;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1460469837;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1472736647;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1487586848;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1487773714;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1496837955;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1497341594;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findMergedAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null___		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,merged,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,merged,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1429829748;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1429909529;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1430075599;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1430861700;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1430864232;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1430914027;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1430920537;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1430930906;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1431525996;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1432246071;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1432309594;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1432323470;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1432742110;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1432856630;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1432928160;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException;1432929850;Bridge/bridged method setup code copied from_{@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}._@since 4.2;@Test_	public void findAnnotationAttributesFromBridgeMethod() throws NoSuchMethodException {_		Method[] methods = StringGenericParameter.class.getMethods()__		Method bridgeMethod = null__		Method bridgedMethod = null__		for (Method method : methods) {_			if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {_				if (method.getReturnType().equals(Object.class)) {_					bridgeMethod = method__				}_				else {_					bridgedMethod = method__				}_			}_		}_		assertTrue(bridgeMethod != null && bridgeMethod.isBridge())__		assertTrue(bridgedMethod != null && !bridgedMethod.isBridge())___		AnnotationAttributes attributes = findAnnotationAttributes(bridgeMethod, Order.class)__		assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes)__	};bridge,bridged,method,setup,code,copied,from,link,org,springframework,core,bridge,method,resolver,tests,test,with,generic,parameter,since,4,2;test,public,void,find,annotation,attributes,from,bridge,method,throws,no,such,method,exception,method,methods,string,generic,parameter,class,get,methods,method,bridge,method,null,method,bridged,method,null,for,method,method,methods,if,get,for,equals,method,get,name,method,get,parameter,types,0,equals,integer,class,if,method,get,return,type,equals,object,class,bridge,method,method,else,bridged,method,method,assert,true,bridge,method,null,bridge,method,is,bridge,assert,true,bridged,method,null,bridged,method,is,bridge,annotation,attributes,attributes,find,annotation,attributes,bridge,method,order,class,assert,not,null,should,find,order,on,string,generic,parameter,get,for,bridge,method,attributes
AnnotatedElementUtilsTests -> @Ignore("Permanently disabled but left in place for illustrative purposes") 	@Test 	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation();1459427895;This test should never pass, simply because Spring does not support a hybrid_approach for annotation attribute overrides with transitive implicit aliases._See SPR-13554 for details._<p>Furthermore, if you choose to execute this test, it can fail for either_the first test class or the second one (with different exceptions), depending_on the order in which the JVM returns the attribute methods via reflection.;@Ignore("Permanently disabled but left in place for illustrative purposes")_	@Test_	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {_		for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,_				HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {_			getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz)__		}_	};this,test,should,never,pass,simply,because,spring,does,not,support,a,hybrid,approach,for,annotation,attribute,overrides,with,transitive,implicit,aliases,see,spr,13554,for,details,p,furthermore,if,you,choose,to,execute,this,test,it,can,fail,for,either,the,first,test,class,or,the,second,one,with,different,exceptions,depending,on,the,order,in,which,the,jvm,returns,the,attribute,methods,via,reflection;ignore,permanently,disabled,but,left,in,place,for,illustrative,purposes,test,public,void,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,for,class,clazz,as,list,half,convention,based,and,half,aliased,composed,context,config,class,v1,class,half,convention,based,and,half,aliased,composed,context,config,class,v2,class,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,clazz
AnnotatedElementUtilsTests -> @Ignore("Permanently disabled but left in place for illustrative purposes") 	@Test 	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation();1460469837;This test should never pass, simply because Spring does not support a hybrid_approach for annotation attribute overrides with transitive implicit aliases._See SPR-13554 for details._<p>Furthermore, if you choose to execute this test, it can fail for either_the first test class or the second one (with different exceptions), depending_on the order in which the JVM returns the attribute methods via reflection.;@Ignore("Permanently disabled but left in place for illustrative purposes")_	@Test_	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {_		for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,_				HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {_			getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz)__		}_	};this,test,should,never,pass,simply,because,spring,does,not,support,a,hybrid,approach,for,annotation,attribute,overrides,with,transitive,implicit,aliases,see,spr,13554,for,details,p,furthermore,if,you,choose,to,execute,this,test,it,can,fail,for,either,the,first,test,class,or,the,second,one,with,different,exceptions,depending,on,the,order,in,which,the,jvm,returns,the,attribute,methods,via,reflection;ignore,permanently,disabled,but,left,in,place,for,illustrative,purposes,test,public,void,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,for,class,clazz,as,list,half,convention,based,and,half,aliased,composed,context,config,class,v1,class,half,convention,based,and,half,aliased,composed,context,config,class,v2,class,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,clazz
AnnotatedElementUtilsTests -> @Ignore("Permanently disabled but left in place for illustrative purposes") 	@Test 	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation();1472736647;This test should never pass, simply because Spring does not support a hybrid_approach for annotation attribute overrides with transitive implicit aliases._See SPR-13554 for details._<p>Furthermore, if you choose to execute this test, it can fail for either_the first test class or the second one (with different exceptions), depending_on the order in which the JVM returns the attribute methods via reflection.;@Ignore("Permanently disabled but left in place for illustrative purposes")_	@Test_	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {_		for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,_				HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {_			getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz)__		}_	};this,test,should,never,pass,simply,because,spring,does,not,support,a,hybrid,approach,for,annotation,attribute,overrides,with,transitive,implicit,aliases,see,spr,13554,for,details,p,furthermore,if,you,choose,to,execute,this,test,it,can,fail,for,either,the,first,test,class,or,the,second,one,with,different,exceptions,depending,on,the,order,in,which,the,jvm,returns,the,attribute,methods,via,reflection;ignore,permanently,disabled,but,left,in,place,for,illustrative,purposes,test,public,void,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,for,class,clazz,as,list,half,convention,based,and,half,aliased,composed,context,config,class,v1,class,half,convention,based,and,half,aliased,composed,context,config,class,v2,class,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,clazz
AnnotatedElementUtilsTests -> @Ignore("Permanently disabled but left in place for illustrative purposes") 	@Test 	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation();1487586848;This test should never pass, simply because Spring does not support a hybrid_approach for annotation attribute overrides with transitive implicit aliases._See SPR-13554 for details._<p>Furthermore, if you choose to execute this test, it can fail for either_the first test class or the second one (with different exceptions), depending_on the order in which the JVM returns the attribute methods via reflection.;@Ignore("Permanently disabled but left in place for illustrative purposes")_	@Test_	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {_		for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,_				HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {_			getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz)__		}_	};this,test,should,never,pass,simply,because,spring,does,not,support,a,hybrid,approach,for,annotation,attribute,overrides,with,transitive,implicit,aliases,see,spr,13554,for,details,p,furthermore,if,you,choose,to,execute,this,test,it,can,fail,for,either,the,first,test,class,or,the,second,one,with,different,exceptions,depending,on,the,order,in,which,the,jvm,returns,the,attribute,methods,via,reflection;ignore,permanently,disabled,but,left,in,place,for,illustrative,purposes,test,public,void,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,for,class,clazz,as,list,half,convention,based,and,half,aliased,composed,context,config,class,v1,class,half,convention,based,and,half,aliased,composed,context,config,class,v2,class,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,clazz
AnnotatedElementUtilsTests -> @Ignore("Permanently disabled but left in place for illustrative purposes") 	@Test 	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation();1487773714;This test should never pass, simply because Spring does not support a hybrid_approach for annotation attribute overrides with transitive implicit aliases._See SPR-13554 for details._<p>Furthermore, if you choose to execute this test, it can fail for either_the first test class or the second one (with different exceptions), depending_on the order in which the JVM returns the attribute methods via reflection.;@Ignore("Permanently disabled but left in place for illustrative purposes")_	@Test_	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {_		for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,_				HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {_			getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz)__		}_	};this,test,should,never,pass,simply,because,spring,does,not,support,a,hybrid,approach,for,annotation,attribute,overrides,with,transitive,implicit,aliases,see,spr,13554,for,details,p,furthermore,if,you,choose,to,execute,this,test,it,can,fail,for,either,the,first,test,class,or,the,second,one,with,different,exceptions,depending,on,the,order,in,which,the,jvm,returns,the,attribute,methods,via,reflection;ignore,permanently,disabled,but,left,in,place,for,illustrative,purposes,test,public,void,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,for,class,clazz,as,list,half,convention,based,and,half,aliased,composed,context,config,class,v1,class,half,convention,based,and,half,aliased,composed,context,config,class,v2,class,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,clazz
AnnotatedElementUtilsTests -> @Ignore("Permanently disabled but left in place for illustrative purposes") 	@Test 	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation();1496837955;This test should never pass, simply because Spring does not support a hybrid_approach for annotation attribute overrides with transitive implicit aliases._See SPR-13554 for details._<p>Furthermore, if you choose to execute this test, it can fail for either_the first test class or the second one (with different exceptions), depending_on the order in which the JVM returns the attribute methods via reflection.;@Ignore("Permanently disabled but left in place for illustrative purposes")_	@Test_	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {_		for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,_				HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {_			getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz)__		}_	};this,test,should,never,pass,simply,because,spring,does,not,support,a,hybrid,approach,for,annotation,attribute,overrides,with,transitive,implicit,aliases,see,spr,13554,for,details,p,furthermore,if,you,choose,to,execute,this,test,it,can,fail,for,either,the,first,test,class,or,the,second,one,with,different,exceptions,depending,on,the,order,in,which,the,jvm,returns,the,attribute,methods,via,reflection;ignore,permanently,disabled,but,left,in,place,for,illustrative,purposes,test,public,void,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,for,class,clazz,as,list,half,convention,based,and,half,aliased,composed,context,config,class,v1,class,half,convention,based,and,half,aliased,composed,context,config,class,v2,class,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,clazz
AnnotatedElementUtilsTests -> @Ignore("Permanently disabled but left in place for illustrative purposes") 	@Test 	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation();1497341594;This test should never pass, simply because Spring does not support a hybrid_approach for annotation attribute overrides with transitive implicit aliases._See SPR-13554 for details._<p>Furthermore, if you choose to execute this test, it can fail for either_the first test class or the second one (with different exceptions), depending_on the order in which the JVM returns the attribute methods via reflection.;@Ignore("Permanently disabled but left in place for illustrative purposes")_	@Test_	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {_		for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,_				HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {_			getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz)__		}_	};this,test,should,never,pass,simply,because,spring,does,not,support,a,hybrid,approach,for,annotation,attribute,overrides,with,transitive,implicit,aliases,see,spr,13554,for,details,p,furthermore,if,you,choose,to,execute,this,test,it,can,fail,for,either,the,first,test,class,or,the,second,one,with,different,exceptions,depending,on,the,order,in,which,the,jvm,returns,the,attribute,methods,via,reflection;ignore,permanently,disabled,but,left,in,place,for,illustrative,purposes,test,public,void,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,for,class,clazz,as,list,half,convention,based,and,half,aliased,composed,context,config,class,v1,class,half,convention,based,and,half,aliased,composed,context,config,class,v2,class,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,clazz
AnnotatedElementUtilsTests -> @Ignore("Permanently disabled but left in place for illustrative purposes") 	@Test 	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation();1533765167;This test should never pass, simply because Spring does not support a hybrid_approach for annotation attribute overrides with transitive implicit aliases._See SPR-13554 for details._<p>Furthermore, if you choose to execute this test, it can fail for either_the first test class or the second one (with different exceptions), depending_on the order in which the JVM returns the attribute methods via reflection.;@Ignore("Permanently disabled but left in place for illustrative purposes")_	@Test_	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {_		for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,_				HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {_			getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz)__		}_	};this,test,should,never,pass,simply,because,spring,does,not,support,a,hybrid,approach,for,annotation,attribute,overrides,with,transitive,implicit,aliases,see,spr,13554,for,details,p,furthermore,if,you,choose,to,execute,this,test,it,can,fail,for,either,the,first,test,class,or,the,second,one,with,different,exceptions,depending,on,the,order,in,which,the,jvm,returns,the,attribute,methods,via,reflection;ignore,permanently,disabled,but,left,in,place,for,illustrative,purposes,test,public,void,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,for,class,clazz,as,list,half,convention,based,and,half,aliased,composed,context,config,class,v1,class,half,convention,based,and,half,aliased,composed,context,config,class,v2,class,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,clazz
AnnotatedElementUtilsTests -> @Ignore("Permanently disabled but left in place for illustrative purposes") 	@Test 	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation();1542613849;This test should never pass, simply because Spring does not support a hybrid_approach for annotation attribute overrides with transitive implicit aliases._See SPR-13554 for details._<p>Furthermore, if you choose to execute this test, it can fail for either_the first test class or the second one (with different exceptions), depending_on the order in which the JVM returns the attribute methods via reflection.;@Ignore("Permanently disabled but left in place for illustrative purposes")_	@Test_	public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {_		for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class,_				HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {_			getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz)__		}_	};this,test,should,never,pass,simply,because,spring,does,not,support,a,hybrid,approach,for,annotation,attribute,overrides,with,transitive,implicit,aliases,see,spr,13554,for,details,p,furthermore,if,you,choose,to,execute,this,test,it,can,fail,for,either,the,first,test,class,or,the,second,one,with,different,exceptions,depending,on,the,order,in,which,the,jvm,returns,the,attribute,methods,via,reflection;ignore,permanently,disabled,but,left,in,place,for,illustrative,purposes,test,public,void,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,for,class,clazz,as,list,half,convention,based,and,half,aliased,composed,context,config,class,v1,class,half,convention,based,and,half,aliased,composed,context,config,class,v2,class,get,merged,annotation,attributes,with,half,convention,based,and,half,aliased,composed,annotation,clazz
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1393427369;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1395766086;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1413848647;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1422118903;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1424456355;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1429745617;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1429829748;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1429909529;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1430075599;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1430861700;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1430864232;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1430914027;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class,_			Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1430920537;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1430930906;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, Transactional.class.getName())__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", Arrays.asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,transactional,class,get,name,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,arrays,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1431525996;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1432246071;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1432309594;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1432323470;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1432742110;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1432856630;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1432928160;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1432929850;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1434234880;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1438880648;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1439383081;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1440781118;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1441028924;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1444422229;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1444423887;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1444777208;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1446723029;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail.__@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1446737707;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1449506174;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1456179870;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1457360547;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1458244432;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1458311365;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1458402176;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1458415324;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1458844052;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1458917994;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1459427895;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1460469837;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1472736647;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1487586848;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1487773714;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1496837955;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1497341594;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1533765167;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass();1542613849;If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then_the algorithm is accidentally picking up shadowed annotations of the same_type within the class hierarchy. Such undesirable behavior would cause the_logic in {@link org.springframework.context.annotation.ProfileCondition}_to fail._@see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass;@Test_	public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {_		MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME)__		assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes)__		assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value"))__	};if,the,value,entry,contains,both,derived,tx,config,and,tx,config,then,the,algorithm,is,accidentally,picking,up,shadowed,annotations,of,the,same,type,within,the,class,hierarchy,such,undesirable,behavior,would,cause,the,logic,in,link,org,springframework,context,annotation,profile,condition,to,fail,see,org,springframework,core,env,environment,system,integration,tests;test,public,void,get,all,annotation,attributes,on,class,with,local,annotation,that,shadows,annotation,from,superclass,multi,value,map,string,object,attributes,get,all,annotation,attributes,derived,tx,config,class,assert,not,null,annotation,attributes,map,for,transactional,on,derived,tx,config,attributes,assert,equals,value,for,derived,tx,config,as,list,derived,tx,config,attributes,get,value
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnNonInheritedAnnotationInterface();1429745617;@since 4.2;@Test_	public void getAnnotationAttributesOnNonInheritedAnnotationInterface() {_		String name = Order.class.getName()__		AnnotationAttributes attributes = getAnnotationAttributes(NonInheritedAnnotationInterface.class, name)__		assertNotNull("Should find @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,non,inherited,annotation,interface,string,name,order,class,get,name,annotation,attributes,attributes,get,annotation,attributes,non,inherited,annotation,interface,class,name,assert,not,null,should,find,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnNonInheritedAnnotationInterface();1429829748;@since 4.2;@Test_	public void getAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = getAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class.getName())__		assertNotNull("Should get @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,get,annotation,attributes,non,inherited,annotation,interface,class,order,class,get,name,assert,not,null,should,get,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnNonInheritedAnnotationInterface();1429909529;@since 4.2;@Test_	public void getAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = getAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class.getName())__		assertNotNull("Should get @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,get,annotation,attributes,non,inherited,annotation,interface,class,order,class,get,name,assert,not,null,should,get,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnNonInheritedAnnotationInterface();1430075599;@since 4.2;@Test_	public void getAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = getAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class.getName())__		assertNotNull("Should get @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,get,annotation,attributes,non,inherited,annotation,interface,class,order,class,get,name,assert,not,null,should,get,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnNonInheritedAnnotationInterface();1430861700;@since 4.2;@Test_	public void getAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = getAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class.getName())__		assertNotNull("Should get @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,get,annotation,attributes,non,inherited,annotation,interface,class,order,class,get,name,assert,not,null,should,get,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnNonInheritedAnnotationInterface();1430864232;@since 4.2;@Test_	public void getAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = getAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class.getName())__		assertNotNull("Should get @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,get,annotation,attributes,non,inherited,annotation,interface,class,order,class,get,name,assert,not,null,should,get,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void getAnnotationAttributesOnNonInheritedAnnotationInterface();1430914027;@since 4.2;@Test_	public void getAnnotationAttributesOnNonInheritedAnnotationInterface() {_		AnnotationAttributes attributes = getAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class.getName())__		assertNotNull("Should get @Order on NonInheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,get,annotation,attributes,on,non,inherited,annotation,interface,annotation,attributes,attributes,get,annotation,attributes,non,inherited,annotation,interface,class,order,class,get,name,assert,not,null,should,get,order,on,non,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1434234880;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1438880648;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1439383081;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1440781118;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1441028924;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1444422229;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1444423887;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1444777208;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1446723029;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1446737707;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1449506174;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1456179870;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1457360547;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1458244432;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1458311365;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1458402176;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1458415324;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1458844052;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1458917994;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1459427895;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1460469837;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1472736647;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1487586848;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1487773714;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1496837955;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1497341594;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}._<p>As of Spring 4.2, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method._@since 4.2;@Test_	public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,merged,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,merged,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnInheritedAnnotationInterface();1429829748;@since 4.2;@Test_	public void findAnnotationAttributesOnInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnInheritedAnnotationInterface();1429909529;@since 4.2;@Test_	public void findAnnotationAttributesOnInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnInheritedAnnotationInterface();1430075599;@since 4.2;@Test_	public void findAnnotationAttributesOnInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnInheritedAnnotationInterface();1430861700;@since 4.2;@Test_	public void findAnnotationAttributesOnInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnInheritedAnnotationInterface();1430864232;@since 4.2;@Test_	public void findAnnotationAttributesOnInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesOnInheritedAnnotationInterface();1430914027;@since 4.2;@Test_	public void findAnnotationAttributesOnInheritedAnnotationInterface() {_		AnnotationAttributes attributes = findAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class)__		assertNotNull("Should find @Transactional on InheritedAnnotationInterface", attributes)__	};since,4,2;test,public,void,find,annotation,attributes,on,inherited,annotation,interface,annotation,attributes,attributes,find,annotation,attributes,inherited,annotation,interface,class,transactional,class,assert,not,null,should,find,transactional,on,inherited,annotation,interface,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1429909529;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized() method", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1430075599;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized() method", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1430861700;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized() method", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1430864232;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized() method", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1430914027;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized() method", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1430920537;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized() method", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1430930906;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized() method", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,method,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1431525996;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1432246071;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1432309594;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1432323470;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1432742110;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1432856630;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1432928160;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
AnnotatedElementUtilsTests -> @Test 	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException;1432929850;<p>{@code AbstractClassWithInheritedAnnotation} declares {@code handleParameterized(T)}_ whereas,_{@code ConcreteClassWithInheritedAnnotation} declares {@code handleParameterized(String)}.__<p>As of Spring 4.2 RC1, {@code AnnotatedElementUtils.processWithFindSemantics()} does not resolve an_<em>equivalent</em> method in {@code AbstractClassWithInheritedAnnotation} for the <em>bridged</em>_{@code handleParameterized(String)} method.__@since 4.2;@Test_	public void findAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {_		Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class)__		AnnotationAttributes attributes = findAnnotationAttributes(method, Transactional.class)__		assertNull("Should not find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes)__	};p,code,abstract,class,with,inherited,annotation,declares,code,handle,parameterized,t,whereas,code,concrete,class,with,inherited,annotation,declares,code,handle,parameterized,string,p,as,of,spring,4,2,rc1,code,annotated,element,utils,process,with,find,semantics,does,not,resolve,an,em,equivalent,em,method,in,code,abstract,class,with,inherited,annotation,for,the,em,bridged,em,code,handle,parameterized,string,method,since,4,2;test,public,void,find,annotation,attributes,inherited,from,bridged,method,throws,no,such,method,exception,method,method,concrete,class,with,inherited,annotation,class,get,method,handle,parameterized,string,class,annotation,attributes,attributes,find,annotation,attributes,method,transactional,class,assert,null,should,not,find,transactional,on,bridged,concrete,class,with,inherited,annotation,handle,parameterized,attributes
