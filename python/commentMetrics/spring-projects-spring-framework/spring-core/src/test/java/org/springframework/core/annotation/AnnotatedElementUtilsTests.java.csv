commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Test public void getMetaAnnotationTypesOnNonAnnotatedClass() {     assertTrue(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class).isEmpty()).     assertTrue(getMetaAnnotationTypes(NonAnnotatedClass.class, TransactionalComponent.class.getName()).isEmpty()). }
false;public;0;8;;@Test public void getMetaAnnotationTypesOnClassWithMetaDepth1() {     Set<String> names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class).     assertEquals(names(Transactional.class, Component.class, Indexed.class), names).     names = getMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName()).     assertEquals(names(Transactional.class, Component.class, Indexed.class), names). }
false;public;0;8;;@Test public void getMetaAnnotationTypesOnClassWithMetaDepth2() {     Set<String> names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class).     assertEquals(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class), names).     names = getMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName()).     assertEquals(names(TransactionalComponent.class, Transactional.class, Component.class, Indexed.class), names). }
false;private;1;3;;private Set<String> names(Class<?>... classes) {     return stream(classes).map(Class::getName).collect(toSet()). }
false;public;0;4;;@Test public void hasMetaAnnotationTypesOnNonAnnotatedClass() {     assertFalse(hasMetaAnnotationTypes(NonAnnotatedClass.class, TX_NAME)). }
false;public;0;4;;@Test public void hasMetaAnnotationTypesOnClassWithMetaDepth0() {     assertFalse(hasMetaAnnotationTypes(TransactionalComponentClass.class, TransactionalComponent.class.getName())). }
false;public;0;5;;@Test public void hasMetaAnnotationTypesOnClassWithMetaDepth1() {     assertTrue(hasMetaAnnotationTypes(TransactionalComponentClass.class, TX_NAME)).     assertTrue(hasMetaAnnotationTypes(TransactionalComponentClass.class, Component.class.getName())). }
false;public;0;6;;@Test public void hasMetaAnnotationTypesOnClassWithMetaDepth2() {     assertTrue(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, TX_NAME)).     assertTrue(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, Component.class.getName())).     assertFalse(hasMetaAnnotationTypes(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())). }
false;public;0;4;;@Test public void isAnnotatedOnNonAnnotatedClass() {     assertFalse(isAnnotated(NonAnnotatedClass.class, TX_NAME)). }
false;public;0;4;;@Test public void isAnnotatedOnClassWithMetaDepth0() {     assertTrue(isAnnotated(TransactionalComponentClass.class, TransactionalComponent.class.getName())). }
false;public;0;5;;@Test public void isAnnotatedOnSubclassWithMetaDepth0() {     assertFalse("isAnnotated() does not search the class hierarchy.", isAnnotated(SubTransactionalComponentClass.class, TransactionalComponent.class.getName())). }
false;public;0;5;;@Test public void isAnnotatedOnClassWithMetaDepth1() {     assertTrue(isAnnotated(TransactionalComponentClass.class, TX_NAME)).     assertTrue(isAnnotated(TransactionalComponentClass.class, Component.class.getName())). }
false;public;0;6;;@Test public void isAnnotatedOnClassWithMetaDepth2() {     assertTrue(isAnnotated(ComposedTransactionalComponentClass.class, TX_NAME)).     assertTrue(isAnnotated(ComposedTransactionalComponentClass.class, Component.class.getName())).     assertTrue(isAnnotated(ComposedTransactionalComponentClass.class, ComposedTransactionalComponent.class.getName())). }
false;public;0;4;;@Test public void getAllAnnotationAttributesOnNonAnnotatedClass() {     assertNull(getAllAnnotationAttributes(NonAnnotatedClass.class, TX_NAME)). }
false;public;0;6;;@Test public void getAllAnnotationAttributesOnClassWithLocalAnnotation() {     MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxConfig.class, TX_NAME).     assertNotNull("Annotation attributes map for @Transactional on TxConfig", attributes).     assertEquals("value for TxConfig.", asList("TxConfig"), attributes.get("value")). }
false;public;0;6;;@Test public void getAllAnnotationAttributesOnClassWithLocalComposedAnnotationAndInheritedAnnotation() {     MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubClassWithInheritedAnnotation.class, TX_NAME).     assertNotNull("Annotation attributes map for @Transactional on SubClassWithInheritedAnnotation", attributes).     assertEquals(asList("composed2", "transactionManager"), attributes.get("qualifier")). }
false;public;0;6;;@Test public void getAllAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {     MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedAnnotation.class, TX_NAME).     assertNotNull("Annotation attributes map for @Transactional on SubSubClassWithInheritedAnnotation", attributes).     assertEquals(asList("transactionManager"), attributes.get("qualifier")). }
false;public;0;6;;@Test public void getAllAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {     MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(SubSubClassWithInheritedComposedAnnotation.class, TX_NAME).     assertNotNull("Annotation attributes map for @Transactional on SubSubClassWithInheritedComposedAnnotation", attributes).     assertEquals(asList("composed1"), attributes.get("qualifier")). }
true;public;0;6;/**  * If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then  * the algorithm is accidentally picking up shadowed annotations of the same  * type within the class hierarchy. Such undesirable behavior would cause the  * logic in {@link org.springframework.context.annotation.ProfileCondition}  * to fail.  * @see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass  */ ;/**  * If the "value" entry contains both "DerivedTxConfig" AND "TxConfig", then  * the algorithm is accidentally picking up shadowed annotations of the same  * type within the class hierarchy. Such undesirable behavior would cause the  * logic in {@link org.springframework.context.annotation.ProfileCondition}  * to fail.  * @see org.springframework.core.env.EnvironmentSystemIntegrationTests#mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass  */ @Test public void getAllAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {     MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(DerivedTxConfig.class, TX_NAME).     assertNotNull("Annotation attributes map for @Transactional on DerivedTxConfig", attributes).     assertEquals("value for DerivedTxConfig.", asList("DerivedTxConfig"), attributes.get("value")). }
true;public;0;7;/**  * Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.  * @see org.springframework.core.env.EnvironmentSystemIntegrationTests  */ ;/**  * Note: this functionality is required by {@link org.springframework.context.annotation.ProfileCondition}.  * @see org.springframework.core.env.EnvironmentSystemIntegrationTests  */ @Test public void getAllAnnotationAttributesOnClassWithMultipleComposedAnnotations() {     MultiValueMap<String, Object> attributes = getAllAnnotationAttributes(TxFromMultipleComposedAnnotations.class, TX_NAME).     assertNotNull("Annotation attributes map for @Transactional on TxFromMultipleComposedAnnotations", attributes).     assertEquals("value for TxFromMultipleComposedAnnotations.", asList("TxInheritedComposed", "TxComposed"), attributes.get("value")). }
false;public;0;10;;@Test public void getMergedAnnotationAttributesOnClassWithLocalAnnotation() {     Class<?> element = TxConfig.class.     String name = TX_NAME.     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("Annotation attributes for @Transactional on TxConfig", attributes).     assertEquals("value for TxConfig.", "TxConfig", attributes.getString("value")).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
false;public;0;10;;@Test public void getMergedAnnotationAttributesOnClassWithLocalAnnotationThatShadowsAnnotationFromSuperclass() {     Class<?> element = DerivedTxConfig.class.     String name = TX_NAME.     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("Annotation attributes for @Transactional on DerivedTxConfig", attributes).     assertEquals("value for DerivedTxConfig.", "DerivedTxConfig", attributes.getString("value")).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
false;public;0;5;;@Test public void getMergedAnnotationAttributesOnMetaCycleAnnotatedClassWithMissingTargetMetaAnnotation() {     AnnotationAttributes attributes = getMergedAnnotationAttributes(MetaCycleAnnotatedClass.class, TX_NAME).     assertNull("Should not find annotation attributes for @Transactional on MetaCycleAnnotatedClass", attributes). }
false;public;0;10;;@Test public void getMergedAnnotationAttributesFavorsLocalComposedAnnotationOverInheritedAnnotation() {     Class<?> element = SubClassWithInheritedAnnotation.class.     String name = TX_NAME.     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("AnnotationAttributes for @Transactional on SubClassWithInheritedAnnotation", attributes).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)).     assertTrue("readOnly flag for SubClassWithInheritedAnnotation.", attributes.getBoolean("readOnly")). }
false;public;0;10;;@Test public void getMergedAnnotationAttributesFavorsInheritedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {     Class<?> element = SubSubClassWithInheritedAnnotation.class.     String name = TX_NAME.     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("AnnotationAttributes for @Transactional on SubSubClassWithInheritedAnnotation", attributes).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)).     assertFalse("readOnly flag for SubSubClassWithInheritedAnnotation.", attributes.getBoolean("readOnly")). }
false;public;0;10;;@Test public void getMergedAnnotationAttributesFavorsInheritedComposedAnnotationsOverMoreLocallyDeclaredComposedAnnotations() {     Class<?> element = SubSubClassWithInheritedComposedAnnotation.class.     String name = TX_NAME.     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("AnnotationAttributes for @Transactional on SubSubClassWithInheritedComposedAnnotation.", attributes).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)).     assertFalse("readOnly flag for SubSubClassWithInheritedComposedAnnotation.", attributes.getBoolean("readOnly")). }
false;public;0;9;;@Test public void getMergedAnnotationAttributesFromInterfaceImplementedBySuperclass() {     Class<?> element = ConcreteClassWithInheritedAnnotation.class.     String name = TX_NAME.     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNull("Should not find @Transactional on ConcreteClassWithInheritedAnnotation", attributes).     // Verify contracts between utility methods:     assertFalse(isAnnotated(element, name)). }
false;public;0;9;;@Test public void getMergedAnnotationAttributesOnInheritedAnnotationInterface() {     Class<?> element = InheritedAnnotationInterface.class.     String name = TX_NAME.     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("Should find @Transactional on InheritedAnnotationInterface", attributes).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
false;public;0;9;;@Test public void getMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {     Class<?> element = NonInheritedAnnotationInterface.class.     String name = Order.class.getName().     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("Should find @Order on NonInheritedAnnotationInterface", attributes).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
false;public;0;13;;@Test public void getMergedAnnotationAttributesWithConventionBasedComposedAnnotation() {     Class<?> element = ConventionBasedComposedContextConfigClass.class.     String name = ContextConfig.class.getName().     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("Should find @ContextConfig on " + element.getSimpleName(), attributes).     assertArrayEquals("locations", asArray("explicitDeclaration"), attributes.getStringArray("locations")).     assertArrayEquals("value", asArray("explicitDeclaration"), attributes.getStringArray("value")).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
true;public;0;8;/**  * This test should never pass, simply because Spring does not support a hybrid  * approach for annotation attribute overrides with transitive implicit aliases.  * See SPR-13554 for details.  * <p>Furthermore, if you choose to execute this test, it can fail for either  * the first test class or the second one (with different exceptions), depending  * on the order in which the JVM returns the attribute methods via reflection.  */ ;/**  * This test should never pass, simply because Spring does not support a hybrid  * approach for annotation attribute overrides with transitive implicit aliases.  * See SPR-13554 for details.  * <p>Furthermore, if you choose to execute this test, it can fail for either  * the first test class or the second one (with different exceptions), depending  * on the order in which the JVM returns the attribute methods via reflection.  */ @Ignore("Permanently disabled but left in place for illustrative purposes") @Test public void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation() {     for (Class<?> clazz : asList(HalfConventionBasedAndHalfAliasedComposedContextConfigClassV1.class, HalfConventionBasedAndHalfAliasedComposedContextConfigClassV2.class)) {         getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(clazz).     } }
false;private;1;13;;private void getMergedAnnotationAttributesWithHalfConventionBasedAndHalfAliasedComposedAnnotation(Class<?> clazz) {     String[] expected = asArray("explicitDeclaration").     String name = ContextConfig.class.getName().     String simpleName = clazz.getSimpleName().     AnnotationAttributes attributes = getMergedAnnotationAttributes(clazz, name).     assertNotNull("Should find @ContextConfig on " + simpleName, attributes).     assertArrayEquals("locations for class [" + clazz.getSimpleName() + "]", expected, attributes.getStringArray("locations")).     assertArrayEquals("value for class [" + clazz.getSimpleName() + "]", expected, attributes.getStringArray("value")).     // Verify contracts between utility methods:     assertTrue(isAnnotated(clazz, name)). }
false;public;0;13;;@Test public void getMergedAnnotationAttributesWithAliasedComposedAnnotation() {     Class<?> element = AliasedComposedContextConfigClass.class.     String name = ContextConfig.class.getName().     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("Should find @ContextConfig on " + element.getSimpleName(), attributes).     assertArrayEquals("value", asArray("test.xml"), attributes.getStringArray("value")).     assertArrayEquals("locations", asArray("test.xml"), attributes.getStringArray("locations")).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
false;public;0;13;;@Test public void getMergedAnnotationAttributesWithAliasedValueComposedAnnotation() {     Class<?> element = AliasedValueComposedContextConfigClass.class.     String name = ContextConfig.class.getName().     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     assertNotNull("Should find @ContextConfig on " + element.getSimpleName(), attributes).     assertArrayEquals("locations", asArray("test.xml"), attributes.getStringArray("locations")).     assertArrayEquals("value", asArray("test.xml"), attributes.getStringArray("value")).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
false;public;0;16;;@Test public void getMergedAnnotationAttributesWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {     Class<?> element = ComposedImplicitAliasesContextConfigClass.class.     String name = ImplicitAliasesContextConfig.class.getName().     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, name).     String[] expected = asArray("A.xml", "B.xml").     assertNotNull("Should find @ImplicitAliasesContextConfig on " + element.getSimpleName(), attributes).     assertArrayEquals("groovyScripts", expected, attributes.getStringArray("groovyScripts")).     assertArrayEquals("xmlFiles", expected, attributes.getStringArray("xmlFiles")).     assertArrayEquals("locations", expected, attributes.getStringArray("locations")).     assertArrayEquals("value", expected, attributes.getStringArray("value")).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
false;public;0;4;;@Test public void getMergedAnnotationWithAliasedValueComposedAnnotation() {     assertGetMergedAnnotation(AliasedValueComposedContextConfigClass.class, "test.xml"). }
false;public;0;6;;@Test public void getMergedAnnotationWithImplicitAliasesForSameAttributeInComposedAnnotation() {     assertGetMergedAnnotation(ImplicitAliasesContextConfigClass1.class, "foo.xml").     assertGetMergedAnnotation(ImplicitAliasesContextConfigClass2.class, "bar.xml").     assertGetMergedAnnotation(ImplicitAliasesContextConfigClass3.class, "baz.xml"). }
false;public;0;4;;@Test public void getMergedAnnotationWithTransitiveImplicitAliases() {     assertGetMergedAnnotation(TransitiveImplicitAliasesContextConfigClass.class, "test.groovy"). }
false;public;0;4;;@Test public void getMergedAnnotationWithTransitiveImplicitAliasesWithSingleElementOverridingAnArrayViaAliasFor() {     assertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesContextConfigClass.class, "test.groovy"). }
false;public;0;4;;@Test public void getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevel() {     assertGetMergedAnnotation(TransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, "test.xml"). }
false;public;0;4;;@Test public void getMergedAnnotationWithTransitiveImplicitAliasesWithSkippedLevelWithSingleElementOverridingAnArrayViaAliasFor() {     assertGetMergedAnnotation(SingleLocationTransitiveImplicitAliasesWithSkippedLevelContextConfigClass.class, "test.xml"). }
false;private;2;12;;private void assertGetMergedAnnotation(Class<?> element, String... expected) {     String name = ContextConfig.class.getName().     ContextConfig contextConfig = getMergedAnnotation(element, ContextConfig.class).     assertNotNull("Should find @ContextConfig on " + element.getSimpleName(), contextConfig).     assertArrayEquals("locations", expected, contextConfig.locations()).     assertArrayEquals("value", expected, contextConfig.value()).     assertArrayEquals("classes", new Class<?>[0], contextConfig.classes()).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
false;public;0;16;;@Test public void getMergedAnnotationWithImplicitAliasesInMetaAnnotationOnComposedAnnotation() {     Class<?> element = ComposedImplicitAliasesContextConfigClass.class.     String name = ImplicitAliasesContextConfig.class.getName().     ImplicitAliasesContextConfig config = getMergedAnnotation(element, ImplicitAliasesContextConfig.class).     String[] expected = asArray("A.xml", "B.xml").     assertNotNull("Should find @ImplicitAliasesContextConfig on " + element.getSimpleName(), config).     assertArrayEquals("groovyScripts", expected, config.groovyScripts()).     assertArrayEquals("xmlFiles", expected, config.xmlFiles()).     assertArrayEquals("locations", expected, config.locations()).     assertArrayEquals("value", expected, config.value()).     // Verify contracts between utility methods:     assertTrue(isAnnotated(element, name)). }
false;public;0;12;;@Test public void getMergedAnnotationAttributesWithInvalidConventionBasedComposedAnnotation() {     Class<?> element = InvalidConventionBasedComposedContextConfigClass.class.     exception.expect(AnnotationConfigurationException.class).     exception.expectMessage(either(containsString("attribute 'value' and its alias 'locations'")).or(containsString("attribute 'locations' and its alias 'value'"))).     exception.expectMessage(either(containsString("values of [{duplicateDeclaration}] and [{requiredLocationsDeclaration}]")).or(containsString("values of [{requiredLocationsDeclaration}] and [{duplicateDeclaration}]"))).     exception.expectMessage(containsString("but only one is permitted")).     getMergedAnnotationAttributes(element, ContextConfig.class). }
false;public;0;11;;@Test public void getMergedAnnotationAttributesWithShadowedAliasComposedAnnotation() {     Class<?> element = ShadowedAliasComposedContextConfigClass.class.     AnnotationAttributes attributes = getMergedAnnotationAttributes(element, ContextConfig.class).     String[] expected = asArray("test.xml").     assertNotNull("Should find @ContextConfig on " + element.getSimpleName(), attributes).     assertArrayEquals("locations", expected, attributes.getStringArray("locations")).     assertArrayEquals("value", expected, attributes.getStringArray("value")). }
false;public;0;5;;@Test public void findMergedAnnotationAttributesOnInheritedAnnotationInterface() {     AnnotationAttributes attributes = findMergedAnnotationAttributes(InheritedAnnotationInterface.class, Transactional.class).     assertNotNull("Should find @Transactional on InheritedAnnotationInterface", attributes). }
false;public;0;5;;@Test public void findMergedAnnotationAttributesOnSubInheritedAnnotationInterface() {     AnnotationAttributes attributes = findMergedAnnotationAttributes(SubInheritedAnnotationInterface.class, Transactional.class).     assertNotNull("Should find @Transactional on SubInheritedAnnotationInterface", attributes). }
false;public;0;5;;@Test public void findMergedAnnotationAttributesOnSubSubInheritedAnnotationInterface() {     AnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubInheritedAnnotationInterface.class, Transactional.class).     assertNotNull("Should find @Transactional on SubSubInheritedAnnotationInterface", attributes). }
false;public;0;5;;@Test public void findMergedAnnotationAttributesOnNonInheritedAnnotationInterface() {     AnnotationAttributes attributes = findMergedAnnotationAttributes(NonInheritedAnnotationInterface.class, Order.class).     assertNotNull("Should find @Order on NonInheritedAnnotationInterface", attributes). }
false;public;0;5;;@Test public void findMergedAnnotationAttributesOnSubNonInheritedAnnotationInterface() {     AnnotationAttributes attributes = findMergedAnnotationAttributes(SubNonInheritedAnnotationInterface.class, Order.class).     assertNotNull("Should find @Order on SubNonInheritedAnnotationInterface", attributes). }
false;public;0;5;;@Test public void findMergedAnnotationAttributesOnSubSubNonInheritedAnnotationInterface() {     AnnotationAttributes attributes = findMergedAnnotationAttributes(SubSubNonInheritedAnnotationInterface.class, Order.class).     assertNotNull("Should find @Order on SubSubNonInheritedAnnotationInterface", attributes). }
false;public;0;6;;@Test public void findMergedAnnotationAttributesInheritedFromInterfaceMethod() throws NoSuchMethodException {     Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleFromInterface").     AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Order.class).     assertNotNull("Should find @Order on ConcreteClassWithInheritedAnnotation.handleFromInterface() method", attributes). }
false;public;0;6;;@Test public void findMergedAnnotationAttributesInheritedFromAbstractMethod() throws NoSuchMethodException {     Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handle").     AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class).     assertNotNull("Should find @Transactional on ConcreteClassWithInheritedAnnotation.handle() method", attributes). }
false;public;0;6;;@Test public void findMergedAnnotationAttributesInheritedFromBridgedMethod() throws NoSuchMethodException {     Method method = ConcreteClassWithInheritedAnnotation.class.getMethod("handleParameterized", String.class).     AnnotationAttributes attributes = findMergedAnnotationAttributes(method, Transactional.class).     assertNotNull("Should find @Transactional on bridged ConcreteClassWithInheritedAnnotation.handleParameterized()", attributes). }
true;public;0;22;/**  * Bridge/bridged method setup code copied from  * {@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}.  * @since 4.2  */ ;/**  * Bridge/bridged method setup code copied from  * {@link org.springframework.core.BridgeMethodResolverTests#testWithGenericParameter()}.  * @since 4.2  */ @Test public void findMergedAnnotationAttributesFromBridgeMethod() {     Method[] methods = StringGenericParameter.class.getMethods().     Method bridgeMethod = null.     Method bridgedMethod = null.     for (Method method : methods) {         if ("getFor".equals(method.getName()) && !method.getParameterTypes()[0].equals(Integer.class)) {             if (method.getReturnType().equals(Object.class)) {                 bridgeMethod = method.             } else {                 bridgedMethod = method.             }         }     }     assertTrue(bridgeMethod != null && bridgeMethod.isBridge()).     assertTrue(bridgedMethod != null && !bridgedMethod.isBridge()).     AnnotationAttributes attributes = findMergedAnnotationAttributes(bridgeMethod, Order.class).     assertNotNull("Should find @Order on StringGenericParameter.getFor() bridge method", attributes). }
false;public;0;6;;@Test public void findMergedAnnotationAttributesOnClassWithMetaAndLocalTxConfig() {     AnnotationAttributes attributes = findMergedAnnotationAttributes(MetaAndLocalTxConfigClass.class, Transactional.class).     assertNotNull("Should find @Transactional on MetaAndLocalTxConfigClass", attributes).     assertEquals("TX qualifier for MetaAndLocalTxConfigClass.", "localTxMgr", attributes.getString("qualifier")). }
false;public;0;20;;@Test public void findAndSynthesizeAnnotationAttributesOnClassWithAttributeAliasesInTargetAnnotation() {     String qualifier = "aliasForQualifier".     // 1) Find and merge AnnotationAttributes from the annotation hierarchy     AnnotationAttributes attributes = findMergedAnnotationAttributes(AliasedTransactionalComponentClass.class, AliasedTransactional.class).     assertNotNull("@AliasedTransactional on AliasedTransactionalComponentClass.", attributes).     // 2) Synthesize the AnnotationAttributes back into the target annotation     AliasedTransactional annotation = AnnotationUtils.synthesizeAnnotation(attributes, AliasedTransactional.class, AliasedTransactionalComponentClass.class).     assertNotNull(annotation).     // 3) Verify that the AnnotationAttributes and synthesized annotation are equivalent     assertEquals("TX value via attributes.", qualifier, attributes.getString("value")).     assertEquals("TX value via synthesized annotation.", qualifier, annotation.value()).     assertEquals("TX qualifier via attributes.", qualifier, attributes.getString("qualifier")).     assertEquals("TX qualifier via synthesized annotation.", qualifier, annotation.qualifier()). }
false;public;0;10;;@Test public void findMergedAnnotationAttributesOnClassWithAttributeAliasInComposedAnnotationAndNestedAnnotationsInTargetAnnotation() {     AnnotationAttributes attributes = assertComponentScanAttributes(TestComponentScanClass.class, "com.example.app.test").     Filter[] excludeFilters = attributes.getAnnotationArray("excludeFilters", Filter.class).     assertNotNull(excludeFilters).     List<String> patterns = stream(excludeFilters).map(Filter::pattern).collect(toList()).     assertEquals(asList("*Test", "*Tests"), patterns). }
true;public;0;4;/**  * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}  * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation  * attributes since attributes may be arrays.  */ ;/**  * This test ensures that {@link AnnotationUtils#postProcessAnnotationAttributes}  * uses {@code ObjectUtils.nullSafeEquals()} to check for equality between annotation  * attributes since attributes may be arrays.  */ @Test public void findMergedAnnotationAttributesOnClassWithBothAttributesOfAnAliasPairDeclared() {     assertComponentScanAttributes(ComponentScanWithBasePackagesAndValueAliasClass.class, "com.example.app.test"). }
false;public;0;4;;@Test public void findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaConvention() {     assertComponentScanAttributes(ConventionBasedSinglePackageComponentScanClass.class, "com.example.app.test"). }
false;public;0;4;;@Test public void findMergedAnnotationAttributesWithSingleElementOverridingAnArrayViaAliasFor() {     assertComponentScanAttributes(AliasForBasedSinglePackageComponentScanClass.class, "com.example.app.test"). }
false;private;2;9;;private AnnotationAttributes assertComponentScanAttributes(Class<?> element, String... expected) {     AnnotationAttributes attributes = findMergedAnnotationAttributes(element, ComponentScan.class).     assertNotNull("Should find @ComponentScan on " + element, attributes).     assertArrayEquals("value: ", expected, attributes.getStringArray("value")).     assertArrayEquals("basePackages: ", expected, attributes.getStringArray("basePackages")).     return attributes. }
false;private;2;4;;private AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element, Class<? extends Annotation> annotationType) {     Assert.notNull(annotationType, "annotationType must not be null").     return AnnotatedElementUtils.findMergedAnnotationAttributes(element, annotationType.getName(), false, false). }
false;public;0;8;;@Test public void findMergedAnnotationWithAttributeAliasesInTargetAnnotation() {     Class<?> element = AliasedTransactionalComponentClass.class.     AliasedTransactional annotation = findMergedAnnotation(element, AliasedTransactional.class).     assertNotNull("@AliasedTransactional on " + element, annotation).     assertEquals("TX value via synthesized annotation.", "aliasForQualifier", annotation.value()).     assertEquals("TX qualifier via synthesized annotation.", "aliasForQualifier", annotation.qualifier()). }
false;public;0;23;;@Test public void findMergedAnnotationForMultipleMetaAnnotationsWithClashingAttributeNames() {     String[] xmlLocations = asArray("test.xml").     String[] propFiles = asArray("test.properties").     Class<?> element = AliasedComposedContextConfigAndTestPropSourceClass.class.     ContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class).     assertNotNull("@ContextConfig on " + element, contextConfig).     assertArrayEquals("locations", xmlLocations, contextConfig.locations()).     assertArrayEquals("value", xmlLocations, contextConfig.value()).     // Synthesized annotation     TestPropSource testPropSource = AnnotationUtils.findAnnotation(element, TestPropSource.class).     assertArrayEquals("locations", propFiles, testPropSource.locations()).     assertArrayEquals("value", propFiles, testPropSource.value()).     // Merged annotation     testPropSource = findMergedAnnotation(element, TestPropSource.class).     assertNotNull("@TestPropSource on " + element, testPropSource).     assertArrayEquals("locations", propFiles, testPropSource.locations()).     assertArrayEquals("value", propFiles, testPropSource.value()). }
false;public;0;12;;@Test public void findMergedAnnotationWithLocalAliasesThatConflictWithAttributesInMetaAnnotationByConvention() {     final String[] EMPTY = new String[0].     Class<?> element = SpringAppConfigClass.class.     ContextConfig contextConfig = findMergedAnnotation(element, ContextConfig.class).     assertNotNull("Should find @ContextConfig on " + element, contextConfig).     assertArrayEquals("locations for " + element, EMPTY, contextConfig.locations()).     // 'value' in @SpringAppConfig should not override 'value' in @ContextConfig     assertArrayEquals("value for " + element, EMPTY, contextConfig.value()).     assertArrayEquals("classes for " + element, new Class<?>[] { Number.class }, contextConfig.classes()). }
false;public;0;4;;@Test public void findMergedAnnotationWithSingleElementOverridingAnArrayViaConvention() throws Exception {     assertWebMapping(WebController.class.getMethod("postMappedWithPathAttribute")). }
false;public;0;5;;@Test public void findMergedAnnotationWithSingleElementOverridingAnArrayViaAliasFor() throws Exception {     assertWebMapping(WebController.class.getMethod("getMappedWithValueAttribute")).     assertWebMapping(WebController.class.getMethod("getMappedWithPathAttribute")). }
false;private;1;6;;private void assertWebMapping(AnnotatedElement element) throws ArrayComparisonFailure {     WebMapping webMapping = findMergedAnnotation(element, WebMapping.class).     assertNotNull(webMapping).     assertArrayEquals("value attribute: ", asArray("/test"), webMapping.value()).     assertArrayEquals("path attribute: ", asArray("/test"), webMapping.path()). }
false;public;0;6;;@Test public void javaLangAnnotationTypeViaFindMergedAnnotation() throws Exception {     Constructor<?> deprecatedCtor = Date.class.getConstructor(String.class).     assertEquals(deprecatedCtor.getAnnotation(Deprecated.class), findMergedAnnotation(deprecatedCtor, Deprecated.class)).     assertEquals(Date.class.getAnnotation(Deprecated.class), findMergedAnnotation(Date.class, Deprecated.class)). }
false;public;0;5;;@Test public void javaxAnnotationTypeViaFindMergedAnnotation() throws Exception {     assertEquals(ResourceHolder.class.getAnnotation(Resource.class), findMergedAnnotation(ResourceHolder.class, Resource.class)).     assertEquals(SpringAppConfigClass.class.getAnnotation(Resource.class), findMergedAnnotation(SpringAppConfigClass.class, Resource.class)). }
false;public;0;6;;@Test public void getAllMergedAnnotationsOnClassWithInterface() throws Exception {     Method m = TransactionalServiceImpl.class.getMethod("doIt").     Set<Transactional> allMergedAnnotations = getAllMergedAnnotations(m, Transactional.class).     assertTrue(allMergedAnnotations.isEmpty()). }
false;public;0;6;;@Test public void findAllMergedAnnotationsOnClassWithInterface() throws Exception {     Method m = TransactionalServiceImpl.class.getMethod("doIt").     Set<Transactional> allMergedAnnotations = findAllMergedAnnotations(m, Transactional.class).     assertEquals(1, allMergedAnnotations.size()). }
false;public;0;6;;// SPR-16060 @Test public void findMethodAnnotationFromGenericInterface() throws Exception {     Method method = ImplementsInterfaceWithGenericAnnotatedMethod.class.getMethod("foo", String.class).     Order order = findMergedAnnotation(method, Order.class).     assertNotNull(order). }
false;public;0;6;;// SPR-17146 @Test public void findMethodAnnotationFromGenericSuperclass() throws Exception {     Method method = ExtendsBaseClassWithGenericAnnotatedMethod.class.getMethod("foo", String.class).     Order order = findMergedAnnotation(method, Order.class).     assertNotNull(order). }
false;;0;2;;@Order void handleFromInterface().
false;public,abstract;0;2;;@Transactional public abstract void handle().
false;public;1;3;;@Transactional public void handleParameterized(T t) { }
false;public;0;3;;@Override public void handle() { }
false;public;1;3;;@Override public void handleParameterized(String s) { }
false;public;0;3;;@Override public void handleFromInterface() { }
false;;1;1;;T getFor(Class<T> cls).
false;public;1;5;;@Order @Override public String getFor(Class<String> cls) {     return "foo". }
false;public;1;3;;public String getFor(Integer integer) {     return "foo". }
false;;0;2;;@Transactional void doIt().
false;public;0;3;;@Override public void doIt() { }
