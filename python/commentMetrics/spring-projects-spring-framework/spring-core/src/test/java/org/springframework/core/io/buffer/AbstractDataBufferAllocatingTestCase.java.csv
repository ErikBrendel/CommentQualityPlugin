commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;13;;@Parameterized.Parameters(name = "{0}") public static Object[][] dataBufferFactories() {     return new Object[][] { { new NettyDataBufferFactory(new UnpooledByteBufAllocator(true)) }, { new NettyDataBufferFactory(new UnpooledByteBufAllocator(false)) }, // disable caching for reliable leak detection, see https://github.com/netty/netty/issues/5275     { new NettyDataBufferFactory(new PooledByteBufAllocator(true, 1, 1, 8192, 11, 0, 0, 0, true)) }, { new NettyDataBufferFactory(new PooledByteBufAllocator(false, 1, 1, 8192, 11, 0, 0, 0, true)) }, { new DefaultDataBufferFactory(true) }, { new DefaultDataBufferFactory(false) } }. }
false;protected;1;3;;protected DataBuffer createDataBuffer(int capacity) {     return this.bufferFactory.allocateBuffer(capacity). }
false;protected;1;3;;protected DataBuffer stringBuffer(String value) {     return byteBuffer(value.getBytes(StandardCharsets.UTF_8)). }
false;protected;1;3;;protected Mono<DataBuffer> deferStringBuffer(String value) {     return Mono.defer(() -> Mono.just(stringBuffer(value))). }
false;protected;1;5;;protected DataBuffer byteBuffer(byte[] value) {     DataBuffer buffer = this.bufferFactory.allocateBuffer(value.length).     buffer.write(value).     return buffer. }
false;protected;1;3;;protected void release(DataBuffer... buffers) {     Arrays.stream(buffers).forEach(DataBufferUtils::release). }
false;protected;1;8;;protected Consumer<DataBuffer> stringConsumer(String expected) {     return dataBuffer -> {         String value = DataBufferTestUtils.dumpString(dataBuffer, StandardCharsets.UTF_8).         DataBufferUtils.release(dataBuffer).         assertEquals(expected, value).     }. }
true;protected;1;13;/**  * Wait until allocations are at 0, or the given duration elapses.  */ ;/**  * Wait until allocations are at 0, or the given duration elapses.  */ protected void waitForDataBufferRelease(Duration duration) throws InterruptedException {     Instant start = Instant.now().     while (Instant.now().isBefore(start.plus(duration))) {         try {             verifyAllocations().             break.         } catch (AssertionError ex) {         // ignore.         }         Thread.sleep(50).     } }
false;private;0;10;;private void verifyAllocations() {     if (this.bufferFactory instanceof NettyDataBufferFactory) {         ByteBufAllocator allocator = ((NettyDataBufferFactory) this.bufferFactory).getByteBufAllocator().         if (allocator instanceof PooledByteBufAllocator) {             PooledByteBufAllocatorMetric metric = ((PooledByteBufAllocator) allocator).metric().             long total = getAllocations(metric.directArenas()) + getAllocations(metric.heapArenas()).             assertEquals("ByteBuf Leak: " + total + " unreleased allocations", 0, total).         }     } }
false;private,static;1;3;;private static long getAllocations(List<PoolArenaMetric> metrics) {     return metrics.stream().mapToLong(PoolArenaMetric::numActiveAllocations).sum(). }
false;public;0;4;;@Override public void verify() {     AbstractDataBufferAllocatingTestCase.this.verifyAllocations(). }
