commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Override @Test public void canDecode() {     assertTrue(this.decoder.canDecode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.TEXT_PLAIN)).     assertFalse(this.decoder.canDecode(ResolvableType.forClass(Integer.class), MimeTypeUtils.TEXT_PLAIN)).     assertTrue(this.decoder.canDecode(ResolvableType.forClass(ByteBuffer.class), MimeTypeUtils.APPLICATION_JSON)). }
false;public;0;14;;@Override @Test public void decode() {     Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes)).     testDecodeAll(input, ByteBuffer.class, step -> step.consumeNextWith(expectByteBuffer(ByteBuffer.wrap(this.fooBytes))).consumeNextWith(expectByteBuffer(ByteBuffer.wrap(this.barBytes))).verifyComplete()). }
false;public;0;14;;@Override @Test public void decodeToMono() {     Flux<DataBuffer> input = Flux.concat(dataBuffer(this.fooBytes), dataBuffer(this.barBytes)).     ByteBuffer expected = ByteBuffer.allocate(this.fooBytes.length + this.barBytes.length).     expected.put(this.fooBytes).put(this.barBytes).flip().     testDecodeToMonoAll(input, ByteBuffer.class, step -> step.consumeNextWith(expectByteBuffer(expected)).verifyComplete()). }
false;private;1;3;;private Consumer<ByteBuffer> expectByteBuffer(ByteBuffer expected) {     return actual -> assertEquals(expected, actual). }
