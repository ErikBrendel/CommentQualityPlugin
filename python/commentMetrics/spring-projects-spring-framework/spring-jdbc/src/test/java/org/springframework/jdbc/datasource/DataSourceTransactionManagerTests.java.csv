commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void setup() throws Exception {     ds = mock(DataSource.class).     con = mock(Connection.class).     given(ds.getConnection()).willReturn(con).     tm = new DataSourceTransactionManager(ds). }
false;public;0;7;;@After public void verifyTransactionSynchronizationManagerState() {     assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty()).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertFalse(TransactionSynchronizationManager.isActualTransactionActive()). }
false;public;0;4;;@Test public void testTransactionCommitWithAutoCommitTrue() throws Exception {     doTestTransactionCommitRestoringAutoCommit(true, false, false). }
false;public;0;4;;@Test public void testTransactionCommitWithAutoCommitFalse() throws Exception {     doTestTransactionCommitRestoringAutoCommit(false, false, false). }
false;public;0;4;;@Test public void testTransactionCommitWithAutoCommitTrueAndLazyConnection() throws Exception {     doTestTransactionCommitRestoringAutoCommit(true, true, false). }
false;public;0;4;;@Test public void testTransactionCommitWithAutoCommitFalseAndLazyConnection() throws Exception {     doTestTransactionCommitRestoringAutoCommit(false, true, false). }
false;public;0;4;;@Test public void testTransactionCommitWithAutoCommitTrueAndLazyConnectionAndStatementCreated() throws Exception {     doTestTransactionCommitRestoringAutoCommit(true, true, true). }
false;public;0;4;;@Test public void testTransactionCommitWithAutoCommitFalseAndLazyConnectionAndStatementCreated() throws Exception {     doTestTransactionCommitRestoringAutoCommit(false, true, true). }
false;protected;1;17;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(dsToUse)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Is new transaction", status.isNewTransaction()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).     Connection tCon = DataSourceUtils.getConnection(dsToUse).     try {         if (createStatement) {             tCon.createStatement().         }     } catch (SQLException ex) {         throw new UncategorizedSQLException("", "", ex).     } }
false;private;3;54;;private void doTestTransactionCommitRestoringAutoCommit(boolean autoCommit, boolean lazyConnection, final boolean createStatement) throws Exception {     if (lazyConnection) {         given(con.getAutoCommit()).willReturn(autoCommit).         given(con.getTransactionIsolation()).willReturn(Connection.TRANSACTION_READ_COMMITTED).     }     if (!lazyConnection || createStatement) {         given(con.getAutoCommit()).willReturn(autoCommit).     }     final DataSource dsToUse = (lazyConnection ? new LazyConnectionDataSourceProxy(ds) : ds).     tm = new DataSourceTransactionManager(dsToUse).     TransactionTemplate tt = new TransactionTemplate(tm).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(dsToUse)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(dsToUse)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Is new transaction", status.isNewTransaction()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).             Connection tCon = DataSourceUtils.getConnection(dsToUse).             try {                 if (createStatement) {                     tCon.createStatement().                 }             } catch (SQLException ex) {                 throw new UncategorizedSQLException("", "", ex).             }         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(dsToUse)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     if (autoCommit && (!lazyConnection || createStatement)) {         InOrder ordered = inOrder(con).         ordered.verify(con).setAutoCommit(false).         ordered.verify(con).commit().         ordered.verify(con).setAutoCommit(true).     }     if (createStatement) {         verify(con, times(2)).close().     } else {         verify(con).close().     } }
false;public;0;4;;@Test public void testTransactionRollbackWithAutoCommitTrue() throws Exception {     doTestTransactionRollbackRestoringAutoCommit(true, false, false). }
false;public;0;4;;@Test public void testTransactionRollbackWithAutoCommitFalse() throws Exception {     doTestTransactionRollbackRestoringAutoCommit(false, false, false). }
false;public;0;4;;@Test public void testTransactionRollbackWithAutoCommitTrueAndLazyConnection() throws Exception {     doTestTransactionRollbackRestoringAutoCommit(true, true, false). }
false;public;0;4;;@Test public void testTransactionRollbackWithAutoCommitFalseAndLazyConnection() throws Exception {     doTestTransactionRollbackRestoringAutoCommit(false, true, false). }
false;public;0;4;;@Test public void testTransactionRollbackWithAutoCommitTrueAndLazyConnectionAndCreateStatement() throws Exception {     doTestTransactionRollbackRestoringAutoCommit(true, true, true). }
false;public;0;4;;@Test public void testTransactionRollbackWithAutoCommitFalseAndLazyConnectionAndCreateStatement() throws Exception {     doTestTransactionRollbackRestoringAutoCommit(false, true, true). }
false;protected;1;16;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(dsToUse)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Is new transaction", status.isNewTransaction()).     Connection con = DataSourceUtils.getConnection(dsToUse).     if (createStatement) {         try {             con.createStatement().         } catch (SQLException ex) {             throw new UncategorizedSQLException("", "", ex).         }     }     throw ex. }
false;private;3;61;;private void doTestTransactionRollbackRestoringAutoCommit(boolean autoCommit, boolean lazyConnection, final boolean createStatement) throws Exception {     if (lazyConnection) {         given(con.getAutoCommit()).willReturn(autoCommit).         given(con.getTransactionIsolation()).willReturn(Connection.TRANSACTION_READ_COMMITTED).     }     if (!lazyConnection || createStatement) {         given(con.getAutoCommit()).willReturn(autoCommit).     }     final DataSource dsToUse = (lazyConnection ? new LazyConnectionDataSourceProxy(ds) : ds).     tm = new DataSourceTransactionManager(dsToUse).     TransactionTemplate tt = new TransactionTemplate(tm).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(dsToUse)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     final RuntimeException ex = new RuntimeException("Application exception").     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(dsToUse)).                 assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                 assertTrue("Is new transaction", status.isNewTransaction()).                 Connection con = DataSourceUtils.getConnection(dsToUse).                 if (createStatement) {                     try {                         con.createStatement().                     } catch (SQLException ex) {                         throw new UncategorizedSQLException("", "", ex).                     }                 }                 throw ex.             }         }).         fail("Should have thrown RuntimeException").     } catch (RuntimeException ex2) {         // expected         assertTrue("Correct exception thrown", ex2.equals(ex)).     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     if (autoCommit && (!lazyConnection || createStatement)) {         InOrder ordered = inOrder(con).         ordered.verify(con).setAutoCommit(false).         ordered.verify(con).rollback().         ordered.verify(con).setAutoCommit(true).     }     if (createStatement) {         verify(con, times(2)).close().     } else {         verify(con).close().     } }
false;protected;1;7;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Is existing transaction", !status.isNewTransaction()).     throw ex. }
false;public;0;34;;@Test public void testTransactionRollbackOnly() throws Exception {     tm.setTransactionSynchronization(DataSourceTransactionManager.SYNCHRONIZATION_NEVER).     TransactionTemplate tt = new TransactionTemplate(tm).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     ConnectionHolder conHolder = new ConnectionHolder(con).     conHolder.setTransactionActive(true).     TransactionSynchronizationManager.bindResource(ds, conHolder).     final RuntimeException ex = new RuntimeException("Application exception").     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                 assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).                 assertTrue("Is existing transaction", !status.isNewTransaction()).                 throw ex.             }         }).         fail("Should have thrown RuntimeException").     } catch (RuntimeException ex2) {         // expected         assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).         assertEquals("Correct exception thrown", ex, ex2).     } finally {         TransactionSynchronizationManager.unbindResource(ds).     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)). }
false;public;0;4;;@Test public void testParticipatingTransactionWithRollbackOnly() throws Exception {     doTestParticipatingTransactionWithRollbackOnly(false). }
false;public;0;4;;@Test public void testParticipatingTransactionWithRollbackOnlyAndFailEarly() throws Exception {     doTestParticipatingTransactionWithRollbackOnly(true). }
false;protected;1;7;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Is existing transaction", !status.isNewTransaction()).     status.setRollbackOnly(). }
false;protected;1;16;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is existing transaction", !status.isNewTransaction()).     assertFalse("Is not rollback-only", status.isRollbackOnly()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Is existing transaction", !status.isNewTransaction()).             status.setRollbackOnly().         }     }).     assertTrue("Is existing transaction", !status.isNewTransaction()).     assertTrue("Is rollback-only", status.isRollbackOnly()). }
false;private;1;63;;private void doTestParticipatingTransactionWithRollbackOnly(boolean failEarly) throws Exception {     given(con.isReadOnly()).willReturn(false).     if (failEarly) {         tm.setFailEarlyOnGlobalRollbackOnly(true).     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition()).     TestTransactionSynchronization synch = new TestTransactionSynchronization(ds, TransactionSynchronization.STATUS_ROLLED_BACK).     TransactionSynchronizationManager.registerSynchronization(synch).     boolean outerTransactionBoundaryReached = false.     try {         assertTrue("Is new transaction", ts.isNewTransaction()).         final TransactionTemplate tt = new TransactionTemplate(tm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertTrue("Is existing transaction", !status.isNewTransaction()).                 assertFalse("Is not rollback-only", status.isRollbackOnly()).                 tt.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                         assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                         assertTrue("Is existing transaction", !status.isNewTransaction()).                         status.setRollbackOnly().                     }                 }).                 assertTrue("Is existing transaction", !status.isNewTransaction()).                 assertTrue("Is rollback-only", status.isRollbackOnly()).             }         }).         outerTransactionBoundaryReached = true.         tm.commit(ts).         fail("Should have thrown UnexpectedRollbackException").     } catch (UnexpectedRollbackException ex) {         // expected         if (!outerTransactionBoundaryReached) {             tm.rollback(ts).         }         if (failEarly) {             assertFalse(outerTransactionBoundaryReached).         } else {             assertTrue(outerTransactionBoundaryReached).         }     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertFalse(synch.beforeCommitCalled).     assertTrue(synch.beforeCompletionCalled).     assertFalse(synch.afterCommitCalled).     assertTrue(synch.afterCompletionCalled).     verify(con).rollback().     verify(con).close(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     status.setRollbackOnly(). }
false;protected;1;11;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertFalse("Is not rollback-only", status.isRollbackOnly()).     tt2.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             status.setRollbackOnly().         }     }).     assertTrue("Is rollback-only", status.isRollbackOnly()). }
false;public;0;36;;@Test public void testParticipatingTransactionWithIncompatibleIsolationLevel() throws Exception {     tm.setValidateExistingTransaction(true).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     try {         final TransactionTemplate tt = new TransactionTemplate(tm).         final TransactionTemplate tt2 = new TransactionTemplate(tm).         tt2.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertFalse("Is not rollback-only", status.isRollbackOnly()).                 tt2.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         status.setRollbackOnly().                     }                 }).                 assertTrue("Is rollback-only", status.isRollbackOnly()).             }         }).         fail("Should have thrown IllegalTransactionStateException").     } catch (IllegalTransactionStateException ex) {     // expected     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback().     verify(con).close(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     status.setRollbackOnly(). }
false;protected;1;11;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertFalse("Is not rollback-only", status.isRollbackOnly()).     tt2.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             status.setRollbackOnly().         }     }).     assertTrue("Is rollback-only", status.isRollbackOnly()). }
false;public;0;38;;@Test public void testParticipatingTransactionWithIncompatibleReadOnly() throws Exception {     willThrow(new SQLException("read-only not supported")).given(con).setReadOnly(true).     tm.setValidateExistingTransaction(true).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     try {         final TransactionTemplate tt = new TransactionTemplate(tm).         tt.setReadOnly(true).         final TransactionTemplate tt2 = new TransactionTemplate(tm).         tt2.setReadOnly(false).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertFalse("Is not rollback-only", status.isRollbackOnly()).                 tt2.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         status.setRollbackOnly().                     }                 }).                 assertTrue("Is rollback-only", status.isRollbackOnly()).             }         }).         fail("Should have thrown IllegalTransactionStateException").     } catch (IllegalTransactionStateException ex) {     // expected     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback().     verify(con).close(). }
false;protected;1;3;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { }
false;protected;1;12;;@Override protected void doAfterCompletion(int status) {     super.doAfterCompletion(status).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {         }     }).     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {     }). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     TransactionSynchronizationManager.registerSynchronization(synch). }
false;public;0;40;;@Test public void testParticipatingTransactionWithTransactionStartedFromSynch() throws Exception {     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     final TestTransactionSynchronization synch = new TestTransactionSynchronization(ds, TransactionSynchronization.STATUS_COMMITTED) {          @Override         protected void doAfterCompletion(int status) {             super.doAfterCompletion(status).             tt.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) {                 }             }).             TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {             }).         }     }.     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             TransactionSynchronizationManager.registerSynchronization(synch).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue(synch.beforeCommitCalled).     assertTrue(synch.beforeCompletionCalled).     assertTrue(synch.afterCommitCalled).     assertTrue(synch.afterCompletionCalled).     assertTrue(synch.afterCompletionException instanceof IllegalStateException).     verify(con, times(2)).commit().     verify(con, times(2)).close(). }
false;protected;1;6;;@Override protected void doAfterCompletion(int status) {     super.doAfterCompletion(status).     Connection con = DataSourceUtils.getConnection(ds2).     DataSourceUtils.releaseConnection(con, ds2). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     TransactionSynchronizationManager.registerSynchronization(synch). }
false;public;0;38;;@Test public void testParticipatingTransactionWithDifferentConnectionObtainedFromSynch() throws Exception {     DataSource ds2 = mock(DataSource.class).     final Connection con2 = mock(Connection.class).     given(ds2.getConnection()).willReturn(con2).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     final TransactionTemplate tt = new TransactionTemplate(tm).     final TestTransactionSynchronization synch = new TestTransactionSynchronization(ds, TransactionSynchronization.STATUS_COMMITTED) {          @Override         protected void doAfterCompletion(int status) {             super.doAfterCompletion(status).             Connection con = DataSourceUtils.getConnection(ds2).             DataSourceUtils.releaseConnection(con, ds2).         }     }.     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             TransactionSynchronizationManager.registerSynchronization(synch).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue(synch.beforeCommitCalled).     assertTrue(synch.beforeCompletionCalled).     assertTrue(synch.afterCommitCalled).     assertTrue(synch.afterCompletionCalled).     assertNull(synch.afterCompletionException).     verify(con).commit().     verify(con).close().     verify(con2).close(). }
false;protected;1;7;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Is existing transaction", !status.isNewTransaction()).     status.setRollbackOnly(). }
false;protected;1;17;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is existing transaction", !status.isNewTransaction()).     assertFalse("Is not rollback-only", status.isRollbackOnly()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Is existing transaction", !status.isNewTransaction()).             status.setRollbackOnly().         }     }).     assertTrue("Is existing transaction", !status.isNewTransaction()).     assertTrue("Is rollback-only", status.isRollbackOnly()).     TransactionSynchronizationManager.registerSynchronization(synch). }
false;public;0;53;;@Test public void testParticipatingTransactionWithRollbackOnlyAndInnerSynch() throws Exception {     tm.setTransactionSynchronization(DataSourceTransactionManager.SYNCHRONIZATION_NEVER).     DataSourceTransactionManager tm2 = new DataSourceTransactionManager(ds).     // tm has no synch enabled (used at outer level), tm2 has synch enabled (inner level)     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition()).     final TestTransactionSynchronization synch = new TestTransactionSynchronization(ds, TransactionSynchronization.STATUS_UNKNOWN).     try {         assertTrue("Is new transaction", ts.isNewTransaction()).         final TransactionTemplate tt = new TransactionTemplate(tm2).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertTrue("Is existing transaction", !status.isNewTransaction()).                 assertFalse("Is not rollback-only", status.isRollbackOnly()).                 tt.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                         assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                         assertTrue("Is existing transaction", !status.isNewTransaction()).                         status.setRollbackOnly().                     }                 }).                 assertTrue("Is existing transaction", !status.isNewTransaction()).                 assertTrue("Is rollback-only", status.isRollbackOnly()).                 TransactionSynchronizationManager.registerSynchronization(synch).             }         }).         tm.commit(ts).         fail("Should have thrown UnexpectedRollbackException").     } catch (UnexpectedRollbackException ex) {     // expected     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertFalse(synch.beforeCommitCalled).     assertTrue(synch.beforeCompletionCalled).     assertFalse(synch.afterCommitCalled).     assertTrue(synch.afterCompletionCalled).     verify(con).rollback().     verify(con).close(). }
false;protected;1;9;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Is new transaction", status.isNewTransaction()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).     status.setRollbackOnly(). }
false;protected;1;21;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Is new transaction", status.isNewTransaction()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).             status.setRollbackOnly().         }     }).     assertTrue("Is new transaction", status.isNewTransaction()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()). }
false;public;0;36;;@Test public void testPropagationRequiresNewWithExistingTransaction() throws Exception {     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).             tt.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                     assertTrue("Is new transaction", status.isNewTransaction()).                     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).                     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).                     status.setRollbackOnly().                 }             }).             assertTrue("Is new transaction", status.isNewTransaction()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback().     verify(con).commit().     verify(con, times(2)).close(). }
false;protected;1;9;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Is new transaction", status.isNewTransaction()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).     status.setRollbackOnly(). }
false;protected;1;21;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).     tt2.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Is new transaction", status.isNewTransaction()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).             status.setRollbackOnly().         }     }).     assertTrue("Is new transaction", status.isNewTransaction()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()). }
false;public;0;48;;@Test public void testPropagationRequiresNewWithExistingTransactionAndUnrelatedDataSource() throws Exception {     Connection con2 = mock(Connection.class).     final DataSource ds2 = mock(DataSource.class).     given(ds2.getConnection()).willReturn(con2).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     PlatformTransactionManager tm2 = new DataSourceTransactionManager(ds2).     final TransactionTemplate tt2 = new TransactionTemplate(tm2).     tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds2)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).             tt2.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                     assertTrue("Is new transaction", status.isNewTransaction()).                     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).                     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).                     status.setRollbackOnly().                 }             }).             assertTrue("Is new transaction", status.isNewTransaction()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds2)).     verify(con).commit().     verify(con).close().     verify(con2).rollback().     verify(con2).close(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     status.setRollbackOnly(). }
false;protected;1;13;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).     tt2.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             status.setRollbackOnly().         }     }). }
false;public;0;46;;@Test public void testPropagationRequiresNewWithExistingTransactionAndUnrelatedFailingDataSource() throws Exception {     final DataSource ds2 = mock(DataSource.class).     SQLException failure = new SQLException().     given(ds2.getConnection()).willThrow(failure).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     DataSourceTransactionManager tm2 = new DataSourceTransactionManager(ds2).     tm2.setTransactionSynchronization(DataSourceTransactionManager.SYNCHRONIZATION_NEVER).     final TransactionTemplate tt2 = new TransactionTemplate(tm2).     tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds2)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertTrue("Is new transaction", status.isNewTransaction()).                 assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                 assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).                 assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).                 tt2.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         status.setRollbackOnly().                     }                 }).             }         }).         fail("Should have thrown CannotCreateTransactionException").     } catch (CannotCreateTransactionException ex) {         assertSame(failure, ex.getCause()).     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds2)).     verify(con).rollback().     verify(con).close(). }
false;protected;1;9;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Isn't new transaction", !status.isNewTransaction()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertFalse(TransactionSynchronizationManager.isActualTransactionActive()).     status.setRollbackOnly(). }
false;protected;1;21;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NOT_SUPPORTED).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Isn't new transaction", !status.isNewTransaction()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertFalse(TransactionSynchronizationManager.isActualTransactionActive()).             status.setRollbackOnly().         }     }).     assertTrue("Is new transaction", status.isNewTransaction()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()). }
false;public;0;35;;@Test public void testPropagationNotSupportedWithExistingTransaction() throws Exception {     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).             tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NOT_SUPPORTED).             tt.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).                     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                     assertTrue("Isn't new transaction", !status.isNewTransaction()).                     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).                     assertFalse(TransactionSynchronizationManager.isActualTransactionActive()).                     status.setRollbackOnly().                 }             }).             assertTrue("Is new transaction", status.isNewTransaction()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).commit().     verify(con).close(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     fail("Should have thrown IllegalTransactionStateException"). }
false;protected;1;12;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NEVER).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             fail("Should have thrown IllegalTransactionStateException").         }     }).     fail("Should have thrown IllegalTransactionStateException"). }
false;public;0;31;;@Test public void testPropagationNeverWithExistingTransaction() throws Exception {     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertTrue("Is new transaction", status.isNewTransaction()).                 tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NEVER).                 tt.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         fail("Should have thrown IllegalTransactionStateException").                     }                 }).                 fail("Should have thrown IllegalTransactionStateException").             }         }).     } catch (IllegalTransactionStateException ex) {     // expected     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback().     verify(con).close(). }
false;protected;1;8;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Is new transaction", status.isNewTransaction()).     assertSame(con, DataSourceUtils.getConnection(ds)).     assertSame(con, DataSourceUtils.getConnection(ds)). }
false;protected;1;16;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     TransactionTemplate tt2 = new TransactionTemplate(tm).     tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     tt2.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Is new transaction", status.isNewTransaction()).             assertSame(con, DataSourceUtils.getConnection(ds)).             assertSame(con, DataSourceUtils.getConnection(ds)).         }     }). }
false;public;0;30;;@Test public void testPropagationSupportsAndRequiresNew() throws Exception {     TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             TransactionTemplate tt2 = new TransactionTemplate(tm).             tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).             tt2.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                     assertTrue("Is new transaction", status.isNewTransaction()).                     assertSame(con, DataSourceUtils.getConnection(ds)).                     assertSame(con, DataSourceUtils.getConnection(ds)).                 }             }).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).commit().     verify(con).close(). }
false;protected;1;8;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Is new transaction", status.isNewTransaction()).     assertSame(con2, DataSourceUtils.getConnection(ds)).     assertSame(con2, DataSourceUtils.getConnection(ds)). }
false;protected;1;19;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertSame(con1, DataSourceUtils.getConnection(ds)).     assertSame(con1, DataSourceUtils.getConnection(ds)).     TransactionTemplate tt2 = new TransactionTemplate(tm).     tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     tt2.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Is new transaction", status.isNewTransaction()).             assertSame(con2, DataSourceUtils.getConnection(ds)).             assertSame(con2, DataSourceUtils.getConnection(ds)).         }     }).     assertSame(con1, DataSourceUtils.getConnection(ds)). }
false;public;0;39;;@Test public void testPropagationSupportsAndRequiresNewWithEarlyAccess() throws Exception {     final Connection con1 = mock(Connection.class).     final Connection con2 = mock(Connection.class).     given(ds.getConnection()).willReturn(con1, con2).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertSame(con1, DataSourceUtils.getConnection(ds)).             assertSame(con1, DataSourceUtils.getConnection(ds)).             TransactionTemplate tt2 = new TransactionTemplate(tm).             tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).             tt2.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                     assertTrue("Is new transaction", status.isNewTransaction()).                     assertSame(con2, DataSourceUtils.getConnection(ds)).                     assertSame(con2, DataSourceUtils.getConnection(ds)).                 }             }).             assertSame(con1, DataSourceUtils.getConnection(ds)).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con1).close().     verify(con2).commit().     verify(con2).close(). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()). // something transactional }
false;public;0;28;;@Test public void testTransactionWithIsolationAndReadOnly() throws Exception {     given(con.getTransactionIsolation()).willReturn(Connection.TRANSACTION_READ_COMMITTED).     given(con.getAutoCommit()).willReturn(true).     TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     tt.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE).     tt.setReadOnly(true).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).         // something transactional         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     InOrder ordered = inOrder(con).     ordered.verify(con).setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE).     ordered.verify(con).setAutoCommit(false).     ordered.verify(con).commit().     ordered.verify(con).setAutoCommit(true).     ordered.verify(con).setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED).     verify(con).close(). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()). // something transactional }
false;public;0;30;;@Test public void testTransactionWithEnforceReadOnly() throws Exception {     tm.setEnforceReadOnly(true).     given(con.getAutoCommit()).willReturn(true).     Statement stmt = mock(Statement.class).     given(con.createStatement()).willReturn(stmt).     TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     tt.setReadOnly(true).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).         // something transactional         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     InOrder ordered = inOrder(con, stmt).     ordered.verify(con).setAutoCommit(false).     ordered.verify(stmt).executeUpdate("SET TRANSACTION READ ONLY").     ordered.verify(stmt).close().     ordered.verify(con).commit().     ordered.verify(con).setAutoCommit(true).     ordered.verify(con).close(). }
false;public;0;4;;@Test public void testTransactionWithLongTimeout() throws Exception {     doTestTransactionWithTimeout(10). }
false;public;0;4;;@Test public void testTransactionWithShortTimeout() throws Exception {     doTestTransactionWithTimeout(1). }
false;protected;1;16;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     try {         Thread.sleep(1500).     } catch (InterruptedException ex) {     }     try {         Connection con = DataSourceUtils.getConnection(ds).         PreparedStatement ps = con.prepareStatement("some SQL statement").         DataSourceUtils.applyTransactionTimeout(ps, ds).     } catch (SQLException ex) {         throw new DataAccessResourceFailureException("", ex).     } }
false;private;1;57;;private void doTestTransactionWithTimeout(int timeout) throws Exception {     Assume.group(TestGroup.PERFORMANCE).     PreparedStatement ps = mock(PreparedStatement.class).     given(con.getAutoCommit()).willReturn(true).     given(con.prepareStatement("some SQL statement")).willReturn(ps).     TransactionTemplate tt = new TransactionTemplate(tm).     tt.setTimeout(timeout).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 try {                     Thread.sleep(1500).                 } catch (InterruptedException ex) {                 }                 try {                     Connection con = DataSourceUtils.getConnection(ds).                     PreparedStatement ps = con.prepareStatement("some SQL statement").                     DataSourceUtils.applyTransactionTimeout(ps, ds).                 } catch (SQLException ex) {                     throw new DataAccessResourceFailureException("", ex).                 }             }         }).         if (timeout <= 1) {             fail("Should have thrown TransactionTimedOutException").         }     } catch (TransactionTimedOutException ex) {         if (timeout <= 1) {         // expected         } else {             throw ex.         }     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     if (timeout > 1) {         verify(ps).setQueryTimeout(timeout - 1).         verify(con).commit().     } else {         verify(con).rollback().     }     InOrder ordered = inOrder(con).     ordered.verify(con).setAutoCommit(false).     ordered.verify(con).setAutoCommit(true).     verify(con).close(). }
false;protected;1;14;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     assertEquals(con, DataSourceUtils.getConnection(ds)).     TransactionAwareDataSourceProxy dsProxy = new TransactionAwareDataSourceProxy(ds).     try {         assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).         // should be ignored         dsProxy.getConnection().close().     } catch (SQLException ex) {         throw new UncategorizedSQLException("", "", ex).     } }
false;public;0;30;;@Test public void testTransactionAwareDataSourceProxy() throws Exception {     given(con.getAutoCommit()).willReturn(true).     TransactionTemplate tt = new TransactionTemplate(tm).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             assertEquals(con, DataSourceUtils.getConnection(ds)).             TransactionAwareDataSourceProxy dsProxy = new TransactionAwareDataSourceProxy(ds).             try {                 assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).                 // should be ignored                 dsProxy.getConnection().close().             } catch (SQLException ex) {                 throw new UncategorizedSQLException("", "", ex).             }         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     InOrder ordered = inOrder(con).     ordered.verify(con).setAutoCommit(false).     ordered.verify(con).commit().     ordered.verify(con).setAutoCommit(true).     verify(con).close(). }
false;protected;1;13;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     assertEquals(con, DataSourceUtils.getConnection(ds)).     try {         assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).         // should be ignored         dsProxy.getConnection().close().     } catch (SQLException ex) {         throw new UncategorizedSQLException("", "", ex).     } }
false;protected;1;39;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     assertEquals(con, DataSourceUtils.getConnection(ds)).     final TransactionAwareDataSourceProxy dsProxy = new TransactionAwareDataSourceProxy(ds).     try {         assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).         // should be ignored         dsProxy.getConnection().close().     } catch (SQLException ex) {         throw new UncategorizedSQLException("", "", ex).     }     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             assertEquals(con, DataSourceUtils.getConnection(ds)).             try {                 assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).                 // should be ignored                 dsProxy.getConnection().close().             } catch (SQLException ex) {                 throw new UncategorizedSQLException("", "", ex).             }         }     }).     try {         assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).         // should be ignored         dsProxy.getConnection().close().     } catch (SQLException ex) {         throw new UncategorizedSQLException("", "", ex).     } }
false;public;0;57;;@Test public void testTransactionAwareDataSourceProxyWithSuspension() throws Exception {     given(con.getAutoCommit()).willReturn(true).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionTemplate.PROPAGATION_REQUIRES_NEW).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             assertEquals(con, DataSourceUtils.getConnection(ds)).             final TransactionAwareDataSourceProxy dsProxy = new TransactionAwareDataSourceProxy(ds).             try {                 assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).                 // should be ignored                 dsProxy.getConnection().close().             } catch (SQLException ex) {                 throw new UncategorizedSQLException("", "", ex).             }             tt.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) {                     // something transactional                     assertEquals(con, DataSourceUtils.getConnection(ds)).                     try {                         assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).                         // should be ignored                         dsProxy.getConnection().close().                     } catch (SQLException ex) {                         throw new UncategorizedSQLException("", "", ex).                     }                 }             }).             try {                 assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).                 // should be ignored                 dsProxy.getConnection().close().             } catch (SQLException ex) {                 throw new UncategorizedSQLException("", "", ex).             }         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     InOrder ordered = inOrder(con).     ordered.verify(con).setAutoCommit(false).     ordered.verify(con).commit().     ordered.verify(con).setAutoCommit(true).     verify(con, times(2)).close(). }
false;protected;1;13;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     assertEquals(con, DataSourceUtils.getConnection(ds)).     try {         assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).         // should be ignored         dsProxy.getConnection().close().     } catch (SQLException ex) {         throw new UncategorizedSQLException("", "", ex).     } }
false;protected;1;40;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     assertEquals(con, DataSourceUtils.getConnection(ds)).     final TransactionAwareDataSourceProxy dsProxy = new TransactionAwareDataSourceProxy(ds).     dsProxy.setReobtainTransactionalConnections(true).     try {         assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).         // should be ignored         dsProxy.getConnection().close().     } catch (SQLException ex) {         throw new UncategorizedSQLException("", "", ex).     }     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             assertEquals(con, DataSourceUtils.getConnection(ds)).             try {                 assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).                 // should be ignored                 dsProxy.getConnection().close().             } catch (SQLException ex) {                 throw new UncategorizedSQLException("", "", ex).             }         }     }).     try {         assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).         // should be ignored         dsProxy.getConnection().close().     } catch (SQLException ex) {         throw new UncategorizedSQLException("", "", ex).     } }
false;public;0;58;;@Test public void testTransactionAwareDataSourceProxyWithSuspensionAndReobtaining() throws Exception {     given(con.getAutoCommit()).willReturn(true).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionTemplate.PROPAGATION_REQUIRES_NEW).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             assertEquals(con, DataSourceUtils.getConnection(ds)).             final TransactionAwareDataSourceProxy dsProxy = new TransactionAwareDataSourceProxy(ds).             dsProxy.setReobtainTransactionalConnections(true).             try {                 assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).                 // should be ignored                 dsProxy.getConnection().close().             } catch (SQLException ex) {                 throw new UncategorizedSQLException("", "", ex).             }             tt.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) {                     // something transactional                     assertEquals(con, DataSourceUtils.getConnection(ds)).                     try {                         assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).                         // should be ignored                         dsProxy.getConnection().close().                     } catch (SQLException ex) {                         throw new UncategorizedSQLException("", "", ex).                     }                 }             }).             try {                 assertEquals(con, ((ConnectionProxy) dsProxy.getConnection()).getTargetConnection()).                 // should be ignored                 dsProxy.getConnection().close().             } catch (SQLException ex) {                 throw new UncategorizedSQLException("", "", ex).             }         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     InOrder ordered = inOrder(con).     ordered.verify(con).setAutoCommit(false).     ordered.verify(con).commit().     ordered.verify(con).setAutoCommit(true).     verify(con, times(2)).close(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { // something transactional }
true;public;0;21;/**  * Test behavior if the first operation on a connection (getAutoCommit) throws SQLException.  */ ;/**  * Test behavior if the first operation on a connection (getAutoCommit) throws SQLException.  */ @Test public void testTransactionWithExceptionOnBegin() throws Exception {     willThrow(new SQLException("Cannot begin")).given(con).getAutoCommit().     TransactionTemplate tt = new TransactionTemplate(tm).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             }         }).         fail("Should have thrown CannotCreateTransactionException").     } catch (CannotCreateTransactionException ex) {     // expected     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).close(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { // something transactional }
false;public;0;21;;@Test public void testTransactionWithExceptionOnCommit() throws Exception {     willThrow(new SQLException("Cannot commit")).given(con).commit().     TransactionTemplate tt = new TransactionTemplate(tm).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException ex) {     // expected     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).close(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { // something transactional }
false;public;0;23;;@Test public void testTransactionWithExceptionOnCommitAndRollbackOnCommitFailure() throws Exception {     willThrow(new SQLException("Cannot commit")).given(con).commit().     tm.setRollbackOnCommitFailure(true).     TransactionTemplate tt = new TransactionTemplate(tm).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException ex) {     // expected     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback().     verify(con).close(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     status.setRollbackOnly(). }
false;public;0;26;;@Test public void testTransactionWithExceptionOnRollback() throws Exception {     given(con.getAutoCommit()).willReturn(true).     willThrow(new SQLException("Cannot rollback")).given(con).rollback().     TransactionTemplate tt = new TransactionTemplate(tm).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 status.setRollbackOnly().             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException ex) {     // expected     }     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     InOrder ordered = inOrder(con).     ordered.verify(con).setAutoCommit(false).     ordered.verify(con).rollback().     ordered.verify(con).setAutoCommit(true).     verify(con).close(). }
false;protected;1;7;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Is not new transaction", !status.isNewTransaction()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertFalse(TransactionSynchronizationManager.isActualTransactionActive()). }
false;public;0;18;;@Test public void testTransactionWithPropagationSupports() throws Exception {     TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Is not new transaction", !status.isNewTransaction()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertFalse(TransactionSynchronizationManager.isActualTransactionActive()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)). }
false;protected;1;5;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Is not new transaction", !status.isNewTransaction()). }
false;public;0;15;;@Test public void testTransactionWithPropagationNotSupported() throws Exception {     TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NOT_SUPPORTED).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Is not new transaction", !status.isNewTransaction()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)). }
false;protected;1;5;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Is not new transaction", !status.isNewTransaction()). }
false;public;0;16;;@Test public void testTransactionWithPropagationNever() throws Exception {     TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NEVER).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Is not new transaction", !status.isNewTransaction()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)). }
false;public;0;4;;@Test public void testExistingTransactionWithPropagationNested() throws Exception {     doTestExistingTransactionWithPropagationNested(1). }
false;public;0;4;;@Test public void testExistingTransactionWithPropagationNestedTwice() throws Exception {     doTestExistingTransactionWithPropagationNested(2). }
false;protected;1;7;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Isn't new transaction", !status.isNewTransaction()).     assertTrue("Is nested transaction", status.hasSavepoint()). }
false;protected;1;18;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Isn't nested transaction", !status.hasSavepoint()).     for (int i = 0. i < count. i++) {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                 assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                 assertTrue("Isn't new transaction", !status.isNewTransaction()).                 assertTrue("Is nested transaction", status.hasSavepoint()).             }         }).     }     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Isn't nested transaction", !status.hasSavepoint()). }
false;private;1;41;;private void doTestExistingTransactionWithPropagationNested(final int count) throws Exception {     DatabaseMetaData md = mock(DatabaseMetaData.class).     Savepoint sp = mock(Savepoint.class).     given(md.supportsSavepoints()).willReturn(true).     given(con.getMetaData()).willReturn(md).     for (int i = 1. i <= count. i++) {         given(con.setSavepoint(ConnectionHolder.SAVEPOINT_NAME_PREFIX + i)).willReturn(sp).     }     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Isn't nested transaction", !status.hasSavepoint()).             for (int i = 0. i < count. i++) {                 tt.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                         assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                         assertTrue("Isn't new transaction", !status.isNewTransaction()).                         assertTrue("Is nested transaction", status.hasSavepoint()).                     }                 }).             }             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Isn't nested transaction", !status.hasSavepoint()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con, times(count)).releaseSavepoint(sp).     verify(con).commit().     verify(con).close(). }
false;protected;1;8;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Isn't new transaction", !status.isNewTransaction()).     assertTrue("Is nested transaction", status.hasSavepoint()).     status.setRollbackOnly(). }
false;protected;1;17;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Isn't nested transaction", !status.hasSavepoint()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Isn't new transaction", !status.isNewTransaction()).             assertTrue("Is nested transaction", status.hasSavepoint()).             status.setRollbackOnly().         }     }).     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Isn't nested transaction", !status.hasSavepoint()). }
false;public;0;41;;@Test public void testExistingTransactionWithPropagationNestedAndRollback() throws Exception {     DatabaseMetaData md = mock(DatabaseMetaData.class).     Savepoint sp = mock(Savepoint.class).     given(md.supportsSavepoints()).willReturn(true).     given(con.getMetaData()).willReturn(md).     given(con.setSavepoint("SAVEPOINT_1")).willReturn(sp).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Isn't nested transaction", !status.hasSavepoint()).             tt.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                     assertTrue("Isn't new transaction", !status.isNewTransaction()).                     assertTrue("Is nested transaction", status.hasSavepoint()).                     status.setRollbackOnly().                 }             }).             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Isn't nested transaction", !status.hasSavepoint()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback(sp).     verify(con).releaseSavepoint(sp).     verify(con).commit().     verify(con).isReadOnly().     verify(con).close(). }
false;protected;1;8;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Isn't new transaction", !status.isNewTransaction()).     assertTrue("Is regular transaction", !status.hasSavepoint()).     throw new IllegalStateException(). }
false;protected;1;18;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Isn't new transaction", !status.isNewTransaction()).     assertTrue("Is nested transaction", status.hasSavepoint()).     TransactionTemplate ntt = new TransactionTemplate(tm).     ntt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Isn't new transaction", !status.isNewTransaction()).             assertTrue("Is regular transaction", !status.hasSavepoint()).             throw new IllegalStateException().         }     }). }
false;protected;1;33;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Isn't nested transaction", !status.hasSavepoint()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                 assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                 assertTrue("Isn't new transaction", !status.isNewTransaction()).                 assertTrue("Is nested transaction", status.hasSavepoint()).                 TransactionTemplate ntt = new TransactionTemplate(tm).                 ntt.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                         assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                         assertTrue("Isn't new transaction", !status.isNewTransaction()).                         assertTrue("Is regular transaction", !status.hasSavepoint()).                         throw new IllegalStateException().                     }                 }).             }         }).         fail("Should have thrown IllegalStateException").     } catch (IllegalStateException ex) {     // expected     }     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Isn't nested transaction", !status.hasSavepoint()). }
false;public;0;57;;@Test public void testExistingTransactionWithPropagationNestedAndRequiredRollback() throws Exception {     DatabaseMetaData md = mock(DatabaseMetaData.class).     Savepoint sp = mock(Savepoint.class).     given(md.supportsSavepoints()).willReturn(true).     given(con.getMetaData()).willReturn(md).     given(con.setSavepoint("SAVEPOINT_1")).willReturn(sp).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Isn't nested transaction", !status.hasSavepoint()).             try {                 tt.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                         assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                         assertTrue("Isn't new transaction", !status.isNewTransaction()).                         assertTrue("Is nested transaction", status.hasSavepoint()).                         TransactionTemplate ntt = new TransactionTemplate(tm).                         ntt.execute(new TransactionCallbackWithoutResult() {                              @Override                             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                                 assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                                 assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                                 assertTrue("Isn't new transaction", !status.isNewTransaction()).                                 assertTrue("Is regular transaction", !status.hasSavepoint()).                                 throw new IllegalStateException().                             }                         }).                     }                 }).                 fail("Should have thrown IllegalStateException").             } catch (IllegalStateException ex) {             // expected             }             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Isn't nested transaction", !status.hasSavepoint()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback(sp).     verify(con).releaseSavepoint(sp).     verify(con).commit().     verify(con).isReadOnly().     verify(con).close(). }
false;protected;1;8;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Isn't new transaction", !status.isNewTransaction()).     assertTrue("Is regular transaction", !status.hasSavepoint()).     status.setRollbackOnly(). }
false;protected;1;18;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue("Isn't new transaction", !status.isNewTransaction()).     assertTrue("Is nested transaction", status.hasSavepoint()).     TransactionTemplate ntt = new TransactionTemplate(tm).     ntt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).             assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue("Isn't new transaction", !status.isNewTransaction()).             assertTrue("Is regular transaction", !status.hasSavepoint()).             status.setRollbackOnly().         }     }). }
false;protected;1;33;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Isn't nested transaction", !status.hasSavepoint()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                 assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                 assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                 assertTrue("Isn't new transaction", !status.isNewTransaction()).                 assertTrue("Is nested transaction", status.hasSavepoint()).                 TransactionTemplate ntt = new TransactionTemplate(tm).                 ntt.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                         assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                         assertTrue("Isn't new transaction", !status.isNewTransaction()).                         assertTrue("Is regular transaction", !status.hasSavepoint()).                         status.setRollbackOnly().                     }                 }).             }         }).         fail("Should have thrown UnexpectedRollbackException").     } catch (UnexpectedRollbackException ex) {     // expected     }     assertTrue("Is new transaction", status.isNewTransaction()).     assertTrue("Isn't nested transaction", !status.hasSavepoint()). }
false;public;0;57;;@Test public void testExistingTransactionWithPropagationNestedAndRequiredRollbackOnly() throws Exception {     DatabaseMetaData md = mock(DatabaseMetaData.class).     Savepoint sp = mock(Savepoint.class).     given(md.supportsSavepoints()).willReturn(true).     given(con.getMetaData()).willReturn(md).     given(con.setSavepoint("SAVEPOINT_1")).willReturn(sp).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Isn't nested transaction", !status.hasSavepoint()).             try {                 tt.execute(new TransactionCallbackWithoutResult() {                      @Override                     protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                         assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                         assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                         assertTrue("Isn't new transaction", !status.isNewTransaction()).                         assertTrue("Is nested transaction", status.hasSavepoint()).                         TransactionTemplate ntt = new TransactionTemplate(tm).                         ntt.execute(new TransactionCallbackWithoutResult() {                              @Override                             protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {                                 assertTrue("Has thread connection", TransactionSynchronizationManager.hasResource(ds)).                                 assertTrue("Synchronization active", TransactionSynchronizationManager.isSynchronizationActive()).                                 assertTrue("Isn't new transaction", !status.isNewTransaction()).                                 assertTrue("Is regular transaction", !status.hasSavepoint()).                                 status.setRollbackOnly().                             }                         }).                     }                 }).                 fail("Should have thrown UnexpectedRollbackException").             } catch (UnexpectedRollbackException ex) {             // expected             }             assertTrue("Is new transaction", status.isNewTransaction()).             assertTrue("Isn't nested transaction", !status.hasSavepoint()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback(sp).     verify(con).releaseSavepoint(sp).     verify(con).commit().     verify(con).isReadOnly().     verify(con).close(). }
false;protected;1;7;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     Object savepoint = status.createSavepoint().     status.releaseSavepoint(savepoint).     assertTrue("Is new transaction", status.isNewTransaction()). }
false;public;0;30;;@Test public void testExistingTransactionWithManualSavepoint() throws Exception {     DatabaseMetaData md = mock(DatabaseMetaData.class).     Savepoint sp = mock(Savepoint.class).     given(md.supportsSavepoints()).willReturn(true).     given(con.getMetaData()).willReturn(md).     given(con.setSavepoint("SAVEPOINT_1")).willReturn(sp).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             Object savepoint = status.createSavepoint().             status.releaseSavepoint(savepoint).             assertTrue("Is new transaction", status.isNewTransaction()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).releaseSavepoint(sp).     verify(con).commit().     verify(con).close().     verify(ds).getConnection(). }
false;protected;1;7;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     Object savepoint = status.createSavepoint().     status.rollbackToSavepoint(savepoint).     assertTrue("Is new transaction", status.isNewTransaction()). }
false;public;0;29;;@Test public void testExistingTransactionWithManualSavepointAndRollback() throws Exception {     DatabaseMetaData md = mock(DatabaseMetaData.class).     Savepoint sp = mock(Savepoint.class).     given(md.supportsSavepoints()).willReturn(true).     given(con.getMetaData()).willReturn(md).     given(con.setSavepoint("SAVEPOINT_1")).willReturn(sp).     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             Object savepoint = status.createSavepoint().             status.rollbackToSavepoint(savepoint).             assertTrue("Is new transaction", status.isNewTransaction()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback(sp).     verify(con).commit().     verify(con).close(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()). }
false;public;0;18;;@Test public void testTransactionWithPropagationNested() throws Exception {     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).commit().     verify(con).close(). }
false;protected;1;5;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {     assertTrue("Is new transaction", status.isNewTransaction()).     status.setRollbackOnly(). }
false;public;0;19;;@Test public void testTransactionWithPropagationNestedAndRollback() throws Exception {     final TransactionTemplate tt = new TransactionTemplate(tm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     assertTrue("Synchronization not active", !TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) throws RuntimeException {             assertTrue("Is new transaction", status.isNewTransaction()).             status.setRollbackOnly().         }     }).     assertTrue("Hasn't thread connection", !TransactionSynchronizationManager.hasResource(ds)).     verify(con).rollback().     verify(con).close(). }
false;public;0;3;;@Override public void suspend() { }
false;public;0;3;;@Override public void resume() { }
false;public;0;3;;@Override public void flush() { }
false;public;1;8;;@Override public void beforeCommit(boolean readOnly) {     if (this.status != TransactionSynchronization.STATUS_COMMITTED) {         fail("Should never be called").     }     assertFalse(this.beforeCommitCalled).     this.beforeCommitCalled = true. }
false;public;0;5;;@Override public void beforeCompletion() {     assertFalse(this.beforeCompletionCalled).     this.beforeCompletionCalled = true. }
false;public;0;8;;@Override public void afterCommit() {     if (this.status != TransactionSynchronization.STATUS_COMMITTED) {         fail("Should never be called").     }     assertFalse(this.afterCommitCalled).     this.afterCommitCalled = true. }
false;public;1;9;;@Override public void afterCompletion(int status) {     try {         doAfterCompletion(status).     } catch (Throwable ex) {         this.afterCompletionException = ex.     } }
false;protected;1;6;;protected void doAfterCompletion(int status) {     assertFalse(this.afterCompletionCalled).     this.afterCompletionCalled = true.     assertTrue(status == this.status).     assertTrue(TransactionSynchronizationManager.hasResource(this.dataSource)). }
