commented;modifiers;parameterAmount;loc;comment;code
false;public;0;33;;@Test public void errorCodeTranslation() {     SQLExceptionTranslator sext = new SQLErrorCodeSQLExceptionTranslator(ERROR_CODES).     SQLException badSqlEx = new SQLException("", "", 1).     BadSqlGrammarException bsgex = (BadSqlGrammarException) sext.translate("task", "SQL", badSqlEx).     assertEquals("SQL", bsgex.getSql()).     assertEquals(badSqlEx, bsgex.getSQLException()).     SQLException invResEx = new SQLException("", "", 4).     InvalidResultSetAccessException irsex = (InvalidResultSetAccessException) sext.translate("task", "SQL", invResEx).     assertEquals("SQL", irsex.getSql()).     assertEquals(invResEx, irsex.getSQLException()).     checkTranslation(sext, 5, DataAccessResourceFailureException.class).     checkTranslation(sext, 6, DataIntegrityViolationException.class).     checkTranslation(sext, 7, CannotAcquireLockException.class).     checkTranslation(sext, 8, DeadlockLoserDataAccessException.class).     checkTranslation(sext, 9, CannotSerializeTransactionException.class).     checkTranslation(sext, 10, DuplicateKeyException.class).     SQLException dupKeyEx = new SQLException("", "", 10).     DataAccessException dksex = sext.translate("task", "SQL", dupKeyEx).     assertTrue("Not instance of DataIntegrityViolationException", DataIntegrityViolationException.class.isAssignableFrom(dksex.getClass())).     // Test fallback. We assume that no database will ever return this error code,     // but 07xxx will be bad grammar picked up by the fallback SQLState translator     SQLException sex = new SQLException("", "07xxx", 666666666).     BadSqlGrammarException bsgex2 = (BadSqlGrammarException) sext.translate("task", "SQL2", sex).     assertEquals("SQL2", bsgex2.getSql()).     assertEquals(sex, bsgex2.getSQLException()). }
false;private;3;6;;private void checkTranslation(SQLExceptionTranslator sext, int errorCode, Class<?> exClass) {     SQLException sex = new SQLException("", "", errorCode).     DataAccessException ex = sext.translate("", "", sex).     assertTrue(exClass.isInstance(ex)).     assertTrue(ex.getCause() == sex). }
false;public;0;11;;@Test public void batchExceptionTranslation() {     SQLExceptionTranslator sext = new SQLErrorCodeSQLExceptionTranslator(ERROR_CODES).     SQLException badSqlEx = new SQLException("", "", 1).     BatchUpdateException batchUpdateEx = new BatchUpdateException().     batchUpdateEx.setNextException(badSqlEx).     BadSqlGrammarException bsgex = (BadSqlGrammarException) sext.translate("task", "SQL", batchUpdateEx).     assertEquals("SQL", bsgex.getSql()).     assertEquals(badSqlEx, bsgex.getSQLException()). }
false;public;0;9;;@Test public void dataTruncationTranslation() {     SQLExceptionTranslator sext = new SQLErrorCodeSQLExceptionTranslator(ERROR_CODES).     SQLException dataAccessEx = new SQLException("", "", 5).     DataTruncation dataTruncation = new DataTruncation(1, true, true, 1, 1, dataAccessEx).     DataAccessResourceFailureException daex = (DataAccessResourceFailureException) sext.translate("task", "SQL", dataTruncation).     assertEquals(dataTruncation, daex.getCause()). }
false;protected;3;7;;@Override @Nullable protected DataAccessException customTranslate(String task, @Nullable String sql, SQLException sqlex) {     assertEquals(TASK, task).     assertEquals(SQL, sql).     return (sqlex == badSqlEx) ? customDex : null. }
false;public;0;26;;@SuppressWarnings("serial") @Test public void customTranslateMethodTranslation() {     final String TASK = "TASK".     final String SQL = "SQL SELECT *".     final DataAccessException customDex = new DataAccessException("") {     }.     final SQLException badSqlEx = new SQLException("", "", 1).     SQLException intVioEx = new SQLException("", "", 6).     SQLErrorCodeSQLExceptionTranslator sext = new SQLErrorCodeSQLExceptionTranslator() {          @Override         @Nullable         protected DataAccessException customTranslate(String task, @Nullable String sql, SQLException sqlex) {             assertEquals(TASK, task).             assertEquals(SQL, sql).             return (sqlex == badSqlEx) ? customDex : null.         }     }.     sext.setSqlErrorCodes(ERROR_CODES).     // Shouldn't custom translate this     assertEquals(customDex, sext.translate(TASK, SQL, badSqlEx)).     DataIntegrityViolationException diex = (DataIntegrityViolationException) sext.translate(TASK, SQL, intVioEx).     assertEquals(intVioEx, diex.getCause()). }
false;public;0;30;;@Test public void customExceptionTranslation() {     final String TASK = "TASK".     final String SQL = "SQL SELECT *".     final SQLErrorCodes customErrorCodes = new SQLErrorCodes().     final CustomSQLErrorCodesTranslation customTranslation = new CustomSQLErrorCodesTranslation().     customErrorCodes.setBadSqlGrammarCodes(new String[] { "1", "2" }).     customErrorCodes.setDataIntegrityViolationCodes(new String[] { "3", "4" }).     customTranslation.setErrorCodes(new String[] { "1" }).     customTranslation.setExceptionClass(CustomErrorCodeException.class).     customErrorCodes.setCustomTranslations(new CustomSQLErrorCodesTranslation[] { customTranslation }).     SQLErrorCodeSQLExceptionTranslator sext = new SQLErrorCodeSQLExceptionTranslator().     sext.setSqlErrorCodes(customErrorCodes).     // Should custom translate this     SQLException badSqlEx = new SQLException("", "", 1).     assertEquals(CustomErrorCodeException.class, sext.translate(TASK, SQL, badSqlEx).getClass()).     assertEquals(badSqlEx, sext.translate(TASK, SQL, badSqlEx).getCause()).     // Shouldn't custom translate this     SQLException invResEx = new SQLException("", "", 3).     DataIntegrityViolationException diex = (DataIntegrityViolationException) sext.translate(TASK, SQL, invResEx).     assertEquals(invResEx, diex.getCause()).     // Shouldn't custom translate this - invalid class     exception.expect(IllegalArgumentException.class).     customTranslation.setExceptionClass(String.class). }
