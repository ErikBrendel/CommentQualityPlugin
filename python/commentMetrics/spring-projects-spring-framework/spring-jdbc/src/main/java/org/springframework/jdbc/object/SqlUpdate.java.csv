commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the maximum number of rows that may be affected by this update.  * The default value is 0, which does not limit the number of rows affected.  * @param maxRowsAffected the maximum number of rows that can be affected by  * this update without this class's update method considering it an error  */ ;/**  * Set the maximum number of rows that may be affected by this update.  * The default value is 0, which does not limit the number of rows affected.  * @param maxRowsAffected the maximum number of rows that can be affected by  * this update without this class's update method considering it an error  */ public void setMaxRowsAffected(int maxRowsAffected) {     this.maxRowsAffected = maxRowsAffected. }
true;public;1;3;/**  * Set the <i>exact</i> number of rows that must be affected by this update.  * The default value is 0, which allows any number of rows to be affected.  * <p>This is an alternative to setting the <i>maximum</i> number of rows  * that may be affected.  * @param requiredRowsAffected the exact number of rows that must be affected  * by this update without this class's update method considering it an error  */ ;/**  * Set the <i>exact</i> number of rows that must be affected by this update.  * The default value is 0, which allows any number of rows to be affected.  * <p>This is an alternative to setting the <i>maximum</i> number of rows  * that may be affected.  * @param requiredRowsAffected the exact number of rows that must be affected  * by this update without this class's update method considering it an error  */ public void setRequiredRowsAffected(int requiredRowsAffected) {     this.requiredRowsAffected = requiredRowsAffected. }
true;protected;1;8;/**  * Check the given number of affected rows against the  * specified maximum number or required number.  * @param rowsAffected the number of affected rows  * @throws JdbcUpdateAffectedIncorrectNumberOfRowsException  * if the actually affected rows are out of bounds  * @see #setMaxRowsAffected  * @see #setRequiredRowsAffected  */ ;/**  * Check the given number of affected rows against the  * specified maximum number or required number.  * @param rowsAffected the number of affected rows  * @throws JdbcUpdateAffectedIncorrectNumberOfRowsException  * if the actually affected rows are out of bounds  * @see #setMaxRowsAffected  * @see #setRequiredRowsAffected  */ protected void checkRowsAffected(int rowsAffected) throws JdbcUpdateAffectedIncorrectNumberOfRowsException {     if (this.maxRowsAffected > 0 && rowsAffected > this.maxRowsAffected) {         throw new JdbcUpdateAffectedIncorrectNumberOfRowsException(resolveSql(), this.maxRowsAffected, rowsAffected).     }     if (this.requiredRowsAffected > 0 && rowsAffected != this.requiredRowsAffected) {         throw new JdbcUpdateAffectedIncorrectNumberOfRowsException(resolveSql(), this.requiredRowsAffected, rowsAffected).     } }
true;public;1;6;/**  * Generic method to execute the update given parameters.  * All other update methods invoke this method.  * @param params array of parameters objects  * @return the number of rows affected by the update  */ ;/**  * Generic method to execute the update given parameters.  * All other update methods invoke this method.  * @param params array of parameters objects  * @return the number of rows affected by the update  */ public int update(Object... params) throws DataAccessException {     validateParameters(params).     int rowsAffected = getJdbcTemplate().update(newPreparedStatementCreator(params)).     checkRowsAffected(rowsAffected).     return rowsAffected. }
true;public;2;12;/**  * Method to execute the update given arguments and  * retrieve the generated keys using a KeyHolder.  * @param params array of parameter objects  * @param generatedKeyHolder the KeyHolder that will hold the generated keys  * @return the number of rows affected by the update  */ ;/**  * Method to execute the update given arguments and  * retrieve the generated keys using a KeyHolder.  * @param params array of parameter objects  * @param generatedKeyHolder the KeyHolder that will hold the generated keys  * @return the number of rows affected by the update  */ public int update(Object[] params, KeyHolder generatedKeyHolder) throws DataAccessException {     if (!isReturnGeneratedKeys() && getGeneratedKeysColumnNames() == null) {         throw new InvalidDataAccessApiUsageException("The update method taking a KeyHolder should only be used when generated keys have " + "been configured by calling either 'setReturnGeneratedKeys' or " + "'setGeneratedKeysColumnNames'.").     }     validateParameters(params).     int rowsAffected = getJdbcTemplate().update(newPreparedStatementCreator(params), generatedKeyHolder).     checkRowsAffected(rowsAffected).     return rowsAffected. }
true;public;0;3;/**  * Convenience method to execute an update with no parameters.  */ ;/**  * Convenience method to execute an update with no parameters.  */ public int update() throws DataAccessException {     return update(new Object[0]). }
true;public;1;3;/**  * Convenient method to execute an update given one int arg.  */ ;/**  * Convenient method to execute an update given one int arg.  */ public int update(int p1) throws DataAccessException {     return update(new Object[] { p1 }). }
true;public;2;3;/**  * Convenient method to execute an update given two int args.  */ ;/**  * Convenient method to execute an update given two int args.  */ public int update(int p1, int p2) throws DataAccessException {     return update(new Object[] { p1, p2 }). }
true;public;1;3;/**  * Convenient method to execute an update given one long arg.  */ ;/**  * Convenient method to execute an update given one long arg.  */ public int update(long p1) throws DataAccessException {     return update(new Object[] { p1 }). }
true;public;2;3;/**  * Convenient method to execute an update given two long args.  */ ;/**  * Convenient method to execute an update given two long args.  */ public int update(long p1, long p2) throws DataAccessException {     return update(new Object[] { p1, p2 }). }
true;public;1;3;/**  * Convenient method to execute an update given one String arg.  */ ;/**  * Convenient method to execute an update given one String arg.  */ public int update(String p) throws DataAccessException {     return update(new Object[] { p }). }
true;public;2;3;/**  * Convenient method to execute an update given two String args.  */ ;/**  * Convenient method to execute an update given two String args.  */ public int update(String p1, String p2) throws DataAccessException {     return update(new Object[] { p1, p2 }). }
true;public;1;10;/**  * Generic method to execute the update given named parameters.  * All other update methods invoke this method.  * @param paramMap a Map of parameter name to parameter object,  * matching named parameters specified in the SQL statement  * @return the number of rows affected by the update  */ ;/**  * Generic method to execute the update given named parameters.  * All other update methods invoke this method.  * @param paramMap a Map of parameter name to parameter object,  * matching named parameters specified in the SQL statement  * @return the number of rows affected by the update  */ public int updateByNamedParam(Map<String, ?> paramMap) throws DataAccessException {     validateNamedParameters(paramMap).     ParsedSql parsedSql = getParsedSql().     MapSqlParameterSource paramSource = new MapSqlParameterSource(paramMap).     String sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource).     Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, getDeclaredParameters()).     int rowsAffected = getJdbcTemplate().update(newPreparedStatementCreator(sqlToUse, params)).     checkRowsAffected(rowsAffected).     return rowsAffected. }
true;public;2;10;/**  * Method to execute the update given arguments and  * retrieve the generated keys using a KeyHolder.  * @param paramMap a Map of parameter name to parameter object,  * matching named parameters specified in the SQL statement  * @param generatedKeyHolder the KeyHolder that will hold the generated keys  * @return the number of rows affected by the update  */ ;/**  * Method to execute the update given arguments and  * retrieve the generated keys using a KeyHolder.  * @param paramMap a Map of parameter name to parameter object,  * matching named parameters specified in the SQL statement  * @param generatedKeyHolder the KeyHolder that will hold the generated keys  * @return the number of rows affected by the update  */ public int updateByNamedParam(Map<String, ?> paramMap, KeyHolder generatedKeyHolder) throws DataAccessException {     validateNamedParameters(paramMap).     ParsedSql parsedSql = getParsedSql().     MapSqlParameterSource paramSource = new MapSqlParameterSource(paramMap).     String sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource).     Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, getDeclaredParameters()).     int rowsAffected = getJdbcTemplate().update(newPreparedStatementCreator(sqlToUse, params), generatedKeyHolder).     checkRowsAffected(rowsAffected).     return rowsAffected. }
