commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the number of statements that will trigger an automatic intermediate  * flush. {@code update} calls or the given statement parameters will  * be queued until the batch size is met, at which point it will empty the  * queue and execute the batch.  * <p>You can also flush already queued statements with an explicit  * {@code flush} call. Note that you need to this after queueing  * all parameters to guarantee that all statements have been flushed.  */ ;/**  * Set the number of statements that will trigger an automatic intermediate  * flush. {@code update} calls or the given statement parameters will  * be queued until the batch size is met, at which point it will empty the  * queue and execute the batch.  * <p>You can also flush already queued statements with an explicit  * {@code flush} call. Note that you need to this after queueing  * all parameters to guarantee that all statements have been flushed.  */ public void setBatchSize(int batchSize) {     this.batchSize = batchSize. }
true;public;1;3;/**  * Set whether to track the rows affected by batch updates performed  * by this operation object.  * <p>Default is "true". Turn this off to save the memory needed for  * the list of row counts.  * @see #getRowsAffected()  */ ;/**  * Set whether to track the rows affected by batch updates performed  * by this operation object.  * <p>Default is "true". Turn this off to save the memory needed for  * the list of row counts.  * @see #getRowsAffected()  */ public void setTrackRowsAffected(boolean trackRowsAffected) {     this.trackRowsAffected = trackRowsAffected. }
true;protected;0;4;/**  * BatchSqlUpdate does not support BLOB or CLOB parameters.  */ ;/**  * BatchSqlUpdate does not support BLOB or CLOB parameters.  */ @Override protected boolean supportsLobParameters() {     return false. }
true;public;1;14;/**  * Overridden version of {@code update} that adds the given statement  * parameters to the queue rather than executing them immediately.  * All other {@code update} methods of the SqlUpdate base class go  * through this method and will thus behave similarly.  * <p>You need to call {@code flush} to actually execute the batch.  * If the specified batch size is reached, an implicit flush will happen.  * you still need to finally call {@code flush} to flush all statements.  * @param params array of parameter objects  * @return the number of rows affected by the update (always -1,  * meaning "not applicable", as the statement is not actually  * executed by this method)  * @see #flush  */ ;/**  * Overridden version of {@code update} that adds the given statement  * parameters to the queue rather than executing them immediately.  * All other {@code update} methods of the SqlUpdate base class go  * through this method and will thus behave similarly.  * <p>You need to call {@code flush} to actually execute the batch.  * If the specified batch size is reached, an implicit flush will happen.  * you still need to finally call {@code flush} to flush all statements.  * @param params array of parameter objects  * @return the number of rows affected by the update (always -1,  * meaning "not applicable", as the statement is not actually  * executed by this method)  * @see #flush  */ @Override public int update(Object... params) throws DataAccessException {     validateParameters(params).     this.parameterQueue.add(params.clone()).     if (this.parameterQueue.size() == this.batchSize) {         if (logger.isDebugEnabled()) {             logger.debug("Triggering auto-flush because queue reached batch size of " + this.batchSize).         }         flush().     }     return -1. }
false;public;0;4;;@Override public int getBatchSize() {     return parameterQueue.size(). }
false;public;2;5;;@Override public void setValues(PreparedStatement ps, int index) throws SQLException {     Object[] params = parameterQueue.removeFirst().     newPreparedStatementSetter(params).setValues(ps). }
true;public;0;28;/**  * Trigger any queued update operations to be added as a final batch.  * @return an array of the number of rows affected by each statement  */ ;/**  * Trigger any queued update operations to be added as a final batch.  * @return an array of the number of rows affected by each statement  */ public int[] flush() {     if (this.parameterQueue.isEmpty()) {         return new int[0].     }     int[] rowsAffected = getJdbcTemplate().batchUpdate(resolveSql(), new BatchPreparedStatementSetter() {          @Override         public int getBatchSize() {             return parameterQueue.size().         }          @Override         public void setValues(PreparedStatement ps, int index) throws SQLException {             Object[] params = parameterQueue.removeFirst().             newPreparedStatementSetter(params).setValues(ps).         }     }).     for (int rowCount : rowsAffected) {         checkRowsAffected(rowCount).         if (this.trackRowsAffected) {             this.rowsAffected.add(rowCount).         }     }     return rowsAffected. }
true;public;0;3;/**  * Return the current number of statements or statement parameters  * in the queue.  */ ;/**  * Return the current number of statements or statement parameters  * in the queue.  */ public int getQueueCount() {     return this.parameterQueue.size(). }
true;public;0;3;/**  * Return the number of already executed statements.  */ ;/**  * Return the number of already executed statements.  */ public int getExecutionCount() {     return this.rowsAffected.size(). }
true;public;0;8;/**  * Return the number of affected rows for all already executed statements.  * Accumulates all of {@code flush}'s return values until  * {@code reset} is invoked.  * @return an array of the number of rows affected by each statement  * @see #reset  */ ;/**  * Return the number of affected rows for all already executed statements.  * Accumulates all of {@code flush}'s return values until  * {@code reset} is invoked.  * @return an array of the number of rows affected by each statement  * @see #reset  */ public int[] getRowsAffected() {     int[] result = new int[this.rowsAffected.size()].     int i = 0.     for (Iterator<Integer> it = this.rowsAffected.iterator(). it.hasNext(). i++) {         result[i] = it.next().     }     return result. }
true;public;0;4;/**  * Reset the statement parameter queue, the rows affected cache,  * and the execution count.  */ ;/**  * Reset the statement parameter queue, the rows affected cache,  * and the execution count.  */ public void reset() {     this.parameterQueue.clear().     this.rowsAffected.clear(). }
