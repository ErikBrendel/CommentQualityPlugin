commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Add a script to execute to initialize or clean up the database.  * @param script the path to an SQL script (never {@code null})  */ ;/**  * Add a script to execute to initialize or clean up the database.  * @param script the path to an SQL script (never {@code null})  */ public void addScript(Resource script) {     Assert.notNull(script, "Script must not be null").     this.scripts.add(script). }
true;public;1;4;/**  * Add multiple scripts to execute to initialize or clean up the database.  * @param scripts the scripts to execute (never {@code null})  */ ;/**  * Add multiple scripts to execute to initialize or clean up the database.  * @param scripts the scripts to execute (never {@code null})  */ public void addScripts(Resource... scripts) {     assertContentsOfScriptArray(scripts).     this.scripts.addAll(Arrays.asList(scripts)). }
true;public;1;5;/**  * Set the scripts to execute to initialize or clean up the database,  * replacing any previously added scripts.  * @param scripts the scripts to execute (never {@code null})  */ ;/**  * Set the scripts to execute to initialize or clean up the database,  * replacing any previously added scripts.  * @param scripts the scripts to execute (never {@code null})  */ public void setScripts(Resource... scripts) {     assertContentsOfScriptArray(scripts).     // Ensure that the list is modifiable     this.scripts = new ArrayList<>(Arrays.asList(scripts)). }
false;private;1;4;;private void assertContentsOfScriptArray(Resource... scripts) {     Assert.notNull(scripts, "Scripts array must not be null").     Assert.noNullElements(scripts, "Scripts array must not contain null elements"). }
true;public;1;3;/**  * Specify the encoding for the configured SQL scripts,  * if different from the platform encoding.  * @param sqlScriptEncoding the encoding used in scripts  * (may be {@code null} or empty to indicate platform encoding)  * @see #addScript(Resource)  */ ;/**  * Specify the encoding for the configured SQL scripts,  * if different from the platform encoding.  * @param sqlScriptEncoding the encoding used in scripts  * (may be {@code null} or empty to indicate platform encoding)  * @see #addScript(Resource)  */ public void setSqlScriptEncoding(@Nullable String sqlScriptEncoding) {     this.sqlScriptEncoding = (StringUtils.hasText(sqlScriptEncoding) ? sqlScriptEncoding : null). }
true;public;1;3;/**  * Specify the statement separator, if a custom one.  * <p>Defaults to {@code "."} if not specified and falls back to {@code "\n"}  * as a last resort. may be set to {@link ScriptUtils#EOF_STATEMENT_SEPARATOR}  * to signal that each script contains a single statement without a separator.  * @param separator the script statement separator  */ ;/**  * Specify the statement separator, if a custom one.  * <p>Defaults to {@code "."} if not specified and falls back to {@code "\n"}  * as a last resort. may be set to {@link ScriptUtils#EOF_STATEMENT_SEPARATOR}  * to signal that each script contains a single statement without a separator.  * @param separator the script statement separator  */ public void setSeparator(String separator) {     this.separator = separator. }
true;public;1;3;/**  * Set the prefix that identifies single-line comments within the SQL scripts.  * <p>Defaults to {@code "--"}.  * @param commentPrefix the prefix for single-line comments  */ ;/**  * Set the prefix that identifies single-line comments within the SQL scripts.  * <p>Defaults to {@code "--"}.  * @param commentPrefix the prefix for single-line comments  */ public void setCommentPrefix(String commentPrefix) {     this.commentPrefix = commentPrefix. }
true;public;1;4;/**  * Set the start delimiter that identifies block comments within the SQL  * scripts.  * <p>Defaults to {@code "/*"}.  * @param blockCommentStartDelimiter the start delimiter for block comments  * (never {@code null} or empty)  * @since 4.0.3  * @see #setBlockCommentEndDelimiter  */ ;/**  * Set the start delimiter that identifies block comments within the SQL  * scripts.  * <p>Defaults to {@code "/*"}.  * @param blockCommentStartDelimiter the start delimiter for block comments  * (never {@code null} or empty)  * @since 4.0.3  * @see #setBlockCommentEndDelimiter  */ public void setBlockCommentStartDelimiter(String blockCommentStartDelimiter) {     Assert.hasText(blockCommentStartDelimiter, "BlockCommentStartDelimiter must not be null or empty").     this.blockCommentStartDelimiter = blockCommentStartDelimiter. }
true;public;1;4;/**  * Set the end delimiter that identifies block comments within the SQL  * scripts.  * <p>Defaults to <code>"*&#47."</code>.  * @param blockCommentEndDelimiter the end delimiter for block comments  * (never {@code null} or empty)  * @since 4.0.3  * @see #setBlockCommentStartDelimiter  */ ;/**  * Set the end delimiter that identifies block comments within the SQL  * scripts.  * <p>Defaults to <code>"*&#47."</code>.  * @param blockCommentEndDelimiter the end delimiter for block comments  * (never {@code null} or empty)  * @since 4.0.3  * @see #setBlockCommentStartDelimiter  */ public void setBlockCommentEndDelimiter(String blockCommentEndDelimiter) {     Assert.hasText(blockCommentEndDelimiter, "BlockCommentEndDelimiter must not be null or empty").     this.blockCommentEndDelimiter = blockCommentEndDelimiter. }
true;public;1;3;/**  * Flag to indicate that all failures in SQL should be logged but not cause a failure.  * <p>Defaults to {@code false}.  * @param continueOnError {@code true} if script execution should continue on error  */ ;/**  * Flag to indicate that all failures in SQL should be logged but not cause a failure.  * <p>Defaults to {@code false}.  * @param continueOnError {@code true} if script execution should continue on error  */ public void setContinueOnError(boolean continueOnError) {     this.continueOnError = continueOnError. }
true;public;1;3;/**  * Flag to indicate that a failed SQL {@code DROP} statement can be ignored.  * <p>This is useful for a non-embedded database whose SQL dialect does not  * support an {@code IF EXISTS} clause in a {@code DROP} statement.  * <p>The default is {@code false} so that if the populator runs accidentally, it will  * fail fast if a script starts with a {@code DROP} statement.  * @param ignoreFailedDrops {@code true} if failed drop statements should be ignored  */ ;/**  * Flag to indicate that a failed SQL {@code DROP} statement can be ignored.  * <p>This is useful for a non-embedded database whose SQL dialect does not  * support an {@code IF EXISTS} clause in a {@code DROP} statement.  * <p>The default is {@code false} so that if the populator runs accidentally, it will  * fail fast if a script starts with a {@code DROP} statement.  * @param ignoreFailedDrops {@code true} if failed drop statements should be ignored  */ public void setIgnoreFailedDrops(boolean ignoreFailedDrops) {     this.ignoreFailedDrops = ignoreFailedDrops. }
true;public;1;9;/**  * {@inheritDoc}  * @see #execute(DataSource)  */ ;/**  * {@inheritDoc}  * @see #execute(DataSource)  */ @Override public void populate(Connection connection) throws ScriptException {     Assert.notNull(connection, "Connection must not be null").     for (Resource script : this.scripts) {         EncodedResource encodedScript = new EncodedResource(script, this.sqlScriptEncoding).         ScriptUtils.executeSqlScript(connection, encodedScript, this.continueOnError, this.ignoreFailedDrops, this.commentPrefix, this.separator, this.blockCommentStartDelimiter, this.blockCommentEndDelimiter).     } }
true;public;1;3;/**  * Execute this {@code ResourceDatabasePopulator} against the given  * {@link DataSource}.  * <p>Delegates to {@link DatabasePopulatorUtils#execute}.  * @param dataSource the {@code DataSource} to execute against (never {@code null})  * @throws ScriptException if an error occurs  * @since 4.1  * @see #populate(Connection)  */ ;/**  * Execute this {@code ResourceDatabasePopulator} against the given  * {@link DataSource}.  * <p>Delegates to {@link DatabasePopulatorUtils#execute}.  * @param dataSource the {@code DataSource} to execute against (never {@code null})  * @throws ScriptException if an error occurs  * @since 4.1  * @see #populate(Connection)  */ public void execute(DataSource dataSource) throws ScriptException {     DatabasePopulatorUtils.execute(this, dataSource). }
