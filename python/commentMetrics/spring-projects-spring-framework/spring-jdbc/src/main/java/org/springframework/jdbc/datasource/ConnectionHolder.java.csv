commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Return the ConnectionHandle held by this ConnectionHolder.  */ ;/**  * Return the ConnectionHandle held by this ConnectionHolder.  */ @Nullable public ConnectionHandle getConnectionHandle() {     return this.connectionHandle. }
true;protected;0;3;/**  * Return whether this holder currently has a Connection.  */ ;/**  * Return whether this holder currently has a Connection.  */ protected boolean hasConnection() {     return (this.connectionHandle != null). }
true;protected;1;3;/**  * Set whether this holder represents an active, JDBC-managed transaction.  * @see DataSourceTransactionManager  */ ;/**  * Set whether this holder represents an active, JDBC-managed transaction.  * @see DataSourceTransactionManager  */ protected void setTransactionActive(boolean transactionActive) {     this.transactionActive = transactionActive. }
true;protected;0;3;/**  * Return whether this holder represents an active, JDBC-managed transaction.  */ ;/**  * Return whether this holder represents an active, JDBC-managed transaction.  */ protected boolean isTransactionActive() {     return this.transactionActive. }
true;protected;1;14;/**  * Override the existing Connection handle with the given Connection.  * Reset the handle if given {@code null}.  * <p>Used for releasing the Connection on suspend (with a {@code null}  * argument) and setting a fresh Connection on resume.  */ ;/**  * Override the existing Connection handle with the given Connection.  * Reset the handle if given {@code null}.  * <p>Used for releasing the Connection on suspend (with a {@code null}  * argument) and setting a fresh Connection on resume.  */ protected void setConnection(@Nullable Connection connection) {     if (this.currentConnection != null) {         if (this.connectionHandle != null) {             this.connectionHandle.releaseConnection(this.currentConnection).         }         this.currentConnection = null.     }     if (connection != null) {         this.connectionHandle = new SimpleConnectionHandle(connection).     } else {         this.connectionHandle = null.     } }
true;public;0;7;/**  * Return the current Connection held by this ConnectionHolder.  * <p>This will be the same Connection until {@code released}  * gets called on the ConnectionHolder, which will reset the  * held Connection, fetching a new Connection on demand.  * @see ConnectionHandle#getConnection()  * @see #released()  */ ;/**  * Return the current Connection held by this ConnectionHolder.  * <p>This will be the same Connection until {@code released}  * gets called on the ConnectionHolder, which will reset the  * held Connection, fetching a new Connection on demand.  * @see ConnectionHandle#getConnection()  * @see #released()  */ public Connection getConnection() {     Assert.notNull(this.connectionHandle, "Active Connection is required").     if (this.currentConnection == null) {         this.currentConnection = this.connectionHandle.getConnection().     }     return this.currentConnection. }
true;public;0;6;/**  * Return whether JDBC 3.0 Savepoints are supported.  * Caches the flag for the lifetime of this ConnectionHolder.  * @throws SQLException if thrown by the JDBC driver  */ ;/**  * Return whether JDBC 3.0 Savepoints are supported.  * Caches the flag for the lifetime of this ConnectionHolder.  * @throws SQLException if thrown by the JDBC driver  */ public boolean supportsSavepoints() throws SQLException {     if (this.savepointsSupported == null) {         this.savepointsSupported = getConnection().getMetaData().supportsSavepoints().     }     return this.savepointsSupported. }
true;public;0;4;/**  * Create a new JDBC 3.0 Savepoint for the current Connection,  * using generated savepoint names that are unique for the Connection.  * @return the new Savepoint  * @throws SQLException if thrown by the JDBC driver  */ ;/**  * Create a new JDBC 3.0 Savepoint for the current Connection,  * using generated savepoint names that are unique for the Connection.  * @return the new Savepoint  * @throws SQLException if thrown by the JDBC driver  */ public Savepoint createSavepoint() throws SQLException {     this.savepointCounter++.     return getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter). }
true;public;0;10;/**  * Releases the current Connection held by this ConnectionHolder.  * <p>This is necessary for ConnectionHandles that expect "Connection borrowing",  * where each returned Connection is only temporarily leased and needs to be  * returned once the data operation is done, to make the Connection available  * for other operations within the same transaction.  */ ;/**  * Releases the current Connection held by this ConnectionHolder.  * <p>This is necessary for ConnectionHandles that expect "Connection borrowing",  * where each returned Connection is only temporarily leased and needs to be  * returned once the data operation is done, to make the Connection available  * for other operations within the same transaction.  */ @Override public void released() {     super.released().     if (!isOpen() && this.currentConnection != null) {         if (this.connectionHandle != null) {             this.connectionHandle.releaseConnection(this.currentConnection).         }         this.currentConnection = null.     } }
false;public;0;7;;@Override public void clear() {     super.clear().     this.transactionActive = false.     this.savepointsSupported = null.     this.savepointCounter = 0. }
