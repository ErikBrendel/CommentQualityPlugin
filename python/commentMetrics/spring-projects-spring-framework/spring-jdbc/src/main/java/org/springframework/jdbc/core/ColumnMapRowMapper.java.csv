commented;modifiers;parameterAmount;loc;comment;code
false;public;2;11;;@Override public Map<String, Object> mapRow(ResultSet rs, int rowNum) throws SQLException {     ResultSetMetaData rsmd = rs.getMetaData().     int columnCount = rsmd.getColumnCount().     Map<String, Object> mapOfColumnValues = createColumnMap(columnCount).     for (int i = 1. i <= columnCount. i++) {         String column = JdbcUtils.lookupColumnName(rsmd, i).         mapOfColumnValues.putIfAbsent(getColumnKey(column), getColumnValue(rs, i)).     }     return mapOfColumnValues. }
true;protected;1;3;/**  * Create a Map instance to be used as column map.  * <p>By default, a linked case-insensitive Map will be created.  * @param columnCount the column count, to be used as initial  * capacity for the Map  * @return the new Map instance  * @see org.springframework.util.LinkedCaseInsensitiveMap  */ ;/**  * Create a Map instance to be used as column map.  * <p>By default, a linked case-insensitive Map will be created.  * @param columnCount the column count, to be used as initial  * capacity for the Map  * @return the new Map instance  * @see org.springframework.util.LinkedCaseInsensitiveMap  */ protected Map<String, Object> createColumnMap(int columnCount) {     return new LinkedCaseInsensitiveMap<>(columnCount). }
true;protected;1;3;/**  * Determine the key to use for the given column in the column Map.  * @param columnName the column name as returned by the ResultSet  * @return the column key to use  * @see java.sql.ResultSetMetaData#getColumnName  */ ;/**  * Determine the key to use for the given column in the column Map.  * @param columnName the column name as returned by the ResultSet  * @return the column key to use  * @see java.sql.ResultSetMetaData#getColumnName  */ protected String getColumnKey(String columnName) {     return columnName. }
true;protected;2;4;/**  * Retrieve a JDBC object value for the specified column.  * <p>The default implementation uses the {@code getObject} method.  * Additionally, this implementation includes a "hack" to get around Oracle  * returning a non standard object for their TIMESTAMP datatype.  * @param rs is the ResultSet holding the data  * @param index is the column index  * @return the Object returned  * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue  */ ;/**  * Retrieve a JDBC object value for the specified column.  * <p>The default implementation uses the {@code getObject} method.  * Additionally, this implementation includes a "hack" to get around Oracle  * returning a non standard object for their TIMESTAMP datatype.  * @param rs is the ResultSet holding the data  * @param index is the column index  * @return the Object returned  * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue  */ @Nullable protected Object getColumnValue(ResultSet rs, int index) throws SQLException {     return JdbcUtils.getResultSetValue(rs, index). }
