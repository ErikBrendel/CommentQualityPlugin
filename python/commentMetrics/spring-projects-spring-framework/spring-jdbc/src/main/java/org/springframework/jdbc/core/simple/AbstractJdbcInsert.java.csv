commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Get the configured {@link JdbcTemplate}.  */ ;// ------------------------------------------------------------------------- // Methods dealing with configuration properties // ------------------------------------------------------------------------- /**  * Get the configured {@link JdbcTemplate}.  */ public JdbcTemplate getJdbcTemplate() {     return this.jdbcTemplate. }
true;public;1;4;/**  * Set the name of the table for this insert.  */ ;/**  * Set the name of the table for this insert.  */ public void setTableName(@Nullable String tableName) {     checkIfConfigurationModificationIsAllowed().     this.tableMetaDataContext.setTableName(tableName). }
true;public;0;4;/**  * Get the name of the table for this insert.  */ ;/**  * Get the name of the table for this insert.  */ @Nullable public String getTableName() {     return this.tableMetaDataContext.getTableName(). }
true;public;1;4;/**  * Set the name of the schema for this insert.  */ ;/**  * Set the name of the schema for this insert.  */ public void setSchemaName(@Nullable String schemaName) {     checkIfConfigurationModificationIsAllowed().     this.tableMetaDataContext.setSchemaName(schemaName). }
true;public;0;4;/**  * Get the name of the schema for this insert.  */ ;/**  * Get the name of the schema for this insert.  */ @Nullable public String getSchemaName() {     return this.tableMetaDataContext.getSchemaName(). }
true;public;1;4;/**  * Set the name of the catalog for this insert.  */ ;/**  * Set the name of the catalog for this insert.  */ public void setCatalogName(@Nullable String catalogName) {     checkIfConfigurationModificationIsAllowed().     this.tableMetaDataContext.setCatalogName(catalogName). }
true;public;0;4;/**  * Get the name of the catalog for this insert.  */ ;/**  * Get the name of the catalog for this insert.  */ @Nullable public String getCatalogName() {     return this.tableMetaDataContext.getCatalogName(). }
true;public;1;5;/**  * Set the names of the columns to be used.  */ ;/**  * Set the names of the columns to be used.  */ public void setColumnNames(List<String> columnNames) {     checkIfConfigurationModificationIsAllowed().     this.declaredColumns.clear().     this.declaredColumns.addAll(columnNames). }
true;public;0;3;/**  * Get the names of the columns used.  */ ;/**  * Get the names of the columns used.  */ public List<String> getColumnNames() {     return Collections.unmodifiableList(this.declaredColumns). }
true;public;1;4;/**  * Specify the name of a single generated key column.  */ ;/**  * Specify the name of a single generated key column.  */ public void setGeneratedKeyName(String generatedKeyName) {     checkIfConfigurationModificationIsAllowed().     this.generatedKeyNames = new String[] { generatedKeyName }. }
true;public;1;4;/**  * Set the names of any generated keys.  */ ;/**  * Set the names of any generated keys.  */ public void setGeneratedKeyNames(String... generatedKeyNames) {     checkIfConfigurationModificationIsAllowed().     this.generatedKeyNames = generatedKeyNames. }
true;public;0;3;/**  * Get the names of any generated keys.  */ ;/**  * Get the names of any generated keys.  */ public String[] getGeneratedKeyNames() {     return this.generatedKeyNames. }
true;public;1;3;/**  * Specify whether the parameter meta-data for the call should be used.  * The default is {@code true}.  */ ;/**  * Specify whether the parameter meta-data for the call should be used.  * The default is {@code true}.  */ public void setAccessTableColumnMetaData(boolean accessTableColumnMetaData) {     this.tableMetaDataContext.setAccessTableColumnMetaData(accessTableColumnMetaData). }
true;public;1;3;/**  * Specify whether the default for including synonyms should be changed.  * The default is {@code false}.  */ ;/**  * Specify whether the default for including synonyms should be changed.  * The default is {@code false}.  */ public void setOverrideIncludeSynonymsDefault(boolean override) {     this.tableMetaDataContext.setOverrideIncludeSynonymsDefault(override). }
true;public;0;3;/**  * Get the insert string to be used.  */ ;/**  * Get the insert string to be used.  */ public String getInsertString() {     return this.insertString. }
true;public;0;3;/**  * Get the array of {@link java.sql.Types} to be used for insert.  */ ;/**  * Get the array of {@link java.sql.Types} to be used for insert.  */ public int[] getInsertTypes() {     return this.insertTypes. }
true;public,final,synchronized;0;18;/**  * Compile this JdbcInsert using provided parameters and meta-data plus other settings.  * This finalizes the configuration for this object and subsequent attempts to compile are  * ignored. This will be implicitly called the first time an un-compiled insert is executed.  * @throws InvalidDataAccessApiUsageException if the object hasn't been correctly initialized,  * for example if no DataSource has been provided  */ ;// ------------------------------------------------------------------------- // Methods handling compilation issues // ------------------------------------------------------------------------- /**  * Compile this JdbcInsert using provided parameters and meta-data plus other settings.  * This finalizes the configuration for this object and subsequent attempts to compile are  * ignored. This will be implicitly called the first time an un-compiled insert is executed.  * @throws InvalidDataAccessApiUsageException if the object hasn't been correctly initialized,  * for example if no DataSource has been provided  */ public final synchronized void compile() throws InvalidDataAccessApiUsageException {     if (!isCompiled()) {         if (getTableName() == null) {             throw new InvalidDataAccessApiUsageException("Table name is required").         }         try {             this.jdbcTemplate.afterPropertiesSet().         } catch (IllegalArgumentException ex) {             throw new InvalidDataAccessApiUsageException(ex.getMessage()).         }         compileInternal().         this.compiled = true.         if (logger.isDebugEnabled()) {             logger.debug("JdbcInsert for table [" + getTableName() + "] compiled").         }     } }
true;protected;0;11;/**  * Delegate method to perform the actual compilation.  * <p>Subclasses can override this template method to perform  their own compilation.  * Invoked after this base class's compilation is complete.  */ ;/**  * Delegate method to perform the actual compilation.  * <p>Subclasses can override this template method to perform  their own compilation.  * Invoked after this base class's compilation is complete.  */ protected void compileInternal() {     DataSource dataSource = getJdbcTemplate().getDataSource().     Assert.state(dataSource != null, "No DataSource set").     this.tableMetaDataContext.processMetaData(dataSource, getColumnNames(), getGeneratedKeyNames()).     this.insertString = this.tableMetaDataContext.createInsertString(getGeneratedKeyNames()).     this.insertTypes = this.tableMetaDataContext.createInsertTypes().     if (logger.isDebugEnabled()) {         logger.debug("Compiled insert object: insert string is [" + this.insertString + "]").     }     onCompileInternal(). }
true;protected;0;2;/**  * Hook method that subclasses may override to react to compilation.  * <p>This implementation is empty.  */ ;/**  * Hook method that subclasses may override to react to compilation.  * <p>This implementation is empty.  */ protected void onCompileInternal() { }
true;public;0;3;/**  * Is this operation "compiled"?  * @return whether this operation is compiled and ready to use  */ ;/**  * Is this operation "compiled"?  * @return whether this operation is compiled and ready to use  */ public boolean isCompiled() {     return this.compiled. }
true;protected;0;6;/**  * Check whether this operation has been compiled already.  * lazily compile it if not already compiled.  * <p>Automatically called by {@code validateParameters}.  */ ;/**  * Check whether this operation has been compiled already.  * lazily compile it if not already compiled.  * <p>Automatically called by {@code validateParameters}.  */ protected void checkCompiled() {     if (!isCompiled()) {         logger.debug("JdbcInsert not compiled before execution - invoking compile").         compile().     } }
true;protected;0;6;/**  * Method to check whether we are allowed to make any configuration changes at this time.  * If the class has been compiled, then no further changes to the configuration are allowed.  */ ;/**  * Method to check whether we are allowed to make any configuration changes at this time.  * If the class has been compiled, then no further changes to the configuration are allowed.  */ protected void checkIfConfigurationModificationIsAllowed() {     if (isCompiled()) {         throw new InvalidDataAccessApiUsageException("Configuration cannot be altered once the class has been compiled or used").     } }
true;protected;1;5;/**  * Delegate method that executes the insert using the passed-in Map of parameters.  * @param args a Map with parameter names and values to be used in insert  * @return the number of rows affected  */ ;// ------------------------------------------------------------------------- // Methods handling execution // ------------------------------------------------------------------------- /**  * Delegate method that executes the insert using the passed-in Map of parameters.  * @param args a Map with parameter names and values to be used in insert  * @return the number of rows affected  */ protected int doExecute(Map<String, ?> args) {     checkCompiled().     List<Object> values = matchInParameterValuesWithInsertColumns(args).     return executeInsertInternal(values). }
true;protected;1;5;/**  * Delegate method that executes the insert using the passed-in {@link SqlParameterSource}.  * @param parameterSource parameter names and values to be used in insert  * @return the number of rows affected  */ ;/**  * Delegate method that executes the insert using the passed-in {@link SqlParameterSource}.  * @param parameterSource parameter names and values to be used in insert  * @return the number of rows affected  */ protected int doExecute(SqlParameterSource parameterSource) {     checkCompiled().     List<Object> values = matchInParameterValuesWithInsertColumns(parameterSource).     return executeInsertInternal(values). }
true;private;1;6;/**  * Delegate method to execute the insert.  */ ;/**  * Delegate method to execute the insert.  */ private int executeInsertInternal(List<?> values) {     if (logger.isDebugEnabled()) {         logger.debug("The following parameters are used for insert " + getInsertString() + " with: " + values).     }     return getJdbcTemplate().update(getInsertString(), values.toArray(), getInsertTypes()). }
true;protected;1;5;/**  * Method that provides execution of the insert using the passed-in  * Map of parameters and returning a generated key.  * @param args a Map with parameter names and values to be used in insert  * @return the key generated by the insert  */ ;/**  * Method that provides execution of the insert using the passed-in  * Map of parameters and returning a generated key.  * @param args a Map with parameter names and values to be used in insert  * @return the key generated by the insert  */ protected Number doExecuteAndReturnKey(Map<String, ?> args) {     checkCompiled().     List<Object> values = matchInParameterValuesWithInsertColumns(args).     return executeInsertAndReturnKeyInternal(values). }
true;protected;1;5;/**  * Method that provides execution of the insert using the passed-in  * {@link SqlParameterSource} and returning a generated key.  * @param parameterSource parameter names and values to be used in insert  * @return the key generated by the insert  */ ;/**  * Method that provides execution of the insert using the passed-in  * {@link SqlParameterSource} and returning a generated key.  * @param parameterSource parameter names and values to be used in insert  * @return the key generated by the insert  */ protected Number doExecuteAndReturnKey(SqlParameterSource parameterSource) {     checkCompiled().     List<Object> values = matchInParameterValuesWithInsertColumns(parameterSource).     return executeInsertAndReturnKeyInternal(values). }
true;protected;1;5;/**  * Method that provides execution of the insert using the passed-in  * Map of parameters and returning all generated keys.  * @param args a Map with parameter names and values to be used in insert  * @return the KeyHolder containing keys generated by the insert  */ ;/**  * Method that provides execution of the insert using the passed-in  * Map of parameters and returning all generated keys.  * @param args a Map with parameter names and values to be used in insert  * @return the KeyHolder containing keys generated by the insert  */ protected KeyHolder doExecuteAndReturnKeyHolder(Map<String, ?> args) {     checkCompiled().     List<Object> values = matchInParameterValuesWithInsertColumns(args).     return executeInsertAndReturnKeyHolderInternal(values). }
true;protected;1;5;/**  * Method that provides execution of the insert using the passed-in  * {@link SqlParameterSource} and returning all generated keys.  * @param parameterSource parameter names and values to be used in insert  * @return the KeyHolder containing keys generated by the insert  */ ;/**  * Method that provides execution of the insert using the passed-in  * {@link SqlParameterSource} and returning all generated keys.  * @param parameterSource parameter names and values to be used in insert  * @return the KeyHolder containing keys generated by the insert  */ protected KeyHolder doExecuteAndReturnKeyHolder(SqlParameterSource parameterSource) {     checkCompiled().     List<Object> values = matchInParameterValuesWithInsertColumns(parameterSource).     return executeInsertAndReturnKeyHolderInternal(values). }
true;private;1;10;/**  * Delegate method to execute the insert, generating a single key.  */ ;/**  * Delegate method to execute the insert, generating a single key.  */ private Number executeInsertAndReturnKeyInternal(final List<?> values) {     KeyHolder kh = executeInsertAndReturnKeyHolderInternal(values).     if (kh.getKey() != null) {         return kh.getKey().     } else {         throw new DataIntegrityViolationException("Unable to retrieve the generated key for the insert: " + getInsertString()).     } }
true;private;1;83;/**  * Delegate method to execute the insert, generating any number of keys.  */ ;/**  * Delegate method to execute the insert, generating any number of keys.  */ private KeyHolder executeInsertAndReturnKeyHolderInternal(final List<?> values) {     if (logger.isDebugEnabled()) {         logger.debug("The following parameters are used for call " + getInsertString() + " with: " + values).     }     final KeyHolder keyHolder = new GeneratedKeyHolder().     if (this.tableMetaDataContext.isGetGeneratedKeysSupported()) {         getJdbcTemplate().update(con -> {             PreparedStatement ps = prepareStatementForGeneratedKeys(con).             setParameterValues(ps, values, getInsertTypes()).             return ps.         }, keyHolder).     } else {         if (!this.tableMetaDataContext.isGetGeneratedKeysSimulated()) {             throw new InvalidDataAccessResourceUsageException("The getGeneratedKeys feature is not supported by this database").         }         if (getGeneratedKeyNames().length < 1) {             throw new InvalidDataAccessApiUsageException("Generated Key Name(s) not specified. " + "Using the generated keys features requires specifying the name(s) of the generated column(s)").         }         if (getGeneratedKeyNames().length > 1) {             throw new InvalidDataAccessApiUsageException("Current database only supports retrieving the key for a single column. There are " + getGeneratedKeyNames().length + " columns specified: " + Arrays.asList(getGeneratedKeyNames())).         }         Assert.state(getTableName() != null, "No table name set").         final String keyQuery = this.tableMetaDataContext.getSimpleQueryForGetGeneratedKey(getTableName(), getGeneratedKeyNames()[0]).         Assert.state(keyQuery != null, "Query for simulating get generated keys must not be null").         if (keyQuery.toUpperCase().startsWith("RETURNING")) {             Long key = getJdbcTemplate().queryForObject(getInsertString() + " " + keyQuery, values.toArray(), Long.class).             Map<String, Object> keys = new HashMap<>(2).             keys.put(getGeneratedKeyNames()[0], key).             keyHolder.getKeyList().add(keys).         } else {             getJdbcTemplate().execute((ConnectionCallback<Object>) con -> {                 PreparedStatement ps = null.                 try {                     ps = con.prepareStatement(getInsertString()).                     setParameterValues(ps, values, getInsertTypes()).                     ps.executeUpdate().                 } finally {                     JdbcUtils.closeStatement(ps).                 }                 Statement keyStmt = null.                 ResultSet rs = null.                 Map<String, Object> keys = new HashMap<>(2).                 try {                     keyStmt = con.createStatement().                     rs = keyStmt.executeQuery(keyQuery).                     if (rs.next()) {                         long key = rs.getLong(1).                         keys.put(getGeneratedKeyNames()[0], key).                         keyHolder.getKeyList().add(keys).                     }                 } finally {                     JdbcUtils.closeResultSet(rs).                     JdbcUtils.closeStatement(keyStmt).                 }                 return null.             }).         }     }     return keyHolder. }
true;private;1;20;/**  * Create a PreparedStatement to be used for an insert operation with generated keys.  * @param con the Connection to use  * @return the PreparedStatement  */ ;/**  * Create a PreparedStatement to be used for an insert operation with generated keys.  * @param con the Connection to use  * @return the PreparedStatement  */ private PreparedStatement prepareStatementForGeneratedKeys(Connection con) throws SQLException {     if (getGeneratedKeyNames().length < 1) {         throw new InvalidDataAccessApiUsageException("Generated Key Name(s) not specified. " + "Using the generated keys features requires specifying the name(s) of the generated column(s).").     }     PreparedStatement ps.     if (this.tableMetaDataContext.isGeneratedKeysColumnNameArraySupported()) {         if (logger.isDebugEnabled()) {             logger.debug("Using generated keys support with array of column names.").         }         ps = con.prepareStatement(getInsertString(), getGeneratedKeyNames()).     } else {         if (logger.isDebugEnabled()) {             logger.debug("Using generated keys support with Statement.RETURN_GENERATED_KEYS.").         }         ps = con.prepareStatement(getInsertString(), Statement.RETURN_GENERATED_KEYS).     }     return ps. }
true;protected;1;9;/**  * Delegate method that executes a batch insert using the passed-in Maps of parameters.  * @param batch array of Maps with parameter names and values to be used in batch insert  * @return array of number of rows affected  */ ;/**  * Delegate method that executes a batch insert using the passed-in Maps of parameters.  * @param batch array of Maps with parameter names and values to be used in batch insert  * @return array of number of rows affected  */ @SuppressWarnings("unchecked") protected int[] doExecuteBatch(Map<String, ?>... batch) {     checkCompiled().     List<List<Object>> batchValues = new ArrayList<>(batch.length).     for (Map<String, ?> args : batch) {         batchValues.add(matchInParameterValuesWithInsertColumns(args)).     }     return executeBatchInternal(batchValues). }
true;protected;1;8;/**  * Delegate method that executes a batch insert using the passed-in {@link SqlParameterSource SqlParameterSources}.  * @param batch array of SqlParameterSource with parameter names and values to be used in insert  * @return array of number of rows affected  */ ;/**  * Delegate method that executes a batch insert using the passed-in {@link SqlParameterSource SqlParameterSources}.  * @param batch array of SqlParameterSource with parameter names and values to be used in insert  * @return array of number of rows affected  */ protected int[] doExecuteBatch(SqlParameterSource... batch) {     checkCompiled().     List<List<Object>> batchValues = new ArrayList<>(batch.length).     for (SqlParameterSource parameterSource : batch) {         batchValues.add(matchInParameterValuesWithInsertColumns(parameterSource)).     }     return executeBatchInternal(batchValues). }
false;public;2;4;;@Override public void setValues(PreparedStatement ps, int i) throws SQLException {     setParameterValues(ps, batchValues.get(i), getInsertTypes()). }
false;public;0;4;;@Override public int getBatchSize() {     return batchValues.size(). }
true;private;1;16;/**  * Delegate method to execute the batch insert.  */ ;/**  * Delegate method to execute the batch insert.  */ private int[] executeBatchInternal(final List<List<Object>> batchValues) {     if (logger.isDebugEnabled()) {         logger.debug("Executing statement " + getInsertString() + " with batch of size: " + batchValues.size()).     }     return getJdbcTemplate().batchUpdate(getInsertString(), new BatchPreparedStatementSetter() {          @Override         public void setValues(PreparedStatement ps, int i) throws SQLException {             setParameterValues(ps, batchValues.get(i), getInsertTypes()).         }          @Override         public int getBatchSize() {             return batchValues.size().         }     }). }
true;private;3;14;/**  * Internal implementation for setting parameter values.  * @param preparedStatement the PreparedStatement  * @param values the values to be set  */ ;/**  * Internal implementation for setting parameter values.  * @param preparedStatement the PreparedStatement  * @param values the values to be set  */ private void setParameterValues(PreparedStatement preparedStatement, List<?> values, @Nullable int... columnTypes) throws SQLException {     int colIndex = 0.     for (Object value : values) {         colIndex++.         if (columnTypes == null || colIndex > columnTypes.length) {             StatementCreatorUtils.setParameterValue(preparedStatement, colIndex, SqlTypeValue.TYPE_UNKNOWN, value).         } else {             StatementCreatorUtils.setParameterValue(preparedStatement, colIndex, columnTypes[colIndex - 1], value).         }     } }
true;protected;1;3;/**  * Match the provided in parameter values with registered parameters and parameters  * defined via meta-data processing.  * @param parameterSource the parameter values provided as a {@link SqlParameterSource}  * @return a Map with parameter names and values  */ ;/**  * Match the provided in parameter values with registered parameters and parameters  * defined via meta-data processing.  * @param parameterSource the parameter values provided as a {@link SqlParameterSource}  * @return a Map with parameter names and values  */ protected List<Object> matchInParameterValuesWithInsertColumns(SqlParameterSource parameterSource) {     return this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(parameterSource). }
true;protected;1;3;/**  * Match the provided in parameter values with registered parameters and parameters  * defined via meta-data processing.  * @param args the parameter values provided in a Map  * @return a Map with parameter names and values  */ ;/**  * Match the provided in parameter values with registered parameters and parameters  * defined via meta-data processing.  * @param args the parameter values provided in a Map  * @return a Map with parameter names and values  */ protected List<Object> matchInParameterValuesWithInsertColumns(Map<String, ?> args) {     return this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(args). }
