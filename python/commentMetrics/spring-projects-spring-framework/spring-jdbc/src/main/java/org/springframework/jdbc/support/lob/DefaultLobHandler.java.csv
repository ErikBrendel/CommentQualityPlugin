commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify whether to submit a byte array / String to the JDBC driver  * wrapped in a JDBC Blob / Clob object, using the JDBC {@code setBlob} /  * {@code setClob} method with a Blob / Clob argument.  * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}  * / {@code setCharacterStream} method for setting the content. Switch this  * to "true" for explicit Blob / Clob wrapping against JDBC drivers that  * are known to require such wrapping (e.g. PostgreSQL's for access to OID  * columns, whereas BYTEA columns need to be accessed the standard way).  * <p>This setting affects byte array / String arguments as well as stream  * arguments, unless {@link #setStreamAsLob "streamAsLob"} overrides this  * handling to use JDBC 4.0's new explicit streaming support (if available).  * @see java.sql.PreparedStatement#setBlob(int, java.sql.Blob)  * @see java.sql.PreparedStatement#setClob(int, java.sql.Clob)  */ ;/**  * Specify whether to submit a byte array / String to the JDBC driver  * wrapped in a JDBC Blob / Clob object, using the JDBC {@code setBlob} /  * {@code setClob} method with a Blob / Clob argument.  * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}  * / {@code setCharacterStream} method for setting the content. Switch this  * to "true" for explicit Blob / Clob wrapping against JDBC drivers that  * are known to require such wrapping (e.g. PostgreSQL's for access to OID  * columns, whereas BYTEA columns need to be accessed the standard way).  * <p>This setting affects byte array / String arguments as well as stream  * arguments, unless {@link #setStreamAsLob "streamAsLob"} overrides this  * handling to use JDBC 4.0's new explicit streaming support (if available).  * @see java.sql.PreparedStatement#setBlob(int, java.sql.Blob)  * @see java.sql.PreparedStatement#setClob(int, java.sql.Clob)  */ public void setWrapAsLob(boolean wrapAsLob) {     this.wrapAsLob = wrapAsLob. }
true;public;1;3;/**  * Specify whether to submit a binary stream / character stream to the JDBC  * driver as explicit LOB content, using the JDBC 4.0 {@code setBlob} /  * {@code setClob} method with a stream argument.  * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}  * / {@code setCharacterStream} method for setting the content.  * Switch this to "true" for explicit JDBC 4.0 streaming, provided that your  * JDBC driver actually supports those JDBC 4.0 operations (e.g. Derby's).  * <p>This setting affects stream arguments as well as byte array / String  * arguments, requiring JDBC 4.0 support. For supporting LOB content against  * JDBC 3.0, check out the {@link #setWrapAsLob "wrapAsLob"} setting.  * @see java.sql.PreparedStatement#setBlob(int, java.io.InputStream, long)  * @see java.sql.PreparedStatement#setClob(int, java.io.Reader, long)  */ ;/**  * Specify whether to submit a binary stream / character stream to the JDBC  * driver as explicit LOB content, using the JDBC 4.0 {@code setBlob} /  * {@code setClob} method with a stream argument.  * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}  * / {@code setCharacterStream} method for setting the content.  * Switch this to "true" for explicit JDBC 4.0 streaming, provided that your  * JDBC driver actually supports those JDBC 4.0 operations (e.g. Derby's).  * <p>This setting affects stream arguments as well as byte array / String  * arguments, requiring JDBC 4.0 support. For supporting LOB content against  * JDBC 3.0, check out the {@link #setWrapAsLob "wrapAsLob"} setting.  * @see java.sql.PreparedStatement#setBlob(int, java.io.InputStream, long)  * @see java.sql.PreparedStatement#setClob(int, java.io.Reader, long)  */ public void setStreamAsLob(boolean streamAsLob) {     this.streamAsLob = streamAsLob. }
true;public;1;3;/**  * Specify whether to copy a byte array / String into a temporary JDBC  * Blob / Clob object created through the JDBC 4.0 {@code createBlob} /  * {@code createClob} methods.  * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}  * / {@code setCharacterStream} method for setting the content. Switch this  * to "true" for explicit Blob / Clob creation using JDBC 4.0.  * <p>This setting affects stream arguments as well as byte array / String  * arguments, requiring JDBC 4.0 support. For supporting LOB content against  * JDBC 3.0, check out the {@link #setWrapAsLob "wrapAsLob"} setting.  * @see java.sql.Connection#createBlob()  * @see java.sql.Connection#createClob()  */ ;/**  * Specify whether to copy a byte array / String into a temporary JDBC  * Blob / Clob object created through the JDBC 4.0 {@code createBlob} /  * {@code createClob} methods.  * <p>Default is "false", using the common JDBC 2.0 {@code setBinaryStream}  * / {@code setCharacterStream} method for setting the content. Switch this  * to "true" for explicit Blob / Clob creation using JDBC 4.0.  * <p>This setting affects stream arguments as well as byte array / String  * arguments, requiring JDBC 4.0 support. For supporting LOB content against  * JDBC 3.0, check out the {@link #setWrapAsLob "wrapAsLob"} setting.  * @see java.sql.Connection#createBlob()  * @see java.sql.Connection#createClob()  */ public void setCreateTemporaryLob(boolean createTemporaryLob) {     this.createTemporaryLob = createTemporaryLob. }
false;public;2;12;;@Override @Nullable public byte[] getBlobAsBytes(ResultSet rs, int columnIndex) throws SQLException {     logger.debug("Returning BLOB as bytes").     if (this.wrapAsLob) {         Blob blob = rs.getBlob(columnIndex).         return blob.getBytes(1, (int) blob.length()).     } else {         return rs.getBytes(columnIndex).     } }
false;public;2;12;;@Override @Nullable public InputStream getBlobAsBinaryStream(ResultSet rs, int columnIndex) throws SQLException {     logger.debug("Returning BLOB as binary stream").     if (this.wrapAsLob) {         Blob blob = rs.getBlob(columnIndex).         return blob.getBinaryStream().     } else {         return rs.getBinaryStream(columnIndex).     } }
false;public;2;12;;@Override @Nullable public String getClobAsString(ResultSet rs, int columnIndex) throws SQLException {     logger.debug("Returning CLOB as string").     if (this.wrapAsLob) {         Clob clob = rs.getClob(columnIndex).         return clob.getSubString(1, (int) clob.length()).     } else {         return rs.getString(columnIndex).     } }
false;public;2;11;;@Override public InputStream getClobAsAsciiStream(ResultSet rs, int columnIndex) throws SQLException {     logger.debug("Returning CLOB as ASCII stream").     if (this.wrapAsLob) {         Clob clob = rs.getClob(columnIndex).         return clob.getAsciiStream().     } else {         return rs.getAsciiStream(columnIndex).     } }
false;public;2;11;;@Override public Reader getClobAsCharacterStream(ResultSet rs, int columnIndex) throws SQLException {     logger.debug("Returning CLOB as character stream").     if (this.wrapAsLob) {         Clob clob = rs.getClob(columnIndex).         return clob.getCharacterStream().     } else {         return rs.getCharacterStream(columnIndex).     } }
false;public;0;4;;@Override public LobCreator getLobCreator() {     return (this.createTemporaryLob ? new TemporaryLobCreator() : new DefaultLobCreator()). }
false;public;3;28;;@Override public void setBlobAsBytes(PreparedStatement ps, int paramIndex, @Nullable byte[] content) throws SQLException {     if (streamAsLob) {         if (content != null) {             ps.setBlob(paramIndex, new ByteArrayInputStream(content), content.length).         } else {             ps.setBlob(paramIndex, (Blob) null).         }     } else if (wrapAsLob) {         if (content != null) {             ps.setBlob(paramIndex, new PassThroughBlob(content)).         } else {             ps.setBlob(paramIndex, (Blob) null).         }     } else {         ps.setBytes(paramIndex, content).     }     if (logger.isDebugEnabled()) {         logger.debug(content != null ? "Set bytes for BLOB with length " + content.length : "Set BLOB to null").     } }
false;public;4;37;;@Override public void setBlobAsBinaryStream(PreparedStatement ps, int paramIndex, @Nullable InputStream binaryStream, int contentLength) throws SQLException {     if (streamAsLob) {         if (binaryStream != null) {             if (contentLength >= 0) {                 ps.setBlob(paramIndex, binaryStream, contentLength).             } else {                 ps.setBlob(paramIndex, binaryStream).             }         } else {             ps.setBlob(paramIndex, (Blob) null).         }     } else if (wrapAsLob) {         if (binaryStream != null) {             ps.setBlob(paramIndex, new PassThroughBlob(binaryStream, contentLength)).         } else {             ps.setBlob(paramIndex, (Blob) null).         }     } else if (contentLength >= 0) {         ps.setBinaryStream(paramIndex, binaryStream, contentLength).     } else {         ps.setBinaryStream(paramIndex, binaryStream).     }     if (logger.isDebugEnabled()) {         logger.debug(binaryStream != null ? "Set binary stream for BLOB with length " + contentLength : "Set BLOB to null").     } }
false;public;3;28;;@Override public void setClobAsString(PreparedStatement ps, int paramIndex, @Nullable String content) throws SQLException {     if (streamAsLob) {         if (content != null) {             ps.setClob(paramIndex, new StringReader(content), content.length()).         } else {             ps.setClob(paramIndex, (Clob) null).         }     } else if (wrapAsLob) {         if (content != null) {             ps.setClob(paramIndex, new PassThroughClob(content)).         } else {             ps.setClob(paramIndex, (Clob) null).         }     } else {         ps.setString(paramIndex, content).     }     if (logger.isDebugEnabled()) {         logger.debug(content != null ? "Set string for CLOB with length " + content.length() : "Set CLOB to null").     } }
false;public;4;38;;@Override public void setClobAsAsciiStream(PreparedStatement ps, int paramIndex, @Nullable InputStream asciiStream, int contentLength) throws SQLException {     if (streamAsLob) {         if (asciiStream != null) {             Reader reader = new InputStreamReader(asciiStream, StandardCharsets.US_ASCII).             if (contentLength >= 0) {                 ps.setClob(paramIndex, reader, contentLength).             } else {                 ps.setClob(paramIndex, reader).             }         } else {             ps.setClob(paramIndex, (Clob) null).         }     } else if (wrapAsLob) {         if (asciiStream != null) {             ps.setClob(paramIndex, new PassThroughClob(asciiStream, contentLength)).         } else {             ps.setClob(paramIndex, (Clob) null).         }     } else if (contentLength >= 0) {         ps.setAsciiStream(paramIndex, asciiStream, contentLength).     } else {         ps.setAsciiStream(paramIndex, asciiStream).     }     if (logger.isDebugEnabled()) {         logger.debug(asciiStream != null ? "Set ASCII stream for CLOB with length " + contentLength : "Set CLOB to null").     } }
false;public;4;37;;@Override public void setClobAsCharacterStream(PreparedStatement ps, int paramIndex, @Nullable Reader characterStream, int contentLength) throws SQLException {     if (streamAsLob) {         if (characterStream != null) {             if (contentLength >= 0) {                 ps.setClob(paramIndex, characterStream, contentLength).             } else {                 ps.setClob(paramIndex, characterStream).             }         } else {             ps.setClob(paramIndex, (Clob) null).         }     } else if (wrapAsLob) {         if (characterStream != null) {             ps.setClob(paramIndex, new PassThroughClob(characterStream, contentLength)).         } else {             ps.setClob(paramIndex, (Clob) null).         }     } else if (contentLength >= 0) {         ps.setCharacterStream(paramIndex, characterStream, contentLength).     } else {         ps.setCharacterStream(paramIndex, characterStream).     }     if (logger.isDebugEnabled()) {         logger.debug(characterStream != null ? "Set character stream for CLOB with length " + contentLength : "Set CLOB to null").     } }
false;public;0;4;;@Override public void close() { // nothing to do when not creating temporary LOBs }
