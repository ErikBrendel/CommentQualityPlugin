commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the type that each result object is expected to match.  * <p>If not specified, the column value will be exposed as  * returned by the JDBC driver.  */ ;/**  * Set the type that each result object is expected to match.  * <p>If not specified, the column value will be exposed as  * returned by the JDBC driver.  */ public void setRequiredType(Class<T> requiredType) {     this.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType). }
true;public;1;3;/**  * Set a {@link ConversionService} for converting a fetched value.  * <p>Default is the {@link DefaultConversionService}.  * @since 5.0.4  * @see DefaultConversionService#getSharedInstance  */ ;/**  * Set a {@link ConversionService} for converting a fetched value.  * <p>Default is the {@link DefaultConversionService}.  * @since 5.0.4  * @see DefaultConversionService#getSharedInstance  */ public void setConversionService(@Nullable ConversionService conversionService) {     this.conversionService = conversionService. }
true;public;2;26;/**  * Extract a value for the single column in the current row.  * <p>Validates that there is only one column selected,  * then delegates to {@code getColumnValue()} and also  * {@code convertValueToRequiredType}, if necessary.  * @see java.sql.ResultSetMetaData#getColumnCount()  * @see #getColumnValue(java.sql.ResultSet, int, Class)  * @see #convertValueToRequiredType(Object, Class)  */ ;/**  * Extract a value for the single column in the current row.  * <p>Validates that there is only one column selected,  * then delegates to {@code getColumnValue()} and also  * {@code convertValueToRequiredType}, if necessary.  * @see java.sql.ResultSetMetaData#getColumnCount()  * @see #getColumnValue(java.sql.ResultSet, int, Class)  * @see #convertValueToRequiredType(Object, Class)  */ @Override @SuppressWarnings("unchecked") @Nullable public T mapRow(ResultSet rs, int rowNum) throws SQLException {     // Validate column count.     ResultSetMetaData rsmd = rs.getMetaData().     int nrOfColumns = rsmd.getColumnCount().     if (nrOfColumns != 1) {         throw new IncorrectResultSetColumnCountException(1, nrOfColumns).     }     // Extract column value from JDBC ResultSet.     Object result = getColumnValue(rs, 1, this.requiredType).     if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {         // Extracted value does not match already: try to convert it.         try {             return (T) convertValueToRequiredType(result, this.requiredType).         } catch (IllegalArgumentException ex) {             throw new TypeMismatchDataAccessException("Type mismatch affecting row number " + rowNum + " and column type '" + rsmd.getColumnTypeName(1) + "': " + ex.getMessage()).         }     }     return (T) result. }
true;protected;3;10;/**  * Retrieve a JDBC object value for the specified column.  * <p>The default implementation calls  * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.  * If no required type has been specified, this method delegates to  * {@code getColumnValue(rs, index)}, which basically calls  * {@code ResultSet.getObject(index)} but applies some additional  * default conversion to appropriate value types.  * @param rs is the ResultSet holding the data  * @param index is the column index  * @param requiredType the type that each result object is expected to match  * (or {@code null} if none specified)  * @return the Object value  * @throws SQLException in case of extraction failure  * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)  * @see #getColumnValue(java.sql.ResultSet, int)  */ ;/**  * Retrieve a JDBC object value for the specified column.  * <p>The default implementation calls  * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.  * If no required type has been specified, this method delegates to  * {@code getColumnValue(rs, index)}, which basically calls  * {@code ResultSet.getObject(index)} but applies some additional  * default conversion to appropriate value types.  * @param rs is the ResultSet holding the data  * @param index is the column index  * @param requiredType the type that each result object is expected to match  * (or {@code null} if none specified)  * @return the Object value  * @throws SQLException in case of extraction failure  * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)  * @see #getColumnValue(java.sql.ResultSet, int)  */ @Nullable protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {     if (requiredType != null) {         return JdbcUtils.getResultSetValue(rs, index, requiredType).     } else {         // No required type specified -> perform default extraction.         return getColumnValue(rs, index).     } }
true;protected;2;4;/**  * Retrieve a JDBC object value for the specified column, using the most  * appropriate value type. Called if no required type has been specified.  * <p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},  * which uses the {@code ResultSet.getObject(index)} method. Additionally,  * it includes a "hack" to get around Oracle returning a non-standard object for  * their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}  * javadoc for details.  * @param rs is the ResultSet holding the data  * @param index is the column index  * @return the Object value  * @throws SQLException in case of extraction failure  * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int)  */ ;/**  * Retrieve a JDBC object value for the specified column, using the most  * appropriate value type. Called if no required type has been specified.  * <p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},  * which uses the {@code ResultSet.getObject(index)} method. Additionally,  * it includes a "hack" to get around Oracle returning a non-standard object for  * their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}  * javadoc for details.  * @param rs is the ResultSet holding the data  * @param index is the column index  * @return the Object value  * @throws SQLException in case of extraction failure  * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int)  */ @Nullable protected Object getColumnValue(ResultSet rs, int index) throws SQLException {     return JdbcUtils.getResultSetValue(rs, index). }
true;protected;2;25;/**  * Convert the given column value to the specified required type.  * Only called if the extracted column value does not match already.  * <p>If the required type is String, the value will simply get stringified  * via {@code toString()}. In case of a Number, the value will be  * converted into a Number, either through number conversion or through  * String parsing (depending on the value type). Otherwise, the value will  * be converted to a required type using the {@link ConversionService}.  * @param value the column value as extracted from {@code getColumnValue()}  * (never {@code null})  * @param requiredType the type that each result object is expected to match  * (never {@code null})  * @return the converted value  * @see #getColumnValue(java.sql.ResultSet, int, Class)  */ ;/**  * Convert the given column value to the specified required type.  * Only called if the extracted column value does not match already.  * <p>If the required type is String, the value will simply get stringified  * via {@code toString()}. In case of a Number, the value will be  * converted into a Number, either through number conversion or through  * String parsing (depending on the value type). Otherwise, the value will  * be converted to a required type using the {@link ConversionService}.  * @param value the column value as extracted from {@code getColumnValue()}  * (never {@code null})  * @param requiredType the type that each result object is expected to match  * (never {@code null})  * @return the converted value  * @see #getColumnValue(java.sql.ResultSet, int, Class)  */ @SuppressWarnings("unchecked") @Nullable protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {     if (String.class == requiredType) {         return value.toString().     } else if (Number.class.isAssignableFrom(requiredType)) {         if (value instanceof Number) {             // Convert original Number to target Number class.             return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType).         } else {             // Convert stringified value to target Number class.             return NumberUtils.parseNumber(value.toString(), (Class<Number>) requiredType).         }     } else if (this.conversionService != null && this.conversionService.canConvert(value.getClass(), requiredType)) {         return this.conversionService.convert(value, requiredType).     } else {         throw new IllegalArgumentException("Value [" + value + "] is of type [" + value.getClass().getName() + "] and cannot be converted to required type [" + requiredType.getName() + "]").     } }
true;public,static;1;3;/**  * Static factory method to create a new {@code SingleColumnRowMapper}  * (with the required type specified only once).  * @param requiredType the type that each result object is expected to match  * @since 4.1  */ ;/**  * Static factory method to create a new {@code SingleColumnRowMapper}  * (with the required type specified only once).  * @param requiredType the type that each result object is expected to match  * @since 4.1  */ public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {     return new SingleColumnRowMapper<>(requiredType). }
true;public,static;2;5;/**  * Static factory method to create a new {@code SingleColumnRowMapper}  * (with the required type specified only once).  * @param requiredType the type that each result object is expected to match  * @param conversionService the {@link ConversionService} for converting a fetched value  * @since 5.0.4  */ ;/**  * Static factory method to create a new {@code SingleColumnRowMapper}  * (with the required type specified only once).  * @param requiredType the type that each result object is expected to match  * @param conversionService the {@link ConversionService} for converting a fetched value  * @since 5.0.4  */ public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService) {     SingleColumnRowMapper<T> rowMapper = newInstance(requiredType).     rowMapper.setConversionService(conversionService).     return rowMapper. }
