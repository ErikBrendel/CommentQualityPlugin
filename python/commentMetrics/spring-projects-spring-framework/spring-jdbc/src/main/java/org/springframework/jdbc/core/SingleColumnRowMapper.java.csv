# id;timestamp;commentText;codeText;commentWords;codeWords
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1403630813;Static factory method to create a new ParameterizedSingleColumnRowMapper_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		SingleColumnRowMapper<T> newInstance = new SingleColumnRowMapper<T>()__		newInstance.setRequiredType(requiredType)__		return newInstance__	};static,factory,method,to,create,a,new,parameterized,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,single,column,row,mapper,t,new,instance,new,single,column,row,mapper,t,new,instance,set,required,type,required,type,return,new,instance
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1432125256;Static factory method to create a new ParameterizedSingleColumnRowMapper_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		SingleColumnRowMapper<T> newInstance = new SingleColumnRowMapper<T>()__		newInstance.setRequiredType(requiredType)__		return newInstance__	};static,factory,method,to,create,a,new,parameterized,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,single,column,row,mapper,t,new,instance,new,single,column,row,mapper,t,new,instance,set,required,type,required,type,return,new,instance
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1436815857;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		return new SingleColumnRowMapper<T>(requiredType)__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,return,new,single,column,row,mapper,t,required,type
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1467730834;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		return new SingleColumnRowMapper<>(requiredType)__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,return,new,single,column,row,mapper,required,type
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1495868221;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		return new SingleColumnRowMapper<>(requiredType)__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,return,new,single,column,row,mapper,required,type
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1496837955;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		return new SingleColumnRowMapper<>(requiredType)__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,return,new,single,column,row,mapper,required,type
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1498780456;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		return new SingleColumnRowMapper<>(requiredType)__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,return,new,single,column,row,mapper,required,type
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1502974979;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		return new SingleColumnRowMapper<>(requiredType)__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,return,new,single,column,row,mapper,required,type
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1518385010;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		return new SingleColumnRowMapper<>(requiredType)__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,return,new,single,column,row,mapper,required,type
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType);1530174524;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@since 4.1;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType) {_		return new SingleColumnRowMapper<>(requiredType)__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,since,4,1;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,return,new,single,column,row,mapper,required,type
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1385412762;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class.equals(requiredType)) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,equals,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1403630813;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class.equals(requiredType)) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,equals,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1432125256;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class == requiredType) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1436815857;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class == requiredType) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1467730834;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class == requiredType) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1495868221;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class == requiredType) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1496837955;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class == requiredType) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1498780456;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class == requiredType) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1502974979;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class == requiredType) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> public void setConversionService(@Nullable ConversionService conversionService);1518385010;Set a {@link ConversionService} for converting a fetched value._<p>Default is the {@link DefaultConversionService}._@since 5.0.4_@see DefaultConversionService#getSharedInstance;public void setConversionService(@Nullable ConversionService conversionService) {_		this.conversionService = conversionService__	};set,a,link,conversion,service,for,converting,a,fetched,value,p,default,is,the,link,default,conversion,service,since,5,0,4,see,default,conversion,service,get,shared,instance;public,void,set,conversion,service,nullable,conversion,service,conversion,service,this,conversion,service,conversion,service
SingleColumnRowMapper -> public void setConversionService(@Nullable ConversionService conversionService);1530174524;Set a {@link ConversionService} for converting a fetched value._<p>Default is the {@link DefaultConversionService}._@since 5.0.4_@see DefaultConversionService#getSharedInstance;public void setConversionService(@Nullable ConversionService conversionService) {_		this.conversionService = conversionService__	};set,a,link,conversion,service,for,converting,a,fetched,value,p,default,is,the,link,default,conversion,service,since,5,0,4,see,default,conversion,service,get,shared,instance;public,void,set,conversion,service,nullable,conversion,service,conversion,service,this,conversion,service,conversion,service
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1496837955;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1498780456;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1502974979;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1518385010;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1530174524;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1356735495;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1368482696;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1385412762;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1403630813;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1432125256;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1436815857;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1467730834;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1495868221;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1496837955;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1498780456;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1328020251;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = requiredType__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1356735495;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = requiredType__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1357119239;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = requiredType__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1368482696;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = requiredType__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1385412762;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = requiredType__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1403630813;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = requiredType__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1432125256;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = requiredType__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1436815857;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType)__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,class,utils,resolve,primitive,if,necessary,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1467730834;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType)__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,class,utils,resolve,primitive,if,necessary,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1495868221;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType)__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,class,utils,resolve,primitive,if,necessary,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1496837955;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType)__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,class,utils,resolve,primitive,if,necessary,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1498780456;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType)__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,class,utils,resolve,primitive,if,necessary,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1502974979;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType)__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,class,utils,resolve,primitive,if,necessary,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1518385010;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType)__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,class,utils,resolve,primitive,if,necessary,required,type
SingleColumnRowMapper -> public void setRequiredType(Class<T> requiredType);1530174524;Set the type that each result object is expected to match._<p>If not specified, the column value will be exposed as_returned by the JDBC driver.;public void setRequiredType(Class<T> requiredType) {_		this.requiredType = ClassUtils.resolvePrimitiveIfNecessary(requiredType)__	};set,the,type,that,each,result,object,is,expected,to,match,p,if,not,specified,the,column,value,will,be,exposed,as,returned,by,the,jdbc,driver;public,void,set,required,type,class,t,required,type,this,required,type,class,utils,resolve,primitive,if,necessary,required,type
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService);1518385010;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@param conversionService the {@link ConversionService} for converting a fetched value_@since 5.0.4;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService) {_		SingleColumnRowMapper<T> rowMapper = newInstance(requiredType)__		rowMapper.setConversionService(conversionService)__		return rowMapper__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,param,conversion,service,the,link,conversion,service,for,converting,a,fetched,value,since,5,0,4;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,nullable,conversion,service,conversion,service,single,column,row,mapper,t,row,mapper,new,instance,required,type,row,mapper,set,conversion,service,conversion,service,return,row,mapper
SingleColumnRowMapper -> public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService);1530174524;Static factory method to create a new {@code SingleColumnRowMapper}_(with the required type specified only once)._@param requiredType the type that each result object is expected to match_@param conversionService the {@link ConversionService} for converting a fetched value_@since 5.0.4;public static <T> SingleColumnRowMapper<T> newInstance(Class<T> requiredType, @Nullable ConversionService conversionService) {_		SingleColumnRowMapper<T> rowMapper = newInstance(requiredType)__		rowMapper.setConversionService(conversionService)__		return rowMapper__	};static,factory,method,to,create,a,new,code,single,column,row,mapper,with,the,required,type,specified,only,once,param,required,type,the,type,that,each,result,object,is,expected,to,match,param,conversion,service,the,link,conversion,service,for,converting,a,fetched,value,since,5,0,4;public,static,t,single,column,row,mapper,t,new,instance,class,t,required,type,nullable,conversion,service,conversion,service,single,column,row,mapper,t,row,mapper,new,instance,required,type,row,mapper,set,conversion,service,conversion,service,return,row,mapper
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1328020251;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to <code>getColumnValue()</code> and also_<code>convertValueToRequiredType</code>, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,code,and,also,code,convert,value,to,required,type,code,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1357119239;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@SuppressWarnings("unchecked")_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;suppress,warnings,unchecked,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1328020251;Create a new SingleColumnRowMapper._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		this.requiredType = requiredType__	};create,a,new,single,column,row,mapper,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1356735495;Create a new SingleColumnRowMapper._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		this.requiredType = requiredType__	};create,a,new,single,column,row,mapper,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1357119239;Create a new SingleColumnRowMapper._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		this.requiredType = requiredType__	};create,a,new,single,column,row,mapper,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1368482696;Create a new SingleColumnRowMapper._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		this.requiredType = requiredType__	};create,a,new,single,column,row,mapper,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1385412762;Create a new SingleColumnRowMapper._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		this.requiredType = requiredType__	};create,a,new,single,column,row,mapper,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1403630813;Create a new SingleColumnRowMapper._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		this.requiredType = requiredType__	};create,a,new,single,column,row,mapper,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1432125256;Create a new SingleColumnRowMapper._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		this.requiredType = requiredType__	};create,a,new,single,column,row,mapper,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,this,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1436815857;Create a new {@code SingleColumnRowMapper}._<p>Consider using the {@link #newInstance} factory method instead,_which allows for specifying the required type once only._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		setRequiredType(requiredType)__	};create,a,new,code,single,column,row,mapper,p,consider,using,the,link,new,instance,factory,method,instead,which,allows,for,specifying,the,required,type,once,only,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,set,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1467730834;Create a new {@code SingleColumnRowMapper}._<p>Consider using the {@link #newInstance} factory method instead,_which allows for specifying the required type once only._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		setRequiredType(requiredType)__	};create,a,new,code,single,column,row,mapper,p,consider,using,the,link,new,instance,factory,method,instead,which,allows,for,specifying,the,required,type,once,only,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,set,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1495868221;Create a new {@code SingleColumnRowMapper}._<p>Consider using the {@link #newInstance} factory method instead,_which allows for specifying the required type once only._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		setRequiredType(requiredType)__	};create,a,new,code,single,column,row,mapper,p,consider,using,the,link,new,instance,factory,method,instead,which,allows,for,specifying,the,required,type,once,only,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,set,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1496837955;Create a new {@code SingleColumnRowMapper}._<p>Consider using the {@link #newInstance} factory method instead,_which allows for specifying the required type once only._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		setRequiredType(requiredType)__	};create,a,new,code,single,column,row,mapper,p,consider,using,the,link,new,instance,factory,method,instead,which,allows,for,specifying,the,required,type,once,only,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,set,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1498780456;Create a new {@code SingleColumnRowMapper}._<p>Consider using the {@link #newInstance} factory method instead,_which allows for specifying the required type once only._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		setRequiredType(requiredType)__	};create,a,new,code,single,column,row,mapper,p,consider,using,the,link,new,instance,factory,method,instead,which,allows,for,specifying,the,required,type,once,only,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,set,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1502974979;Create a new {@code SingleColumnRowMapper}._<p>Consider using the {@link #newInstance} factory method instead,_which allows for specifying the required type once only._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		setRequiredType(requiredType)__	};create,a,new,code,single,column,row,mapper,p,consider,using,the,link,new,instance,factory,method,instead,which,allows,for,specifying,the,required,type,once,only,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,set,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1518385010;Create a new {@code SingleColumnRowMapper}._<p>Consider using the {@link #newInstance} factory method instead,_which allows for specifying the required type once only._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		setRequiredType(requiredType)__	};create,a,new,code,single,column,row,mapper,p,consider,using,the,link,new,instance,factory,method,instead,which,allows,for,specifying,the,required,type,once,only,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,set,required,type,required,type
SingleColumnRowMapper -> public SingleColumnRowMapper(Class<T> requiredType);1530174524;Create a new {@code SingleColumnRowMapper}._<p>Consider using the {@link #newInstance} factory method instead,_which allows for specifying the required type once only._@param requiredType the type that each result object is expected to match;public SingleColumnRowMapper(Class<T> requiredType) {_		setRequiredType(requiredType)__	};create,a,new,code,single,column,row,mapper,p,consider,using,the,link,new,instance,factory,method,instead,which,allows,for,specifying,the,required,type,once,only,param,required,type,the,type,that,each,result,object,is,expected,to,match;public,single,column,row,mapper,class,t,required,type,set,required,type,required,type
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class requiredType);1328020251;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via <code>toString()</code>. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from <code>getColumnValue()</code>_(never <code>null</code>)_@param requiredType the type that each result object is expected to match_(never <code>null</code>)_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class requiredType) {_		if (String.class.equals(requiredType)) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(), requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,code,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,code,never,code,null,code,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,code,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,equals,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,required,type,else,return,number,utils,parse,number,value,to,string,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class requiredType);1356735495;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class requiredType) {_		if (String.class.equals(requiredType)) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(), requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,equals,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,required,type,else,return,number,utils,parse,number,value,to,string,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class requiredType);1357119239;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class requiredType) {_		if (String.class.equals(requiredType)) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(), requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,equals,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,required,type,else,return,number,utils,parse,number,value,to,string,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	protected Object convertValueToRequiredType(Object value, Class requiredType);1368482696;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type)._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	protected Object convertValueToRequiredType(Object value, Class requiredType) {_		if (String.class.equals(requiredType)) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(), requiredType)__			}_		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,equals,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,required,type,else,return,number,utils,parse,number,value,to,string,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> public SingleColumnRowMapper();1328020251;Create a new SingleColumnRowMapper._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,single,column,row,mapper,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1356735495;Create a new SingleColumnRowMapper._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,single,column,row,mapper,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1357119239;Create a new SingleColumnRowMapper._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,single,column,row,mapper,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1368482696;Create a new SingleColumnRowMapper._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,single,column,row,mapper,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1385412762;Create a new SingleColumnRowMapper._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,single,column,row,mapper,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1403630813;Create a new SingleColumnRowMapper._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,single,column,row,mapper,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1432125256;Create a new SingleColumnRowMapper._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,single,column,row,mapper,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1436815857;Create a new {@code SingleColumnRowMapper} for bean-style configuration._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,code,single,column,row,mapper,for,bean,style,configuration,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1467730834;Create a new {@code SingleColumnRowMapper} for bean-style configuration._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,code,single,column,row,mapper,for,bean,style,configuration,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1495868221;Create a new {@code SingleColumnRowMapper} for bean-style configuration._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,code,single,column,row,mapper,for,bean,style,configuration,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1496837955;Create a new {@code SingleColumnRowMapper} for bean-style configuration._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,code,single,column,row,mapper,for,bean,style,configuration,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1498780456;Create a new {@code SingleColumnRowMapper} for bean-style configuration._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,code,single,column,row,mapper,for,bean,style,configuration,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1502974979;Create a new {@code SingleColumnRowMapper} for bean-style configuration._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,code,single,column,row,mapper,for,bean,style,configuration,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1518385010;Create a new {@code SingleColumnRowMapper} for bean-style configuration._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,code,single,column,row,mapper,for,bean,style,configuration,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> public SingleColumnRowMapper();1530174524;Create a new {@code SingleColumnRowMapper} for bean-style configuration._@see #setRequiredType;public SingleColumnRowMapper() {_	};create,a,new,code,single,column,row,mapper,for,bean,style,configuration,see,set,required,type;public,single,column,row,mapper
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1328020251;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to <code>JdbcUtils.getResultSetValue()</code>,_which uses the <code>ResultSet.getObject(index)</code> method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the <code>JdbcUtils#getResultSetValue()</code>_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,code,which,uses,the,code,result,set,get,object,index,code,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,code,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1356735495;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1357119239;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1368482696;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1385412762;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1403630813;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1432125256;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1436815857;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1467730834;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1495868221;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1496837955;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1498780456;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1502974979;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1518385010;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> @Nullable 	protected Object getColumnValue(ResultSet rs, int index) throws SQLException;1530174524;Retrieve a JDBC object value for the specified column, using the most_appropriate value type. Called if no required type has been specified._<p>The default implementation delegates to {@code JdbcUtils.getResultSetValue()},_which uses the {@code ResultSet.getObject(index)} method. Additionally,_it includes a "hack" to get around Oracle returning a non-standard object for_their TIMESTAMP datatype. See the {@code JdbcUtils#getResultSetValue()}_javadoc for details._@param rs is the ResultSet holding the data_@param index is the column index_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int);@Nullable_	protected Object getColumnValue(ResultSet rs, int index) throws SQLException {_		return JdbcUtils.getResultSetValue(rs, index)__	};retrieve,a,jdbc,object,value,for,the,specified,column,using,the,most,appropriate,value,type,called,if,no,required,type,has,been,specified,p,the,default,implementation,delegates,to,code,jdbc,utils,get,result,set,value,which,uses,the,code,result,set,get,object,index,method,additionally,it,includes,a,hack,to,get,around,oracle,returning,a,non,standard,object,for,their,timestamp,datatype,see,the,code,jdbc,utils,get,result,set,value,javadoc,for,details,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int;nullable,protected,object,get,column,value,result,set,rs,int,index,throws,sqlexception,return,jdbc,utils,get,result,set,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index, Class requiredType) throws SQLException;1328020251;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_<code>getColumnValue(rs, index)</code>, which basically calls_<code>ResultSet.getObject(index)</code> but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or <code>null</code> if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index, Class requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,code,which,basically,calls,code,result,set,get,object,index,code,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,code,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index, Class requiredType) throws SQLException;1356735495;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index, Class requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index, Class requiredType) throws SQLException;1357119239;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index, Class requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index, Class requiredType) throws SQLException;1368482696;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index, Class requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1385412762;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1403630813;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1432125256;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1436815857;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1467730834;Retrieve a JDBC object value for the specified column._<p>The default implementation calls_{@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}._If no required type has been specified, this method delegates to_{@code getColumnValue(rs, index)}, which basically calls_{@code ResultSet.getObject(index)} but applies some additional_default conversion to appropriate value types._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the type that each result object is expected to match_(or {@code null} if none specified)_@return the Object value_@throws SQLException in case of extraction failure_@see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)_@see #getColumnValue(java.sql.ResultSet, int);protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType != null) {_			return JdbcUtils.getResultSetValue(rs, index, requiredType)__		}_		else {_			_			return getColumnValue(rs, index)__		}_	};retrieve,a,jdbc,object,value,for,the,specified,column,p,the,default,implementation,calls,link,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,if,no,required,type,has,been,specified,this,method,delegates,to,code,get,column,value,rs,index,which,basically,calls,code,result,set,get,object,index,but,applies,some,additional,default,conversion,to,appropriate,value,types,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,type,that,each,result,object,is,expected,to,match,or,code,null,if,none,specified,return,the,object,value,throws,sqlexception,in,case,of,extraction,failure,see,org,springframework,jdbc,support,jdbc,utils,get,result,set,value,java,sql,result,set,int,class,see,get,column,value,java,sql,result,set,int;protected,object,get,column,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,jdbc,utils,get,result,set,value,rs,index,required,type,else,return,get,column,value,rs,index
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	@Nullable 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1518385010;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type). Otherwise, the value will_be converted to a required type using the {@link ConversionService}._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	@Nullable_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class == requiredType) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else if (this.conversionService != null && this.conversionService.canConvert(value.getClass(), requiredType)) {_			return this.conversionService.convert(value, requiredType)__		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,otherwise,the,value,will,be,converted,to,a,required,type,using,the,link,conversion,service,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,nullable,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,if,this,conversion,service,null,this,conversion,service,can,convert,value,get,class,required,type,return,this,conversion,service,convert,value,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @SuppressWarnings("unchecked") 	@Nullable 	protected Object convertValueToRequiredType(Object value, Class<?> requiredType);1530174524;Convert the given column value to the specified required type._Only called if the extracted column value does not match already._<p>If the required type is String, the value will simply get stringified_via {@code toString()}. In case of a Number, the value will be_converted into a Number, either through number conversion or through_String parsing (depending on the value type). Otherwise, the value will_be converted to a required type using the {@link ConversionService}._@param value the column value as extracted from {@code getColumnValue()}_(never {@code null})_@param requiredType the type that each result object is expected to match_(never {@code null})_@return the converted value_@see #getColumnValue(java.sql.ResultSet, int, Class);@SuppressWarnings("unchecked")_	@Nullable_	protected Object convertValueToRequiredType(Object value, Class<?> requiredType) {_		if (String.class == requiredType) {_			return value.toString()__		}_		else if (Number.class.isAssignableFrom(requiredType)) {_			if (value instanceof Number) {_				_				return NumberUtils.convertNumberToTargetClass(((Number) value), (Class<Number>) requiredType)__			}_			else {_				_				return NumberUtils.parseNumber(value.toString(),(Class<Number>) requiredType)__			}_		}_		else if (this.conversionService != null && this.conversionService.canConvert(value.getClass(), requiredType)) {_			return this.conversionService.convert(value, requiredType)__		}_		else {_			throw new IllegalArgumentException(_					"Value [" + value + "] is of type [" + value.getClass().getName() +_					"] and cannot be converted to required type [" + requiredType.getName() + "]")__		}_	};convert,the,given,column,value,to,the,specified,required,type,only,called,if,the,extracted,column,value,does,not,match,already,p,if,the,required,type,is,string,the,value,will,simply,get,stringified,via,code,to,string,in,case,of,a,number,the,value,will,be,converted,into,a,number,either,through,number,conversion,or,through,string,parsing,depending,on,the,value,type,otherwise,the,value,will,be,converted,to,a,required,type,using,the,link,conversion,service,param,value,the,column,value,as,extracted,from,code,get,column,value,never,code,null,param,required,type,the,type,that,each,result,object,is,expected,to,match,never,code,null,return,the,converted,value,see,get,column,value,java,sql,result,set,int,class;suppress,warnings,unchecked,nullable,protected,object,convert,value,to,required,type,object,value,class,required,type,if,string,class,required,type,return,value,to,string,else,if,number,class,is,assignable,from,required,type,if,value,instanceof,number,return,number,utils,convert,number,to,target,class,number,value,class,number,required,type,else,return,number,utils,parse,number,value,to,string,class,number,required,type,else,if,this,conversion,service,null,this,conversion,service,can,convert,value,get,class,required,type,return,this,conversion,service,convert,value,required,type,else,throw,new,illegal,argument,exception,value,value,is,of,type,value,get,class,get,name,and,cannot,be,converted,to,required,type,required,type,get,name
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	@Nullable 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1502974979;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	@Nullable_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,nullable,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	@Nullable 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1518385010;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	@Nullable_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,nullable,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
SingleColumnRowMapper -> @Override 	@SuppressWarnings("unchecked") 	@Nullable 	public T mapRow(ResultSet rs, int rowNum) throws SQLException;1530174524;Extract a value for the single column in the current row._<p>Validates that there is only one column selected,_then delegates to {@code getColumnValue()} and also_{@code convertValueToRequiredType}, if necessary._@see java.sql.ResultSetMetaData#getColumnCount()_@see #getColumnValue(java.sql.ResultSet, int, Class)_@see #convertValueToRequiredType(Object, Class);@Override_	@SuppressWarnings("unchecked")_	@Nullable_	public T mapRow(ResultSet rs, int rowNum) throws SQLException {_		_		ResultSetMetaData rsmd = rs.getMetaData()__		int nrOfColumns = rsmd.getColumnCount()__		if (nrOfColumns != 1) {_			throw new IncorrectResultSetColumnCountException(1, nrOfColumns)__		}__		_		Object result = getColumnValue(rs, 1, this.requiredType)__		if (result != null && this.requiredType != null && !this.requiredType.isInstance(result)) {_			_			try {_				return (T) convertValueToRequiredType(result, this.requiredType)__			}_			catch (IllegalArgumentException ex) {_				throw new TypeMismatchDataAccessException(_						"Type mismatch affecting row number " + rowNum + " and column type '" +_						rsmd.getColumnTypeName(1) + "': " + ex.getMessage())__			}_		}_		return (T) result__	};extract,a,value,for,the,single,column,in,the,current,row,p,validates,that,there,is,only,one,column,selected,then,delegates,to,code,get,column,value,and,also,code,convert,value,to,required,type,if,necessary,see,java,sql,result,set,meta,data,get,column,count,see,get,column,value,java,sql,result,set,int,class,see,convert,value,to,required,type,object,class;override,suppress,warnings,unchecked,nullable,public,t,map,row,result,set,rs,int,row,num,throws,sqlexception,result,set,meta,data,rsmd,rs,get,meta,data,int,nr,of,columns,rsmd,get,column,count,if,nr,of,columns,1,throw,new,incorrect,result,set,column,count,exception,1,nr,of,columns,object,result,get,column,value,rs,1,this,required,type,if,result,null,this,required,type,null,this,required,type,is,instance,result,try,return,t,convert,value,to,required,type,result,this,required,type,catch,illegal,argument,exception,ex,throw,new,type,mismatch,data,access,exception,type,mismatch,affecting,row,number,row,num,and,column,type,rsmd,get,column,type,name,1,ex,get,message,return,t,result
