# id;timestamp;commentText;codeText;commentWords;codeWords
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class requiredType) throws SQLException;1328020251;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be <code>null</code>)_@return the value object_@throws SQLException if thrown by the JDBC API;public static Object getResultSetValue(ResultSet rs, int index, Class requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value = null__		boolean wasNullCheck = false___		_		if (String.class.equals(requiredType)) {_			value = rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__			wasNullCheck = true__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__			wasNullCheck = true__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__			wasNullCheck = true__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__			wasNullCheck = true__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__			wasNullCheck = true__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__			wasNullCheck = true__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__			wasNullCheck = true__		}_		else if (byte[].class.equals(requiredType)) {_			value = rs.getBytes(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			value = rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			value = rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			value = rs.getTimestamp(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			value = rs.getBigDecimal(index)__		}_		else if (Blob.class.equals(requiredType)) {_			value = rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			value = rs.getClob(index)__		}_		else {_			_			value = getResultSetValue(rs, index)__		}__		_		_		if (wasNullCheck && value != null && rs.wasNull()) {_			value = null__		}_		return value__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,code,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,null,boolean,was,null,check,false,if,string,class,equals,required,type,value,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,was,null,check,true,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,was,null,check,true,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,was,null,check,true,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,was,null,check,true,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,was,null,check,true,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,was,null,check,true,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,was,null,check,true,else,if,byte,class,equals,required,type,value,rs,get,bytes,index,else,if,java,sql,date,class,equals,required,type,value,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,value,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,value,rs,get,timestamp,index,else,if,big,decimal,class,equals,required,type,value,rs,get,big,decimal,index,else,if,blob,class,equals,required,type,value,rs,get,blob,index,else,if,clob,class,equals,required,type,value,rs,get,clob,index,else,value,get,result,set,value,rs,index,if,was,null,check,value,null,rs,was,null,value,null,return,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class requiredType) throws SQLException;1356735495;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;public static Object getResultSetValue(ResultSet rs, int index, Class requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value = null__		boolean wasNullCheck = false___		_		if (String.class.equals(requiredType)) {_			value = rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__			wasNullCheck = true__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__			wasNullCheck = true__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__			wasNullCheck = true__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__			wasNullCheck = true__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__			wasNullCheck = true__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__			wasNullCheck = true__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__			wasNullCheck = true__		}_		else if (byte[].class.equals(requiredType)) {_			value = rs.getBytes(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			value = rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			value = rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			value = rs.getTimestamp(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			value = rs.getBigDecimal(index)__		}_		else if (Blob.class.equals(requiredType)) {_			value = rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			value = rs.getClob(index)__		}_		else {_			_			value = getResultSetValue(rs, index)__		}__		_		_		if (wasNullCheck && value != null && rs.wasNull()) {_			value = null__		}_		return value__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,null,boolean,was,null,check,false,if,string,class,equals,required,type,value,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,was,null,check,true,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,was,null,check,true,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,was,null,check,true,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,was,null,check,true,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,was,null,check,true,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,was,null,check,true,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,was,null,check,true,else,if,byte,class,equals,required,type,value,rs,get,bytes,index,else,if,java,sql,date,class,equals,required,type,value,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,value,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,value,rs,get,timestamp,index,else,if,big,decimal,class,equals,required,type,value,rs,get,big,decimal,index,else,if,blob,class,equals,required,type,value,rs,get,blob,index,else,if,clob,class,equals,required,type,value,rs,get,clob,index,else,value,get,result,set,value,rs,index,if,was,null,check,value,null,rs,was,null,value,null,return,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class requiredType) throws SQLException;1357119239;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;public static Object getResultSetValue(ResultSet rs, int index, Class requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value = null__		boolean wasNullCheck = false___		_		if (String.class.equals(requiredType)) {_			value = rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__			wasNullCheck = true__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__			wasNullCheck = true__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__			wasNullCheck = true__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__			wasNullCheck = true__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__			wasNullCheck = true__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__			wasNullCheck = true__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__			wasNullCheck = true__		}_		else if (byte[].class.equals(requiredType)) {_			value = rs.getBytes(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			value = rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			value = rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			value = rs.getTimestamp(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			value = rs.getBigDecimal(index)__		}_		else if (Blob.class.equals(requiredType)) {_			value = rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			value = rs.getClob(index)__		}_		else {_			_			value = getResultSetValue(rs, index)__		}__		_		_		if (wasNullCheck && value != null && rs.wasNull()) {_			value = null__		}_		return value__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,null,boolean,was,null,check,false,if,string,class,equals,required,type,value,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,was,null,check,true,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,was,null,check,true,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,was,null,check,true,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,was,null,check,true,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,was,null,check,true,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,was,null,check,true,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,was,null,check,true,else,if,byte,class,equals,required,type,value,rs,get,bytes,index,else,if,java,sql,date,class,equals,required,type,value,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,value,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,value,rs,get,timestamp,index,else,if,big,decimal,class,equals,required,type,value,rs,get,big,decimal,index,else,if,blob,class,equals,required,type,value,rs,get,blob,index,else,if,clob,class,equals,required,type,value,rs,get,clob,index,else,value,get,result,set,value,rs,index,if,was,null,check,value,null,rs,was,null,value,null,return,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class requiredType) throws SQLException;1368482696;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;public static Object getResultSetValue(ResultSet rs, int index, Class requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value = null__		boolean wasNullCheck = false___		_		if (String.class.equals(requiredType)) {_			value = rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__			wasNullCheck = true__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__			wasNullCheck = true__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__			wasNullCheck = true__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__			wasNullCheck = true__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__			wasNullCheck = true__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__			wasNullCheck = true__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__			wasNullCheck = true__		}_		else if (byte[].class.equals(requiredType)) {_			value = rs.getBytes(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			value = rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			value = rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			value = rs.getTimestamp(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			value = rs.getBigDecimal(index)__		}_		else if (Blob.class.equals(requiredType)) {_			value = rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			value = rs.getClob(index)__		}_		else {_			_			value = getResultSetValue(rs, index)__		}__		_		_		if (wasNullCheck && value != null && rs.wasNull()) {_			value = null__		}_		return value__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,null,boolean,was,null,check,false,if,string,class,equals,required,type,value,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,was,null,check,true,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,was,null,check,true,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,was,null,check,true,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,was,null,check,true,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,was,null,check,true,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,was,null,check,true,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,was,null,check,true,else,if,byte,class,equals,required,type,value,rs,get,bytes,index,else,if,java,sql,date,class,equals,required,type,value,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,value,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,value,rs,get,timestamp,index,else,if,big,decimal,class,equals,required,type,value,rs,get,big,decimal,index,else,if,blob,class,equals,required,type,value,rs,get,blob,index,else,if,clob,class,equals,required,type,value,rs,get,clob,index,else,value,get,result,set,value,rs,index,if,was,null,check,value,null,rs,was,null,value,null,return,value
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1328020251;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1356735495;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1357119239;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1368482696;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1385412762;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1397137904;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1398858661;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1401910463;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1410122589;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1410532068;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1414509556;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1432125256;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1467677340;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1479822741;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1481218225;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1487178248;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1488037840;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1495868221;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1496837955;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1506097334;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1513100167;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1518615840;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1520339775;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1521457504;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta-data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (name == null || name.length() < 1) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,name,null,name,length,1,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1528313484;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@return the column name to use_@param resultSetMetaData the current meta-data to use_@param columnIndex the index of the column for the look up_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (!StringUtils.hasLength(name)) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,return,the,column,name,to,use,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,string,utils,has,length,name,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1530174524;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@param resultSetMetaData the current meta-data to use_@param columnIndex the index of the column for the look up_@return the column name to use_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (!StringUtils.hasLength(name)) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,return,the,column,name,to,use,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,string,utils,has,length,name,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException;1549380778;Determine the column name to use. The column name is determined based on a_lookup using ResultSetMetaData._<p>This method implementation takes into account recent clarifications_expressed in the JDBC 4.0 specification:_<p><i>columnLabel - the label for the column specified with the SQL AS clause._If the SQL AS clause was not specified, then the label is the name of the column</i>._@param resultSetMetaData the current meta-data to use_@param columnIndex the index of the column for the look up_@return the column name to use_@throws SQLException in case of lookup failure;public static String lookupColumnName(ResultSetMetaData resultSetMetaData, int columnIndex) throws SQLException {_		String name = resultSetMetaData.getColumnLabel(columnIndex)__		if (!StringUtils.hasLength(name)) {_			name = resultSetMetaData.getColumnName(columnIndex)__		}_		return name__	};determine,the,column,name,to,use,the,column,name,is,determined,based,on,a,lookup,using,result,set,meta,data,p,this,method,implementation,takes,into,account,recent,clarifications,expressed,in,the,jdbc,4,0,specification,p,i,column,label,the,label,for,the,column,specified,with,the,sql,as,clause,if,the,sql,as,clause,was,not,specified,then,the,label,is,the,name,of,the,column,i,param,result,set,meta,data,the,current,meta,data,to,use,param,column,index,the,index,of,the,column,for,the,look,up,return,the,column,name,to,use,throws,sqlexception,in,case,of,lookup,failure;public,static,string,lookup,column,name,result,set,meta,data,result,set,meta,data,int,column,index,throws,sqlexception,string,name,result,set,meta,data,get,column,label,column,index,if,string,utils,has,length,name,name,result,set,meta,data,get,column,name,column,index,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1328020251;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) || _				"ASE".equals(source) || _				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1356735495;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1357119239;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1368482696;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1385412762;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1397137904;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1398858661;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1401910463;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1410122589;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1410532068;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1414509556;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1432125256;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1467677340;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1479822741;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1481218225;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metedata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metedata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1487178248;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metadata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metadata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1488037840;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metadata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metadata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static String commonDatabaseName(String source);1495868221;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metadata_@return the common name to be used;public static String commonDatabaseName(String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metadata,return,the,common,name,to,be,used;public,static,string,common,database,name,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> @UsesJava7   	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1401910463;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;@UsesJava7  _	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class.equals(requiredType)) {_			return rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class.equals(requiredType)) {_			return rs.getBytes(index)__		}_		else if (Blob.class.equals(requiredType)) {_			return rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			return rs.getClob(index)__		}_		else {_			_			if (getObjectWithTypeAvailable) {_				try {_					return rs.getObject(index, requiredType)__				}_				catch (SQLFeatureNotSupportedException ex) {_					logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__				}_				catch (AbstractMethodError err) {_					logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__				}_			}_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;uses,java7,public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,equals,required,type,return,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,else,if,big,decimal,class,equals,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,equals,required,type,return,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,return,rs,get,timestamp,index,else,if,byte,class,equals,required,type,return,rs,get,bytes,index,else,if,blob,class,equals,required,type,return,rs,get,blob,index,else,if,clob,class,equals,required,type,return,rs,get,clob,index,else,if,get,object,with,type,available,try,return,rs,get,object,index,required,type,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @UsesJava7   	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1410122589;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;@UsesJava7  _	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class.equals(requiredType)) {_			return rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class.equals(requiredType)) {_			return rs.getBytes(index)__		}_		else if (Blob.class.equals(requiredType)) {_			return rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			return rs.getClob(index)__		}_		else {_			_			if (getObjectWithTypeAvailable) {_				try {_					return rs.getObject(index, requiredType)__				}_				catch (SQLDataException ex) {_					logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__				}_				catch (SQLFeatureNotSupportedException ex) {_					logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__				}_				catch (AbstractMethodError err) {_					logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__				}_			}_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;uses,java7,public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,equals,required,type,return,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,else,if,big,decimal,class,equals,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,equals,required,type,return,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,return,rs,get,timestamp,index,else,if,byte,class,equals,required,type,return,rs,get,bytes,index,else,if,blob,class,equals,required,type,return,rs,get,blob,index,else,if,clob,class,equals,required,type,return,rs,get,clob,index,else,if,get,object,with,type,available,try,return,rs,get,object,index,required,type,catch,sqldata,exception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @UsesJava7   	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1410532068;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;@UsesJava7  _	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class.equals(requiredType)) {_			return rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class.equals(requiredType)) {_			return rs.getBytes(index)__		}_		else if (Blob.class.equals(requiredType)) {_			return rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			return rs.getClob(index)__		}_		else {_			_			if (getObjectWithTypeAvailable) {_				try {_					return rs.getObject(index, requiredType)__				}_				catch (AbstractMethodError err) {_					logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__				}_				catch (SQLFeatureNotSupportedException ex) {_					logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__				}_				catch (SQLException ex) {_					logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__				}_			}_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;uses,java7,public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,equals,required,type,return,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,else,if,big,decimal,class,equals,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,equals,required,type,return,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,return,rs,get,timestamp,index,else,if,byte,class,equals,required,type,return,rs,get,bytes,index,else,if,blob,class,equals,required,type,return,rs,get,blob,index,else,if,clob,class,equals,required,type,return,rs,get,clob,index,else,if,get,object,with,type,available,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @UsesJava7   	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1414509556;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;@UsesJava7  _	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class.equals(requiredType)) {_			return rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class.equals(requiredType)) {_			return rs.getBytes(index)__		}_		else if (Blob.class.equals(requiredType)) {_			return rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			return rs.getClob(index)__		}_		else {_			_			if (getObjectWithTypeAvailable) {_				try {_					return rs.getObject(index, requiredType)__				}_				catch (AbstractMethodError err) {_					logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__				}_				catch (SQLFeatureNotSupportedException ex) {_					logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__				}_				catch (SQLException ex) {_					logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__				}_			}_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;uses,java7,public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,equals,required,type,return,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,else,if,big,decimal,class,equals,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,equals,required,type,return,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,return,rs,get,timestamp,index,else,if,byte,class,equals,required,type,return,rs,get,bytes,index,else,if,blob,class,equals,required,type,return,rs,get,blob,index,else,if,clob,class,equals,required,type,return,rs,get,clob,index,else,if,get,object,with,type,available,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @UsesJava7   	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1432125256;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;@UsesJava7  _	public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else {_			_			if (getObjectWithTypeAvailable) {_				try {_					return rs.getObject(index, requiredType)__				}_				catch (AbstractMethodError err) {_					logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__				}_				catch (SQLFeatureNotSupportedException ex) {_					logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__				}_				catch (SQLException ex) {_					logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__				}_			}_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;uses,java7,public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,get,object,with,type,available,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1495868221;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1496837955;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1506097334;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1513100167;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1518615840;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1520339775;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1521457504;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1528313484;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1530174524;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(@Nullable Statement stmt);1549380778;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(@Nullable Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,nullable,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1495868221;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1496837955;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1506097334;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1513100167;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1518615840;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1520339775;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1521457504;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1528313484;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1530174524;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(@Nullable Connection con);1549380778;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(@Nullable Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,nullable,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1506097334;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);@Nullable_	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1513100167;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);@Nullable_	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1518615840;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);@Nullable_	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1520339775;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);@Nullable_	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1521457504;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);@Nullable_	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1528313484;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);@Nullable_	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1530174524;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);@Nullable_	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1549380778;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);@Nullable_	public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1328020251;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's <code>processMetaData</code> method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,code,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1356735495;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1357119239;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1368482696;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1385412762;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1397137904;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1398858661;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1401910463;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1410122589;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1410532068;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1414509556;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1432125256;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1467677340;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1479822741;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1481218225;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1487178248;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1488037840;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1495868221;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			if (con == null) {_				_				throw new MetaDataAccessException("Connection returned by DataSource [" + dataSource + "] was null")__			}_			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,if,con,null,throw,new,meta,data,access,exception,connection,returned,by,data,source,data,source,was,null,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1506097334;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1513100167;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1518615840;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1520339775;Extract database meta data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database metadata._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract metadata for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,metadata,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,metadata,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1521457504;Extract database meta-data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database meta-data._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract meta-data for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta-data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta-data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,meta,data,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,meta,data,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1528313484;Extract database meta-data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database meta-data._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract meta-data for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta-data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta-data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,meta,data,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,meta,data,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1530174524;Extract database meta-data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database meta-data._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract meta-data for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta-data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta-data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,meta,data,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,meta,data,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action) 			throws MetaDataAccessException;1549380778;Extract database meta-data via the given DatabaseMetaDataCallback._<p>This method will open a connection to the database and retrieve the database meta-data._Since this method is called before the exception translation feature is configured for_a datasource, this method can not rely on the SQLException translation functionality._<p>Any exceptions will be wrapped in a MetaDataAccessException. This is a checked exception_and any calling code should catch and handle this exception. You can just log the_error and hope for the best, but there is probably a more serious error that will_reappear when you try to access the database again._@param dataSource the DataSource to extract meta-data for_@param action callback that will do the actual work_@return object containing the extracted information, as returned by_the DatabaseMetaDataCallback's {@code processMetaData} method_@throws MetaDataAccessException if meta-data access failed;public static Object extractDatabaseMetaData(DataSource dataSource, DatabaseMetaDataCallback action)_			throws MetaDataAccessException {__		Connection con = null__		try {_			con = DataSourceUtils.getConnection(dataSource)__			DatabaseMetaData metaData = con.getMetaData()__			if (metaData == null) {_				_				throw new MetaDataAccessException("DatabaseMetaData returned by Connection [" + con + "] was null")__			}_			return action.processMetaData(metaData)__		}_		catch (CannotGetJdbcConnectionException ex) {_			throw new MetaDataAccessException("Could not get Connection for extracting meta-data", ex)__		}_		catch (SQLException ex) {_			throw new MetaDataAccessException("Error while extracting DatabaseMetaData", ex)__		}_		catch (AbstractMethodError err) {_			throw new MetaDataAccessException(_					"JDBC DatabaseMetaData method not implemented by JDBC driver - upgrade your driver", err)__		}_		finally {_			DataSourceUtils.releaseConnection(con, dataSource)__		}_	};extract,database,meta,data,via,the,given,database,meta,data,callback,p,this,method,will,open,a,connection,to,the,database,and,retrieve,the,database,meta,data,since,this,method,is,called,before,the,exception,translation,feature,is,configured,for,a,datasource,this,method,can,not,rely,on,the,sqlexception,translation,functionality,p,any,exceptions,will,be,wrapped,in,a,meta,data,access,exception,this,is,a,checked,exception,and,any,calling,code,should,catch,and,handle,this,exception,you,can,just,log,the,error,and,hope,for,the,best,but,there,is,probably,a,more,serious,error,that,will,reappear,when,you,try,to,access,the,database,again,param,data,source,the,data,source,to,extract,meta,data,for,param,action,callback,that,will,do,the,actual,work,return,object,containing,the,extracted,information,as,returned,by,the,database,meta,data,callback,s,code,process,meta,data,method,throws,meta,data,access,exception,if,meta,data,access,failed;public,static,object,extract,database,meta,data,data,source,data,source,database,meta,data,callback,action,throws,meta,data,access,exception,connection,con,null,try,con,data,source,utils,get,connection,data,source,database,meta,data,meta,data,con,get,meta,data,if,meta,data,null,throw,new,meta,data,access,exception,database,meta,data,returned,by,connection,con,was,null,return,action,process,meta,data,meta,data,catch,cannot,get,jdbc,connection,exception,ex,throw,new,meta,data,access,exception,could,not,get,connection,for,extracting,meta,data,ex,catch,sqlexception,ex,throw,new,meta,data,access,exception,error,while,extracting,database,meta,data,ex,catch,abstract,method,error,err,throw,new,meta,data,access,exception,jdbc,database,meta,data,method,not,implemented,by,jdbc,driver,upgrade,your,driver,err,finally,data,source,utils,release,connection,con,data,source
JdbcUtils -> @Nullable 	public static String commonDatabaseName(@Nullable String source);1496837955;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metadata_@return the common name to be used;@Nullable_	public static String commonDatabaseName(@Nullable String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metadata,return,the,common,name,to,be,used;nullable,public,static,string,common,database,name,nullable,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> @Nullable 	public static String commonDatabaseName(@Nullable String source);1506097334;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metadata_@return the common name to be used;@Nullable_	public static String commonDatabaseName(@Nullable String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metadata,return,the,common,name,to,be,used;nullable,public,static,string,common,database,name,nullable,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> @Nullable 	public static String commonDatabaseName(@Nullable String source);1513100167;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metadata_@return the common name to be used;@Nullable_	public static String commonDatabaseName(@Nullable String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metadata,return,the,common,name,to,be,used;nullable,public,static,string,common,database,name,nullable,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> @Nullable 	public static String commonDatabaseName(@Nullable String source);1518615840;Extract a common name for the database in use even if various drivers/platforms provide varying names._@param source the name as provided in database metadata_@return the common name to be used;@Nullable_	public static String commonDatabaseName(@Nullable String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,database,in,use,even,if,various,drivers,platforms,provide,varying,names,param,source,the,name,as,provided,in,database,metadata,return,the,common,name,to,be,used;nullable,public,static,string,common,database,name,nullable,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> @Nullable 	public static String commonDatabaseName(@Nullable String source);1520339775;Extract a common name for the target database in use even if_various drivers/platforms provide varying names at runtime._@param source the name as provided in database metadata_@return the common name to be used (e.g. "DB2" or "Sybase");@Nullable_	public static String commonDatabaseName(@Nullable String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,target,database,in,use,even,if,various,drivers,platforms,provide,varying,names,at,runtime,param,source,the,name,as,provided,in,database,metadata,return,the,common,name,to,be,used,e,g,db2,or,sybase;nullable,public,static,string,common,database,name,nullable,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> @Nullable 	public static String commonDatabaseName(@Nullable String source);1521457504;Extract a common name for the target database in use even if_various drivers/platforms provide varying names at runtime._@param source the name as provided in database meta-data_@return the common name to be used (e.g. "DB2" or "Sybase");@Nullable_	public static String commonDatabaseName(@Nullable String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,target,database,in,use,even,if,various,drivers,platforms,provide,varying,names,at,runtime,param,source,the,name,as,provided,in,database,meta,data,return,the,common,name,to,be,used,e,g,db2,or,sybase;nullable,public,static,string,common,database,name,nullable,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> @Nullable 	public static String commonDatabaseName(@Nullable String source);1528313484;Extract a common name for the target database in use even if_various drivers/platforms provide varying names at runtime._@param source the name as provided in database meta-data_@return the common name to be used (e.g. "DB2" or "Sybase");@Nullable_	public static String commonDatabaseName(@Nullable String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,target,database,in,use,even,if,various,drivers,platforms,provide,varying,names,at,runtime,param,source,the,name,as,provided,in,database,meta,data,return,the,common,name,to,be,used,e,g,db2,or,sybase;nullable,public,static,string,common,database,name,nullable,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> @Nullable 	public static String commonDatabaseName(@Nullable String source);1530174524;Extract a common name for the target database in use even if_various drivers/platforms provide varying names at runtime._@param source the name as provided in database meta-data_@return the common name to be used (e.g. "DB2" or "Sybase");@Nullable_	public static String commonDatabaseName(@Nullable String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,target,database,in,use,even,if,various,drivers,platforms,provide,varying,names,at,runtime,param,source,the,name,as,provided,in,database,meta,data,return,the,common,name,to,be,used,e,g,db2,or,sybase;nullable,public,static,string,common,database,name,nullable,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> @Nullable 	public static String commonDatabaseName(@Nullable String source);1549380778;Extract a common name for the target database in use even if_various drivers/platforms provide varying names at runtime._@param source the name as provided in database meta-data_@return the common name to be used (e.g. "DB2" or "Sybase");@Nullable_	public static String commonDatabaseName(@Nullable String source) {_		String name = source__		if (source != null && source.startsWith("DB2")) {_			name = "DB2"__		}_		else if ("MariaDB".equals(source)) {_			name = "MySQL"__		}_		else if ("Sybase SQL Server".equals(source) ||_				"Adaptive Server Enterprise".equals(source) ||_				"ASE".equals(source) ||_				"sql server".equalsIgnoreCase(source) ) {_			name = "Sybase"__		}_		return name__	};extract,a,common,name,for,the,target,database,in,use,even,if,various,drivers,platforms,provide,varying,names,at,runtime,param,source,the,name,as,provided,in,database,meta,data,return,the,common,name,to,be,used,e,g,db2,or,sybase;nullable,public,static,string,common,database,name,nullable,string,source,string,name,source,if,source,null,source,starts,with,db2,name,db2,else,if,maria,db,equals,source,name,my,sql,else,if,sybase,sql,server,equals,source,adaptive,server,enterprise,equals,source,ase,equals,source,sql,server,equals,ignore,case,source,name,sybase,return,name
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1328020251;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1356735495;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1357119239;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1368482696;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1385412762;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1397137904;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1398858661;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1401910463;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1410122589;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1410532068;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1414509556;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1432125256;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1467677340;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1479822741;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1481218225;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1487178248;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1488037840;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1495868221;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;public static Object extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return extractDatabaseMetaData(dataSource,_				new DatabaseMetaDataCallback() {_					@Override_					public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {_						try {_							Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__							return method.invoke(dbmd, (Object[]) null)__						}_						catch (NoSuchMethodException ex) {_							throw new MetaDataAccessException("No method named '" + metaDataMethodName +_									"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__						}_						catch (IllegalAccessException ex) {_							throw new MetaDataAccessException(_									"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__						}_						catch (InvocationTargetException ex) {_							if (ex.getTargetException() instanceof SQLException) {_								throw (SQLException) ex.getTargetException()__							}_							throw new MetaDataAccessException(_									"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__						}_					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;public,static,object,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,extract,database,meta,data,data,source,new,database,meta,data,callback,override,public,object,process,meta,data,database,meta,data,dbmd,throws,sqlexception,meta,data,access,exception,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static void closeConnection(Connection con);1328020251;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be <code>null</code>);public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null,code;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1356735495;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1357119239;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1368482696;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1385412762;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1397137904;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1398858661;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1401910463;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1410122589;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1410532068;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1414509556;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1432125256;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1467677340;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1479822741;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1481218225;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1487178248;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static void closeConnection(Connection con);1488037840;Close the given JDBC Connection and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param con the JDBC Connection to close (may be {@code null});public static void closeConnection(Connection con) {_		if (con != null) {_			try {_				con.close()__			}_			catch (SQLException ex) {_				logger.debug("Could not close JDBC Connection", ex)__			}_			catch (Throwable ex) {_				_				logger.debug("Unexpected exception on closing JDBC Connection", ex)__			}_		}_	};close,the,given,jdbc,connection,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,con,the,jdbc,connection,to,close,may,be,code,null;public,static,void,close,connection,connection,con,if,con,null,try,con,close,catch,sqlexception,ex,logger,debug,could,not,close,jdbc,connection,ex,catch,throwable,ex,logger,debug,unexpected,exception,on,closing,jdbc,connection,ex
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1328020251;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array respectively String representation._<p>Uses the <code>getObject(index)</code> method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a <code>java.sql.Date</code> for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_<code>java.sql.Timestamp</code> object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if (className != null &&_				("oracle.sql.TIMESTAMP".equals(className) ||_				"oracle.sql.TIMESTAMPTZ".equals(className))) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) ||_					"oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,respectively,string,representation,p,uses,the,code,get,object,index,code,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,code,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,code,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,class,name,null,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1356735495;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array respectively String representation._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if (className != null &&_				("oracle.sql.TIMESTAMP".equals(className) ||_				"oracle.sql.TIMESTAMPTZ".equals(className))) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) ||_					"oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,respectively,string,representation,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,class,name,null,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1357119239;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array respectively String representation._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if (className != null &&_				("oracle.sql.TIMESTAMP".equals(className) ||_				"oracle.sql.TIMESTAMPTZ".equals(className))) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) ||_					"oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,respectively,string,representation,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,class,name,null,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1368482696;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array respectively String representation._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if (className != null &&_				("oracle.sql.TIMESTAMP".equals(className) ||_				"oracle.sql.TIMESTAMPTZ".equals(className))) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) ||_					"oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,respectively,string,representation,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,class,name,null,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1385412762;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array respectively String representation._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if (className != null &&_				("oracle.sql.TIMESTAMP".equals(className) ||_				"oracle.sql.TIMESTAMPTZ".equals(className))) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) ||_					"oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,respectively,string,representation,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,class,name,null,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1397137904;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array respectively String representation._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,respectively,string,representation,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1398858661;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array respectively String representation._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,respectively,string,representation,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1401910463;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array respectively String representation._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,respectively,string,representation,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1410122589;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array respectively String representation._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,respectively,string,representation,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1410532068;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			obj = rs.getBytes(index)__		}_		else if (obj instanceof Clob) {_			obj = rs.getString(index)__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,obj,rs,get,bytes,index,else,if,obj,instanceof,clob,obj,rs,get,string,index,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1414509556;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1432125256;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1467677340;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj != null && obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,null,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1479822741;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1481218225;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1487178248;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1488037840;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1495868221;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1495868221;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1496837955;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1506097334;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1513100167;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1518615840;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1520339775;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1521457504;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1528313484;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1530174524;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(@Nullable ResultSet rs);1549380778;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(@Nullable ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,nullable,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1328020251;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be <code>null</code>);public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null,code;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1356735495;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1357119239;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1368482696;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1385412762;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1397137904;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1398858661;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1401910463;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1410122589;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1410532068;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1414509556;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1432125256;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1467677340;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1479822741;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1481218225;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1487178248;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static void closeResultSet(ResultSet rs);1488037840;Close the given JDBC ResultSet and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param rs the JDBC ResultSet to close (may be {@code null});public static void closeResultSet(ResultSet rs) {_		if (rs != null) {_			try {_				rs.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC ResultSet", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC ResultSet", ex)__			}_		}_	};close,the,given,jdbc,result,set,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,rs,the,jdbc,result,set,to,close,may,be,code,null;public,static,void,close,result,set,result,set,rs,if,rs,null,try,rs,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,result,set,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,result,set,ex
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1328020251;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns <code>false</code> in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		catch (AbstractMethodError err) {_			logger.debug("JDBC driver does not support JDBC 2.0 'supportsBatchUpdates' method", err)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,code,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,support,jdbc,2,0,supports,batch,updates,method,err,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1356735495;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		catch (AbstractMethodError err) {_			logger.debug("JDBC driver does not support JDBC 2.0 'supportsBatchUpdates' method", err)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,support,jdbc,2,0,supports,batch,updates,method,err,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1357119239;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		catch (AbstractMethodError err) {_			logger.debug("JDBC driver does not support JDBC 2.0 'supportsBatchUpdates' method", err)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,support,jdbc,2,0,supports,batch,updates,method,err,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1368482696;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		catch (AbstractMethodError err) {_			logger.debug("JDBC driver does not support JDBC 2.0 'supportsBatchUpdates' method", err)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,support,jdbc,2,0,supports,batch,updates,method,err,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1385412762;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		catch (AbstractMethodError err) {_			logger.debug("JDBC driver does not support JDBC 2.0 'supportsBatchUpdates' method", err)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,support,jdbc,2,0,supports,batch,updates,method,err,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1397137904;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1398858661;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1401910463;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1410122589;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1410532068;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1414509556;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1432125256;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1467677340;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1479822741;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1481218225;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1487178248;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1488037840;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1495868221;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1496837955;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1506097334;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1513100167;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1518615840;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1520339775;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1521457504;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1528313484;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1530174524;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static boolean supportsBatchUpdates(Connection con);1549380778;Return whether the given JDBC driver supports JDBC 2.0 batch updates._<p>Typically invoked right before execution of a given set of statements:_to decide whether the set of SQL statements should be executed through_the JDBC 2.0 batch mechanism or simply in a traditional one-by-one fashion._<p>Logs a warning if the "supportsBatchUpdates" methods throws an exception_and simply returns {@code false} in that case._@param con the Connection to check_@return whether JDBC 2.0 batch updates are supported_@see java.sql.DatabaseMetaData#supportsBatchUpdates();public static boolean supportsBatchUpdates(Connection con) {_		try {_			DatabaseMetaData dbmd = con.getMetaData()__			if (dbmd != null) {_				if (dbmd.supportsBatchUpdates()) {_					logger.debug("JDBC driver supports batch updates")__					return true__				}_				else {_					logger.debug("JDBC driver does not support batch updates")__				}_			}_		}_		catch (SQLException ex) {_			logger.debug("JDBC driver 'supportsBatchUpdates' method threw exception", ex)__		}_		return false__	};return,whether,the,given,jdbc,driver,supports,jdbc,2,0,batch,updates,p,typically,invoked,right,before,execution,of,a,given,set,of,statements,to,decide,whether,the,set,of,sql,statements,should,be,executed,through,the,jdbc,2,0,batch,mechanism,or,simply,in,a,traditional,one,by,one,fashion,p,logs,a,warning,if,the,supports,batch,updates,methods,throws,an,exception,and,simply,returns,code,false,in,that,case,param,con,the,connection,to,check,return,whether,jdbc,2,0,batch,updates,are,supported,see,java,sql,database,meta,data,supports,batch,updates;public,static,boolean,supports,batch,updates,connection,con,try,database,meta,data,dbmd,con,get,meta,data,if,dbmd,null,if,dbmd,supports,batch,updates,logger,debug,jdbc,driver,supports,batch,updates,return,true,else,logger,debug,jdbc,driver,does,not,support,batch,updates,catch,sqlexception,ex,logger,debug,jdbc,driver,supports,batch,updates,method,threw,exception,ex,return,false
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(@Nullable String name);1496837955;Convert a column name with underscores to the corresponding property name using "camel case"._A name like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(@Nullable String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1, 2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,nullable,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(@Nullable String name);1506097334;Convert a column name with underscores to the corresponding property name using "camel case"._A name like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(@Nullable String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1, 2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,nullable,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(@Nullable String name);1513100167;Convert a column name with underscores to the corresponding property name using "camel case"._A name like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(@Nullable String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.charAt(1) == '_') {_				result.append(Character.toUpperCase(name.charAt(0)))__			}_			else {_				result.append(Character.toLowerCase(name.charAt(0)))__			}_			for (int i = 1_ i < name.length()_ i++) {_				char c = name.charAt(i)__				if (c == '_') {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(Character.toUpperCase(c))__						nextIsUpper = false__					}_					else {_						result.append(Character.toLowerCase(c))__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,nullable,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,char,at,1,result,append,character,to,upper,case,name,char,at,0,else,result,append,character,to,lower,case,name,char,at,0,for,int,i,1,i,name,length,i,char,c,name,char,at,i,if,c,next,is,upper,true,else,if,next,is,upper,result,append,character,to,upper,case,c,next,is,upper,false,else,result,append,character,to,lower,case,c,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(@Nullable String name);1518615840;Convert a column name with underscores to the corresponding property name using "camel case"._A name like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(@Nullable String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.charAt(1) == '_') {_				result.append(Character.toUpperCase(name.charAt(0)))__			}_			else {_				result.append(Character.toLowerCase(name.charAt(0)))__			}_			for (int i = 1_ i < name.length()_ i++) {_				char c = name.charAt(i)__				if (c == '_') {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(Character.toUpperCase(c))__						nextIsUpper = false__					}_					else {_						result.append(Character.toLowerCase(c))__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,nullable,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,char,at,1,result,append,character,to,upper,case,name,char,at,0,else,result,append,character,to,lower,case,name,char,at,0,for,int,i,1,i,name,length,i,char,c,name,char,at,i,if,c,next,is,upper,true,else,if,next,is,upper,result,append,character,to,upper,case,c,next,is,upper,false,else,result,append,character,to,lower,case,c,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(@Nullable String name);1520339775;Convert a column name with underscores to the corresponding property name using "camel case"._A name like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(@Nullable String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.charAt(1) == '_') {_				result.append(Character.toUpperCase(name.charAt(0)))__			}_			else {_				result.append(Character.toLowerCase(name.charAt(0)))__			}_			for (int i = 1_ i < name.length()_ i++) {_				char c = name.charAt(i)__				if (c == '_') {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(Character.toUpperCase(c))__						nextIsUpper = false__					}_					else {_						result.append(Character.toLowerCase(c))__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,nullable,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,char,at,1,result,append,character,to,upper,case,name,char,at,0,else,result,append,character,to,lower,case,name,char,at,0,for,int,i,1,i,name,length,i,char,c,name,char,at,i,if,c,next,is,upper,true,else,if,next,is,upper,result,append,character,to,upper,case,c,next,is,upper,false,else,result,append,character,to,lower,case,c,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(@Nullable String name);1521457504;Convert a column name with underscores to the corresponding property name using "camel case"._A name like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(@Nullable String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.charAt(1) == '_') {_				result.append(Character.toUpperCase(name.charAt(0)))__			}_			else {_				result.append(Character.toLowerCase(name.charAt(0)))__			}_			for (int i = 1_ i < name.length()_ i++) {_				char c = name.charAt(i)__				if (c == '_') {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(Character.toUpperCase(c))__						nextIsUpper = false__					}_					else {_						result.append(Character.toLowerCase(c))__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,nullable,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,char,at,1,result,append,character,to,upper,case,name,char,at,0,else,result,append,character,to,lower,case,name,char,at,0,for,int,i,1,i,name,length,i,char,c,name,char,at,i,if,c,next,is,upper,true,else,if,next,is,upper,result,append,character,to,upper,case,c,next,is,upper,false,else,result,append,character,to,lower,case,c,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(@Nullable String name);1528313484;Convert a column name with underscores to the corresponding property name using "camel case"._A name like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(@Nullable String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.charAt(1) == '_') {_				result.append(Character.toUpperCase(name.charAt(0)))__			}_			else {_				result.append(Character.toLowerCase(name.charAt(0)))__			}_			for (int i = 1_ i < name.length()_ i++) {_				char c = name.charAt(i)__				if (c == '_') {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(Character.toUpperCase(c))__						nextIsUpper = false__					}_					else {_						result.append(Character.toLowerCase(c))__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,nullable,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,char,at,1,result,append,character,to,upper,case,name,char,at,0,else,result,append,character,to,lower,case,name,char,at,0,for,int,i,1,i,name,length,i,char,c,name,char,at,i,if,c,next,is,upper,true,else,if,next,is,upper,result,append,character,to,upper,case,c,next,is,upper,false,else,result,append,character,to,lower,case,c,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(@Nullable String name);1530174524;Convert a column name with underscores to the corresponding property name using "camel case"._A name like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(@Nullable String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.charAt(1) == '_') {_				result.append(Character.toUpperCase(name.charAt(0)))__			}_			else {_				result.append(Character.toLowerCase(name.charAt(0)))__			}_			for (int i = 1_ i < name.length()_ i++) {_				char c = name.charAt(i)__				if (c == '_') {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(Character.toUpperCase(c))__						nextIsUpper = false__					}_					else {_						result.append(Character.toLowerCase(c))__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,nullable,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,char,at,1,result,append,character,to,upper,case,name,char,at,0,else,result,append,character,to,lower,case,name,char,at,0,for,int,i,1,i,name,length,i,char,c,name,char,at,i,if,c,next,is,upper,true,else,if,next,is,upper,result,append,character,to,upper,case,c,next,is,upper,false,else,result,append,character,to,lower,case,c,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(@Nullable String name);1549380778;Convert a column name with underscores to the corresponding property name using "camel case"._A name like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(@Nullable String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.charAt(1) == '_') {_				result.append(Character.toUpperCase(name.charAt(0)))__			}_			else {_				result.append(Character.toLowerCase(name.charAt(0)))__			}_			for (int i = 1_ i < name.length()_ i++) {_				char c = name.charAt(i)__				if (c == '_') {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(Character.toUpperCase(c))__						nextIsUpper = false__					}_					else {_						result.append(Character.toLowerCase(c))__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,nullable,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,char,at,1,result,append,character,to,upper,case,name,char,at,0,else,result,append,character,to,lower,case,name,char,at,0,for,int,i,1,i,name,length,i,char,c,name,char,at,i,if,c,next,is,upper,true,else,if,next,is,upper,result,append,character,to,upper,case,c,next,is,upper,false,else,result,append,character,to,lower,case,c,return,result,to,string
JdbcUtils -> @SuppressWarnings("unchecked") 	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1506097334;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;@SuppressWarnings("unchecked")_	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return (T) extractDatabaseMetaData(dataSource,_				dbmd -> {_					try {_						Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__						return method.invoke(dbmd, (Object[]) null)__					}_					catch (NoSuchMethodException ex) {_						throw new MetaDataAccessException("No method named '" + metaDataMethodName +_								"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__					}_					catch (IllegalAccessException ex) {_						throw new MetaDataAccessException(_								"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__					}_					catch (InvocationTargetException ex) {_						if (ex.getTargetException() instanceof SQLException) {_							throw (SQLException) ex.getTargetException()__						}_						throw new MetaDataAccessException(_								"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;suppress,warnings,unchecked,public,static,t,t,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,t,extract,database,meta,data,data,source,dbmd,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> @SuppressWarnings("unchecked") 	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1513100167;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;@SuppressWarnings("unchecked")_	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return (T) extractDatabaseMetaData(dataSource,_				dbmd -> {_					try {_						Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null)__						return method.invoke(dbmd, (Object[]) null)__					}_					catch (NoSuchMethodException ex) {_						throw new MetaDataAccessException("No method named '" + metaDataMethodName +_								"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__					}_					catch (IllegalAccessException ex) {_						throw new MetaDataAccessException(_								"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__					}_					catch (InvocationTargetException ex) {_						if (ex.getTargetException() instanceof SQLException) {_							throw (SQLException) ex.getTargetException()__						}_						throw new MetaDataAccessException(_								"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;suppress,warnings,unchecked,public,static,t,t,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,t,extract,database,meta,data,data,source,dbmd,try,method,method,database,meta,data,class,get,method,meta,data,method,name,class,null,return,method,invoke,dbmd,object,null,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> @SuppressWarnings("unchecked") 	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1518615840;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;@SuppressWarnings("unchecked")_	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return (T) extractDatabaseMetaData(dataSource,_				dbmd -> {_					try {_						return DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd)__					}_					catch (NoSuchMethodException ex) {_						throw new MetaDataAccessException("No method named '" + metaDataMethodName +_								"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__					}_					catch (IllegalAccessException ex) {_						throw new MetaDataAccessException(_								"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__					}_					catch (InvocationTargetException ex) {_						if (ex.getTargetException() instanceof SQLException) {_							throw (SQLException) ex.getTargetException()__						}_						throw new MetaDataAccessException(_								"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;suppress,warnings,unchecked,public,static,t,t,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,t,extract,database,meta,data,data,source,dbmd,try,return,database,meta,data,class,get,method,meta,data,method,name,invoke,dbmd,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> @SuppressWarnings("unchecked") 	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1520339775;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;@SuppressWarnings("unchecked")_	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return (T) extractDatabaseMetaData(dataSource,_				dbmd -> {_					try {_						return DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd)__					}_					catch (NoSuchMethodException ex) {_						throw new MetaDataAccessException("No method named '" + metaDataMethodName +_								"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__					}_					catch (IllegalAccessException ex) {_						throw new MetaDataAccessException(_								"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__					}_					catch (InvocationTargetException ex) {_						if (ex.getTargetException() instanceof SQLException) {_							throw (SQLException) ex.getTargetException()__						}_						throw new MetaDataAccessException(_								"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;suppress,warnings,unchecked,public,static,t,t,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,t,extract,database,meta,data,data,source,dbmd,try,return,database,meta,data,class,get,method,meta,data,method,name,invoke,dbmd,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> @SuppressWarnings("unchecked") 	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1521457504;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta-data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;@SuppressWarnings("unchecked")_	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return (T) extractDatabaseMetaData(dataSource,_				dbmd -> {_					try {_						return DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd)__					}_					catch (NoSuchMethodException ex) {_						throw new MetaDataAccessException("No method named '" + metaDataMethodName +_								"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__					}_					catch (IllegalAccessException ex) {_						throw new MetaDataAccessException(_								"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__					}_					catch (InvocationTargetException ex) {_						if (ex.getTargetException() instanceof SQLException) {_							throw (SQLException) ex.getTargetException()__						}_						throw new MetaDataAccessException(_								"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;suppress,warnings,unchecked,public,static,t,t,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,t,extract,database,meta,data,data,source,dbmd,try,return,database,meta,data,class,get,method,meta,data,method,name,invoke,dbmd,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> @SuppressWarnings("unchecked") 	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1528313484;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta-data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;@SuppressWarnings("unchecked")_	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return (T) extractDatabaseMetaData(dataSource,_				dbmd -> {_					try {_						return DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd)__					}_					catch (NoSuchMethodException ex) {_						throw new MetaDataAccessException("No method named '" + metaDataMethodName +_								"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__					}_					catch (IllegalAccessException ex) {_						throw new MetaDataAccessException(_								"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__					}_					catch (InvocationTargetException ex) {_						if (ex.getTargetException() instanceof SQLException) {_							throw (SQLException) ex.getTargetException()__						}_						throw new MetaDataAccessException(_								"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;suppress,warnings,unchecked,public,static,t,t,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,t,extract,database,meta,data,data,source,dbmd,try,return,database,meta,data,class,get,method,meta,data,method,name,invoke,dbmd,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> @SuppressWarnings("unchecked") 	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1530174524;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta-data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;@SuppressWarnings("unchecked")_	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return (T) extractDatabaseMetaData(dataSource,_				dbmd -> {_					try {_						return DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd)__					}_					catch (NoSuchMethodException ex) {_						throw new MetaDataAccessException("No method named '" + metaDataMethodName +_								"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__					}_					catch (IllegalAccessException ex) {_						throw new MetaDataAccessException(_								"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__					}_					catch (InvocationTargetException ex) {_						if (ex.getTargetException() instanceof SQLException) {_							throw (SQLException) ex.getTargetException()__						}_						throw new MetaDataAccessException(_								"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;suppress,warnings,unchecked,public,static,t,t,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,t,extract,database,meta,data,data,source,dbmd,try,return,database,meta,data,class,get,method,meta,data,method,name,invoke,dbmd,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> @SuppressWarnings("unchecked") 	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName) 			throws MetaDataAccessException;1549380778;Call the specified method on DatabaseMetaData for the given DataSource,_and extract the invocation result._@param dataSource the DataSource to extract meta-data for_@param metaDataMethodName the name of the DatabaseMetaData method to call_@return the object returned by the specified DatabaseMetaData method_@throws MetaDataAccessException if we couldn't access the DatabaseMetaData_or failed to invoke the specified method_@see java.sql.DatabaseMetaData;@SuppressWarnings("unchecked")_	public static <T> T extractDatabaseMetaData(DataSource dataSource, final String metaDataMethodName)_			throws MetaDataAccessException {__		return (T) extractDatabaseMetaData(dataSource,_				dbmd -> {_					try {_						return DatabaseMetaData.class.getMethod(metaDataMethodName).invoke(dbmd)__					}_					catch (NoSuchMethodException ex) {_						throw new MetaDataAccessException("No method named '" + metaDataMethodName +_								"' found on DatabaseMetaData instance [" + dbmd + "]", ex)__					}_					catch (IllegalAccessException ex) {_						throw new MetaDataAccessException(_								"Could not access DatabaseMetaData method '" + metaDataMethodName + "'", ex)__					}_					catch (InvocationTargetException ex) {_						if (ex.getTargetException() instanceof SQLException) {_							throw (SQLException) ex.getTargetException()__						}_						throw new MetaDataAccessException(_								"Invocation of DatabaseMetaData method '" + metaDataMethodName + "' failed", ex)__					}_				})__	};call,the,specified,method,on,database,meta,data,for,the,given,data,source,and,extract,the,invocation,result,param,data,source,the,data,source,to,extract,meta,data,for,param,meta,data,method,name,the,name,of,the,database,meta,data,method,to,call,return,the,object,returned,by,the,specified,database,meta,data,method,throws,meta,data,access,exception,if,we,couldn,t,access,the,database,meta,data,or,failed,to,invoke,the,specified,method,see,java,sql,database,meta,data;suppress,warnings,unchecked,public,static,t,t,extract,database,meta,data,data,source,data,source,final,string,meta,data,method,name,throws,meta,data,access,exception,return,t,extract,database,meta,data,data,source,dbmd,try,return,database,meta,data,class,get,method,meta,data,method,name,invoke,dbmd,catch,no,such,method,exception,ex,throw,new,meta,data,access,exception,no,method,named,meta,data,method,name,found,on,database,meta,data,instance,dbmd,ex,catch,illegal,access,exception,ex,throw,new,meta,data,access,exception,could,not,access,database,meta,data,method,meta,data,method,name,ex,catch,invocation,target,exception,ex,if,ex,get,target,exception,instanceof,sqlexception,throw,sqlexception,ex,get,target,exception,throw,new,meta,data,access,exception,invocation,of,database,meta,data,method,meta,data,method,name,failed,ex
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1328020251;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1356735495;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1357119239;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1368482696;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1385412762;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1397137904;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1398858661;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1401910463;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1410122589;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1410532068;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1414509556;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1432125256;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1467677340;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1479822741;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1481218225;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1487178248;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1,2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1488037840;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1, 2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static String convertUnderscoreNameToPropertyName(String name);1495868221;Convert a column name with underscores to the corresponding property name using "camel case".  A name_like "customer_number" would match a "customerNumber" property name._@param name the column name to be converted_@return the name using "camel case";public static String convertUnderscoreNameToPropertyName(String name) {_		StringBuilder result = new StringBuilder()__		boolean nextIsUpper = false__		if (name != null && name.length() > 0) {_			if (name.length() > 1 && name.substring(1, 2).equals("_")) {_				result.append(name.substring(0, 1).toUpperCase())__			}_			else {_				result.append(name.substring(0, 1).toLowerCase())__			}_			for (int i = 1_ i < name.length()_ i++) {_				String s = name.substring(i, i + 1)__				if (s.equals("_")) {_					nextIsUpper = true__				}_				else {_					if (nextIsUpper) {_						result.append(s.toUpperCase())__						nextIsUpper = false__					}_					else {_						result.append(s.toLowerCase())__					}_				}_			}_		}_		return result.toString()__	};convert,a,column,name,with,underscores,to,the,corresponding,property,name,using,camel,case,a,name,like,would,match,a,customer,number,property,name,param,name,the,column,name,to,be,converted,return,the,name,using,camel,case;public,static,string,convert,underscore,name,to,property,name,string,name,string,builder,result,new,string,builder,boolean,next,is,upper,false,if,name,null,name,length,0,if,name,length,1,name,substring,1,2,equals,result,append,name,substring,0,1,to,upper,case,else,result,append,name,substring,0,1,to,lower,case,for,int,i,1,i,name,length,i,string,s,name,substring,i,i,1,if,s,equals,next,is,upper,true,else,if,next,is,upper,result,append,s,to,upper,case,next,is,upper,false,else,result,append,s,to,lower,case,return,result,to,string
JdbcUtils -> public static boolean isNumeric(int sqlType);1328020251;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1356735495;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1357119239;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1368482696;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1385412762;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1397137904;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1398858661;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1401910463;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1410122589;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1410532068;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1414509556;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1432125256;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1467677340;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1479822741;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1481218225;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1487178248;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1488037840;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1495868221;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1496837955;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1506097334;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1513100167;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1518615840;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1520339775;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return (Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType)__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1521457504;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return (Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType)__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1528313484;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return (Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType)__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1530174524;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return (Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType)__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static boolean isNumeric(int sqlType);1549380778;Check whether the given SQL type is numeric._@param sqlType the SQL type to be checked_@return whether the type is numeric;public static boolean isNumeric(int sqlType) {_		return (Types.BIT == sqlType || Types.BIGINT == sqlType || Types.DECIMAL == sqlType ||_				Types.DOUBLE == sqlType || Types.FLOAT == sqlType || Types.INTEGER == sqlType ||_				Types.NUMERIC == sqlType || Types.REAL == sqlType || Types.SMALLINT == sqlType ||_				Types.TINYINT == sqlType)__	};check,whether,the,given,sql,type,is,numeric,param,sql,type,the,sql,type,to,be,checked,return,whether,the,type,is,numeric;public,static,boolean,is,numeric,int,sql,type,return,types,bit,sql,type,types,bigint,sql,type,types,decimal,sql,type,types,double,sql,type,types,float,sql,type,types,integer,sql,type,types,numeric,sql,type,types,real,sql,type,types,smallint,sql,type,types,tinyint,sql,type
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1385412762;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value = null__		boolean wasNullCheck = false___		_		if (String.class.equals(requiredType)) {_			value = rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__			wasNullCheck = true__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__			wasNullCheck = true__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__			wasNullCheck = true__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__			wasNullCheck = true__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__			wasNullCheck = true__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__			wasNullCheck = true__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__			wasNullCheck = true__		}_		else if (byte[].class.equals(requiredType)) {_			value = rs.getBytes(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			value = rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			value = rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			value = rs.getTimestamp(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			value = rs.getBigDecimal(index)__		}_		else if (Blob.class.equals(requiredType)) {_			value = rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			value = rs.getClob(index)__		}_		else {_			_			value = getResultSetValue(rs, index)__		}__		_		_		if (wasNullCheck && value != null && rs.wasNull()) {_			value = null__		}_		return value__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,null,boolean,was,null,check,false,if,string,class,equals,required,type,value,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,was,null,check,true,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,was,null,check,true,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,was,null,check,true,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,was,null,check,true,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,was,null,check,true,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,was,null,check,true,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,was,null,check,true,else,if,byte,class,equals,required,type,value,rs,get,bytes,index,else,if,java,sql,date,class,equals,required,type,value,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,value,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,value,rs,get,timestamp,index,else,if,big,decimal,class,equals,required,type,value,rs,get,big,decimal,index,else,if,blob,class,equals,required,type,value,rs,get,blob,index,else,if,clob,class,equals,required,type,value,rs,get,clob,index,else,value,get,result,set,value,rs,index,if,was,null,check,value,null,rs,was,null,value,null,return,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1397137904;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class.equals(requiredType)) {_			return rs.getString(index)__		}_		else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) {_			value = rs.getBoolean(index)__		}_		else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) {_			value = rs.getByte(index)__		}_		else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) {_			value = rs.getShort(index)__		}_		else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) {_			value = rs.getInt(index)__		}_		else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) {_			value = rs.getLong(index)__		}_		else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) {_			value = rs.getFloat(index)__		}_		else if (double.class.equals(requiredType) || Double.class.equals(requiredType) ||_				Number.class.equals(requiredType)) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class.equals(requiredType)) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class.equals(requiredType)) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class.equals(requiredType)) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class.equals(requiredType)) {_			return rs.getBytes(index)__		}_		else if (Blob.class.equals(requiredType)) {_			return rs.getBlob(index)__		}_		else if (Clob.class.equals(requiredType)) {_			return rs.getClob(index)__		}_		else {_			_			if (getObjectWithTypeAvailable) {_				try {_					return rs.getObject(index, requiredType)__				}_				catch (SQLFeatureNotSupportedException ex) {_					logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__				}_				catch (AbstractMethodError err) {_					logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__				}_			}_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,equals,required,type,return,rs,get,string,index,else,if,boolean,class,equals,required,type,boolean,class,equals,required,type,value,rs,get,boolean,index,else,if,byte,class,equals,required,type,byte,class,equals,required,type,value,rs,get,byte,index,else,if,short,class,equals,required,type,short,class,equals,required,type,value,rs,get,short,index,else,if,int,class,equals,required,type,integer,class,equals,required,type,value,rs,get,int,index,else,if,long,class,equals,required,type,long,class,equals,required,type,value,rs,get,long,index,else,if,float,class,equals,required,type,float,class,equals,required,type,value,rs,get,float,index,else,if,double,class,equals,required,type,double,class,equals,required,type,number,class,equals,required,type,value,rs,get,double,index,else,if,big,decimal,class,equals,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,equals,required,type,return,rs,get,date,index,else,if,java,sql,time,class,equals,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,equals,required,type,java,util,date,class,equals,required,type,return,rs,get,timestamp,index,else,if,byte,class,equals,required,type,return,rs,get,bytes,index,else,if,blob,class,equals,required,type,return,rs,get,blob,index,else,if,clob,class,equals,required,type,return,rs,get,clob,index,else,if,get,object,with,type,available,try,return,rs,get,object,index,required,type,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1467677340;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object_@throws SQLException if thrown by the JDBC API;public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1479822741;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1481218225;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1487178248;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException;1488037840;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);public static Object getResultSetValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;public,static,object,get,result,set,value,result,set,rs,int,index,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1496837955;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;@Nullable_	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1506097334;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;@Nullable_	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1513100167;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;@Nullable_	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1518615840;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;@Nullable_	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1520339775;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;@Nullable_	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1521457504;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;@Nullable_	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1528313484;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;@Nullable_	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1530174524;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;@Nullable_	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> @Nullable 	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException;1549380778;Retrieve a JDBC column value from a ResultSet, using the most appropriate_value type. The returned value should be a detached value object, not having_any ties to the active ResultSet: in particular, it should not be a Blob or_Clob object but rather a byte array or String representation, respectively._<p>Uses the {@code getObject(index)} method, but includes additional "hacks"_to get around Oracle 10g returning a non-standard object for its TIMESTAMP_datatype and a {@code java.sql.Date} for DATE columns leaving out the_time portion: These columns will explicitly be extracted as standard_{@code java.sql.Timestamp} object._@param rs is the ResultSet holding the data_@param index is the column index_@return the value object_@throws SQLException if thrown by the JDBC API_@see java.sql.Blob_@see java.sql.Clob_@see java.sql.Timestamp;@Nullable_	public static Object getResultSetValue(ResultSet rs, int index) throws SQLException {_		Object obj = rs.getObject(index)__		String className = null__		if (obj != null) {_			className = obj.getClass().getName()__		}_		if (obj instanceof Blob) {_			Blob blob = (Blob) obj__			obj = blob.getBytes(1, (int) blob.length())__		}_		else if (obj instanceof Clob) {_			Clob clob = (Clob) obj__			obj = clob.getSubString(1, (int) clob.length())__		}_		else if ("oracle.sql.TIMESTAMP".equals(className) || "oracle.sql.TIMESTAMPTZ".equals(className)) {_			obj = rs.getTimestamp(index)__		}_		else if (className != null && className.startsWith("oracle.sql.DATE")) {_			String metaDataClassName = rs.getMetaData().getColumnClassName(index)__			if ("java.sql.Timestamp".equals(metaDataClassName) || "oracle.sql.TIMESTAMP".equals(metaDataClassName)) {_				obj = rs.getTimestamp(index)__			}_			else {_				obj = rs.getDate(index)__			}_		}_		else if (obj instanceof java.sql.Date) {_			if ("java.sql.Timestamp".equals(rs.getMetaData().getColumnClassName(index))) {_				obj = rs.getTimestamp(index)__			}_		}_		return obj__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,most,appropriate,value,type,the,returned,value,should,be,a,detached,value,object,not,having,any,ties,to,the,active,result,set,in,particular,it,should,not,be,a,blob,or,clob,object,but,rather,a,byte,array,or,string,representation,respectively,p,uses,the,code,get,object,index,method,but,includes,additional,hacks,to,get,around,oracle,10g,returning,a,non,standard,object,for,its,timestamp,datatype,and,a,code,java,sql,date,for,date,columns,leaving,out,the,time,portion,these,columns,will,explicitly,be,extracted,as,standard,code,java,sql,timestamp,object,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,return,the,value,object,throws,sqlexception,if,thrown,by,the,jdbc,api,see,java,sql,blob,see,java,sql,clob,see,java,sql,timestamp;nullable,public,static,object,get,result,set,value,result,set,rs,int,index,throws,sqlexception,object,obj,rs,get,object,index,string,class,name,null,if,obj,null,class,name,obj,get,class,get,name,if,obj,instanceof,blob,blob,blob,blob,obj,obj,blob,get,bytes,1,int,blob,length,else,if,obj,instanceof,clob,clob,clob,clob,obj,obj,clob,get,sub,string,1,int,clob,length,else,if,oracle,sql,timestamp,equals,class,name,oracle,sql,timestamptz,equals,class,name,obj,rs,get,timestamp,index,else,if,class,name,null,class,name,starts,with,oracle,sql,date,string,meta,data,class,name,rs,get,meta,data,get,column,class,name,index,if,java,sql,timestamp,equals,meta,data,class,name,oracle,sql,timestamp,equals,meta,data,class,name,obj,rs,get,timestamp,index,else,obj,rs,get,date,index,else,if,obj,instanceof,java,sql,date,if,java,sql,timestamp,equals,rs,get,meta,data,get,column,class,name,index,obj,rs,get,timestamp,index,return,obj
JdbcUtils -> public static void closeStatement(Statement stmt);1328020251;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be <code>null</code>);public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null,code;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1356735495;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1357119239;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1368482696;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1385412762;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1397137904;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1398858661;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1401910463;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1410122589;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1410532068;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1414509556;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1432125256;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1467677340;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1479822741;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1481218225;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1487178248;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static void closeStatement(Statement stmt);1488037840;Close the given JDBC Statement and ignore any thrown exception._This is useful for typical finally blocks in manual JDBC code._@param stmt the JDBC Statement to close (may be {@code null});public static void closeStatement(Statement stmt) {_		if (stmt != null) {_			try {_				stmt.close()__			}_			catch (SQLException ex) {_				logger.trace("Could not close JDBC Statement", ex)__			}_			catch (Throwable ex) {_				_				logger.trace("Unexpected exception on closing JDBC Statement", ex)__			}_		}_	};close,the,given,jdbc,statement,and,ignore,any,thrown,exception,this,is,useful,for,typical,finally,blocks,in,manual,jdbc,code,param,stmt,the,jdbc,statement,to,close,may,be,code,null;public,static,void,close,statement,statement,stmt,if,stmt,null,try,stmt,close,catch,sqlexception,ex,logger,trace,could,not,close,jdbc,statement,ex,catch,throwable,ex,logger,trace,unexpected,exception,on,closing,jdbc,statement,ex
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1495868221;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
JdbcUtils -> public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException;1496837955;Retrieve a JDBC column value from a ResultSet, using the specified value type._<p>Uses the specifically typed ResultSet accessor methods, falling back to_{@link #getResultSetValue(java.sql.ResultSet, int)} for unknown types._<p>Note that the returned value may not be assignable to the specified_required type, in case of an unknown type. Calling code needs to deal_with this case appropriately, e.g. throwing a corresponding exception._@param rs is the ResultSet holding the data_@param index is the column index_@param requiredType the required value type (may be {@code null})_@return the value object (possibly not of the specified required type,_with further conversion steps necessary)_@throws SQLException if thrown by the JDBC API_@see #getResultSetValue(ResultSet, int);public static Object getResultSetValue(ResultSet rs, int index, @Nullable Class<?> requiredType) throws SQLException {_		if (requiredType == null) {_			return getResultSetValue(rs, index)__		}__		Object value___		_		if (String.class == requiredType) {_			return rs.getString(index)__		}_		else if (boolean.class == requiredType || Boolean.class == requiredType) {_			value = rs.getBoolean(index)__		}_		else if (byte.class == requiredType || Byte.class == requiredType) {_			value = rs.getByte(index)__		}_		else if (short.class == requiredType || Short.class == requiredType) {_			value = rs.getShort(index)__		}_		else if (int.class == requiredType || Integer.class == requiredType) {_			value = rs.getInt(index)__		}_		else if (long.class == requiredType || Long.class == requiredType) {_			value = rs.getLong(index)__		}_		else if (float.class == requiredType || Float.class == requiredType) {_			value = rs.getFloat(index)__		}_		else if (double.class == requiredType || Double.class == requiredType ||_				Number.class == requiredType) {_			value = rs.getDouble(index)__		}_		else if (BigDecimal.class == requiredType) {_			return rs.getBigDecimal(index)__		}_		else if (java.sql.Date.class == requiredType) {_			return rs.getDate(index)__		}_		else if (java.sql.Time.class == requiredType) {_			return rs.getTime(index)__		}_		else if (java.sql.Timestamp.class == requiredType || java.util.Date.class == requiredType) {_			return rs.getTimestamp(index)__		}_		else if (byte[].class == requiredType) {_			return rs.getBytes(index)__		}_		else if (Blob.class == requiredType) {_			return rs.getBlob(index)__		}_		else if (Clob.class == requiredType) {_			return rs.getClob(index)__		}_		else if (requiredType.isEnum()) {_			_			_			_			Object obj = rs.getObject(index)__			if (obj instanceof String) {_				return obj__			}_			else if (obj instanceof Number) {_				_				_				return NumberUtils.convertNumberToTargetClass((Number) obj, Integer.class)__			}_			else {_				_				return rs.getString(index)__			}_		}__		else {_			_			try {_				return rs.getObject(index, requiredType)__			}_			catch (AbstractMethodError err) {_				logger.debug("JDBC driver does not implement JDBC 4.1 'getObject(int, Class)' method", err)__			}_			catch (SQLFeatureNotSupportedException ex) {_				logger.debug("JDBC driver does not support JDBC 4.1 'getObject(int, Class)' method", ex)__			}_			catch (SQLException ex) {_				logger.debug("JDBC driver has limited support for JDBC 4.1 'getObject(int, Class)' method", ex)__			}__			_			_			String typeName = requiredType.getSimpleName()__			if ("LocalDate".equals(typeName)) {_				return rs.getDate(index)__			}_			else if ("LocalTime".equals(typeName)) {_				return rs.getTime(index)__			}_			else if ("LocalDateTime".equals(typeName)) {_				return rs.getTimestamp(index)__			}__			_			_			return getResultSetValue(rs, index)__		}__		_		return (rs.wasNull() ? null : value)__	};retrieve,a,jdbc,column,value,from,a,result,set,using,the,specified,value,type,p,uses,the,specifically,typed,result,set,accessor,methods,falling,back,to,link,get,result,set,value,java,sql,result,set,int,for,unknown,types,p,note,that,the,returned,value,may,not,be,assignable,to,the,specified,required,type,in,case,of,an,unknown,type,calling,code,needs,to,deal,with,this,case,appropriately,e,g,throwing,a,corresponding,exception,param,rs,is,the,result,set,holding,the,data,param,index,is,the,column,index,param,required,type,the,required,value,type,may,be,code,null,return,the,value,object,possibly,not,of,the,specified,required,type,with,further,conversion,steps,necessary,throws,sqlexception,if,thrown,by,the,jdbc,api,see,get,result,set,value,result,set,int;public,static,object,get,result,set,value,result,set,rs,int,index,nullable,class,required,type,throws,sqlexception,if,required,type,null,return,get,result,set,value,rs,index,object,value,if,string,class,required,type,return,rs,get,string,index,else,if,boolean,class,required,type,boolean,class,required,type,value,rs,get,boolean,index,else,if,byte,class,required,type,byte,class,required,type,value,rs,get,byte,index,else,if,short,class,required,type,short,class,required,type,value,rs,get,short,index,else,if,int,class,required,type,integer,class,required,type,value,rs,get,int,index,else,if,long,class,required,type,long,class,required,type,value,rs,get,long,index,else,if,float,class,required,type,float,class,required,type,value,rs,get,float,index,else,if,double,class,required,type,double,class,required,type,number,class,required,type,value,rs,get,double,index,else,if,big,decimal,class,required,type,return,rs,get,big,decimal,index,else,if,java,sql,date,class,required,type,return,rs,get,date,index,else,if,java,sql,time,class,required,type,return,rs,get,time,index,else,if,java,sql,timestamp,class,required,type,java,util,date,class,required,type,return,rs,get,timestamp,index,else,if,byte,class,required,type,return,rs,get,bytes,index,else,if,blob,class,required,type,return,rs,get,blob,index,else,if,clob,class,required,type,return,rs,get,clob,index,else,if,required,type,is,enum,object,obj,rs,get,object,index,if,obj,instanceof,string,return,obj,else,if,obj,instanceof,number,return,number,utils,convert,number,to,target,class,number,obj,integer,class,else,return,rs,get,string,index,else,try,return,rs,get,object,index,required,type,catch,abstract,method,error,err,logger,debug,jdbc,driver,does,not,implement,jdbc,4,1,get,object,int,class,method,err,catch,sqlfeature,not,supported,exception,ex,logger,debug,jdbc,driver,does,not,support,jdbc,4,1,get,object,int,class,method,ex,catch,sqlexception,ex,logger,debug,jdbc,driver,has,limited,support,for,jdbc,4,1,get,object,int,class,method,ex,string,type,name,required,type,get,simple,name,if,local,date,equals,type,name,return,rs,get,date,index,else,if,local,time,equals,type,name,return,rs,get,time,index,else,if,local,date,time,equals,type,name,return,rs,get,timestamp,index,return,get,result,set,value,rs,index,return,rs,was,null,null,value
