commented;modifiers;parameterAmount;loc;comment;code
true;public;1;11;/**  * Set the class that each row should be mapped to.  */ ;/**  * Set the class that each row should be mapped to.  */ public void setMappedClass(Class<T> mappedClass) {     if (this.mappedClass == null) {         initialize(mappedClass).     } else {         if (this.mappedClass != mappedClass) {             throw new InvalidDataAccessApiUsageException("The mapped class can not be reassigned to map to " + mappedClass + " since it is already providing mapping for " + this.mappedClass).         }     } }
true;public,final;0;4;/**  * Get the class that we are mapping to.  */ ;/**  * Get the class that we are mapping to.  */ @Nullable public final Class<T> getMappedClass() {     return this.mappedClass. }
true;public;1;3;/**  * Set whether we're strictly validating that all bean properties have been mapped  * from corresponding database fields.  * <p>Default is {@code false}, accepting unpopulated properties in the target bean.  */ ;/**  * Set whether we're strictly validating that all bean properties have been mapped  * from corresponding database fields.  * <p>Default is {@code false}, accepting unpopulated properties in the target bean.  */ public void setCheckFullyPopulated(boolean checkFullyPopulated) {     this.checkFullyPopulated = checkFullyPopulated. }
true;public;0;3;/**  * Return whether we're strictly validating that all bean properties have been  * mapped from corresponding database fields.  */ ;/**  * Return whether we're strictly validating that all bean properties have been  * mapped from corresponding database fields.  */ public boolean isCheckFullyPopulated() {     return this.checkFullyPopulated. }
true;public;1;3;/**  * Set whether we're defaulting Java primitives in the case of mapping a null value  * from corresponding database fields.  * <p>Default is {@code false}, throwing an exception when nulls are mapped to Java primitives.  */ ;/**  * Set whether we're defaulting Java primitives in the case of mapping a null value  * from corresponding database fields.  * <p>Default is {@code false}, throwing an exception when nulls are mapped to Java primitives.  */ public void setPrimitivesDefaultedForNullValue(boolean primitivesDefaultedForNullValue) {     this.primitivesDefaultedForNullValue = primitivesDefaultedForNullValue. }
true;public;0;3;/**  * Return whether we're defaulting Java primitives in the case of mapping a null value  * from corresponding database fields.  */ ;/**  * Return whether we're defaulting Java primitives in the case of mapping a null value  * from corresponding database fields.  */ public boolean isPrimitivesDefaultedForNullValue() {     return this.primitivesDefaultedForNullValue. }
true;public;1;3;/**  * Set a {@link ConversionService} for binding JDBC values to bean properties,  * or {@code null} for none.  * <p>Default is a {@link DefaultConversionService}, as of Spring 4.3. This  * provides support for {@code java.time} conversion and other special types.  * @since 4.3  * @see #initBeanWrapper(BeanWrapper)  */ ;/**  * Set a {@link ConversionService} for binding JDBC values to bean properties,  * or {@code null} for none.  * <p>Default is a {@link DefaultConversionService}, as of Spring 4.3. This  * provides support for {@code java.time} conversion and other special types.  * @since 4.3  * @see #initBeanWrapper(BeanWrapper)  */ public void setConversionService(@Nullable ConversionService conversionService) {     this.conversionService = conversionService. }
true;public;0;4;/**  * Return a {@link ConversionService} for binding JDBC values to bean properties,  * or {@code null} if none.  * @since 4.3  */ ;/**  * Return a {@link ConversionService} for binding JDBC values to bean properties,  * or {@code null} if none.  * @since 4.3  */ @Nullable public ConversionService getConversionService() {     return this.conversionService. }
true;protected;1;16;/**  * Initialize the mapping meta-data for the given class.  * @param mappedClass the mapped class  */ ;/**  * Initialize the mapping meta-data for the given class.  * @param mappedClass the mapped class  */ protected void initialize(Class<T> mappedClass) {     this.mappedClass = mappedClass.     this.mappedFields = new HashMap<>().     this.mappedProperties = new HashSet<>().     PropertyDescriptor[] pds = BeanUtils.getPropertyDescriptors(mappedClass).     for (PropertyDescriptor pd : pds) {         if (pd.getWriteMethod() != null) {             this.mappedFields.put(lowerCaseName(pd.getName()), pd).             String underscoredName = underscoreName(pd.getName()).             if (!lowerCaseName(pd.getName()).equals(underscoredName)) {                 this.mappedFields.put(underscoredName, pd).             }             this.mappedProperties.add(pd.getName()).         }     } }
true;protected;1;18;/**  * Convert a name in camelCase to an underscored name in lower case.  * Any upper case letters are converted to lower case with a preceding underscore.  * @param name the original name  * @return the converted name  * @since 4.2  * @see #lowerCaseName  */ ;/**  * Convert a name in camelCase to an underscored name in lower case.  * Any upper case letters are converted to lower case with a preceding underscore.  * @param name the original name  * @return the converted name  * @since 4.2  * @see #lowerCaseName  */ protected String underscoreName(String name) {     if (!StringUtils.hasLength(name)) {         return "".     }     StringBuilder result = new StringBuilder().     result.append(lowerCaseName(name.substring(0, 1))).     for (int i = 1. i < name.length(). i++) {         String s = name.substring(i, i + 1).         String slc = lowerCaseName(s).         if (!s.equals(slc)) {             result.append("_").append(slc).         } else {             result.append(s).         }     }     return result.toString(). }
true;protected;1;3;/**  * Convert the given name to lower case.  * By default, conversions will happen within the US locale.  * @param name the original name  * @return the converted name  * @since 4.2  */ ;/**  * Convert the given name to lower case.  * By default, conversions will happen within the US locale.  * @param name the original name  * @return the converted name  * @since 4.2  */ protected String lowerCaseName(String name) {     return name.toLowerCase(Locale.US). }
true;public;2;64;/**  * Extract the values for all columns in the current row.  * <p>Utilizes public setters and result set meta-data.  * @see java.sql.ResultSetMetaData  */ ;/**  * Extract the values for all columns in the current row.  * <p>Utilizes public setters and result set meta-data.  * @see java.sql.ResultSetMetaData  */ @Override public T mapRow(ResultSet rs, int rowNumber) throws SQLException {     Assert.state(this.mappedClass != null, "Mapped class was not specified").     T mappedObject = BeanUtils.instantiateClass(this.mappedClass).     BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(mappedObject).     initBeanWrapper(bw).     ResultSetMetaData rsmd = rs.getMetaData().     int columnCount = rsmd.getColumnCount().     Set<String> populatedProperties = (isCheckFullyPopulated() ? new HashSet<>() : null).     for (int index = 1. index <= columnCount. index++) {         String column = JdbcUtils.lookupColumnName(rsmd, index).         String field = lowerCaseName(StringUtils.delete(column, " ")).         PropertyDescriptor pd = (this.mappedFields != null ? this.mappedFields.get(field) : null).         if (pd != null) {             try {                 Object value = getColumnValue(rs, index, pd).                 if (rowNumber == 0 && logger.isDebugEnabled()) {                     logger.debug("Mapping column '" + column + "' to property '" + pd.getName() + "' of type '" + ClassUtils.getQualifiedName(pd.getPropertyType()) + "'").                 }                 try {                     bw.setPropertyValue(pd.getName(), value).                 } catch (TypeMismatchException ex) {                     if (value == null && this.primitivesDefaultedForNullValue) {                         if (logger.isDebugEnabled()) {                             logger.debug("Intercepted TypeMismatchException for row " + rowNumber + " and column '" + column + "' with null value when setting property '" + pd.getName() + "' of type '" + ClassUtils.getQualifiedName(pd.getPropertyType()) + "' on object: " + mappedObject, ex).                         }                     } else {                         throw ex.                     }                 }                 if (populatedProperties != null) {                     populatedProperties.add(pd.getName()).                 }             } catch (NotWritablePropertyException ex) {                 throw new DataRetrievalFailureException("Unable to map column '" + column + "' to property '" + pd.getName() + "'", ex).             }         } else {             // No PropertyDescriptor found             if (rowNumber == 0 && logger.isDebugEnabled()) {                 logger.debug("No property found for column '" + column + "' mapped to field '" + field + "'").             }         }     }     if (populatedProperties != null && !populatedProperties.equals(this.mappedProperties)) {         throw new InvalidDataAccessApiUsageException("Given ResultSet does not contain all fields " + "necessary to populate object of class [" + this.mappedClass.getName() + "]: " + this.mappedProperties).     }     return mappedObject. }
true;protected;1;6;/**  * Initialize the given BeanWrapper to be used for row mapping.  * To be called for each row.  * <p>The default implementation applies the configured {@link ConversionService},  * if any. Can be overridden in subclasses.  * @param bw the BeanWrapper to initialize  * @see #getConversionService()  * @see BeanWrapper#setConversionService  */ ;/**  * Initialize the given BeanWrapper to be used for row mapping.  * To be called for each row.  * <p>The default implementation applies the configured {@link ConversionService},  * if any. Can be overridden in subclasses.  * @param bw the BeanWrapper to initialize  * @see #getConversionService()  * @see BeanWrapper#setConversionService  */ protected void initBeanWrapper(BeanWrapper bw) {     ConversionService cs = getConversionService().     if (cs != null) {         bw.setConversionService(cs).     } }
true;protected;3;4;/**  * Retrieve a JDBC object value for the specified column.  * <p>The default implementation calls  * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.  * Subclasses may override this to check specific value types upfront,  * or to post-process values return from {@code getResultSetValue}.  * @param rs is the ResultSet holding the data  * @param index is the column index  * @param pd the bean property that each result object is expected to match  * @return the Object value  * @throws SQLException in case of extraction failure  * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)  */ ;/**  * Retrieve a JDBC object value for the specified column.  * <p>The default implementation calls  * {@link JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)}.  * Subclasses may override this to check specific value types upfront,  * or to post-process values return from {@code getResultSetValue}.  * @param rs is the ResultSet holding the data  * @param index is the column index  * @param pd the bean property that each result object is expected to match  * @return the Object value  * @throws SQLException in case of extraction failure  * @see org.springframework.jdbc.support.JdbcUtils#getResultSetValue(java.sql.ResultSet, int, Class)  */ @Nullable protected Object getColumnValue(ResultSet rs, int index, PropertyDescriptor pd) throws SQLException {     return JdbcUtils.getResultSetValue(rs, index, pd.getPropertyType()). }
true;public,static;1;3;/**  * Static factory method to create a new {@code BeanPropertyRowMapper}  * (with the mapped class specified only once).  * @param mappedClass the class that each row should be mapped to  */ ;/**  * Static factory method to create a new {@code BeanPropertyRowMapper}  * (with the mapped class specified only once).  * @param mappedClass the class that each row should be mapped to  */ public static <T> BeanPropertyRowMapper<T> newInstance(Class<T> mappedClass) {     return new BeanPropertyRowMapper<>(mappedClass). }
