commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return the SQL call string.  * @since 5.1.3  */ ;/**  * Return the SQL call string.  * @since 5.1.3  */ public final String getCallString() {     return this.callString. }
true;public;1;3;/**  * Add a new declared parameter.  * <p>Order of parameter addition is significant.  * @param param the parameter to add to the list of declared parameters  */ ;/**  * Add a new declared parameter.  * <p>Order of parameter addition is significant.  * @param param the parameter to add to the list of declared parameters  */ public void addParameter(SqlParameter param) {     this.declaredParameters.add(param). }
true;public;1;3;/**  * Set whether to use prepared statements that return a specific type of ResultSet.  * specific type of ResultSet.  * @param resultSetType the ResultSet type  * @see java.sql.ResultSet#TYPE_FORWARD_ONLY  * @see java.sql.ResultSet#TYPE_SCROLL_INSENSITIVE  * @see java.sql.ResultSet#TYPE_SCROLL_SENSITIVE  */ ;/**  * Set whether to use prepared statements that return a specific type of ResultSet.  * specific type of ResultSet.  * @param resultSetType the ResultSet type  * @see java.sql.ResultSet#TYPE_FORWARD_ONLY  * @see java.sql.ResultSet#TYPE_SCROLL_INSENSITIVE  * @see java.sql.ResultSet#TYPE_SCROLL_SENSITIVE  */ public void setResultSetType(int resultSetType) {     this.resultSetType = resultSetType. }
true;public;1;3;/**  * Set whether to use prepared statements capable of returning updatable ResultSets.  */ ;/**  * Set whether to use prepared statements capable of returning updatable ResultSets.  */ public void setUpdatableResults(boolean updatableResults) {     this.updatableResults = updatableResults. }
true;public;1;3;/**  * Return a new CallableStatementCreator instance given this parameters.  * @param params list of parameters (may be {@code null})  */ ;/**  * Return a new CallableStatementCreator instance given this parameters.  * @param params list of parameters (may be {@code null})  */ public CallableStatementCreator newCallableStatementCreator(@Nullable Map<String, ?> params) {     return new CallableStatementCreatorImpl(params != null ? params : new HashMap<>()). }
true;public;1;3;/**  * Return a new CallableStatementCreator instance given this parameter mapper.  * @param inParamMapper the ParameterMapper implementation that will return a Map of parameters  */ ;/**  * Return a new CallableStatementCreator instance given this parameter mapper.  * @param inParamMapper the ParameterMapper implementation that will return a Map of parameters  */ public CallableStatementCreator newCallableStatementCreator(ParameterMapper inParamMapper) {     return new CallableStatementCreatorImpl(inParamMapper). }
false;public;1;62;;@Override public CallableStatement createCallableStatement(Connection con) throws SQLException {     // If we were given a ParameterMapper, we must let the mapper do its thing to create the Map.     if (this.inParameterMapper != null) {         this.inParameters = this.inParameterMapper.createMap(con).     } else {         if (this.inParameters == null) {             throw new InvalidDataAccessApiUsageException("A ParameterMapper or a Map of parameters must be provided").         }     }     CallableStatement cs = null.     if (resultSetType == ResultSet.TYPE_FORWARD_ONLY && !updatableResults) {         cs = con.prepareCall(callString).     } else {         cs = con.prepareCall(callString, resultSetType, updatableResults ? ResultSet.CONCUR_UPDATABLE : ResultSet.CONCUR_READ_ONLY).     }     int sqlColIndx = 1.     for (SqlParameter declaredParam : declaredParameters) {         if (!declaredParam.isResultsParameter()) {             // So, it's a call parameter - part of the call string.             // Get the value - it may still be null.             Object inValue = this.inParameters.get(declaredParam.getName()).             if (declaredParam instanceof ResultSetSupportingSqlParameter) {                 // It need not (but may be) supplied by the caller.                 if (declaredParam instanceof SqlOutParameter) {                     if (declaredParam.getTypeName() != null) {                         cs.registerOutParameter(sqlColIndx, declaredParam.getSqlType(), declaredParam.getTypeName()).                     } else {                         if (declaredParam.getScale() != null) {                             cs.registerOutParameter(sqlColIndx, declaredParam.getSqlType(), declaredParam.getScale()).                         } else {                             cs.registerOutParameter(sqlColIndx, declaredParam.getSqlType()).                         }                     }                     if (declaredParam.isInputValueProvided()) {                         StatementCreatorUtils.setParameterValue(cs, sqlColIndx, declaredParam, inValue).                     }                 }             } else {                 // It's an input parameter. must be supplied by the caller.                 if (!this.inParameters.containsKey(declaredParam.getName())) {                     throw new InvalidDataAccessApiUsageException("Required input parameter '" + declaredParam.getName() + "' is missing").                 }                 StatementCreatorUtils.setParameterValue(cs, sqlColIndx, declaredParam, inValue).             }             sqlColIndx++.         }     }     return cs. }
false;public;0;4;;@Override public String getSql() {     return callString. }
false;public;0;6;;@Override public void cleanupParameters() {     if (this.inParameters != null) {         StatementCreatorUtils.cleanupParameters(this.inParameters.values()).     } }
false;public;0;4;;@Override public String toString() {     return "CallableStatementCreator: sql=[" + callString + "]. parameters=" + this.inParameters. }
