commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the {@code generateUniqueDatabaseName} flag to enable or disable  * generation of a pseudo-random unique ID to be used as the database name.  * <p>Setting this flag to {@code true} overrides any explicit name set  * via {@link #setDatabaseName}.  * @since 4.2  * @see #setDatabaseName  */ ;/**  * Set the {@code generateUniqueDatabaseName} flag to enable or disable  * generation of a pseudo-random unique ID to be used as the database name.  * <p>Setting this flag to {@code true} overrides any explicit name set  * via {@link #setDatabaseName}.  * @since 4.2  * @see #setDatabaseName  */ public void setGenerateUniqueDatabaseName(boolean generateUniqueDatabaseName) {     this.generateUniqueDatabaseName = generateUniqueDatabaseName. }
true;public;1;4;/**  * Set the name of the database.  * <p>Defaults to {@value #DEFAULT_DATABASE_NAME}.  * <p>Will be overridden if the {@code generateUniqueDatabaseName} flag  * has been set to {@code true}.  * @param databaseName name of the embedded database  * @see #setGenerateUniqueDatabaseName  */ ;/**  * Set the name of the database.  * <p>Defaults to {@value #DEFAULT_DATABASE_NAME}.  * <p>Will be overridden if the {@code generateUniqueDatabaseName} flag  * has been set to {@code true}.  * @param databaseName name of the embedded database  * @see #setGenerateUniqueDatabaseName  */ public void setDatabaseName(String databaseName) {     Assert.hasText(databaseName, "Database name is required").     this.databaseName = databaseName. }
true;public;1;4;/**  * Set the factory to use to create the {@link DataSource} instance that  * connects to the embedded database.  * <p>Defaults to {@link SimpleDriverDataSourceFactory}.  */ ;/**  * Set the factory to use to create the {@link DataSource} instance that  * connects to the embedded database.  * <p>Defaults to {@link SimpleDriverDataSourceFactory}.  */ public void setDataSourceFactory(DataSourceFactory dataSourceFactory) {     Assert.notNull(dataSourceFactory, "DataSourceFactory is required").     this.dataSourceFactory = dataSourceFactory. }
true;public;1;3;/**  * Set the type of embedded database to use.  * <p>Call this when you wish to configure one of the pre-supported types.  * <p>Defaults to HSQL.  * @param type the database type  */ ;/**  * Set the type of embedded database to use.  * <p>Call this when you wish to configure one of the pre-supported types.  * <p>Defaults to HSQL.  * @param type the database type  */ public void setDatabaseType(EmbeddedDatabaseType type) {     this.databaseConfigurer = EmbeddedDatabaseConfigurerFactory.getConfigurer(type). }
true;public;1;3;/**  * Set the strategy that will be used to configure the embedded database instance.  * <p>Call this when you wish to use an embedded database type not already supported.  */ ;/**  * Set the strategy that will be used to configure the embedded database instance.  * <p>Call this when you wish to use an embedded database type not already supported.  */ public void setDatabaseConfigurer(EmbeddedDatabaseConfigurer configurer) {     this.databaseConfigurer = configurer. }
true;public;1;3;/**  * Set the strategy that will be used to initialize or populate the embedded  * database.  * <p>Defaults to {@code null}.  */ ;/**  * Set the strategy that will be used to initialize or populate the embedded  * database.  * <p>Defaults to {@code null}.  */ public void setDatabasePopulator(DatabasePopulator populator) {     this.databasePopulator = populator. }
true;public;0;6;/**  * Factory method that returns the {@linkplain EmbeddedDatabase embedded database}  * instance, which is also a {@link DataSource}.  */ ;/**  * Factory method that returns the {@linkplain EmbeddedDatabase embedded database}  * instance, which is also a {@link DataSource}.  */ public EmbeddedDatabase getDatabase() {     if (this.dataSource == null) {         initDatabase().     }     return new EmbeddedDataSourceProxy(this.dataSource). }
true;protected;0;36;/**  * Hook to initialize the embedded database.  * <p>If the {@code generateUniqueDatabaseName} flag has been set to {@code true},  * the current value of the {@linkplain #setDatabaseName database name} will  * be overridden with an auto-generated name.  * <p>Subclasses may call this method to force initialization. however,  * this method should only be invoked once.  * <p>After calling this method, {@link #getDataSource()} returns the  * {@link DataSource} providing connectivity to the database.  */ ;/**  * Hook to initialize the embedded database.  * <p>If the {@code generateUniqueDatabaseName} flag has been set to {@code true},  * the current value of the {@linkplain #setDatabaseName database name} will  * be overridden with an auto-generated name.  * <p>Subclasses may call this method to force initialization. however,  * this method should only be invoked once.  * <p>After calling this method, {@link #getDataSource()} returns the  * {@link DataSource} providing connectivity to the database.  */ protected void initDatabase() {     if (this.generateUniqueDatabaseName) {         setDatabaseName(UUID.randomUUID().toString()).     }     // Create the embedded database first     if (this.databaseConfigurer == null) {         this.databaseConfigurer = EmbeddedDatabaseConfigurerFactory.getConfigurer(EmbeddedDatabaseType.HSQL).     }     this.databaseConfigurer.configureConnectionProperties(this.dataSourceFactory.getConnectionProperties(), this.databaseName).     this.dataSource = this.dataSourceFactory.getDataSource().     if (logger.isInfoEnabled()) {         if (this.dataSource instanceof SimpleDriverDataSource) {             SimpleDriverDataSource simpleDriverDataSource = (SimpleDriverDataSource) this.dataSource.             logger.info(String.format("Starting embedded database: url='%s', username='%s'", simpleDriverDataSource.getUrl(), simpleDriverDataSource.getUsername())).         } else {             logger.info(String.format("Starting embedded database '%s'", this.databaseName)).         }     }     // Now populate the database     if (this.databasePopulator != null) {         try {             DatabasePopulatorUtils.execute(this.databasePopulator, this.dataSource).         } catch (RuntimeException ex) {             // failed to populate, so leave it as not initialized             shutdownDatabase().             throw ex.         }     } }
true;protected;0;17;/**  * Hook to shutdown the embedded database. Subclasses may call this method  * to force shutdown.  * <p>After calling, {@link #getDataSource()} returns {@code null}.  * <p>Does nothing if no embedded database has been initialized.  */ ;/**  * Hook to shutdown the embedded database. Subclasses may call this method  * to force shutdown.  * <p>After calling, {@link #getDataSource()} returns {@code null}.  * <p>Does nothing if no embedded database has been initialized.  */ protected void shutdownDatabase() {     if (this.dataSource != null) {         if (logger.isInfoEnabled()) {             if (this.dataSource instanceof SimpleDriverDataSource) {                 logger.info(String.format("Shutting down embedded database: url='%s'", ((SimpleDriverDataSource) this.dataSource).getUrl())).             } else {                 logger.info(String.format("Shutting down embedded database '%s'", this.databaseName)).             }         }         if (this.databaseConfigurer != null) {             this.databaseConfigurer.shutdown(this.dataSource, this.databaseName).         }         this.dataSource = null.     } }
true;protected,final;0;4;/**  * Hook that gets the {@link DataSource} that provides the connectivity to the  * embedded database.  * <p>Returns {@code null} if the {@code DataSource} has not been initialized  * or if the database has been shut down. Subclasses may call this method to  * access the {@code DataSource} instance directly.  */ ;/**  * Hook that gets the {@link DataSource} that provides the connectivity to the  * embedded database.  * <p>Returns {@code null} if the {@code DataSource} has not been initialized  * or if the database has been shut down. Subclasses may call this method to  * access the {@code DataSource} instance directly.  */ @Nullable protected final DataSource getDataSource() {     return this.dataSource. }
false;public;0;4;;@Override public Connection getConnection() throws SQLException {     return this.dataSource.getConnection(). }
false;public;2;4;;@Override public Connection getConnection(String username, String password) throws SQLException {     return this.dataSource.getConnection(username, password). }
false;public;0;4;;@Override public PrintWriter getLogWriter() throws SQLException {     return this.dataSource.getLogWriter(). }
false;public;1;4;;@Override public void setLogWriter(PrintWriter out) throws SQLException {     this.dataSource.setLogWriter(out). }
false;public;0;4;;@Override public int getLoginTimeout() throws SQLException {     return this.dataSource.getLoginTimeout(). }
false;public;1;4;;@Override public void setLoginTimeout(int seconds) throws SQLException {     this.dataSource.setLoginTimeout(seconds). }
false;public;1;4;;@Override public <T> T unwrap(Class<T> iface) throws SQLException {     return this.dataSource.unwrap(iface). }
false;public;1;4;;@Override public boolean isWrapperFor(Class<?> iface) throws SQLException {     return this.dataSource.isWrapperFor(iface). }
true;public;0;4;// getParentLogger() is required for JDBC 4.1 compatibility ;// getParentLogger() is required for JDBC 4.1 compatibility @Override public Logger getParentLogger() {     return Logger.getLogger(Logger.GLOBAL_LOGGER_NAME). }
false;public;0;4;;@Override public void shutdown() {     shutdownDatabase(). }
