commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify whether to reobtain the target Connection for each operation  * performed within a transaction.  * <p>The default is "false". Specify "true" to reobtain transactional  * Connections for every call on the Connection proxy. this is advisable  * on JBoss if you hold on to a Connection handle across transaction boundaries.  * <p>The effect of this setting is similar to the  * "hibernate.connection.release_mode" value "after_statement".  */ ;/**  * Specify whether to reobtain the target Connection for each operation  * performed within a transaction.  * <p>The default is "false". Specify "true" to reobtain transactional  * Connections for every call on the Connection proxy. this is advisable  * on JBoss if you hold on to a Connection handle across transaction boundaries.  * <p>The effect of this setting is similar to the  * "hibernate.connection.release_mode" value "after_statement".  */ public void setReobtainTransactionalConnections(boolean reobtainTransactionalConnections) {     this.reobtainTransactionalConnections = reobtainTransactionalConnections. }
true;public;0;4;/**  * Delegates to DataSourceUtils for automatically participating in Spring-managed  * transactions. Throws the original SQLException, if any.  * <p>The returned Connection handle implements the ConnectionProxy interface,  * allowing to retrieve the underlying target Connection.  * @return a transactional Connection if any, a new one else  * @see DataSourceUtils#doGetConnection  * @see ConnectionProxy#getTargetConnection  */ ;/**  * Delegates to DataSourceUtils for automatically participating in Spring-managed  * transactions. Throws the original SQLException, if any.  * <p>The returned Connection handle implements the ConnectionProxy interface,  * allowing to retrieve the underlying target Connection.  * @return a transactional Connection if any, a new one else  * @see DataSourceUtils#doGetConnection  * @see ConnectionProxy#getTargetConnection  */ @Override public Connection getConnection() throws SQLException {     return getTransactionAwareConnectionProxy(obtainTargetDataSource()). }
true;protected;1;6;/**  * Wraps the given Connection with a proxy that delegates every method call to it  * but delegates {@code close()} calls to DataSourceUtils.  * @param targetDataSource the DataSource that the Connection came from  * @return the wrapped Connection  * @see java.sql.Connection#close()  * @see DataSourceUtils#doReleaseConnection  */ ;/**  * Wraps the given Connection with a proxy that delegates every method call to it  * but delegates {@code close()} calls to DataSourceUtils.  * @param targetDataSource the DataSource that the Connection came from  * @return the wrapped Connection  * @see java.sql.Connection#close()  * @see DataSourceUtils#doReleaseConnection  */ protected Connection getTransactionAwareConnectionProxy(DataSource targetDataSource) {     return (Connection) Proxy.newProxyInstance(ConnectionProxy.class.getClassLoader(), new Class<?>[] { ConnectionProxy.class }, new TransactionAwareInvocationHandler(targetDataSource)). }
true;protected;1;4;/**  * Determine whether to obtain a fixed target Connection for the proxy  * or to reobtain the target Connection for each operation.  * <p>The default implementation returns {@code true} for all  * standard cases. This can be overridden through the  * {@link #setReobtainTransactionalConnections "reobtainTransactionalConnections"}  * flag, which enforces a non-fixed target Connection within an active transaction.  * Note that non-transactional access will always use a fixed Connection.  * @param targetDataSource the target DataSource  */ ;/**  * Determine whether to obtain a fixed target Connection for the proxy  * or to reobtain the target Connection for each operation.  * <p>The default implementation returns {@code true} for all  * standard cases. This can be overridden through the  * {@link #setReobtainTransactionalConnections "reobtainTransactionalConnections"}  * flag, which enforces a non-fixed target Connection within an active transaction.  * Note that non-transactional access will always use a fixed Connection.  * @param targetDataSource the target DataSource  */ protected boolean shouldObtainFixedConnection(DataSource targetDataSource) {     return (!TransactionSynchronizationManager.isSynchronizationActive() || !this.reobtainTransactionalConnections). }
false;public;3;83;;@Override @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only considered as equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Use hashCode of Connection proxy.         return System.identityHashCode(proxy).     } else if (method.getName().equals("toString")) {         // Allow for differentiating between the proxy and the raw Connection.         StringBuilder sb = new StringBuilder("Transaction-aware proxy for target Connection ").         if (this.target != null) {             sb.append("[").append(this.target.toString()).append("]").         } else {             sb.append(" from DataSource [").append(this.targetDataSource).append("]").         }         return sb.toString().     } else if (method.getName().equals("unwrap")) {         if (((Class<?>) args[0]).isInstance(proxy)) {             return proxy.         }     } else if (method.getName().equals("isWrapperFor")) {         if (((Class<?>) args[0]).isInstance(proxy)) {             return true.         }     } else if (method.getName().equals("close")) {         // Handle close method: only close if not within a transaction.         DataSourceUtils.doReleaseConnection(this.target, this.targetDataSource).         this.closed = true.         return null.     } else if (method.getName().equals("isClosed")) {         return this.closed.     }     if (this.target == null) {         if (this.closed) {             throw new SQLException("Connection handle already closed").         }         if (shouldObtainFixedConnection(this.targetDataSource)) {             this.target = DataSourceUtils.doGetConnection(this.targetDataSource).         }     }     Connection actualTarget = this.target.     if (actualTarget == null) {         actualTarget = DataSourceUtils.doGetConnection(this.targetDataSource).     }     if (method.getName().equals("getTargetConnection")) {         // Handle getTargetConnection method: return underlying Connection.         return actualTarget.     }     // Invoke method on target Connection.     try {         Object retVal = method.invoke(actualTarget, args).         // Applies to createStatement, prepareStatement, prepareCall.         if (retVal instanceof Statement) {             DataSourceUtils.applyTransactionTimeout((Statement) retVal, this.targetDataSource).         }         return retVal.     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } finally {         if (actualTarget != this.target) {             DataSourceUtils.doReleaseConnection(actualTarget, this.targetDataSource).         }     } }
