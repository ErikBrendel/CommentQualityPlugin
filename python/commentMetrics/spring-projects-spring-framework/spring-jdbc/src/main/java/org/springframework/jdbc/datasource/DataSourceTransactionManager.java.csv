commented;modifiers;parameterAmount;loc;comment;code
true;public;1;11;/**  * Set the JDBC DataSource that this instance should manage transactions for.  * <p>This will typically be a locally defined DataSource, for example an  * Apache Commons DBCP connection pool. Alternatively, you can also drive  * transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA  * DataSource, use JtaTransactionManager.  * <p>The DataSource specified here should be the target DataSource to manage  * transactions for, not a TransactionAwareDataSourceProxy. Only data access  * code may work with TransactionAwareDataSourceProxy, while the transaction  * manager needs to work on the underlying target DataSource. If there's  * nevertheless a TransactionAwareDataSourceProxy passed in, it will be  * unwrapped to extract its target DataSource.  * <p><b>The DataSource passed in here needs to return independent Connections.</b>  * The Connections may come from a pool (the typical case), but the DataSource  * must not return thread-scoped / request-scoped Connections or the like.  * @see TransactionAwareDataSourceProxy  * @see org.springframework.transaction.jta.JtaTransactionManager  */ ;/**  * Set the JDBC DataSource that this instance should manage transactions for.  * <p>This will typically be a locally defined DataSource, for example an  * Apache Commons DBCP connection pool. Alternatively, you can also drive  * transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA  * DataSource, use JtaTransactionManager.  * <p>The DataSource specified here should be the target DataSource to manage  * transactions for, not a TransactionAwareDataSourceProxy. Only data access  * code may work with TransactionAwareDataSourceProxy, while the transaction  * manager needs to work on the underlying target DataSource. If there's  * nevertheless a TransactionAwareDataSourceProxy passed in, it will be  * unwrapped to extract its target DataSource.  * <p><b>The DataSource passed in here needs to return independent Connections.</b>  * The Connections may come from a pool (the typical case), but the DataSource  * must not return thread-scoped / request-scoped Connections or the like.  * @see TransactionAwareDataSourceProxy  * @see org.springframework.transaction.jta.JtaTransactionManager  */ public void setDataSource(@Nullable DataSource dataSource) {     if (dataSource instanceof TransactionAwareDataSourceProxy) {         // If we got a TransactionAwareDataSourceProxy, we need to perform transactions         // for its underlying target DataSource, else data access code won't see         // properly exposed transactions (i.e. transactions for the target DataSource).         this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource().     } else {         this.dataSource = dataSource.     } }
true;public;0;4;/**  * Return the JDBC DataSource that this instance manages transactions for.  */ ;/**  * Return the JDBC DataSource that this instance manages transactions for.  */ @Nullable public DataSource getDataSource() {     return this.dataSource. }
true;protected;0;5;/**  * Obtain the DataSource for actual use.  * @return the DataSource (never {@code null})  * @throws IllegalStateException in case of no DataSource set  * @since 5.0  */ ;/**  * Obtain the DataSource for actual use.  * @return the DataSource (never {@code null})  * @throws IllegalStateException in case of no DataSource set  * @since 5.0  */ protected DataSource obtainDataSource() {     DataSource dataSource = getDataSource().     Assert.state(dataSource != null, "No DataSource set").     return dataSource. }
true;public;1;3;/**  * Specify whether to enforce the read-only nature of a transaction  * (as indicated by {@link TransactionDefinition#isReadOnly()}  * through an explicit statement on the transactional connection:  * "SET TRANSACTION READ ONLY" as understood by Oracle, MySQL and Postgres.  * <p>The exact treatment, including any SQL statement executed on the connection,  * can be customized through through {@link #prepareTransactionalConnection}.  * <p>This mode of read-only handling goes beyond the {@link Connection#setReadOnly}  * hint that Spring applies by default. In contrast to that standard JDBC hint,  * "SET TRANSACTION READ ONLY" enforces an isolation-level-like connection mode  * where data manipulation statements are strictly disallowed. Also, on Oracle,  * this read-only mode provides read consistency for the entire transaction.  * <p>Note that older Oracle JDBC drivers (9i, 10g) used to enforce this read-only  * mode even for {@code Connection.setReadOnly(true}. However, with recent drivers,  * this strong enforcement needs to be applied explicitly, e.g. through this flag.  * @since 4.3.7  * @see #prepareTransactionalConnection  */ ;/**  * Specify whether to enforce the read-only nature of a transaction  * (as indicated by {@link TransactionDefinition#isReadOnly()}  * through an explicit statement on the transactional connection:  * "SET TRANSACTION READ ONLY" as understood by Oracle, MySQL and Postgres.  * <p>The exact treatment, including any SQL statement executed on the connection,  * can be customized through through {@link #prepareTransactionalConnection}.  * <p>This mode of read-only handling goes beyond the {@link Connection#setReadOnly}  * hint that Spring applies by default. In contrast to that standard JDBC hint,  * "SET TRANSACTION READ ONLY" enforces an isolation-level-like connection mode  * where data manipulation statements are strictly disallowed. Also, on Oracle,  * this read-only mode provides read consistency for the entire transaction.  * <p>Note that older Oracle JDBC drivers (9i, 10g) used to enforce this read-only  * mode even for {@code Connection.setReadOnly(true}. However, with recent drivers,  * this strong enforcement needs to be applied explicitly, e.g. through this flag.  * @since 4.3.7  * @see #prepareTransactionalConnection  */ public void setEnforceReadOnly(boolean enforceReadOnly) {     this.enforceReadOnly = enforceReadOnly. }
true;public;0;3;/**  * Return whether to enforce the read-only nature of a transaction  * through an explicit statement on the transactional connection.  * @since 4.3.7  * @see #setEnforceReadOnly  */ ;/**  * Return whether to enforce the read-only nature of a transaction  * through an explicit statement on the transactional connection.  * @since 4.3.7  * @see #setEnforceReadOnly  */ public boolean isEnforceReadOnly() {     return this.enforceReadOnly. }
false;public;0;6;;@Override public void afterPropertiesSet() {     if (getDataSource() == null) {         throw new IllegalArgumentException("Property 'dataSource' is required").     } }
false;public;0;4;;@Override public Object getResourceFactory() {     return obtainDataSource(). }
false;protected;0;9;;@Override protected Object doGetTransaction() {     DataSourceTransactionObject txObject = new DataSourceTransactionObject().     txObject.setSavepointAllowed(isNestedTransactionAllowed()).     ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource()).     txObject.setConnectionHolder(conHolder, false).     return txObject. }
false;protected;1;5;;@Override protected boolean isExistingTransaction(Object transaction) {     DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction.     return (txObject.hasConnectionHolder() && txObject.getConnectionHolder().isTransactionActive()). }
true;protected;2;54;/**  * This implementation sets the isolation level but ignores the timeout.  */ ;/**  * This implementation sets the isolation level but ignores the timeout.  */ @Override protected void doBegin(Object transaction, TransactionDefinition definition) {     DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction.     Connection con = null.     try {         if (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) {             Connection newCon = obtainDataSource().getConnection().             if (logger.isDebugEnabled()) {                 logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction").             }             txObject.setConnectionHolder(new ConnectionHolder(newCon), true).         }         txObject.getConnectionHolder().setSynchronizedWithTransaction(true).         con = txObject.getConnectionHolder().getConnection().         Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition).         txObject.setPreviousIsolationLevel(previousIsolationLevel).         // configured the connection pool to set it already).         if (con.getAutoCommit()) {             txObject.setMustRestoreAutoCommit(true).             if (logger.isDebugEnabled()) {                 logger.debug("Switching JDBC Connection [" + con + "] to manual commit").             }             con.setAutoCommit(false).         }         prepareTransactionalConnection(con, definition).         txObject.getConnectionHolder().setTransactionActive(true).         int timeout = determineTimeout(definition).         if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {             txObject.getConnectionHolder().setTimeoutInSeconds(timeout).         }         // Bind the connection holder to the thread.         if (txObject.isNewConnectionHolder()) {             TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder()).         }     } catch (Throwable ex) {         if (txObject.isNewConnectionHolder()) {             DataSourceUtils.releaseConnection(con, obtainDataSource()).             txObject.setConnectionHolder(null, false).         }         throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex).     } }
false;protected;1;6;;@Override protected Object doSuspend(Object transaction) {     DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction.     txObject.setConnectionHolder(null).     return TransactionSynchronizationManager.unbindResource(obtainDataSource()). }
false;protected;2;4;;@Override protected void doResume(@Nullable Object transaction, Object suspendedResources) {     TransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources). }
false;protected;1;14;;@Override protected void doCommit(DefaultTransactionStatus status) {     DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction().     Connection con = txObject.getConnectionHolder().getConnection().     if (status.isDebug()) {         logger.debug("Committing JDBC transaction on Connection [" + con + "]").     }     try {         con.commit().     } catch (SQLException ex) {         throw new TransactionSystemException("Could not commit JDBC transaction", ex).     } }
false;protected;1;14;;@Override protected void doRollback(DefaultTransactionStatus status) {     DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction().     Connection con = txObject.getConnectionHolder().getConnection().     if (status.isDebug()) {         logger.debug("Rolling back JDBC transaction on Connection [" + con + "]").     }     try {         con.rollback().     } catch (SQLException ex) {         throw new TransactionSystemException("Could not roll back JDBC transaction", ex).     } }
false;protected;1;9;;@Override protected void doSetRollbackOnly(DefaultTransactionStatus status) {     DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction().     if (status.isDebug()) {         logger.debug("Setting JDBC transaction [" + txObject.getConnectionHolder().getConnection() + "] rollback-only").     }     txObject.setRollbackOnly(). }
false;protected;1;30;;@Override protected void doCleanupAfterCompletion(Object transaction) {     DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction.     // Remove the connection holder from the thread, if exposed.     if (txObject.isNewConnectionHolder()) {         TransactionSynchronizationManager.unbindResource(obtainDataSource()).     }     // Reset connection.     Connection con = txObject.getConnectionHolder().getConnection().     try {         if (txObject.isMustRestoreAutoCommit()) {             con.setAutoCommit(true).         }         DataSourceUtils.resetConnectionAfterTransaction(con, txObject.getPreviousIsolationLevel()).     } catch (Throwable ex) {         logger.debug("Could not reset JDBC Connection after transaction", ex).     }     if (txObject.isNewConnectionHolder()) {         if (logger.isDebugEnabled()) {             logger.debug("Releasing JDBC Connection [" + con + "] after transaction").         }         DataSourceUtils.releaseConnection(con, this.dataSource).     }     txObject.getConnectionHolder().clear(). }
true;protected;2;13;/**  * Prepare the transactional {@code Connection} right after transaction begin.  * <p>The default implementation executes a "SET TRANSACTION READ ONLY" statement  * if the {@link #setEnforceReadOnly "enforceReadOnly"} flag is set to {@code true}  * and the transaction definition indicates a read-only transaction.  * <p>The "SET TRANSACTION READ ONLY" is understood by Oracle, MySQL and Postgres  * and may work with other databases as well. If you'd like to adapt this treatment,  * override this method accordingly.  * @param con the transactional JDBC Connection  * @param definition the current transaction definition  * @throws SQLException if thrown by JDBC API  * @since 4.3.7  * @see #setEnforceReadOnly  */ ;/**  * Prepare the transactional {@code Connection} right after transaction begin.  * <p>The default implementation executes a "SET TRANSACTION READ ONLY" statement  * if the {@link #setEnforceReadOnly "enforceReadOnly"} flag is set to {@code true}  * and the transaction definition indicates a read-only transaction.  * <p>The "SET TRANSACTION READ ONLY" is understood by Oracle, MySQL and Postgres  * and may work with other databases as well. If you'd like to adapt this treatment,  * override this method accordingly.  * @param con the transactional JDBC Connection  * @param definition the current transaction definition  * @throws SQLException if thrown by JDBC API  * @since 4.3.7  * @see #setEnforceReadOnly  */ protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition) throws SQLException {     if (isEnforceReadOnly() && definition.isReadOnly()) {         Statement stmt = con.createStatement().         try {             stmt.executeUpdate("SET TRANSACTION READ ONLY").         } finally {             stmt.close().         }     } }
false;public;2;4;;public void setConnectionHolder(@Nullable ConnectionHolder connectionHolder, boolean newConnectionHolder) {     super.setConnectionHolder(connectionHolder).     this.newConnectionHolder = newConnectionHolder. }
false;public;0;3;;public boolean isNewConnectionHolder() {     return this.newConnectionHolder. }
false;public;1;3;;public void setMustRestoreAutoCommit(boolean mustRestoreAutoCommit) {     this.mustRestoreAutoCommit = mustRestoreAutoCommit. }
false;public;0;3;;public boolean isMustRestoreAutoCommit() {     return this.mustRestoreAutoCommit. }
false;public;0;3;;public void setRollbackOnly() {     getConnectionHolder().setRollbackOnly(). }
false;public;0;4;;@Override public boolean isRollbackOnly() {     return getConnectionHolder().isRollbackOnly(). }
false;public;0;6;;@Override public void flush() {     if (TransactionSynchronizationManager.isSynchronizationActive()) {         TransactionSynchronizationUtils.triggerFlush().     } }
