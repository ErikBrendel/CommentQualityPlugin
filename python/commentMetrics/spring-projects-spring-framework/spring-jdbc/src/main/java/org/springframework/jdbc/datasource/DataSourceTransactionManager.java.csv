# id;timestamp;commentText;codeText;commentWords;codeWords
DataSourceTransactionManager -> @Nullable 	public DataSource getDataSource();1496837955;Return the JDBC DataSource that this instance manages transactions for.;@Nullable_	public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;nullable,public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> @Nullable 	public DataSource getDataSource();1498780456;Return the JDBC DataSource that this instance manages transactions for.;@Nullable_	public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;nullable,public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> @Nullable 	public DataSource getDataSource();1500448076;Return the JDBC DataSource that this instance manages transactions for.;@Nullable_	public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;nullable,public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> @Nullable 	public DataSource getDataSource();1530174524;Return the JDBC DataSource that this instance manages transactions for.;@Nullable_	public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;nullable,public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1328020251;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1356735495;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1357119239;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1362408075;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1368482696;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1374672550;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1397137946;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1412253201;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1426267150;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1476521730;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1477661037;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1486062388;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public DataSource getDataSource();1496259743;Return the JDBC DataSource that this instance manages transactions for.;public DataSource getDataSource() {_		return this.dataSource__	};return,the,jdbc,data,source,that,this,instance,manages,transactions,for;public,data,source,get,data,source,return,this,data,source
DataSourceTransactionManager -> public void setEnforceReadOnly(boolean enforceReadOnly);1486062388;Specify whether to enforce the read-only nature of a transaction_(as indicated by {@link TransactionDefinition#isReadOnly()}_through an explicit statement on the transactional connection:_"SET TRANSACTION READ ONLY" as understood by Oracle, MySQL and Postgres._<p>The exact treatment, including any SQL statement executed on the connection,_can be customized through through {@link #prepareTransactionalConnection}._<p>This mode of read-only handling goes beyond the {@link Connection#setReadOnly}_hint that Spring applies by default. In contrast to that standard JDBC hint,_"SET TRANSACTION READ ONLY" enforces an isolation-level-like connection mode_where data manipulation statements are strictly disallowed. Also, on Oracle,_this read-only mode provides read consistency for the entire transaction._<p>Note that older Oracle JDBC drivers (9i, 10g) used to enforce this read-only_mode even for {@code Connection.setReadOnly(true}. However, with recent drivers,_this strong enforcement needs to be applied explicitly, e.g. through this flag._@since 4.3.7_@see #prepareTransactionalConnection;public void setEnforceReadOnly(boolean enforceReadOnly) {_		this.enforceReadOnly = enforceReadOnly__	};specify,whether,to,enforce,the,read,only,nature,of,a,transaction,as,indicated,by,link,transaction,definition,is,read,only,through,an,explicit,statement,on,the,transactional,connection,set,transaction,read,only,as,understood,by,oracle,my,sql,and,postgres,p,the,exact,treatment,including,any,sql,statement,executed,on,the,connection,can,be,customized,through,through,link,prepare,transactional,connection,p,this,mode,of,read,only,handling,goes,beyond,the,link,connection,set,read,only,hint,that,spring,applies,by,default,in,contrast,to,that,standard,jdbc,hint,set,transaction,read,only,enforces,an,isolation,level,like,connection,mode,where,data,manipulation,statements,are,strictly,disallowed,also,on,oracle,this,read,only,mode,provides,read,consistency,for,the,entire,transaction,p,note,that,older,oracle,jdbc,drivers,9i,10g,used,to,enforce,this,read,only,mode,even,for,code,connection,set,read,only,true,however,with,recent,drivers,this,strong,enforcement,needs,to,be,applied,explicitly,e,g,through,this,flag,since,4,3,7,see,prepare,transactional,connection;public,void,set,enforce,read,only,boolean,enforce,read,only,this,enforce,read,only,enforce,read,only
DataSourceTransactionManager -> public void setEnforceReadOnly(boolean enforceReadOnly);1496259743;Specify whether to enforce the read-only nature of a transaction_(as indicated by {@link TransactionDefinition#isReadOnly()}_through an explicit statement on the transactional connection:_"SET TRANSACTION READ ONLY" as understood by Oracle, MySQL and Postgres._<p>The exact treatment, including any SQL statement executed on the connection,_can be customized through through {@link #prepareTransactionalConnection}._<p>This mode of read-only handling goes beyond the {@link Connection#setReadOnly}_hint that Spring applies by default. In contrast to that standard JDBC hint,_"SET TRANSACTION READ ONLY" enforces an isolation-level-like connection mode_where data manipulation statements are strictly disallowed. Also, on Oracle,_this read-only mode provides read consistency for the entire transaction._<p>Note that older Oracle JDBC drivers (9i, 10g) used to enforce this read-only_mode even for {@code Connection.setReadOnly(true}. However, with recent drivers,_this strong enforcement needs to be applied explicitly, e.g. through this flag._@since 4.3.7_@see #prepareTransactionalConnection;public void setEnforceReadOnly(boolean enforceReadOnly) {_		this.enforceReadOnly = enforceReadOnly__	};specify,whether,to,enforce,the,read,only,nature,of,a,transaction,as,indicated,by,link,transaction,definition,is,read,only,through,an,explicit,statement,on,the,transactional,connection,set,transaction,read,only,as,understood,by,oracle,my,sql,and,postgres,p,the,exact,treatment,including,any,sql,statement,executed,on,the,connection,can,be,customized,through,through,link,prepare,transactional,connection,p,this,mode,of,read,only,handling,goes,beyond,the,link,connection,set,read,only,hint,that,spring,applies,by,default,in,contrast,to,that,standard,jdbc,hint,set,transaction,read,only,enforces,an,isolation,level,like,connection,mode,where,data,manipulation,statements,are,strictly,disallowed,also,on,oracle,this,read,only,mode,provides,read,consistency,for,the,entire,transaction,p,note,that,older,oracle,jdbc,drivers,9i,10g,used,to,enforce,this,read,only,mode,even,for,code,connection,set,read,only,true,however,with,recent,drivers,this,strong,enforcement,needs,to,be,applied,explicitly,e,g,through,this,flag,since,4,3,7,see,prepare,transactional,connection;public,void,set,enforce,read,only,boolean,enforce,read,only,this,enforce,read,only,enforce,read,only
DataSourceTransactionManager -> public void setEnforceReadOnly(boolean enforceReadOnly);1496837955;Specify whether to enforce the read-only nature of a transaction_(as indicated by {@link TransactionDefinition#isReadOnly()}_through an explicit statement on the transactional connection:_"SET TRANSACTION READ ONLY" as understood by Oracle, MySQL and Postgres._<p>The exact treatment, including any SQL statement executed on the connection,_can be customized through through {@link #prepareTransactionalConnection}._<p>This mode of read-only handling goes beyond the {@link Connection#setReadOnly}_hint that Spring applies by default. In contrast to that standard JDBC hint,_"SET TRANSACTION READ ONLY" enforces an isolation-level-like connection mode_where data manipulation statements are strictly disallowed. Also, on Oracle,_this read-only mode provides read consistency for the entire transaction._<p>Note that older Oracle JDBC drivers (9i, 10g) used to enforce this read-only_mode even for {@code Connection.setReadOnly(true}. However, with recent drivers,_this strong enforcement needs to be applied explicitly, e.g. through this flag._@since 4.3.7_@see #prepareTransactionalConnection;public void setEnforceReadOnly(boolean enforceReadOnly) {_		this.enforceReadOnly = enforceReadOnly__	};specify,whether,to,enforce,the,read,only,nature,of,a,transaction,as,indicated,by,link,transaction,definition,is,read,only,through,an,explicit,statement,on,the,transactional,connection,set,transaction,read,only,as,understood,by,oracle,my,sql,and,postgres,p,the,exact,treatment,including,any,sql,statement,executed,on,the,connection,can,be,customized,through,through,link,prepare,transactional,connection,p,this,mode,of,read,only,handling,goes,beyond,the,link,connection,set,read,only,hint,that,spring,applies,by,default,in,contrast,to,that,standard,jdbc,hint,set,transaction,read,only,enforces,an,isolation,level,like,connection,mode,where,data,manipulation,statements,are,strictly,disallowed,also,on,oracle,this,read,only,mode,provides,read,consistency,for,the,entire,transaction,p,note,that,older,oracle,jdbc,drivers,9i,10g,used,to,enforce,this,read,only,mode,even,for,code,connection,set,read,only,true,however,with,recent,drivers,this,strong,enforcement,needs,to,be,applied,explicitly,e,g,through,this,flag,since,4,3,7,see,prepare,transactional,connection;public,void,set,enforce,read,only,boolean,enforce,read,only,this,enforce,read,only,enforce,read,only
DataSourceTransactionManager -> public void setEnforceReadOnly(boolean enforceReadOnly);1498780456;Specify whether to enforce the read-only nature of a transaction_(as indicated by {@link TransactionDefinition#isReadOnly()}_through an explicit statement on the transactional connection:_"SET TRANSACTION READ ONLY" as understood by Oracle, MySQL and Postgres._<p>The exact treatment, including any SQL statement executed on the connection,_can be customized through through {@link #prepareTransactionalConnection}._<p>This mode of read-only handling goes beyond the {@link Connection#setReadOnly}_hint that Spring applies by default. In contrast to that standard JDBC hint,_"SET TRANSACTION READ ONLY" enforces an isolation-level-like connection mode_where data manipulation statements are strictly disallowed. Also, on Oracle,_this read-only mode provides read consistency for the entire transaction._<p>Note that older Oracle JDBC drivers (9i, 10g) used to enforce this read-only_mode even for {@code Connection.setReadOnly(true}. However, with recent drivers,_this strong enforcement needs to be applied explicitly, e.g. through this flag._@since 4.3.7_@see #prepareTransactionalConnection;public void setEnforceReadOnly(boolean enforceReadOnly) {_		this.enforceReadOnly = enforceReadOnly__	};specify,whether,to,enforce,the,read,only,nature,of,a,transaction,as,indicated,by,link,transaction,definition,is,read,only,through,an,explicit,statement,on,the,transactional,connection,set,transaction,read,only,as,understood,by,oracle,my,sql,and,postgres,p,the,exact,treatment,including,any,sql,statement,executed,on,the,connection,can,be,customized,through,through,link,prepare,transactional,connection,p,this,mode,of,read,only,handling,goes,beyond,the,link,connection,set,read,only,hint,that,spring,applies,by,default,in,contrast,to,that,standard,jdbc,hint,set,transaction,read,only,enforces,an,isolation,level,like,connection,mode,where,data,manipulation,statements,are,strictly,disallowed,also,on,oracle,this,read,only,mode,provides,read,consistency,for,the,entire,transaction,p,note,that,older,oracle,jdbc,drivers,9i,10g,used,to,enforce,this,read,only,mode,even,for,code,connection,set,read,only,true,however,with,recent,drivers,this,strong,enforcement,needs,to,be,applied,explicitly,e,g,through,this,flag,since,4,3,7,see,prepare,transactional,connection;public,void,set,enforce,read,only,boolean,enforce,read,only,this,enforce,read,only,enforce,read,only
DataSourceTransactionManager -> public void setEnforceReadOnly(boolean enforceReadOnly);1500448076;Specify whether to enforce the read-only nature of a transaction_(as indicated by {@link TransactionDefinition#isReadOnly()}_through an explicit statement on the transactional connection:_"SET TRANSACTION READ ONLY" as understood by Oracle, MySQL and Postgres._<p>The exact treatment, including any SQL statement executed on the connection,_can be customized through through {@link #prepareTransactionalConnection}._<p>This mode of read-only handling goes beyond the {@link Connection#setReadOnly}_hint that Spring applies by default. In contrast to that standard JDBC hint,_"SET TRANSACTION READ ONLY" enforces an isolation-level-like connection mode_where data manipulation statements are strictly disallowed. Also, on Oracle,_this read-only mode provides read consistency for the entire transaction._<p>Note that older Oracle JDBC drivers (9i, 10g) used to enforce this read-only_mode even for {@code Connection.setReadOnly(true}. However, with recent drivers,_this strong enforcement needs to be applied explicitly, e.g. through this flag._@since 4.3.7_@see #prepareTransactionalConnection;public void setEnforceReadOnly(boolean enforceReadOnly) {_		this.enforceReadOnly = enforceReadOnly__	};specify,whether,to,enforce,the,read,only,nature,of,a,transaction,as,indicated,by,link,transaction,definition,is,read,only,through,an,explicit,statement,on,the,transactional,connection,set,transaction,read,only,as,understood,by,oracle,my,sql,and,postgres,p,the,exact,treatment,including,any,sql,statement,executed,on,the,connection,can,be,customized,through,through,link,prepare,transactional,connection,p,this,mode,of,read,only,handling,goes,beyond,the,link,connection,set,read,only,hint,that,spring,applies,by,default,in,contrast,to,that,standard,jdbc,hint,set,transaction,read,only,enforces,an,isolation,level,like,connection,mode,where,data,manipulation,statements,are,strictly,disallowed,also,on,oracle,this,read,only,mode,provides,read,consistency,for,the,entire,transaction,p,note,that,older,oracle,jdbc,drivers,9i,10g,used,to,enforce,this,read,only,mode,even,for,code,connection,set,read,only,true,however,with,recent,drivers,this,strong,enforcement,needs,to,be,applied,explicitly,e,g,through,this,flag,since,4,3,7,see,prepare,transactional,connection;public,void,set,enforce,read,only,boolean,enforce,read,only,this,enforce,read,only,enforce,read,only
DataSourceTransactionManager -> public void setEnforceReadOnly(boolean enforceReadOnly);1530174524;Specify whether to enforce the read-only nature of a transaction_(as indicated by {@link TransactionDefinition#isReadOnly()}_through an explicit statement on the transactional connection:_"SET TRANSACTION READ ONLY" as understood by Oracle, MySQL and Postgres._<p>The exact treatment, including any SQL statement executed on the connection,_can be customized through through {@link #prepareTransactionalConnection}._<p>This mode of read-only handling goes beyond the {@link Connection#setReadOnly}_hint that Spring applies by default. In contrast to that standard JDBC hint,_"SET TRANSACTION READ ONLY" enforces an isolation-level-like connection mode_where data manipulation statements are strictly disallowed. Also, on Oracle,_this read-only mode provides read consistency for the entire transaction._<p>Note that older Oracle JDBC drivers (9i, 10g) used to enforce this read-only_mode even for {@code Connection.setReadOnly(true}. However, with recent drivers,_this strong enforcement needs to be applied explicitly, e.g. through this flag._@since 4.3.7_@see #prepareTransactionalConnection;public void setEnforceReadOnly(boolean enforceReadOnly) {_		this.enforceReadOnly = enforceReadOnly__	};specify,whether,to,enforce,the,read,only,nature,of,a,transaction,as,indicated,by,link,transaction,definition,is,read,only,through,an,explicit,statement,on,the,transactional,connection,set,transaction,read,only,as,understood,by,oracle,my,sql,and,postgres,p,the,exact,treatment,including,any,sql,statement,executed,on,the,connection,can,be,customized,through,through,link,prepare,transactional,connection,p,this,mode,of,read,only,handling,goes,beyond,the,link,connection,set,read,only,hint,that,spring,applies,by,default,in,contrast,to,that,standard,jdbc,hint,set,transaction,read,only,enforces,an,isolation,level,like,connection,mode,where,data,manipulation,statements,are,strictly,disallowed,also,on,oracle,this,read,only,mode,provides,read,consistency,for,the,entire,transaction,p,note,that,older,oracle,jdbc,drivers,9i,10g,used,to,enforce,this,read,only,mode,even,for,code,connection,set,read,only,true,however,with,recent,drivers,this,strong,enforcement,needs,to,be,applied,explicitly,e,g,through,this,flag,since,4,3,7,see,prepare,transactional,connection;public,void,set,enforce,read,only,boolean,enforce,read,only,this,enforce,read,only,enforce,read,only
DataSourceTransactionManager -> public void setDataSource(@Nullable DataSource dataSource);1500448076;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example an_Apache Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(@Nullable DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,an,apache,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,nullable,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(@Nullable DataSource dataSource);1530174524;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example an_Apache Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(@Nullable DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,an,apache,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,nullable,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> protected DataSource obtainDataSource();1496837955;Obtain the DataSource for actual use._@return the DataSource (never {@code null})_@throws IllegalStateException in case of no DataSource set_@since 5.0;protected DataSource obtainDataSource() {_		DataSource dataSource = getDataSource()__		Assert.state(dataSource != null, "No DataSource set")__		return dataSource__	};obtain,the,data,source,for,actual,use,return,the,data,source,never,code,null,throws,illegal,state,exception,in,case,of,no,data,source,set,since,5,0;protected,data,source,obtain,data,source,data,source,data,source,get,data,source,assert,state,data,source,null,no,data,source,set,return,data,source
DataSourceTransactionManager -> protected DataSource obtainDataSource();1498780456;Obtain the DataSource for actual use._@return the DataSource (never {@code null})_@throws IllegalStateException in case of no DataSource set_@since 5.0;protected DataSource obtainDataSource() {_		DataSource dataSource = getDataSource()__		Assert.state(dataSource != null, "No DataSource set")__		return dataSource__	};obtain,the,data,source,for,actual,use,return,the,data,source,never,code,null,throws,illegal,state,exception,in,case,of,no,data,source,set,since,5,0;protected,data,source,obtain,data,source,data,source,data,source,get,data,source,assert,state,data,source,null,no,data,source,set,return,data,source
DataSourceTransactionManager -> protected DataSource obtainDataSource();1500448076;Obtain the DataSource for actual use._@return the DataSource (never {@code null})_@throws IllegalStateException in case of no DataSource set_@since 5.0;protected DataSource obtainDataSource() {_		DataSource dataSource = getDataSource()__		Assert.state(dataSource != null, "No DataSource set")__		return dataSource__	};obtain,the,data,source,for,actual,use,return,the,data,source,never,code,null,throws,illegal,state,exception,in,case,of,no,data,source,set,since,5,0;protected,data,source,obtain,data,source,data,source,data,source,get,data,source,assert,state,data,source,null,no,data,source,set,return,data,source
DataSourceTransactionManager -> protected DataSource obtainDataSource();1530174524;Obtain the DataSource for actual use._@return the DataSource (never {@code null})_@throws IllegalStateException in case of no DataSource set_@since 5.0;protected DataSource obtainDataSource() {_		DataSource dataSource = getDataSource()__		Assert.state(dataSource != null, "No DataSource set")__		return dataSource__	};obtain,the,data,source,for,actual,use,return,the,data,source,never,code,null,throws,illegal,state,exception,in,case,of,no,data,source,set,since,5,0;protected,data,source,obtain,data,source,data,source,data,source,get,data,source,assert,state,data,source,null,no,data,source,set,return,data,source
DataSourceTransactionManager -> public DataSourceTransactionManager();1328020251;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1356735495;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1357119239;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1362408075;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1368482696;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1374672550;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1397137946;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1412253201;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1426267150;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1476521730;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1477661037;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1486062388;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1496259743;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1496837955;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1498780456;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1500448076;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> public DataSourceTransactionManager();1530174524;Create a new DataSourceTransactionManager instance._A DataSource has to be set to be able to use it._@see #setDataSource;public DataSourceTransactionManager() {_		setNestedTransactionAllowed(true)__	};create,a,new,data,source,transaction,manager,instance,a,data,source,has,to,be,set,to,be,able,to,use,it,see,set,data,source;public,data,source,transaction,manager,set,nested,transaction,allowed,true
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1328020251;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Exception ex) {_			DataSourceUtils.releaseConnection(con, this.dataSource)__			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,exception,ex,data,source,utils,release,connection,con,this,data,source,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1356735495;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Exception ex) {_			DataSourceUtils.releaseConnection(con, this.dataSource)__			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,exception,ex,data,source,utils,release,connection,con,this,data,source,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1357119239;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Exception ex) {_			DataSourceUtils.releaseConnection(con, this.dataSource)__			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,exception,ex,data,source,utils,release,connection,con,this,data,source,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1362408075;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Exception ex) {_			DataSourceUtils.releaseConnection(con, this.dataSource)__			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,exception,ex,data,source,utils,release,connection,con,this,data,source,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1368482696;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Exception ex) {_			DataSourceUtils.releaseConnection(con, this.dataSource)__			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,exception,ex,data,source,utils,release,connection,con,this,data,source,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1374672550;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			DataSourceUtils.releaseConnection(con, this.dataSource)__			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,throwable,ex,data,source,utils,release,connection,con,this,data,source,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1397137946;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			DataSourceUtils.releaseConnection(con, this.dataSource)__			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,throwable,ex,data,source,utils,release,connection,con,this,data,source,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1412253201;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, this.dataSource)__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,this,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1426267150;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, this.dataSource)__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,this,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1476521730;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, this.dataSource)__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,this,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1477661037;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}_			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, this.dataSource)__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,this,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1486062388;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}__			prepareTransactionalConnection(con, definition)__			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, this.dataSource)__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,prepare,transactional,connection,con,definition,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,this,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1496259743;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (txObject.getConnectionHolder() == null ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = this.dataSource.getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}__			prepareTransactionalConnection(con, definition)__			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, this.dataSource)__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,get,connection,holder,null,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,this,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,prepare,transactional,connection,con,definition,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,get,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,this,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1496837955;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (!txObject.hasConnectionHolder() ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = obtainDataSource().getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}__			prepareTransactionalConnection(con, definition)__			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, this.dataSource)__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,has,connection,holder,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,obtain,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,prepare,transactional,connection,con,definition,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,obtain,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,this,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1498780456;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (!txObject.hasConnectionHolder() ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = obtainDataSource().getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}__			prepareTransactionalConnection(con, definition)__			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, obtainDataSource())__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,has,connection,holder,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,obtain,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,prepare,transactional,connection,con,definition,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,obtain,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,obtain,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1500448076;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (!txObject.hasConnectionHolder() ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = obtainDataSource().getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}__			prepareTransactionalConnection(con, definition)__			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, obtainDataSource())__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,has,connection,holder,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,obtain,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,prepare,transactional,connection,con,definition,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,obtain,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,obtain,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> @Override 	protected void doBegin(Object transaction, TransactionDefinition definition);1530174524;This implementation sets the isolation level but ignores the timeout.;@Override_	protected void doBegin(Object transaction, TransactionDefinition definition) {_		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction__		Connection con = null___		try {_			if (!txObject.hasConnectionHolder() ||_					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {_				Connection newCon = obtainDataSource().getConnection()__				if (logger.isDebugEnabled()) {_					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction")__				}_				txObject.setConnectionHolder(new ConnectionHolder(newCon), true)__			}__			txObject.getConnectionHolder().setSynchronizedWithTransaction(true)__			con = txObject.getConnectionHolder().getConnection()___			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition)__			txObject.setPreviousIsolationLevel(previousIsolationLevel)___			_			_			_			if (con.getAutoCommit()) {_				txObject.setMustRestoreAutoCommit(true)__				if (logger.isDebugEnabled()) {_					logger.debug("Switching JDBC Connection [" + con + "] to manual commit")__				}_				con.setAutoCommit(false)__			}__			prepareTransactionalConnection(con, definition)__			txObject.getConnectionHolder().setTransactionActive(true)___			int timeout = determineTimeout(definition)__			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {_				txObject.getConnectionHolder().setTimeoutInSeconds(timeout)__			}__			_			if (txObject.isNewConnectionHolder()) {_				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder())__			}_		}__		catch (Throwable ex) {_			if (txObject.isNewConnectionHolder()) {_				DataSourceUtils.releaseConnection(con, obtainDataSource())__				txObject.setConnectionHolder(null, false)__			}_			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex)__		}_	};this,implementation,sets,the,isolation,level,but,ignores,the,timeout;override,protected,void,do,begin,object,transaction,transaction,definition,definition,data,source,transaction,object,tx,object,data,source,transaction,object,transaction,connection,con,null,try,if,tx,object,has,connection,holder,tx,object,get,connection,holder,is,synchronized,with,transaction,connection,new,con,obtain,data,source,get,connection,if,logger,is,debug,enabled,logger,debug,acquired,connection,new,con,for,jdbc,transaction,tx,object,set,connection,holder,new,connection,holder,new,con,true,tx,object,get,connection,holder,set,synchronized,with,transaction,true,con,tx,object,get,connection,holder,get,connection,integer,previous,isolation,level,data,source,utils,prepare,connection,for,transaction,con,definition,tx,object,set,previous,isolation,level,previous,isolation,level,if,con,get,auto,commit,tx,object,set,must,restore,auto,commit,true,if,logger,is,debug,enabled,logger,debug,switching,jdbc,connection,con,to,manual,commit,con,set,auto,commit,false,prepare,transactional,connection,con,definition,tx,object,get,connection,holder,set,transaction,active,true,int,timeout,determine,timeout,definition,if,timeout,transaction,definition,tx,object,get,connection,holder,set,timeout,in,seconds,timeout,if,tx,object,is,new,connection,holder,transaction,synchronization,manager,bind,resource,obtain,data,source,tx,object,get,connection,holder,catch,throwable,ex,if,tx,object,is,new,connection,holder,data,source,utils,release,connection,con,obtain,data,source,tx,object,set,connection,holder,null,false,throw,new,cannot,create,transaction,exception,could,not,open,jdbc,connection,for,transaction,ex
DataSourceTransactionManager -> protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition) 			throws SQLException;1486062388;Prepare the transactional {@code Connection} right after transaction begin._<p>The default implementation executes a "SET TRANSACTION READ ONLY" statement_if the {@link #setEnforceReadOnly "enforceReadOnly"} flag is set to {@code true}_and the transaction definition indicates a read-only transaction._<p>The "SET TRANSACTION READ ONLY" is understood by Oracle, MySQL and Postgres_and may work with other databases as well. If you'd like to adapt this treatment,_override this method accordingly._@param con the transactional JDBC Connection_@param definition the current transaction definition_@throws SQLException if thrown by JDBC API_@since 4.3.7_@see #setEnforceReadOnly;protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)_			throws SQLException {__		if (isEnforceReadOnly() && definition.isReadOnly()) {_			Statement stmt = con.createStatement()__			try {_				stmt.executeUpdate("SET TRANSACTION READ ONLY")__			}_			finally {_				stmt.close()__			}_		}_	};prepare,the,transactional,code,connection,right,after,transaction,begin,p,the,default,implementation,executes,a,set,transaction,read,only,statement,if,the,link,set,enforce,read,only,enforce,read,only,flag,is,set,to,code,true,and,the,transaction,definition,indicates,a,read,only,transaction,p,the,set,transaction,read,only,is,understood,by,oracle,my,sql,and,postgres,and,may,work,with,other,databases,as,well,if,you,d,like,to,adapt,this,treatment,override,this,method,accordingly,param,con,the,transactional,jdbc,connection,param,definition,the,current,transaction,definition,throws,sqlexception,if,thrown,by,jdbc,api,since,4,3,7,see,set,enforce,read,only;protected,void,prepare,transactional,connection,connection,con,transaction,definition,definition,throws,sqlexception,if,is,enforce,read,only,definition,is,read,only,statement,stmt,con,create,statement,try,stmt,execute,update,set,transaction,read,only,finally,stmt,close
DataSourceTransactionManager -> protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition) 			throws SQLException;1496259743;Prepare the transactional {@code Connection} right after transaction begin._<p>The default implementation executes a "SET TRANSACTION READ ONLY" statement_if the {@link #setEnforceReadOnly "enforceReadOnly"} flag is set to {@code true}_and the transaction definition indicates a read-only transaction._<p>The "SET TRANSACTION READ ONLY" is understood by Oracle, MySQL and Postgres_and may work with other databases as well. If you'd like to adapt this treatment,_override this method accordingly._@param con the transactional JDBC Connection_@param definition the current transaction definition_@throws SQLException if thrown by JDBC API_@since 4.3.7_@see #setEnforceReadOnly;protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)_			throws SQLException {__		if (isEnforceReadOnly() && definition.isReadOnly()) {_			Statement stmt = con.createStatement()__			try {_				stmt.executeUpdate("SET TRANSACTION READ ONLY")__			}_			finally {_				stmt.close()__			}_		}_	};prepare,the,transactional,code,connection,right,after,transaction,begin,p,the,default,implementation,executes,a,set,transaction,read,only,statement,if,the,link,set,enforce,read,only,enforce,read,only,flag,is,set,to,code,true,and,the,transaction,definition,indicates,a,read,only,transaction,p,the,set,transaction,read,only,is,understood,by,oracle,my,sql,and,postgres,and,may,work,with,other,databases,as,well,if,you,d,like,to,adapt,this,treatment,override,this,method,accordingly,param,con,the,transactional,jdbc,connection,param,definition,the,current,transaction,definition,throws,sqlexception,if,thrown,by,jdbc,api,since,4,3,7,see,set,enforce,read,only;protected,void,prepare,transactional,connection,connection,con,transaction,definition,definition,throws,sqlexception,if,is,enforce,read,only,definition,is,read,only,statement,stmt,con,create,statement,try,stmt,execute,update,set,transaction,read,only,finally,stmt,close
DataSourceTransactionManager -> protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition) 			throws SQLException;1496837955;Prepare the transactional {@code Connection} right after transaction begin._<p>The default implementation executes a "SET TRANSACTION READ ONLY" statement_if the {@link #setEnforceReadOnly "enforceReadOnly"} flag is set to {@code true}_and the transaction definition indicates a read-only transaction._<p>The "SET TRANSACTION READ ONLY" is understood by Oracle, MySQL and Postgres_and may work with other databases as well. If you'd like to adapt this treatment,_override this method accordingly._@param con the transactional JDBC Connection_@param definition the current transaction definition_@throws SQLException if thrown by JDBC API_@since 4.3.7_@see #setEnforceReadOnly;protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)_			throws SQLException {__		if (isEnforceReadOnly() && definition.isReadOnly()) {_			Statement stmt = con.createStatement()__			try {_				stmt.executeUpdate("SET TRANSACTION READ ONLY")__			}_			finally {_				stmt.close()__			}_		}_	};prepare,the,transactional,code,connection,right,after,transaction,begin,p,the,default,implementation,executes,a,set,transaction,read,only,statement,if,the,link,set,enforce,read,only,enforce,read,only,flag,is,set,to,code,true,and,the,transaction,definition,indicates,a,read,only,transaction,p,the,set,transaction,read,only,is,understood,by,oracle,my,sql,and,postgres,and,may,work,with,other,databases,as,well,if,you,d,like,to,adapt,this,treatment,override,this,method,accordingly,param,con,the,transactional,jdbc,connection,param,definition,the,current,transaction,definition,throws,sqlexception,if,thrown,by,jdbc,api,since,4,3,7,see,set,enforce,read,only;protected,void,prepare,transactional,connection,connection,con,transaction,definition,definition,throws,sqlexception,if,is,enforce,read,only,definition,is,read,only,statement,stmt,con,create,statement,try,stmt,execute,update,set,transaction,read,only,finally,stmt,close
DataSourceTransactionManager -> protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition) 			throws SQLException;1498780456;Prepare the transactional {@code Connection} right after transaction begin._<p>The default implementation executes a "SET TRANSACTION READ ONLY" statement_if the {@link #setEnforceReadOnly "enforceReadOnly"} flag is set to {@code true}_and the transaction definition indicates a read-only transaction._<p>The "SET TRANSACTION READ ONLY" is understood by Oracle, MySQL and Postgres_and may work with other databases as well. If you'd like to adapt this treatment,_override this method accordingly._@param con the transactional JDBC Connection_@param definition the current transaction definition_@throws SQLException if thrown by JDBC API_@since 4.3.7_@see #setEnforceReadOnly;protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)_			throws SQLException {__		if (isEnforceReadOnly() && definition.isReadOnly()) {_			Statement stmt = con.createStatement()__			try {_				stmt.executeUpdate("SET TRANSACTION READ ONLY")__			}_			finally {_				stmt.close()__			}_		}_	};prepare,the,transactional,code,connection,right,after,transaction,begin,p,the,default,implementation,executes,a,set,transaction,read,only,statement,if,the,link,set,enforce,read,only,enforce,read,only,flag,is,set,to,code,true,and,the,transaction,definition,indicates,a,read,only,transaction,p,the,set,transaction,read,only,is,understood,by,oracle,my,sql,and,postgres,and,may,work,with,other,databases,as,well,if,you,d,like,to,adapt,this,treatment,override,this,method,accordingly,param,con,the,transactional,jdbc,connection,param,definition,the,current,transaction,definition,throws,sqlexception,if,thrown,by,jdbc,api,since,4,3,7,see,set,enforce,read,only;protected,void,prepare,transactional,connection,connection,con,transaction,definition,definition,throws,sqlexception,if,is,enforce,read,only,definition,is,read,only,statement,stmt,con,create,statement,try,stmt,execute,update,set,transaction,read,only,finally,stmt,close
DataSourceTransactionManager -> protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition) 			throws SQLException;1500448076;Prepare the transactional {@code Connection} right after transaction begin._<p>The default implementation executes a "SET TRANSACTION READ ONLY" statement_if the {@link #setEnforceReadOnly "enforceReadOnly"} flag is set to {@code true}_and the transaction definition indicates a read-only transaction._<p>The "SET TRANSACTION READ ONLY" is understood by Oracle, MySQL and Postgres_and may work with other databases as well. If you'd like to adapt this treatment,_override this method accordingly._@param con the transactional JDBC Connection_@param definition the current transaction definition_@throws SQLException if thrown by JDBC API_@since 4.3.7_@see #setEnforceReadOnly;protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)_			throws SQLException {__		if (isEnforceReadOnly() && definition.isReadOnly()) {_			Statement stmt = con.createStatement()__			try {_				stmt.executeUpdate("SET TRANSACTION READ ONLY")__			}_			finally {_				stmt.close()__			}_		}_	};prepare,the,transactional,code,connection,right,after,transaction,begin,p,the,default,implementation,executes,a,set,transaction,read,only,statement,if,the,link,set,enforce,read,only,enforce,read,only,flag,is,set,to,code,true,and,the,transaction,definition,indicates,a,read,only,transaction,p,the,set,transaction,read,only,is,understood,by,oracle,my,sql,and,postgres,and,may,work,with,other,databases,as,well,if,you,d,like,to,adapt,this,treatment,override,this,method,accordingly,param,con,the,transactional,jdbc,connection,param,definition,the,current,transaction,definition,throws,sqlexception,if,thrown,by,jdbc,api,since,4,3,7,see,set,enforce,read,only;protected,void,prepare,transactional,connection,connection,con,transaction,definition,definition,throws,sqlexception,if,is,enforce,read,only,definition,is,read,only,statement,stmt,con,create,statement,try,stmt,execute,update,set,transaction,read,only,finally,stmt,close
DataSourceTransactionManager -> protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition) 			throws SQLException;1530174524;Prepare the transactional {@code Connection} right after transaction begin._<p>The default implementation executes a "SET TRANSACTION READ ONLY" statement_if the {@link #setEnforceReadOnly "enforceReadOnly"} flag is set to {@code true}_and the transaction definition indicates a read-only transaction._<p>The "SET TRANSACTION READ ONLY" is understood by Oracle, MySQL and Postgres_and may work with other databases as well. If you'd like to adapt this treatment,_override this method accordingly._@param con the transactional JDBC Connection_@param definition the current transaction definition_@throws SQLException if thrown by JDBC API_@since 4.3.7_@see #setEnforceReadOnly;protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)_			throws SQLException {__		if (isEnforceReadOnly() && definition.isReadOnly()) {_			Statement stmt = con.createStatement()__			try {_				stmt.executeUpdate("SET TRANSACTION READ ONLY")__			}_			finally {_				stmt.close()__			}_		}_	};prepare,the,transactional,code,connection,right,after,transaction,begin,p,the,default,implementation,executes,a,set,transaction,read,only,statement,if,the,link,set,enforce,read,only,enforce,read,only,flag,is,set,to,code,true,and,the,transaction,definition,indicates,a,read,only,transaction,p,the,set,transaction,read,only,is,understood,by,oracle,my,sql,and,postgres,and,may,work,with,other,databases,as,well,if,you,d,like,to,adapt,this,treatment,override,this,method,accordingly,param,con,the,transactional,jdbc,connection,param,definition,the,current,transaction,definition,throws,sqlexception,if,thrown,by,jdbc,api,since,4,3,7,see,set,enforce,read,only;protected,void,prepare,transactional,connection,connection,con,transaction,definition,definition,throws,sqlexception,if,is,enforce,read,only,definition,is,read,only,statement,stmt,con,create,statement,try,stmt,execute,update,set,transaction,read,only,finally,stmt,close
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1328020251;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1356735495;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1357119239;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1362408075;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1368482696;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1374672550;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1397137946;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1412253201;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1426267150;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1476521730;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1477661037;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1486062388;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1496259743;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1496837955;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1498780456;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1500448076;Create a new DataSourceTransactionManager instance._@param dataSource JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public DataSourceTransactionManager(DataSource dataSource);1530174524;Create a new DataSourceTransactionManager instance._@param dataSource the JDBC DataSource to manage transactions for;public DataSourceTransactionManager(DataSource dataSource) {_		this()__		setDataSource(dataSource)__		afterPropertiesSet()__	};create,a,new,data,source,transaction,manager,instance,param,data,source,the,jdbc,data,source,to,manage,transactions,for;public,data,source,transaction,manager,data,source,data,source,this,set,data,source,data,source,after,properties,set
DataSourceTransactionManager -> public boolean isEnforceReadOnly();1486062388;Return whether to enforce the read-only nature of a transaction_through an explicit statement on the transactional connection._@since 4.3.7_@see #setEnforceReadOnly;public boolean isEnforceReadOnly() {_		return this.enforceReadOnly__	};return,whether,to,enforce,the,read,only,nature,of,a,transaction,through,an,explicit,statement,on,the,transactional,connection,since,4,3,7,see,set,enforce,read,only;public,boolean,is,enforce,read,only,return,this,enforce,read,only
DataSourceTransactionManager -> public boolean isEnforceReadOnly();1496259743;Return whether to enforce the read-only nature of a transaction_through an explicit statement on the transactional connection._@since 4.3.7_@see #setEnforceReadOnly;public boolean isEnforceReadOnly() {_		return this.enforceReadOnly__	};return,whether,to,enforce,the,read,only,nature,of,a,transaction,through,an,explicit,statement,on,the,transactional,connection,since,4,3,7,see,set,enforce,read,only;public,boolean,is,enforce,read,only,return,this,enforce,read,only
DataSourceTransactionManager -> public boolean isEnforceReadOnly();1496837955;Return whether to enforce the read-only nature of a transaction_through an explicit statement on the transactional connection._@since 4.3.7_@see #setEnforceReadOnly;public boolean isEnforceReadOnly() {_		return this.enforceReadOnly__	};return,whether,to,enforce,the,read,only,nature,of,a,transaction,through,an,explicit,statement,on,the,transactional,connection,since,4,3,7,see,set,enforce,read,only;public,boolean,is,enforce,read,only,return,this,enforce,read,only
DataSourceTransactionManager -> public boolean isEnforceReadOnly();1498780456;Return whether to enforce the read-only nature of a transaction_through an explicit statement on the transactional connection._@since 4.3.7_@see #setEnforceReadOnly;public boolean isEnforceReadOnly() {_		return this.enforceReadOnly__	};return,whether,to,enforce,the,read,only,nature,of,a,transaction,through,an,explicit,statement,on,the,transactional,connection,since,4,3,7,see,set,enforce,read,only;public,boolean,is,enforce,read,only,return,this,enforce,read,only
DataSourceTransactionManager -> public boolean isEnforceReadOnly();1500448076;Return whether to enforce the read-only nature of a transaction_through an explicit statement on the transactional connection._@since 4.3.7_@see #setEnforceReadOnly;public boolean isEnforceReadOnly() {_		return this.enforceReadOnly__	};return,whether,to,enforce,the,read,only,nature,of,a,transaction,through,an,explicit,statement,on,the,transactional,connection,since,4,3,7,see,set,enforce,read,only;public,boolean,is,enforce,read,only,return,this,enforce,read,only
DataSourceTransactionManager -> public boolean isEnforceReadOnly();1530174524;Return whether to enforce the read-only nature of a transaction_through an explicit statement on the transactional connection._@since 4.3.7_@see #setEnforceReadOnly;public boolean isEnforceReadOnly() {_		return this.enforceReadOnly__	};return,whether,to,enforce,the,read,only,nature,of,a,transaction,through,an,explicit,statement,on,the,transactional,connection,since,4,3,7,see,set,enforce,read,only;public,boolean,is,enforce,read,only,return,this,enforce,read,only
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1328020251;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example a_Jakarta Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,a,jakarta,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1356735495;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example a_Jakarta Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,a,jakarta,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1357119239;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example a_Jakarta Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,a,jakarta,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1362408075;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example a_Jakarta Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,a,jakarta,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1368482696;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example a_Jakarta Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,a,jakarta,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1374672550;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example a_Jakarta Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,a,jakarta,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1397137946;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example a_Jakarta Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,a,jakarta,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1412253201;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example a_Jakarta Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,a,jakarta,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1426267150;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example an_Apache Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,an,apache,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1476521730;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example an_Apache Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,an,apache,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1477661037;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example an_Apache Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,an,apache,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1486062388;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example an_Apache Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,an,apache,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1496259743;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example an_Apache Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,an,apache,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1496837955;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example an_Apache Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,an,apache,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
DataSourceTransactionManager -> public void setDataSource(DataSource dataSource);1498780456;Set the JDBC DataSource that this instance should manage transactions for._<p>This will typically be a locally defined DataSource, for example an_Apache Commons DBCP connection pool. Alternatively, you can also drive_transactions for a non-XA J2EE DataSource fetched from JNDI. For an XA_DataSource, use JtaTransactionManager._<p>The DataSource specified here should be the target DataSource to manage_transactions for, not a TransactionAwareDataSourceProxy. Only data access_code may work with TransactionAwareDataSourceProxy, while the transaction_manager needs to work on the underlying target DataSource. If there's_nevertheless a TransactionAwareDataSourceProxy passed in, it will be_unwrapped to extract its target DataSource._<p><b>The DataSource passed in here needs to return independent Connections.</b>_The Connections may come from a pool (the typical case), but the DataSource_must not return thread-scoped / request-scoped Connections or the like._@see TransactionAwareDataSourceProxy_@see org.springframework.transaction.jta.JtaTransactionManager;public void setDataSource(DataSource dataSource) {_		if (dataSource instanceof TransactionAwareDataSourceProxy) {_			_			_			_			this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource()__		}_		else {_			this.dataSource = dataSource__		}_	};set,the,jdbc,data,source,that,this,instance,should,manage,transactions,for,p,this,will,typically,be,a,locally,defined,data,source,for,example,an,apache,commons,dbcp,connection,pool,alternatively,you,can,also,drive,transactions,for,a,non,xa,j2ee,data,source,fetched,from,jndi,for,an,xa,data,source,use,jta,transaction,manager,p,the,data,source,specified,here,should,be,the,target,data,source,to,manage,transactions,for,not,a,transaction,aware,data,source,proxy,only,data,access,code,may,work,with,transaction,aware,data,source,proxy,while,the,transaction,manager,needs,to,work,on,the,underlying,target,data,source,if,there,s,nevertheless,a,transaction,aware,data,source,proxy,passed,in,it,will,be,unwrapped,to,extract,its,target,data,source,p,b,the,data,source,passed,in,here,needs,to,return,independent,connections,b,the,connections,may,come,from,a,pool,the,typical,case,but,the,data,source,must,not,return,thread,scoped,request,scoped,connections,or,the,like,see,transaction,aware,data,source,proxy,see,org,springframework,transaction,jta,jta,transaction,manager;public,void,set,data,source,data,source,data,source,if,data,source,instanceof,transaction,aware,data,source,proxy,this,data,source,transaction,aware,data,source,proxy,data,source,get,target,data,source,else,this,data,source,data,source
