commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;36;;@Override @Nullable protected DataAccessException doTranslate(String task, @Nullable String sql, SQLException ex) {     // First, the getSQLState check...     String sqlState = getSqlState(ex).     if (sqlState != null && sqlState.length() >= 2) {         String classCode = sqlState.substring(0, 2).         if (logger.isDebugEnabled()) {             logger.debug("Extracted SQL state class '" + classCode + "' from value '" + sqlState + "'").         }         if (BAD_SQL_GRAMMAR_CODES.contains(classCode)) {             return new BadSqlGrammarException(task, (sql != null ? sql : ""), ex).         } else if (DATA_INTEGRITY_VIOLATION_CODES.contains(classCode)) {             return new DataIntegrityViolationException(buildMessage(task, sql, ex), ex).         } else if (DATA_ACCESS_RESOURCE_FAILURE_CODES.contains(classCode)) {             return new DataAccessResourceFailureException(buildMessage(task, sql, ex), ex).         } else if (TRANSIENT_DATA_ACCESS_RESOURCE_CODES.contains(classCode)) {             return new TransientDataAccessResourceException(buildMessage(task, sql, ex), ex).         } else if (CONCURRENCY_FAILURE_CODES.contains(classCode)) {             return new ConcurrencyFailureException(buildMessage(task, sql, ex), ex).         }     }     // (since MySQL doesn't throw the JDBC 4 SQLTimeoutException)     if (ex.getClass().getName().contains("Timeout")) {         return new QueryTimeoutException(buildMessage(task, sql, ex), ex).     }     // Couldn't resolve anything proper - resort to UncategorizedSQLException.     return null. }
true;private;1;11;/**  * Gets the SQL state code from the supplied {@link SQLException exception}.  * <p>Some JDBC drivers nest the actual exception from a batched update, so we  * might need to dig down into the nested exception.  * @param ex the exception from which the {@link SQLException#getSQLState() SQL state}  * is to be extracted  * @return the SQL state code  */ ;/**  * Gets the SQL state code from the supplied {@link SQLException exception}.  * <p>Some JDBC drivers nest the actual exception from a batched update, so we  * might need to dig down into the nested exception.  * @param ex the exception from which the {@link SQLException#getSQLState() SQL state}  * is to be extracted  * @return the SQL state code  */ @Nullable private String getSqlState(SQLException ex) {     String sqlState = ex.getSQLState().     if (sqlState == null) {         SQLException nestedEx = ex.getNextException().         if (nestedEx != null) {             sqlState = nestedEx.getSQLState().         }     }     return sqlState. }
