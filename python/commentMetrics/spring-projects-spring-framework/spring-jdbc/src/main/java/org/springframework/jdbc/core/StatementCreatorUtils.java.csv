# id;timestamp;commentText;codeText;commentWords;codeWords
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1381881108;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			sqlType = Types.NULL__			try {_				sqlType = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			catch (Throwable ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__				}_				_				try {_					DatabaseMetaData dbmd = ps.getConnection().getMetaData()__					String databaseProductName = dbmd.getDatabaseProductName()__					String jdbcDriverName = dbmd.getDriverName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlType = Types.VARCHAR__					}_				}_				catch (Throwable ex2) {_					logger.debug("Could not check database or driver name", ex2)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlType)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,sql,type,types,null,try,sql,type,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,try,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,database,product,name,dbmd,get,database,product,name,string,jdbc,driver,name,dbmd,get,driver,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,types,varchar,catch,throwable,ex2,logger,debug,could,not,check,database,or,driver,name,ex2,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1385412762;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			sqlType = Types.NULL__			try {_				sqlType = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			catch (Throwable ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__				}_				_				try {_					DatabaseMetaData dbmd = ps.getConnection().getMetaData()__					String databaseProductName = dbmd.getDatabaseProductName()__					String jdbcDriverName = dbmd.getDriverName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlType = Types.VARCHAR__					}_				}_				catch (Throwable ex2) {_					logger.debug("Could not check database or driver name", ex2)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlType)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,sql,type,types,null,try,sql,type,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,try,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,database,product,name,dbmd,get,database,product,name,string,jdbc,driver,name,dbmd,get,driver,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,types,varchar,catch,throwable,ex2,logger,debug,could,not,check,database,or,driver,name,ex2,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1386635937;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = true__			if (!driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,true,if,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1386678412;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = true__			if (!driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,true,if,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1391528648;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1391532102;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1397137904;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1404239423;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1408474374;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1411771235;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1429214031;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1449506272;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType) {_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_							_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1451384361;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType &&_							!(jdbcDriverName.startsWith("Oracle") && dbmd.getDriverMajorVersion() >= 12)) {_						_						_						_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_							_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,jdbc,driver,name,starts,with,oracle,dbmd,get,driver,major,version,12,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1459847556;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType &&_							!(jdbcDriverName.startsWith("Oracle") && dbmd.getDriverMajorVersion() >= 12)) {_						_						_						_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_							_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,jdbc,driver,name,starts,with,oracle,dbmd,get,driver,major,version,12,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1459851441;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType &&_							!(jdbcDriverName.startsWith("Oracle") && dbmd.getDriverMajorVersion() >= 12)) {_						_						_						_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_							_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,jdbc,driver,name,starts,with,oracle,dbmd,get,driver,major,version,12,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1467730834;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType &&_							!(jdbcDriverName.startsWith("Oracle") && dbmd.getDriverMajorVersion() >= 12)) {_						_						_						_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_							_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,jdbc,driver,name,starts,with,oracle,dbmd,get,driver,major,version,12,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1469561191;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			DatabaseMetaData dbmd = null__			String jdbcDriverName = null__			boolean checkGetParameterType = !shouldIgnoreGetParameterType__			if (checkGetParameterType && !driversWithNoSupportForGetParameterType.isEmpty()) {_				try {_					dbmd = ps.getConnection().getMetaData()__					jdbcDriverName = dbmd.getDriverName()__					checkGetParameterType = !driversWithNoSupportForGetParameterType.contains(jdbcDriverName)__				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (checkGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (Throwable ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC 3.0 getParameterType call not supported - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				try {_					if (dbmd == null) {_						dbmd = ps.getConnection().getMetaData()__					}_					if (jdbcDriverName == null) {_						jdbcDriverName = dbmd.getDriverName()__					}_					if (checkGetParameterType &&_							!(jdbcDriverName.startsWith("Oracle") && dbmd.getDriverMajorVersion() >= 12)) {_						_						_						_						driversWithNoSupportForGetParameterType.add(jdbcDriverName)__					}_					String databaseProductName = dbmd.getDatabaseProductName()__					if (databaseProductName.startsWith("Informix") ||_							(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_							_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlTypeToUse = Types.VARCHAR__					}_				}_				catch (Throwable ex) {_					logger.debug("Could not check connection metadata", ex)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,database,meta,data,dbmd,null,string,jdbc,driver,name,null,boolean,check,get,parameter,type,should,ignore,get,parameter,type,if,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,is,empty,try,dbmd,ps,get,connection,get,meta,data,jdbc,driver,name,dbmd,get,driver,name,check,get,parameter,type,drivers,with,no,support,for,get,parameter,type,contains,jdbc,driver,name,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,check,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,try,if,dbmd,null,dbmd,ps,get,connection,get,meta,data,if,jdbc,driver,name,null,jdbc,driver,name,dbmd,get,driver,name,if,check,get,parameter,type,jdbc,driver,name,starts,with,oracle,dbmd,get,driver,major,version,12,drivers,with,no,support,for,get,parameter,type,add,jdbc,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,catch,throwable,ex,logger,debug,could,not,check,connection,metadata,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1469695889;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			if (!shouldIgnoreGetParameterType) {_				sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String jdbcDriverName = dbmd.getDriverName()__				String databaseProductName = dbmd.getDatabaseProductName()__				if (databaseProductName.startsWith("Informix") ||_						(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_						_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlTypeToUse = Types.VARCHAR__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,if,should,ignore,get,parameter,type,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,if,sql,type,to,use,null,sql,type,to,use,types,null,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,jdbc,driver,name,dbmd,get,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1495868221;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			if (!shouldIgnoreGetParameterType) {_				sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String jdbcDriverName = dbmd.getDriverName()__				String databaseProductName = dbmd.getDatabaseProductName()__				if (databaseProductName.startsWith("Informix") ||_						(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_						_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlTypeToUse = Types.VARCHAR__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,if,should,ignore,get,parameter,type,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,if,sql,type,to,use,null,sql,type,to,use,types,null,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,jdbc,driver,name,dbmd,get,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1496242568;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			if (!shouldIgnoreGetParameterType) {_				sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String jdbcDriverName = dbmd.getDriverName()__				String databaseProductName = dbmd.getDatabaseProductName()__				if (databaseProductName.startsWith("Informix") ||_						(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_						_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlTypeToUse = Types.VARCHAR__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,if,should,ignore,get,parameter,type,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,if,sql,type,to,use,null,sql,type,to,use,types,null,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,jdbc,driver,name,dbmd,get,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException;1496259743;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) throws SQLException {_		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			if (!shouldIgnoreGetParameterType) {_				sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String jdbcDriverName = dbmd.getDriverName()__				String databaseProductName = dbmd.getDatabaseProductName()__				if (databaseProductName.startsWith("Informix") ||_						(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_						_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlTypeToUse = Types.VARCHAR__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,if,should,ignore,get,parameter,type,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,if,sql,type,to,use,null,sql,type,to,use,types,null,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,jdbc,driver,name,dbmd,get,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1385412762;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1386635937;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1386678412;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1391528648;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1391532102;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1397137904;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1404239423;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1408474374;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1411771235;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1429214031;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1449506272;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1451384361;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1459847556;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1459851441;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1467730834;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1469561191;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1469695889;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1496242568;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@link SqlTypeValue#TYPE_UNKNOWN} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,link,sql,type,value,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class<?> javaType);1496259743;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@link SqlTypeValue#TYPE_UNKNOWN} if none found;public static int javaTypeToSqlParameterType(Class<?> javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,link,sql,type,value,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, 			@Nullable Object inValue) throws SQLException;1498780456;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, 			@Nullable Object inValue) throws SQLException;1505897689;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, 			@Nullable Object inValue) throws SQLException;1509749324;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, 			@Nullable Object inValue) throws SQLException;1522359833;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1385412762;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1386635937;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1386678412;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1391528648;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1391532102;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1397137904;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1404239423;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1408474374;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1411771235;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1429214031;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1449506272;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1451384361;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1459847556;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1459851441;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1467730834;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1469561191;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection<?> paramValues);1469695889;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException;1496837955;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,nullable,integer,scale,nullable,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException;1498780456;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,nullable,integer,scale,nullable,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException;1505897689;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,nullable,integer,scale,nullable,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException;1509749324;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,nullable,integer,scale,nullable,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException;1522359833;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			@Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,nullable,integer,scale,nullable,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1381881108;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1385412762;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1386635937;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1386678412;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1391528648;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1391532102;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1397137904;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1404239423;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1408474374;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1411771235;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1429214031;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1449506272;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1451384361;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1459847556;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1459851441;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1467730834;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1469561191;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1469695889;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1495868221;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType, 			String typeName, Integer scale, Object inValue) throws SQLException;1496242568;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,_			String typeName, Integer scale, Object inValue) throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() + ", type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> public static void cleanupParameters(Object[] paramValues);1328020251;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be <code>null</code>._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object[] paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,code,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object[] paramValues);1356735495;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object[] paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object[] paramValues);1362408075;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object[] paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object[] paramValues);1365871149;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object[] paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object[] paramValues);1381786313;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object[] paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object[] paramValues);1381881108;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object[] paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object[] paramValues);1385412762;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object[] paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object[] paramValues);1386635937;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object[] paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue) 			throws SQLException;1328020251;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue) 			throws SQLException;1356735495;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue) 			throws SQLException;1362408075;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue) 			throws SQLException;1365871149;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue) 			throws SQLException;1381786313;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1328020251;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1356735495;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1362408075;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1365871149;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1381786313;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1328020251;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1356735495;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1362408075;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1365871149;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue( 			PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1381786313;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(_			PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1385412762;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1386635937;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1386678412;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1391528648;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1391532102;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1397137904;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1404239423;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1408474374;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1411771235;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1429214031;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1449506272;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1451384361;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1459847556;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1459851441;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1467730834;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1469561191;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1469695889;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1495868221;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1496242568;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1496259743;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1496837955;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1498780456;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1505897689;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1509749324;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class<?> inValueType);1522359833;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class<?> inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			@Nullable Object inValue) throws SQLException;1498780456;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			@Nullable Object inValue) throws SQLException;1505897689;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			@Nullable Object inValue) throws SQLException;1509749324;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			@Nullable Object inValue) throws SQLException;1522359833;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> private static void setParameterValueInternal( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue) 			throws SQLException;1328020251;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue)_			throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding typeinfo with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() +_						", Type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,typeinfo,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue) 			throws SQLException;1356735495;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue)_			throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding typeinfo with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() +_						", Type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,typeinfo,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue) 			throws SQLException;1362408075;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue)_			throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() +_						", Type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue) 			throws SQLException;1365871149;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue)_			throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() +_						", Type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> private static void setParameterValueInternal( 			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue) 			throws SQLException;1381786313;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param scale the number of digits after the decimal point_(for DECIMAL and NUMERIC types)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;private static void setParameterValueInternal(_			PreparedStatement ps, int paramIndex, int sqlType, String typeName, Integer scale, Object inValue)_			throws SQLException {__		String typeNameToUse = typeName__		int sqlTypeToUse = sqlType__		Object inValueToUse = inValue___		_		if (inValue instanceof SqlParameterValue) {_			SqlParameterValue parameterValue = (SqlParameterValue) inValue__			if (logger.isDebugEnabled()) {_				logger.debug("Overriding type info with runtime info from SqlParameterValue: column index " + paramIndex +_						", SQL type " + parameterValue.getSqlType() +_						", Type name " + parameterValue.getTypeName())__			}_			if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {_				sqlTypeToUse = parameterValue.getSqlType()__			}_			if (parameterValue.getTypeName() != null) {_				typeNameToUse = parameterValue.getTypeName()__			}_			inValueToUse = parameterValue.getValue()__		}__		if (logger.isTraceEnabled()) {_			logger.trace("Setting SQL statement parameter value: column index " + paramIndex +_					", parameter value [" + inValueToUse +_					"], value class [" + (inValueToUse != null ? inValueToUse.getClass().getName() : "null") +_					"], SQL type " + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? "unknown" : Integer.toString(sqlTypeToUse)))__		}__		if (inValueToUse == null) {_			setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse)__		}_		else {_			setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse)__		}_	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,scale,the,number,of,digits,after,the,decimal,point,for,decimal,and,numeric,types,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;private,static,void,set,parameter,value,internal,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,integer,scale,object,in,value,throws,sqlexception,string,type,name,to,use,type,name,int,sql,type,to,use,sql,type,object,in,value,to,use,in,value,if,in,value,instanceof,sql,parameter,value,sql,parameter,value,parameter,value,sql,parameter,value,in,value,if,logger,is,debug,enabled,logger,debug,overriding,type,info,with,runtime,info,from,sql,parameter,value,column,index,param,index,sql,type,parameter,value,get,sql,type,type,name,parameter,value,get,type,name,if,parameter,value,get,sql,type,sql,type,value,sql,type,to,use,parameter,value,get,sql,type,if,parameter,value,get,type,name,null,type,name,to,use,parameter,value,get,type,name,in,value,to,use,parameter,value,get,value,if,logger,is,trace,enabled,logger,trace,setting,sql,statement,parameter,value,column,index,param,index,parameter,value,in,value,to,use,value,class,in,value,to,use,null,in,value,to,use,get,class,get,name,null,sql,type,sql,type,to,use,sql,type,value,unknown,integer,to,string,sql,type,to,use,if,in,value,to,use,null,set,null,ps,param,index,sql,type,to,use,type,name,to,use,else,set,value,ps,param,index,sql,type,to,use,type,name,to,use,scale,in,value,to,use
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class javaType);1328020251;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or <code>null</code> if none found;public static int javaTypeToSqlParameterType(Class javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,code,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class javaType);1356735495;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class javaType);1362408075;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class javaType);1365871149;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class javaType);1381786313;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(Class javaType);1381881108;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@code null} if none found;public static int javaTypeToSqlParameterType(Class javaType) {_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,code,null,if,none,found;public,static,int,java,type,to,sql,parameter,type,class,java,type,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1386678412;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1391528648;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1391532102;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1397137904;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1404239423;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1408474374;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1411771235;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1429214031;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1449506272;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1451384361;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1459847556;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1459851441;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1467730834;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1469561191;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(Object... paramValues);1469695889;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> private static boolean isDateValue(Class inValueType);1328020251;Check whether the given value is a <code>java.util.Date</code>_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,code,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class inValueType);1356735495;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class inValueType);1362408075;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class inValueType);1365871149;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class inValueType);1381786313;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class inValueType);1381881108;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) 			throws SQLException;1328020251;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			sqlType = Types.NULL__			try {_				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String databaseProductName = dbmd.getDatabaseProductName()__				String jdbcDriverName = dbmd.getDriverName()__				if (databaseProductName.startsWith("Informix") ||_						jdbcDriverName.startsWith("Microsoft SQL Server")) {_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlType = Types.VARCHAR__				}_			}_			catch (Throwable ex) {_				logger.debug("Could not check database or driver name", ex)__			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlType)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,sql,type,types,null,try,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,database,product,name,dbmd,get,database,product,name,string,jdbc,driver,name,dbmd,get,driver,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,types,varchar,catch,throwable,ex,logger,debug,could,not,check,database,or,driver,name,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) 			throws SQLException;1356735495;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			sqlType = Types.NULL__			try {_				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String databaseProductName = dbmd.getDatabaseProductName()__				String jdbcDriverName = dbmd.getDriverName()__				if (databaseProductName.startsWith("Informix") ||_						jdbcDriverName.startsWith("Microsoft SQL Server")) {_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlType = Types.VARCHAR__				}_			}_			catch (Throwable ex) {_				logger.debug("Could not check database or driver name", ex)__			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlType)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,sql,type,types,null,try,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,database,product,name,dbmd,get,database,product,name,string,jdbc,driver,name,dbmd,get,driver,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,types,varchar,catch,throwable,ex,logger,debug,could,not,check,database,or,driver,name,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) 			throws SQLException;1362408075;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			sqlType = Types.NULL__			try {_				ParameterMetaData pmd = null__				try {_					pmd = ps.getParameterMetaData()__				}_				catch (Throwable ex) {_					_					_				}_				if (pmd != null) {_					sqlType = pmd.getParameterType(paramIndex)__				}_				else {_					DatabaseMetaData dbmd = ps.getConnection().getMetaData()__					String databaseProductName = dbmd.getDatabaseProductName()__					String jdbcDriverName = dbmd.getDriverName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlType = Types.VARCHAR__					}_				}_			}_			catch (Throwable ex) {_				logger.debug("Could not check database or driver name", ex)__			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlType)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,sql,type,types,null,try,parameter,meta,data,pmd,null,try,pmd,ps,get,parameter,meta,data,catch,throwable,ex,if,pmd,null,sql,type,pmd,get,parameter,type,param,index,else,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,database,product,name,dbmd,get,database,product,name,string,jdbc,driver,name,dbmd,get,driver,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,types,varchar,catch,throwable,ex,logger,debug,could,not,check,database,or,driver,name,ex,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) 			throws SQLException;1365871149;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			sqlType = Types.NULL__			try {_				sqlType = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			catch (Throwable ex) {_				logger.debug("JDBC 3.0 getParameterType call not supported", ex)__				_				_				try {_					DatabaseMetaData dbmd = ps.getConnection().getMetaData()__					String databaseProductName = dbmd.getDatabaseProductName()__					String jdbcDriverName = dbmd.getDriverName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlType = Types.VARCHAR__					}_				}_				catch (Throwable ex2) {_					logger.debug("Could not check database or driver name", ex2)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlType)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,sql,type,types,null,try,sql,type,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,ex,try,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,database,product,name,dbmd,get,database,product,name,string,jdbc,driver,name,dbmd,get,driver,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,types,varchar,catch,throwable,ex2,logger,debug,could,not,check,database,or,driver,name,ex2,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName) 			throws SQLException;1381786313;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN) {_			boolean useSetObject = false__			sqlType = Types.NULL__			try {_				sqlType = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			catch (Throwable ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("JDBC 3.0 getParameterType call not supported: " + ex)__				}_				_				_				try {_					DatabaseMetaData dbmd = ps.getConnection().getMetaData()__					String databaseProductName = dbmd.getDatabaseProductName()__					String jdbcDriverName = dbmd.getDriverName()__					if (databaseProductName.startsWith("Informix") ||_							jdbcDriverName.startsWith("Microsoft SQL Server")) {_						useSetObject = true__					}_					else if (databaseProductName.startsWith("DB2") ||_							jdbcDriverName.startsWith("jConnect") ||_							jdbcDriverName.startsWith("SQLServer")||_							jdbcDriverName.startsWith("Apache Derby")) {_						sqlType = Types.VARCHAR__					}_				}_				catch (Throwable ex2) {_					logger.debug("Could not check database or driver name", ex2)__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlType)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,boolean,use,set,object,false,sql,type,types,null,try,sql,type,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,jdbc,3,0,get,parameter,type,call,not,supported,ex,try,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,database,product,name,dbmd,get,database,product,name,string,jdbc,driver,name,dbmd,get,driver,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,types,varchar,catch,throwable,ex2,logger,debug,could,not,check,database,or,driver,name,ex2,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, 			@Nullable Object inValue) throws SQLException;1498780456;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, 			@Nullable Object inValue) throws SQLException;1505897689;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, 			@Nullable Object inValue) throws SQLException;1509749324;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, 			@Nullable Object inValue) throws SQLException;1522359833;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param,_			@Nullable Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,nullable,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType);1496837955;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@link SqlTypeValue#TYPE_UNKNOWN} if none found;public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType) {_		if (javaType == null) {_			return SqlTypeValue.TYPE_UNKNOWN__		}_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,link,sql,type,value,if,none,found;public,static,int,java,type,to,sql,parameter,type,nullable,class,java,type,if,java,type,null,return,sql,type,value,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType);1498780456;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@link SqlTypeValue#TYPE_UNKNOWN} if none found;public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType) {_		if (javaType == null) {_			return SqlTypeValue.TYPE_UNKNOWN__		}_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,link,sql,type,value,if,none,found;public,static,int,java,type,to,sql,parameter,type,nullable,class,java,type,if,java,type,null,return,sql,type,value,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType);1505897689;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@link SqlTypeValue#TYPE_UNKNOWN} if none found;public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType) {_		if (javaType == null) {_			return SqlTypeValue.TYPE_UNKNOWN__		}_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,link,sql,type,value,if,none,found;public,static,int,java,type,to,sql,parameter,type,nullable,class,java,type,if,java,type,null,return,sql,type,value,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType);1509749324;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@link SqlTypeValue#TYPE_UNKNOWN} if none found;public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType) {_		if (javaType == null) {_			return SqlTypeValue.TYPE_UNKNOWN__		}_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,link,sql,type,value,if,none,found;public,static,int,java,type,to,sql,parameter,type,nullable,class,java,type,if,java,type,null,return,sql,type,value,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType);1522359833;Derive a default SQL type from the given Java type._@param javaType the Java type to translate_@return the corresponding SQL type, or {@link SqlTypeValue#TYPE_UNKNOWN} if none found;public static int javaTypeToSqlParameterType(@Nullable Class<?> javaType) {_		if (javaType == null) {_			return SqlTypeValue.TYPE_UNKNOWN__		}_		Integer sqlType = javaTypeToSqlTypeMap.get(javaType)__		if (sqlType != null) {_			return sqlType__		}_		if (Number.class.isAssignableFrom(javaType)) {_			return Types.NUMERIC__		}_		if (isStringValue(javaType)) {_			return Types.VARCHAR__		}_		if (isDateValue(javaType) || Calendar.class.isAssignableFrom(javaType)) {_			return Types.TIMESTAMP__		}_		return SqlTypeValue.TYPE_UNKNOWN__	};derive,a,default,sql,type,from,the,given,java,type,param,java,type,the,java,type,to,translate,return,the,corresponding,sql,type,or,link,sql,type,value,if,none,found;public,static,int,java,type,to,sql,parameter,type,nullable,class,java,type,if,java,type,null,return,sql,type,value,integer,sql,type,java,type,to,sql,type,map,get,java,type,if,sql,type,null,return,sql,type,if,number,class,is,assignable,from,java,type,return,types,numeric,if,is,string,value,java,type,return,types,varchar,if,is,date,value,java,type,calendar,class,is,assignable,from,java,type,return,types,timestamp,return,sql,type,value
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Object... paramValues);1495868221;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Object... paramValues);1496242568;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Object... paramValues);1496259743;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Object... paramValues);1496837955;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Object... paramValues);1498780456;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Object... paramValues);1505897689;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Object... paramValues);1509749324;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Object... paramValues);1522359833;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Object... paramValues) {_		if (paramValues != null) {_			cleanupParameters(Arrays.asList(paramValues))__		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,object,param,values,if,param,values,null,cleanup,parameters,arrays,as,list,param,values
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1381881108;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1385412762;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1386635937;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1386678412;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1391528648;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1391532102;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1397137904;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1404239423;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1408474374;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1411771235;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1429214031;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1449506272;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1451384361;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1459847556;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1459851441;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1467730834;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1469561191;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1469695889;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1495868221;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1496242568;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1496259743;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue) 			throws SQLException;1496837955;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, null, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,null,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1381881108;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1385412762;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1386635937;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1386678412;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1391528648;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1391532102;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1397137904;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1404239423;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1408474374;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1411771235;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1429214031;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1449506272;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1451384361;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1459847556;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1459851441;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1467730834;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1469561191;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1469695889;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1495868221;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1496242568;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1496259743;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue) 			throws SQLException;1496837955;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param param the parameter as it is declared including type_@param inValue the value to set_@throws SQLException if thrown by PreparedStatement methods;public static void setParameterValue(PreparedStatement ps, int paramIndex, SqlParameter param, Object inValue)_			throws SQLException {__		setParameterValueInternal(ps, paramIndex, param.getSqlType(), param.getTypeName(), param.getScale(), inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,param,the,parameter,as,it,is,declared,including,type,param,in,value,the,value,to,set,throws,sqlexception,if,thrown,by,prepared,statement,methods;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,sql,parameter,param,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,param,get,sql,type,param,get,type,name,param,get,scale,in,value
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1385412762;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1386635937;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1386678412;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1391528648;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1391532102;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1397137904;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1404239423;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1408474374;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1411771235;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1429214031;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1449506272;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1451384361;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1459847556;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1459851441;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1467730834;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1469561191;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1469695889;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1495868221;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1496242568;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1496259743;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1496837955;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1498780456;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1505897689;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1509749324;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isDateValue(Class<?> inValueType);1522359833;Check whether the given value is a {@code java.util.Date}_(but not one of the JDBC-specific subclasses).;private static boolean isDateValue(Class<?> inValueType) {_		return (java.util.Date.class.isAssignableFrom(inValueType) &&_				!(java.sql.Date.class.isAssignableFrom(inValueType) ||_						java.sql.Time.class.isAssignableFrom(inValueType) ||_						java.sql.Timestamp.class.isAssignableFrom(inValueType)))__	};check,whether,the,given,value,is,a,code,java,util,date,but,not,one,of,the,jdbc,specific,subclasses;private,static,boolean,is,date,value,class,in,value,type,return,java,util,date,class,is,assignable,from,in,value,type,java,sql,date,class,is,assignable,from,in,value,type,java,sql,time,class,is,assignable,from,in,value,type,java,sql,timestamp,class,is,assignable,from,in,value,type
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Collection<?> paramValues);1495868221;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Collection<?> paramValues);1496242568;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Collection<?> paramValues);1496259743;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Collection<?> paramValues);1496837955;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Collection<?> paramValues);1498780456;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Collection<?> paramValues);1505897689;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Collection<?> paramValues);1509749324;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(@Nullable Collection<?> paramValues);1522359833;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(@Nullable Collection<?> paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,nullable,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection paramValues);1328020251;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be <code>null</code>._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,code,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection paramValues);1356735495;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection paramValues);1362408075;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection paramValues);1365871149;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection paramValues);1381786313;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void cleanupParameters(Collection paramValues);1381881108;Clean up all resources held by parameter values which were passed to an_execute method. This is for example important for closing LOB values._@param paramValues parameter values supplied. May be {@code null}._@see DisposableSqlTypeValue#cleanup()_@see org.springframework.jdbc.core.support.SqlLobValue#cleanup();public static void cleanupParameters(Collection paramValues) {_		if (paramValues != null) {_			for (Object inValue : paramValues) {_				if (inValue instanceof DisposableSqlTypeValue) {_					((DisposableSqlTypeValue) inValue).cleanup()__				}_				else if (inValue instanceof SqlValue) {_					((SqlValue) inValue).cleanup()__				}_			}_		}_	};clean,up,all,resources,held,by,parameter,values,which,were,passed,to,an,execute,method,this,is,for,example,important,for,closing,lob,values,param,param,values,parameter,values,supplied,may,be,code,null,see,disposable,sql,type,value,cleanup,see,org,springframework,jdbc,core,support,sql,lob,value,cleanup;public,static,void,cleanup,parameters,collection,param,values,if,param,values,null,for,object,in,value,param,values,if,in,value,instanceof,disposable,sql,type,value,disposable,sql,type,value,in,value,cleanup,else,if,in,value,instanceof,sql,value,sql,value,in,value,cleanup
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1381881108;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1385412762;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1386635937;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1386678412;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1391528648;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1391532102;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1397137904;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1404239423;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1408474374;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1411771235;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1429214031;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1449506272;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1451384361;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1459847556;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1459851441;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1467730834;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1469561191;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1469695889;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1495868221;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1496242568;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1496259743;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName, 			Object inValue) throws SQLException;1496837955;Set the value for a parameter. The method used is based on the SQL type_of the parameter and we can handle complex types like arrays and LOBs._@param ps the prepared statement or callable statement_@param paramIndex index of the parameter we are setting_@param sqlType the SQL type of the parameter_@param typeName the type name of the parameter_(optional, only used for SQL NULL and SqlTypeValue)_@param inValue the value to set (plain value or a SqlTypeValue)_@throws SQLException if thrown by PreparedStatement methods_@see SqlTypeValue;public static void setParameterValue(PreparedStatement ps, int paramIndex, int sqlType, String typeName,_			Object inValue) throws SQLException {__		setParameterValueInternal(ps, paramIndex, sqlType, typeName, null, inValue)__	};set,the,value,for,a,parameter,the,method,used,is,based,on,the,sql,type,of,the,parameter,and,we,can,handle,complex,types,like,arrays,and,lobs,param,ps,the,prepared,statement,or,callable,statement,param,param,index,index,of,the,parameter,we,are,setting,param,sql,type,the,sql,type,of,the,parameter,param,type,name,the,type,name,of,the,parameter,optional,only,used,for,sql,null,and,sql,type,value,param,in,value,the,value,to,set,plain,value,or,a,sql,type,value,throws,sqlexception,if,thrown,by,prepared,statement,methods,see,sql,type,value;public,static,void,set,parameter,value,prepared,statement,ps,int,param,index,int,sql,type,string,type,name,object,in,value,throws,sqlexception,set,parameter,value,internal,ps,param,index,sql,type,type,name,null,in,value
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName) 			throws SQLException;1496837955;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			if (!shouldIgnoreGetParameterType) {_				sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String jdbcDriverName = dbmd.getDriverName()__				String databaseProductName = dbmd.getDatabaseProductName()__				if (databaseProductName.startsWith("Informix") ||_						(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_						_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlTypeToUse = Types.VARCHAR__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,if,should,ignore,get,parameter,type,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,if,sql,type,to,use,null,sql,type,to,use,types,null,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,jdbc,driver,name,dbmd,get,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName) 			throws SQLException;1498780456;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			if (!shouldIgnoreGetParameterType) {_				sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String jdbcDriverName = dbmd.getDriverName()__				String databaseProductName = dbmd.getDatabaseProductName()__				if (databaseProductName.startsWith("Informix") ||_						(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_						_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlTypeToUse = Types.VARCHAR__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,if,should,ignore,get,parameter,type,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,if,sql,type,to,use,null,sql,type,to,use,types,null,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,jdbc,driver,name,dbmd,get,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName) 			throws SQLException;1505897689;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			if (!shouldIgnoreGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (SQLException ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC getParameterType call failed - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String jdbcDriverName = dbmd.getDriverName()__				String databaseProductName = dbmd.getDatabaseProductName()__				if (databaseProductName.startsWith("Informix") ||_						(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_						_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlTypeToUse = Types.VARCHAR__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,if,should,ignore,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,sqlexception,ex,if,logger,is,debug,enabled,logger,debug,jdbc,get,parameter,type,call,failed,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,jdbc,driver,name,dbmd,get,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName) 			throws SQLException;1509749324;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || sqlType == Types.OTHER) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			if (!shouldIgnoreGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (SQLException ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC getParameterType call failed - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String jdbcDriverName = dbmd.getDriverName()__				String databaseProductName = dbmd.getDatabaseProductName()__				if (databaseProductName.startsWith("Informix") ||_						(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_						_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlTypeToUse = Types.VARCHAR__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,boolean,use,set,object,false,integer,sql,type,to,use,null,if,should,ignore,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,sqlexception,ex,if,logger,is,debug,enabled,logger,debug,jdbc,get,parameter,type,call,failed,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,jdbc,driver,name,dbmd,get,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName) 			throws SQLException;1522359833;Set the specified PreparedStatement parameter to null,_respecting database-specific peculiarities.;private static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)_			throws SQLException {__		if (sqlType == SqlTypeValue.TYPE_UNKNOWN || (sqlType == Types.OTHER && typeName == null)) {_			boolean useSetObject = false__			Integer sqlTypeToUse = null__			if (!shouldIgnoreGetParameterType) {_				try {_					sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex)__				}_				catch (SQLException ex) {_					if (logger.isDebugEnabled()) {_						logger.debug("JDBC getParameterType call failed - using fallback method instead: " + ex)__					}_				}_			}_			if (sqlTypeToUse == null) {_				_				sqlTypeToUse = Types.NULL__				DatabaseMetaData dbmd = ps.getConnection().getMetaData()__				String jdbcDriverName = dbmd.getDriverName()__				String databaseProductName = dbmd.getDatabaseProductName()__				if (databaseProductName.startsWith("Informix") ||_						(jdbcDriverName.startsWith("Microsoft") && jdbcDriverName.contains("SQL Server"))) {_						_					useSetObject = true__				}_				else if (databaseProductName.startsWith("DB2") ||_						jdbcDriverName.startsWith("jConnect") ||_						jdbcDriverName.startsWith("SQLServer")||_						jdbcDriverName.startsWith("Apache Derby")) {_					sqlTypeToUse = Types.VARCHAR__				}_			}_			if (useSetObject) {_				ps.setObject(paramIndex, null)__			}_			else {_				ps.setNull(paramIndex, sqlTypeToUse)__			}_		}_		else if (typeName != null) {_			ps.setNull(paramIndex, sqlType, typeName)__		}_		else {_			ps.setNull(paramIndex, sqlType)__		}_	};set,the,specified,prepared,statement,parameter,to,null,respecting,database,specific,peculiarities;private,static,void,set,null,prepared,statement,ps,int,param,index,int,sql,type,nullable,string,type,name,throws,sqlexception,if,sql,type,sql,type,value,sql,type,types,other,type,name,null,boolean,use,set,object,false,integer,sql,type,to,use,null,if,should,ignore,get,parameter,type,try,sql,type,to,use,ps,get,parameter,meta,data,get,parameter,type,param,index,catch,sqlexception,ex,if,logger,is,debug,enabled,logger,debug,jdbc,get,parameter,type,call,failed,using,fallback,method,instead,ex,if,sql,type,to,use,null,sql,type,to,use,types,null,database,meta,data,dbmd,ps,get,connection,get,meta,data,string,jdbc,driver,name,dbmd,get,driver,name,string,database,product,name,dbmd,get,database,product,name,if,database,product,name,starts,with,informix,jdbc,driver,name,starts,with,microsoft,jdbc,driver,name,contains,sql,server,use,set,object,true,else,if,database,product,name,starts,with,db2,jdbc,driver,name,starts,with,j,connect,jdbc,driver,name,starts,with,sqlserver,jdbc,driver,name,starts,with,apache,derby,sql,type,to,use,types,varchar,if,use,set,object,ps,set,object,param,index,null,else,ps,set,null,param,index,sql,type,to,use,else,if,type,name,null,ps,set,null,param,index,sql,type,type,name,else,ps,set,null,param,index,sql,type
StatementCreatorUtils -> private static boolean isStringValue(Class inValueType);1328020251;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class inValueType);1356735495;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class inValueType);1362408075;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class inValueType);1365871149;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class inValueType);1381786313;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
StatementCreatorUtils -> private static boolean isStringValue(Class inValueType);1381881108;Check whether the given value can be treated as a String value.;private static boolean isStringValue(Class inValueType) {_		_		return (CharSequence.class.isAssignableFrom(inValueType) ||_				StringWriter.class.isAssignableFrom(inValueType))__	};check,whether,the,given,value,can,be,treated,as,a,string,value;private,static,boolean,is,string,value,class,in,value,type,return,char,sequence,class,is,assignable,from,in,value,type,string,writer,class,is,assignable,from,in,value,type
