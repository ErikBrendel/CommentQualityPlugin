commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;10;;@Override protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {     BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(EmbeddedDatabaseFactoryBean.class).     setGenerateUniqueDatabaseNameFlag(element, builder).     setDatabaseName(element, builder).     setDatabaseType(element, builder).     DatabasePopulatorConfigUtils.setDatabasePopulator(element, builder).     builder.getRawBeanDefinition().setSource(parserContext.extractSource(element)).     return builder.getBeanDefinition(). }
false;protected;0;4;;@Override protected boolean shouldGenerateIdAsFallback() {     return true. }
false;private;2;6;;private void setGenerateUniqueDatabaseNameFlag(Element element, BeanDefinitionBuilder builder) {     String generateName = element.getAttribute(GENERATE_NAME_ATTRIBUTE).     if (StringUtils.hasText(generateName)) {         builder.addPropertyValue("generateUniqueDatabaseName", generateName).     } }
false;private;2;14;;private void setDatabaseName(Element element, BeanDefinitionBuilder builder) {     // 1) Check for an explicit database name     String name = element.getAttribute(DB_NAME_ATTRIBUTE).     // 2) Fall back to an implicit database name based on the ID     if (!StringUtils.hasText(name)) {         name = element.getAttribute(ID_ATTRIBUTE).     }     if (StringUtils.hasText(name)) {         builder.addPropertyValue("databaseName", name).     } // else, let EmbeddedDatabaseFactory use the default "testdb" name }
false;private;2;6;;private void setDatabaseType(Element element, BeanDefinitionBuilder builder) {     String type = element.getAttribute("type").     if (StringUtils.hasText(type)) {         builder.addPropertyValue("databaseType", type).     } }
