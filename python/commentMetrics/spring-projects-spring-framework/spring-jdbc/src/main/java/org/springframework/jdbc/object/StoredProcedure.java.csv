commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;4;/**  * StoredProcedure parameter Maps are by default allowed to contain  * additional entries that are not actually used as parameters.  */ ;/**  * StoredProcedure parameter Maps are by default allowed to contain  * additional entries that are not actually used as parameters.  */ @Override protected boolean allowsUnusedParameters() {     return true. }
true;public;1;7;/**  * Declare a parameter. Overridden method.  * Parameters declared as {@code SqlParameter} and {@code SqlInOutParameter}  * will always be used to provide input values.  In addition to this any parameter declared  * as {@code SqlOutParameter} where an non-null input value is provided will also be used  * as an input paraneter.  * <b>Note: Calls to declareParameter must be made in the same order as  * they appear in the database's stored procedure parameter list.</b>  * Names are purely used to help mapping.  * @param param parameter object  */ ;/**  * Declare a parameter. Overridden method.  * Parameters declared as {@code SqlParameter} and {@code SqlInOutParameter}  * will always be used to provide input values.  In addition to this any parameter declared  * as {@code SqlOutParameter} where an non-null input value is provided will also be used  * as an input paraneter.  * <b>Note: Calls to declareParameter must be made in the same order as  * they appear in the database's stored procedure parameter list.</b>  * Names are purely used to help mapping.  * @param param parameter object  */ @Override public void declareParameter(SqlParameter param) throws InvalidDataAccessApiUsageException {     if (param.getName() == null) {         throw new InvalidDataAccessApiUsageException("Parameters to stored procedures must have names as well as types").     }     super.declareParameter(param). }
true;public;1;11;/**  * Execute the stored procedure with the provided parameter values. This is  * a convenience method where the order of the passed in parameter values  * must match the order that the parameters where declared in.  * @param inParams variable number of input parameters. Output parameters should  * not be included in this map. It is legal for values to be {@code null}, and this  * will produce the correct behavior using a NULL argument to the stored procedure.  * @return map of output params, keyed by name as in parameter declarations.  * Output parameters will appear here, with their values after the stored procedure  * has been called.  */ ;/**  * Execute the stored procedure with the provided parameter values. This is  * a convenience method where the order of the passed in parameter values  * must match the order that the parameters where declared in.  * @param inParams variable number of input parameters. Output parameters should  * not be included in this map. It is legal for values to be {@code null}, and this  * will produce the correct behavior using a NULL argument to the stored procedure.  * @return map of output params, keyed by name as in parameter declarations.  * Output parameters will appear here, with their values after the stored procedure  * has been called.  */ public Map<String, Object> execute(Object... inParams) {     Map<String, Object> paramsToUse = new HashMap<>().     validateParameters(inParams).     int i = 0.     for (SqlParameter sqlParameter : getDeclaredParameters()) {         if (sqlParameter.isInputValueProvided() && i < inParams.length) {             paramsToUse.put(sqlParameter.getName(), inParams[i++]).         }     }     return getJdbcTemplate().call(newCallableStatementCreator(paramsToUse), getDeclaredParameters()). }
true;public;1;4;/**  * Execute the stored procedure. Subclasses should define a strongly typed  * execute method (with a meaningful name) that invokes this method, populating  * the input map and extracting typed values from the output map. Subclass  * execute methods will often take domain objects as arguments and return values.  * Alternatively, they can return void.  * @param inParams map of input parameters, keyed by name as in parameter  * declarations. Output parameters need not (but can) be included in this map.  * It is legal for map entries to be {@code null}, and this will produce the  * correct behavior using a NULL argument to the stored procedure.  * @return map of output params, keyed by name as in parameter declarations.  * Output parameters will appear here, with their values after the  * stored procedure has been called.  */ ;/**  * Execute the stored procedure. Subclasses should define a strongly typed  * execute method (with a meaningful name) that invokes this method, populating  * the input map and extracting typed values from the output map. Subclass  * execute methods will often take domain objects as arguments and return values.  * Alternatively, they can return void.  * @param inParams map of input parameters, keyed by name as in parameter  * declarations. Output parameters need not (but can) be included in this map.  * It is legal for map entries to be {@code null}, and this will produce the  * correct behavior using a NULL argument to the stored procedure.  * @return map of output params, keyed by name as in parameter declarations.  * Output parameters will appear here, with their values after the  * stored procedure has been called.  */ public Map<String, Object> execute(Map<String, ?> inParams) throws DataAccessException {     validateParameters(inParams.values().toArray()).     return getJdbcTemplate().call(newCallableStatementCreator(inParams), getDeclaredParameters()). }
true;public;1;4;/**  * Execute the stored procedure. Subclasses should define a strongly typed  * execute method (with a meaningful name) that invokes this method, passing in  * a ParameterMapper that will populate the input map.  This allows mapping database  * specific features since the ParameterMapper has access to the Connection object.  * The execute method is also responsible for extracting typed values from the output map.  * Subclass execute methods will often take domain objects as arguments and return values.  * Alternatively, they can return void.  * @param inParamMapper map of input parameters, keyed by name as in parameter  * declarations. Output parameters need not (but can) be included in this map.  * It is legal for map entries to be {@code null}, and this will produce the correct  * behavior using a NULL argument to the stored procedure.  * @return map of output params, keyed by name as in parameter declarations.  * Output parameters will appear here, with their values after the  * stored procedure has been called.  */ ;/**  * Execute the stored procedure. Subclasses should define a strongly typed  * execute method (with a meaningful name) that invokes this method, passing in  * a ParameterMapper that will populate the input map.  This allows mapping database  * specific features since the ParameterMapper has access to the Connection object.  * The execute method is also responsible for extracting typed values from the output map.  * Subclass execute methods will often take domain objects as arguments and return values.  * Alternatively, they can return void.  * @param inParamMapper map of input parameters, keyed by name as in parameter  * declarations. Output parameters need not (but can) be included in this map.  * It is legal for map entries to be {@code null}, and this will produce the correct  * behavior using a NULL argument to the stored procedure.  * @return map of output params, keyed by name as in parameter declarations.  * Output parameters will appear here, with their values after the  * stored procedure has been called.  */ public Map<String, Object> execute(ParameterMapper inParamMapper) throws DataAccessException {     checkCompiled().     return getJdbcTemplate().call(newCallableStatementCreator(inParamMapper), getDeclaredParameters()). }
