# id;timestamp;commentText;codeText;commentWords;codeWords
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1496259743;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List<String> paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,string,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1496837955;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List<String> paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,string,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1510181678;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1515532745;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1515948332;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1515949052;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1518009039;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1520549055;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1522328425;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1522751040;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1530174524;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource);1542899558;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, @Nullable SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		List<String> paramNames = parsedSql.getParameterNames()__		if (paramNames.isEmpty()) {_			return originalSql__		}_		StringBuilder actualSql = new StringBuilder(originalSql.length())__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append('(')__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append('?')__							}_							actualSql.append(')')__						}_						else {_							actualSql.append('?')__						}_					}_				}_				else {_					actualSql.append('?')__				}_			}_			else {_				actualSql.append('?')__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,nullable,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,if,param,names,is,empty,return,original,sql,string,builder,actual,sql,new,string,builder,original,sql,length,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1328020251;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be <code>null</code>). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"You can't mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditonal placeholder(s) in [" +_					parsedSql.getOriginalSql() + "]")__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,code,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,you,can,t,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditonal,placeholder,s,in,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1329142650;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be <code>null</code>). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"You can't mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditonal placeholder(s) in [" +_					parsedSql.getOriginalSql() + "]")__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,code,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,you,can,t,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditonal,placeholder,s,in,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1356735495;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"You can't mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditonal placeholder(s) in [" +_					parsedSql.getOriginalSql() + "]")__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,you,can,t,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditonal,placeholder,s,in,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1383086693;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"You can't mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditonal placeholder(s) in [" +_					parsedSql.getOriginalSql() + "]")__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,you,can,t,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditonal,placeholder,s,in,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1383341935;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"You can't mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditonal placeholder(s) in [" +_					parsedSql.getOriginalSql() + "]")__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,you,can,t,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditonal,placeholder,s,in,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1383343670;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1385412762;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1445896032;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1467730834;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1490605035;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams);1492093025;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1328020251;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<SqlParameter>()__		for (String paramName : paramNames) {_			SqlParameter param = new SqlParameter(_					paramName,_					paramSource.getSqlType(paramName),_					paramSource.getTypeName(paramName))__			params.add(param)__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,sql,parameter,for,string,param,name,param,names,sql,parameter,param,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,params,add,param,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1329142650;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<SqlParameter>()__		for (String paramName : paramNames) {_			SqlParameter param = new SqlParameter(_					paramName,_					paramSource.getSqlType(paramName),_					paramSource.getTypeName(paramName))__			params.add(param)__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,sql,parameter,for,string,param,name,param,names,sql,parameter,param,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,params,add,param,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1356735495;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<SqlParameter>()__		for (String paramName : paramNames) {_			SqlParameter param = new SqlParameter(_					paramName,_					paramSource.getSqlType(paramName),_					paramSource.getTypeName(paramName))__			params.add(param)__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,sql,parameter,for,string,param,name,param,names,sql,parameter,param,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,params,add,param,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1383086693;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<SqlParameter>()__		for (String paramName : paramNames) {_			SqlParameter param = new SqlParameter(_					paramName,_					paramSource.getSqlType(paramName),_					paramSource.getTypeName(paramName))__			params.add(param)__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,sql,parameter,for,string,param,name,param,names,sql,parameter,param,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,params,add,param,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1383341935;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<SqlParameter>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,sql,parameter,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1383343670;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<SqlParameter>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,sql,parameter,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1385412762;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<SqlParameter>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,sql,parameter,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1445896032;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<SqlParameter>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,sql,parameter,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1467730834;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1490605035;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1492093025;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1495868221;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1496259743;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1496837955;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<>()__		for (String paramName : paramNames) {_			params.add(_					new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1510181678;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<>()__		for (String paramName : paramNames) {_			params.add(_					new SqlParameter(paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1515532745;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new LinkedList<>()__		for (String paramName : paramNames) {_			params.add(new SqlParameter(_					paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,linked,list,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1515948332;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new ArrayList<>(paramNames.size())__		for (String paramName : paramNames) {_			params.add(new SqlParameter(_					paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,array,list,param,names,size,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1515949052;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new ArrayList<>(paramNames.size())__		for (String paramName : paramNames) {_			params.add(new SqlParameter(_					paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,array,list,param,names,size,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1518009039;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new ArrayList<>(paramNames.size())__		for (String paramName : paramNames) {_			params.add(new SqlParameter(_					paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,array,list,param,names,size,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1520549055;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new ArrayList<>(paramNames.size())__		for (String paramName : paramNames) {_			params.add(new SqlParameter(_					paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,array,list,param,names,size,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1522328425;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new ArrayList<>(paramNames.size())__		for (String paramName : paramNames) {_			params.add(new SqlParameter(_					paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,array,list,param,names,size,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1522751040;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new ArrayList<>(paramNames.size())__		for (String paramName : paramNames) {_			params.add(new SqlParameter(_					paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,array,list,param,names,size,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1530174524;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new ArrayList<>(paramNames.size())__		for (String paramName : paramNames) {_			params.add(new SqlParameter(_					paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,array,list,param,names,size,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource);1542899558;Convert parameter declarations from an SqlParameterSource to a corresponding List of SqlParameters._This is necessary in order to reuse existing methods on JdbcTemplate._The SqlParameter for a named parameter is placed in the correct position in the_resulting list based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static List<SqlParameter> buildSqlParameterList(ParsedSql parsedSql, SqlParameterSource paramSource) {_		List<String> paramNames = parsedSql.getParameterNames()__		List<SqlParameter> params = new ArrayList<>(paramNames.size())__		for (String paramName : paramNames) {_			params.add(new SqlParameter(_					paramName, paramSource.getSqlType(paramName), paramSource.getTypeName(paramName)))__		}_		return params__	};convert,parameter,declarations,from,an,sql,parameter,source,to,a,corresponding,list,of,sql,parameters,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,the,sql,parameter,for,a,named,parameter,is,placed,in,the,correct,position,in,the,resulting,list,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,list,sql,parameter,build,sql,parameter,list,parsed,sql,parsed,sql,sql,parameter,source,param,source,list,string,param,names,parsed,sql,get,parameter,names,list,sql,parameter,params,new,array,list,param,names,size,for,string,param,name,param,names,params,add,new,sql,parameter,param,name,param,source,get,sql,type,param,name,param,source,get,type,name,param,name,return,params
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1328020251;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<String>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<ParameterHolder>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = skipCommentsAndQuotes(statement, i)__			if (i != skipToPosition) {_				if (skipToPosition >= statement.length) {_					break__				}_				i = skipToPosition__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" + statement[j] + "' at position " + i + " in statement " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException("Non-terminated named parameter declaration at position " + i + " in statement " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,parameter,holder,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,if,skip,to,position,statement,length,break,i,skip,to,position,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1329142650;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<String>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<ParameterHolder>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" + statement[j] + "' at position " + i + " in statement " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException("Non-terminated named parameter declaration at position " + i + " in statement " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,parameter,holder,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1356735495;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<String>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<ParameterHolder>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" + statement[j] + "' at position " + i + " in statement " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException("Non-terminated named parameter declaration at position " + i + " in statement " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,parameter,holder,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1383086693;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<String>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<ParameterHolder>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" + statement[j] + "' at position " + i + " in statement " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException("Non-terminated named parameter declaration at position " + i + " in statement " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,parameter,holder,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1383341935;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<String>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<ParameterHolder>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,parameter,holder,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1383343670;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<String>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<ParameterHolder>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,parameter,holder,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1385412762;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<String>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<ParameterHolder>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,parameter,holder,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1445896032;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<String>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<ParameterHolder>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && statement[j] == '?') {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,parameter,holder,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1467730834;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && statement[j] == '?') {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1490605035;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1492093025;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1495868221;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1496259743;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1496837955;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1510181678;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1515532745;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1515948332;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1515949052;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1518009039;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && !('}' == statement[j])) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1520549055;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && '}' != statement[j]) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 3) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,3,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1522328425;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && '}' != statement[j]) {_						j++__						if (':' == statement[j] || '{' == statement[j]) {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 2) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,2,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1522751040;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && statement[j] != '}') {_						j++__						if (statement[j] == ':' || statement[j] == '{') {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 2) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(_								parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(_								parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,2,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1530174524;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (j < statement.length && statement[j] == ':' && c == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (j < statement.length && c == ':' && statement[j] == '{') {_					_					while (j < statement.length && statement[j] != '}') {_						j++__						if (statement[j] == ':' || statement[j] == '{') {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j >= statement.length) {_						throw new InvalidDataAccessApiUsageException(_								"Non-terminated named parameter declaration at position " + i + " in statement: " + sql)__					}_					if (j - i > 2) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(_								parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(_								parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,j,statement,length,statement,j,c,i,i,2,continue,string,parameter,null,if,j,statement,length,c,statement,j,while,j,statement,length,statement,j,j,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,j,i,2,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> public static ParsedSql parseSqlStatement(final String sql);1542899558;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._@param sql the SQL statement_@return the parsed statement, represented as ParsedSql instance;public static ParsedSql parseSqlStatement(final String sql) {_		Assert.notNull(sql, "SQL must not be null")___		Set<String> namedParameters = new HashSet<>()__		String sqlToUse = sql__		List<ParameterHolder> parameterList = new ArrayList<>()___		char[] statement = sql.toCharArray()__		int namedParameterCount = 0__		int unnamedParameterCount = 0__		int totalParameterCount = 0___		int escapes = 0__		int i = 0__		while (i < statement.length) {_			int skipToPosition = i__			while (i < statement.length) {_				skipToPosition = skipCommentsAndQuotes(statement, i)__				if (i == skipToPosition) {_					break__				}_				else {_					i = skipToPosition__				}_			}_			if (i >= statement.length) {_				break__			}_			char c = statement[i]__			if (c == ':' || c == '&') {_				int j = i + 1__				if (c == ':' && j < statement.length && statement[j] == ':') {_					_					i = i + 2__					continue__				}_				String parameter = null__				if (c == ':' && j < statement.length && statement[j] == '{') {_					_					while (statement[j] != '}') {_						j++__						if (j >= statement.length) {_							throw new InvalidDataAccessApiUsageException("Non-terminated named parameter declaration " +_									"at position " + i + " in statement: " + sql)__						}_						if (statement[j] == ':' || statement[j] == '{') {_							throw new InvalidDataAccessApiUsageException("Parameter name contains invalid character '" +_									statement[j] + "' at position " + i + " in statement: " + sql)__						}_					}_					if (j - i > 2) {_						parameter = sql.substring(i + 2, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(_								parameterList, totalParameterCount, escapes, i, j + 1, parameter)__					}_					j++__				}_				else {_					while (j < statement.length && !isParameterSeparator(statement[j])) {_						j++__					}_					if (j - i > 1) {_						parameter = sql.substring(i + 1, j)__						namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter)__						totalParameterCount = addNamedParameter(_								parameterList, totalParameterCount, escapes, i, j, parameter)__					}_				}_				i = j - 1__			}_			else {_				if (c == '\\') {_					int j = i + 1__					if (j < statement.length && statement[j] == ':') {_						_						sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1)__						escapes++__						i = i + 2__						continue__					}_				}_				if (c == '?') {_					int j = i + 1__					if (j < statement.length && (statement[j] == '?' || statement[j] == '|' || statement[j] == '&')) {_						_						i = i + 2__						continue__					}_					unnamedParameterCount++__					totalParameterCount++__				}_			}_			i++__		}_		ParsedSql parsedSql = new ParsedSql(sqlToUse)__		for (ParameterHolder ph : parameterList) {_			parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex())__		}_		parsedSql.setNamedParameterCount(namedParameterCount)__		parsedSql.setUnnamedParameterCount(unnamedParameterCount)__		parsedSql.setTotalParameterCount(totalParameterCount)__		return parsedSql__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,param,sql,the,sql,statement,return,the,parsed,statement,represented,as,parsed,sql,instance;public,static,parsed,sql,parse,sql,statement,final,string,sql,assert,not,null,sql,sql,must,not,be,null,set,string,named,parameters,new,hash,set,string,sql,to,use,sql,list,parameter,holder,parameter,list,new,array,list,char,statement,sql,to,char,array,int,named,parameter,count,0,int,unnamed,parameter,count,0,int,total,parameter,count,0,int,escapes,0,int,i,0,while,i,statement,length,int,skip,to,position,i,while,i,statement,length,skip,to,position,skip,comments,and,quotes,statement,i,if,i,skip,to,position,break,else,i,skip,to,position,if,i,statement,length,break,char,c,statement,i,if,c,c,int,j,i,1,if,c,j,statement,length,statement,j,i,i,2,continue,string,parameter,null,if,c,j,statement,length,statement,j,while,statement,j,j,if,j,statement,length,throw,new,invalid,data,access,api,usage,exception,non,terminated,named,parameter,declaration,at,position,i,in,statement,sql,if,statement,j,statement,j,throw,new,invalid,data,access,api,usage,exception,parameter,name,contains,invalid,character,statement,j,at,position,i,in,statement,sql,if,j,i,2,parameter,sql,substring,i,2,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,1,parameter,j,else,while,j,statement,length,is,parameter,separator,statement,j,j,if,j,i,1,parameter,sql,substring,i,1,j,named,parameter,count,add,new,named,parameter,named,parameters,named,parameter,count,parameter,total,parameter,count,add,named,parameter,parameter,list,total,parameter,count,escapes,i,j,parameter,i,j,1,else,if,c,int,j,i,1,if,j,statement,length,statement,j,sql,to,use,sql,to,use,substring,0,i,escapes,sql,to,use,substring,i,escapes,1,escapes,i,i,2,continue,if,c,int,j,i,1,if,j,statement,length,statement,j,statement,j,statement,j,i,i,2,continue,unnamed,parameter,count,total,parameter,count,i,parsed,sql,parsed,sql,new,parsed,sql,sql,to,use,for,parameter,holder,ph,parameter,list,parsed,sql,add,named,parameter,ph,get,parameter,name,ph,get,start,index,ph,get,end,index,parsed,sql,set,named,parameter,count,named,parameter,count,parsed,sql,set,unnamed,parameter,count,unnamed,parameter,count,parsed,sql,set,total,parameter,count,total,parameter,count,return,parsed,sql
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1328020251;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1329142650;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1356735495;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1383086693;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1383341935;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1383343670;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1385412762;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1445896032;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1467730834;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1490605035;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1492093025;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1495868221;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1496259743;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1496837955;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1510181678;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		if (Character.isWhitespace(c)) {_			return true__		}_		for (char separator : PARAMETER_SEPARATORS) {_			if (c == separator) {_				return true__			}_		}_		return false__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,if,character,is,whitespace,c,return,true,for,char,separator,if,c,separator,return,true,return,false
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1515532745;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		return (separatorIndex[c] || Character.isWhitespace(c))__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,return,separator,index,c,character,is,whitespace,c
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1515948332;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		return (separatorIndex[c] || Character.isWhitespace(c))__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,return,separator,index,c,character,is,whitespace,c
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1515949052;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		return (separatorIndex[c] || Character.isWhitespace(c))__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,return,separator,index,c,character,is,whitespace,c
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1518009039;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		return (c < 128 && separatorIndex[c]) || Character.isWhitespace(c)__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,return,c,128,separator,index,c,character,is,whitespace,c
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1520549055;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		return (c < 128 && separatorIndex[c]) || Character.isWhitespace(c)__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,return,c,128,separator,index,c,character,is,whitespace,c
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1522328425;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		return (c < 128 && separatorIndex[c]) || Character.isWhitespace(c)__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,return,c,128,separator,index,c,character,is,whitespace,c
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1522751040;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		return (c < 128 && separatorIndex[c]) || Character.isWhitespace(c)__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,return,c,128,separator,index,c,character,is,whitespace,c
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1530174524;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		return (c < 128 && separatorIndex[c]) || Character.isWhitespace(c)__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,return,c,128,separator,index,c,character,is,whitespace,c
NamedParameterUtils -> private static boolean isParameterSeparator(char c);1542899558;Determine whether a parameter name ends at the current position,_that is, whether the given character qualifies as a separator.;private static boolean isParameterSeparator(char c) {_		return (c < 128 && separatorIndex[c]) || Character.isWhitespace(c)__	};determine,whether,a,parameter,name,ends,at,the,current,position,that,is,whether,the,given,character,qualifies,as,a,separator;private,static,boolean,is,parameter,separator,char,c,return,c,128,separator,index,c,character,is,whitespace,c
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1328020251;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1329142650;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1356735495;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1383086693;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1383341935;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1383343670;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1385412762;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1445896032;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1467730834;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1490605035;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1492093025;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1495868221;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1496259743;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1496837955;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1510181678;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1515532745;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1515948332;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1515949052;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1518009039;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1520549055;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1522328425;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1522751040;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1530174524;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource);1542899558;Convert parameter types from an SqlParameterSource into a corresponding int array._This is necessary in order to reuse existing methods on JdbcTemplate._Any named parameter types are placed in the correct position in the_Object array based on the parsed SQL statement info._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters;public static int[] buildSqlTypeArray(ParsedSql parsedSql, SqlParameterSource paramSource) {_		int[] sqlTypes = new int[parsedSql.getTotalParameterCount()]__		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			sqlTypes[i] = paramSource.getSqlType(paramName)__		}_		return sqlTypes__	};convert,parameter,types,from,an,sql,parameter,source,into,a,corresponding,int,array,this,is,necessary,in,order,to,reuse,existing,methods,on,jdbc,template,any,named,parameter,types,are,placed,in,the,correct,position,in,the,object,array,based,on,the,parsed,sql,statement,info,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters;public,static,int,build,sql,type,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,int,sql,types,new,int,parsed,sql,get,total,parameter,count,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,sql,types,i,param,source,get,sql,type,param,name,return,sql,types
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1328020251;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders.  Select lists may contain_an array of objects and in that case the placeholders will be grouped and_enclosed with parantheses.  This allows for the use of "expression lists" in_the SQL statement like:<br/>_select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))_<p>The parameter values passed in are used to determine the number of_placeholder to be used for a select list. Select lists should be limited_to 100 or fewer elements. A larger number of elements is not guaramteed to_be supported by the database and is strictly vendor-dependent._@param parsedSql the parsed represenation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = (String) paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql.substring(lastIndex, startIndex))__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof Collection) {_					Iterator entryIter = ((Collection) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql.substring(lastIndex, originalSql.length()))__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parantheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholder,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaramteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,represenation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,string,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,substring,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,substring,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1329142650;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders.  Select lists may contain_an array of objects and in that case the placeholders will be grouped and_enclosed with parantheses.  This allows for the use of "expression lists" in_the SQL statement like:<br/>_select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))_<p>The parameter values passed in are used to determine the number of_placeholder to be used for a select list. Select lists should be limited_to 100 or fewer elements. A larger number of elements is not guaramteed to_be supported by the database and is strictly vendor-dependent._@param parsedSql the parsed represenation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = (String) paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql.substring(lastIndex, startIndex))__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator entryIter = ((Collection) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql.substring(lastIndex, originalSql.length()))__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parantheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholder,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaramteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,represenation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,string,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,substring,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,substring,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1356735495;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders.  Select lists may contain_an array of objects and in that case the placeholders will be grouped and_enclosed with parantheses.  This allows for the use of "expression lists" in_the SQL statement like:<br/>_select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))_<p>The parameter values passed in are used to determine the number of_placeholder to be used for a select list. Select lists should be limited_to 100 or fewer elements. A larger number of elements is not guaramteed to_be supported by the database and is strictly vendor-dependent._@param parsedSql the parsed represenation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = (String) paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql.substring(lastIndex, startIndex))__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator entryIter = ((Collection) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql.substring(lastIndex, originalSql.length()))__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parantheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholder,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaramteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,represenation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,string,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,substring,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,substring,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1383086693;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = (String) paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql.substring(lastIndex, startIndex))__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator entryIter = ((Collection) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql.substring(lastIndex, originalSql.length()))__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,string,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,substring,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,substring,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1383341935;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = (String) paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator entryIter = ((Collection) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,string,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1383343670;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = (String) paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator entryIter = ((Collection) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,string,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1385412762;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List<String> paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,string,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1445896032;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List<String> paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,string,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1467730834;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List<String> paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,string,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1490605035;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List<String> paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,string,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1492093025;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List<String> paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,string,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource);1495868221;Parse the SQL statement and locate any placeholders or named parameters. Named_parameters are substituted for a JDBC placeholder, and any select list is expanded_to the required number of placeholders. Select lists may contain an array of_objects, and in that case the placeholders will be grouped and enclosed with_parentheses. This allows for the use of "expression lists" in the SQL statement_like: <br /><br />_{@code select id, name, state from table where (name, age) in (('John', 35), ('Ann', 50))}_<p>The parameter values passed in are used to determine the number of placeholders to_be used for a select list. Select lists should be limited to 100 or fewer elements._A larger number of elements is not guaranteed to be supported by the database and_is strictly vendor-dependent._@param parsedSql the parsed representation of the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters_@see #parseSqlStatement;public static String substituteNamedParameters(ParsedSql parsedSql, SqlParameterSource paramSource) {_		String originalSql = parsedSql.getOriginalSql()__		StringBuilder actualSql = new StringBuilder()__		List<String> paramNames = parsedSql.getParameterNames()__		int lastIndex = 0__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			int[] indexes = parsedSql.getParameterIndexes(i)__			int startIndex = indexes[0]__			int endIndex = indexes[1]__			actualSql.append(originalSql, lastIndex, startIndex)__			if (paramSource != null && paramSource.hasValue(paramName)) {_				Object value = paramSource.getValue(paramName)__				if (value instanceof SqlParameterValue) {_					value = ((SqlParameterValue) value).getValue()__				}_				if (value instanceof Collection) {_					Iterator<?> entryIter = ((Collection<?>) value).iterator()__					int k = 0__					while (entryIter.hasNext()) {_						if (k > 0) {_							actualSql.append(", ")__						}_						k++__						Object entryItem = entryIter.next()__						if (entryItem instanceof Object[]) {_							Object[] expressionList = (Object[]) entryItem__							actualSql.append("(")__							for (int m = 0_ m < expressionList.length_ m++) {_								if (m > 0) {_									actualSql.append(", ")__								}_								actualSql.append("?")__							}_							actualSql.append(")")__						}_						else {_							actualSql.append("?")__						}_					}_				}_				else {_					actualSql.append("?")__				}_			}_			else {_				actualSql.append("?")__			}_			lastIndex = endIndex__		}_		actualSql.append(originalSql, lastIndex, originalSql.length())__		return actualSql.toString()__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,select,lists,may,contain,an,array,of,objects,and,in,that,case,the,placeholders,will,be,grouped,and,enclosed,with,parentheses,this,allows,for,the,use,of,expression,lists,in,the,sql,statement,like,br,br,code,select,id,name,state,from,table,where,name,age,in,john,35,ann,50,p,the,parameter,values,passed,in,are,used,to,determine,the,number,of,placeholders,to,be,used,for,a,select,list,select,lists,should,be,limited,to,100,or,fewer,elements,a,larger,number,of,elements,is,not,guaranteed,to,be,supported,by,the,database,and,is,strictly,vendor,dependent,param,parsed,sql,the,parsed,representation,of,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters,see,parse,sql,statement;public,static,string,substitute,named,parameters,parsed,sql,parsed,sql,sql,parameter,source,param,source,string,original,sql,parsed,sql,get,original,sql,string,builder,actual,sql,new,string,builder,list,string,param,names,parsed,sql,get,parameter,names,int,last,index,0,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,int,indexes,parsed,sql,get,parameter,indexes,i,int,start,index,indexes,0,int,end,index,indexes,1,actual,sql,append,original,sql,last,index,start,index,if,param,source,null,param,source,has,value,param,name,object,value,param,source,get,value,param,name,if,value,instanceof,sql,parameter,value,value,sql,parameter,value,value,get,value,if,value,instanceof,collection,iterator,entry,iter,collection,value,iterator,int,k,0,while,entry,iter,has,next,if,k,0,actual,sql,append,k,object,entry,item,entry,iter,next,if,entry,item,instanceof,object,object,expression,list,object,entry,item,actual,sql,append,for,int,m,0,m,expression,list,length,m,if,m,0,actual,sql,append,actual,sql,append,actual,sql,append,else,actual,sql,append,else,actual,sql,append,else,actual,sql,append,last,index,end,index,actual,sql,append,original,sql,last,index,original,sql,length,return,actual,sql,to,string
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1328020251;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1329142650;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1356735495;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1383086693;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1383341935;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1383343670;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1385412762;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1445896032;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1467730834;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1490605035;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1492093025;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1495868221;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1496259743;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1496837955;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1510181678;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1515532745;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1515948332;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1515949052;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1518009039;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1520549055;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1522328425;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1522751040;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1530174524;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> public static String parseSqlStatementIntoString(String sql);1542899558;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder._<p>This is a shortcut version of_{@link #parseSqlStatement(String)} in combination with_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@return the actual (parsed) SQL statement;public static String parseSqlStatementIntoString(String sql) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, null)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,p,this,is,a,shortcut,version,of,link,parse,sql,statement,string,in,combination,with,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,return,the,actual,parsed,sql,statement;public,static,string,parse,sql,statement,into,string,string,sql,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1496837955;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1510181678;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1515532745;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1515948332;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1515949052;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1518009039;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1520549055;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1522328425;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1522751040;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1530174524;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter( 			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex);1542899558;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(_			@Nullable List<SqlParameter> declaredParams, String paramName, int paramIndex) {__		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,nullable,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1328020251;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1329142650;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1356735495;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1383086693;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1383341935;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1383343670;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1385412762;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1445896032;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1467730834;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1490605035;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1492093025;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1495868221;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1496259743;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1496837955;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1510181678;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1515532745;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1515948332;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1515949052;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1518009039;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1520549055;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1522328425;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1522751040;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1530174524;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> public static String substituteNamedParameters(String sql, SqlParameterSource paramSource);1542899558;Parse the SQL statement and locate any placeholders or named parameters._Named parameters are substituted for a JDBC placeholder and any select list_is expanded to the required number of placeholders._<p>This is a shortcut version of_{@link #substituteNamedParameters(ParsedSql, SqlParameterSource)}._@param sql the SQL statement_@param paramSource the source for named parameters_@return the SQL statement with substituted parameters;public static String substituteNamedParameters(String sql, SqlParameterSource paramSource) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return substituteNamedParameters(parsedSql, paramSource)__	};parse,the,sql,statement,and,locate,any,placeholders,or,named,parameters,named,parameters,are,substituted,for,a,jdbc,placeholder,and,any,select,list,is,expanded,to,the,required,number,of,placeholders,p,this,is,a,shortcut,version,of,link,substitute,named,parameters,parsed,sql,sql,parameter,source,param,sql,the,sql,statement,param,param,source,the,source,for,named,parameters,return,the,sql,statement,with,substituted,parameters;public,static,string,substitute,named,parameters,string,sql,sql,parameter,source,param,source,parsed,sql,parsed,sql,parse,sql,statement,sql,return,substitute,named,parameters,parsed,sql,param,source
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1328020251;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1329142650;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1356735495;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1383086693;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1383341935;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1383343670;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1385412762;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1445896032;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1467730834;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1490605035;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1492093025;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1495868221;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1496259743;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1496837955;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1510181678;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}__			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1515532745;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}_			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1515948332;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}_			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1515949052;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}_			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1518009039;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (!(statement[position + j] == START_SKIP[i].charAt(j))) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (!(statement[m + n] == STOP_SKIP[i].charAt(n))) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}_			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1520549055;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (statement[position + j] != START_SKIP[i].charAt(j)) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (statement[m + n] != STOP_SKIP[i].charAt(n)) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}_			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1522328425;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (statement[position + j] != START_SKIP[i].charAt(j)) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (statement[m + n] != STOP_SKIP[i].charAt(n)) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}_			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1522751040;Skip over comments and quoted names present in an SQL statement_@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (statement[position + j] != START_SKIP[i].charAt(j)) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (statement[m + n] != STOP_SKIP[i].charAt(n)) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}_			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1530174524;Skip over comments and quoted names present in an SQL statement._@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (statement[position + j] != START_SKIP[i].charAt(j)) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (statement[m + n] != STOP_SKIP[i].charAt(n)) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}_			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static int skipCommentsAndQuotes(char[] statement, int position);1542899558;Skip over comments and quoted names present in an SQL statement._@param statement character array containing SQL statement_@param position current position of statement_@return next position to process after any comments or quotes are skipped;private static int skipCommentsAndQuotes(char[] statement, int position) {_		for (int i = 0_ i < START_SKIP.length_ i++) {_			if (statement[position] == START_SKIP[i].charAt(0)) {_				boolean match = true__				for (int j = 1_ j < START_SKIP[i].length()_ j++) {_					if (statement[position + j] != START_SKIP[i].charAt(j)) {_						match = false__						break__					}_				}_				if (match) {_					int offset = START_SKIP[i].length()__					for (int m = position + offset_ m < statement.length_ m++) {_						if (statement[m] == STOP_SKIP[i].charAt(0)) {_							boolean endMatch = true__							int endPos = m__							for (int n = 1_ n < STOP_SKIP[i].length()_ n++) {_								if (m + n >= statement.length) {_									_									return statement.length__								}_								if (statement[m + n] != STOP_SKIP[i].charAt(n)) {_									endMatch = false__									break__								}_								endPos = m + n__							}_							if (endMatch) {_								_								return endPos + 1__							}_						}_					}_					_					return statement.length__				}_			}_		}_		return position__	};skip,over,comments,and,quoted,names,present,in,an,sql,statement,param,statement,character,array,containing,sql,statement,param,position,current,position,of,statement,return,next,position,to,process,after,any,comments,or,quotes,are,skipped;private,static,int,skip,comments,and,quotes,char,statement,int,position,for,int,i,0,i,length,i,if,statement,position,i,char,at,0,boolean,match,true,for,int,j,1,j,i,length,j,if,statement,position,j,i,char,at,j,match,false,break,if,match,int,offset,i,length,for,int,m,position,offset,m,statement,length,m,if,statement,m,i,char,at,0,boolean,end,match,true,int,end,pos,m,for,int,n,1,n,i,length,n,if,m,n,statement,length,return,statement,length,if,statement,m,n,i,char,at,n,end,match,false,break,end,pos,m,n,if,end,match,return,end,pos,1,return,statement,length,return,position
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1328020251;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or <code>null</code> if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,code,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1329142650;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or <code>null</code> if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,code,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1356735495;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1383086693;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1383341935;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1383343670;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1385412762;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1445896032;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1467730834;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1490605035;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1492093025;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1328020251;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1329142650;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1356735495;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1383086693;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1383341935;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1383343670;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1385412762;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1445896032;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1467730834;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1490605035;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1492093025;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1495868221;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1496259743;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1496837955;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1510181678;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1515532745;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1515948332;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1515949052;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1518009039;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1520549055;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1522328425;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1522751040;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1530174524;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> public static Object[] buildValueArray(String sql, Map<String, ?> paramMap);1542899558;Convert a Map of named parameter values to a corresponding array._<p>This is a shortcut version of_{@link #buildValueArray(ParsedSql, SqlParameterSource, java.util.List)}._@param sql the SQL statement_@param paramMap the Map of parameters_@return the array of values;public static Object[] buildValueArray(String sql, Map<String, ?> paramMap) {_		ParsedSql parsedSql = parseSqlStatement(sql)__		return buildValueArray(parsedSql, new MapSqlParameterSource(paramMap), null)__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,p,this,is,a,shortcut,version,of,link,build,value,array,parsed,sql,sql,parameter,source,java,util,list,param,sql,the,sql,statement,param,param,map,the,map,of,parameters,return,the,array,of,values;public,static,object,build,value,array,string,sql,map,string,param,map,parsed,sql,parsed,sql,parse,sql,statement,sql,return,build,value,array,parsed,sql,new,map,sql,parameter,source,param,map,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1495868221;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> @Nullable 	private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex);1496259743;Find a matching parameter in the given list of declared parameters._@param declaredParams the declared SqlParameter objects_@param paramName the name of the desired parameter_@param paramIndex the index of the desired parameter_@return the declared SqlParameter, or {@code null} if none found;@Nullable_	private static SqlParameter findParameter(List<SqlParameter> declaredParams, String paramName, int paramIndex) {_		if (declaredParams != null) {_			_			for (SqlParameter declaredParam : declaredParams) {_				if (paramName.equals(declaredParam.getName())) {_					return declaredParam__				}_			}_			_			if (paramIndex < declaredParams.size()) {_				SqlParameter declaredParam = declaredParams.get(paramIndex)__				_				if (declaredParam.getName() == null) {_					return declaredParam__				}_			}_		}_		return null__	};find,a,matching,parameter,in,the,given,list,of,declared,parameters,param,declared,params,the,declared,sql,parameter,objects,param,param,name,the,name,of,the,desired,parameter,param,param,index,the,index,of,the,desired,parameter,return,the,declared,sql,parameter,or,code,null,if,none,found;nullable,private,static,sql,parameter,find,parameter,list,sql,parameter,declared,params,string,param,name,int,param,index,if,declared,params,null,for,sql,parameter,declared,param,declared,params,if,param,name,equals,declared,param,get,name,return,declared,param,if,param,index,declared,params,size,sql,parameter,declared,param,declared,params,get,param,index,if,declared,param,get,name,null,return,declared,param,return,null
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1495868221;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1496259743;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1496837955;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1510181678;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1515532745;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1515948332;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1515949052;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1518009039;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1520549055;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1522328425;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1522751040;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1530174524;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
NamedParameterUtils -> public static Object[] buildValueArray( 			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams);1542899558;Convert a Map of named parameter values to a corresponding array._@param parsedSql the parsed SQL statement_@param paramSource the source for named parameters_@param declaredParams the List of declared SqlParameter objects_(may be {@code null}). If specified, the parameter metadata will_be built into the value array in the form of SqlParameterValue objects._@return the array of values;public static Object[] buildValueArray(_			ParsedSql parsedSql, SqlParameterSource paramSource, @Nullable List<SqlParameter> declaredParams) {__		Object[] paramArray = new Object[parsedSql.getTotalParameterCount()]__		if (parsedSql.getNamedParameterCount() > 0 && parsedSql.getUnnamedParameterCount() > 0) {_			throw new InvalidDataAccessApiUsageException(_					"Not allowed to mix named and traditional ? placeholders. You have " +_					parsedSql.getNamedParameterCount() + " named parameter(s) and " +_					parsedSql.getUnnamedParameterCount() + " traditional placeholder(s) in statement: " +_					parsedSql.getOriginalSql())__		}_		List<String> paramNames = parsedSql.getParameterNames()__		for (int i = 0_ i < paramNames.size()_ i++) {_			String paramName = paramNames.get(i)__			try {_				Object value = paramSource.getValue(paramName)__				SqlParameter param = findParameter(declaredParams, paramName, i)__				paramArray[i] = (param != null ? new SqlParameterValue(param, value) : value)__			}_			catch (IllegalArgumentException ex) {_				throw new InvalidDataAccessApiUsageException(_						"No value supplied for the SQL parameter '" + paramName + "': " + ex.getMessage())__			}_		}_		return paramArray__	};convert,a,map,of,named,parameter,values,to,a,corresponding,array,param,parsed,sql,the,parsed,sql,statement,param,param,source,the,source,for,named,parameters,param,declared,params,the,list,of,declared,sql,parameter,objects,may,be,code,null,if,specified,the,parameter,metadata,will,be,built,into,the,value,array,in,the,form,of,sql,parameter,value,objects,return,the,array,of,values;public,static,object,build,value,array,parsed,sql,parsed,sql,sql,parameter,source,param,source,nullable,list,sql,parameter,declared,params,object,param,array,new,object,parsed,sql,get,total,parameter,count,if,parsed,sql,get,named,parameter,count,0,parsed,sql,get,unnamed,parameter,count,0,throw,new,invalid,data,access,api,usage,exception,not,allowed,to,mix,named,and,traditional,placeholders,you,have,parsed,sql,get,named,parameter,count,named,parameter,s,and,parsed,sql,get,unnamed,parameter,count,traditional,placeholder,s,in,statement,parsed,sql,get,original,sql,list,string,param,names,parsed,sql,get,parameter,names,for,int,i,0,i,param,names,size,i,string,param,name,param,names,get,i,try,object,value,param,source,get,value,param,name,sql,parameter,param,find,parameter,declared,params,param,name,i,param,array,i,param,null,new,sql,parameter,value,param,value,value,catch,illegal,argument,exception,ex,throw,new,invalid,data,access,api,usage,exception,no,value,supplied,for,the,sql,parameter,param,name,ex,get,message,return,param,array
