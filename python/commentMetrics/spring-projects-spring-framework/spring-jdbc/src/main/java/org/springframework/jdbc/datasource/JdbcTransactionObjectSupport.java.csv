commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setConnectionHolder(@Nullable ConnectionHolder connectionHolder) {     this.connectionHolder = connectionHolder. }
false;public;0;4;;public ConnectionHolder getConnectionHolder() {     Assert.state(this.connectionHolder != null, "No ConnectionHolder available").     return this.connectionHolder. }
false;public;0;3;;public boolean hasConnectionHolder() {     return (this.connectionHolder != null). }
false;public;1;3;;public void setPreviousIsolationLevel(@Nullable Integer previousIsolationLevel) {     this.previousIsolationLevel = previousIsolationLevel. }
false;public;0;4;;@Nullable public Integer getPreviousIsolationLevel() {     return this.previousIsolationLevel. }
false;public;1;3;;public void setSavepointAllowed(boolean savepointAllowed) {     this.savepointAllowed = savepointAllowed. }
false;public;0;3;;public boolean isSavepointAllowed() {     return this.savepointAllowed. }
false;public;0;4;;@Override public void flush() { // no-op }
true;public;0;18;/**  * This implementation creates a JDBC 3.0 Savepoint and returns it.  * @see java.sql.Connection#setSavepoint  */ ;// --------------------------------------------------------------------- // Implementation of SavepointManager // --------------------------------------------------------------------- /**  * This implementation creates a JDBC 3.0 Savepoint and returns it.  * @see java.sql.Connection#setSavepoint  */ @Override public Object createSavepoint() throws TransactionException {     ConnectionHolder conHolder = getConnectionHolderForSavepoint().     try {         if (!conHolder.supportsSavepoints()) {             throw new NestedTransactionNotSupportedException("Cannot create a nested transaction because savepoints are not supported by your JDBC driver").         }         if (conHolder.isRollbackOnly()) {             throw new CannotCreateTransactionException("Cannot create savepoint for transaction which is already marked as rollback-only").         }         return conHolder.createSavepoint().     } catch (SQLException ex) {         throw new CannotCreateTransactionException("Could not create JDBC savepoint", ex).     } }
true;public;1;11;/**  * This implementation rolls back to the given JDBC 3.0 Savepoint.  * @see java.sql.Connection#rollback(java.sql.Savepoint)  */ ;/**  * This implementation rolls back to the given JDBC 3.0 Savepoint.  * @see java.sql.Connection#rollback(java.sql.Savepoint)  */ @Override public void rollbackToSavepoint(Object savepoint) throws TransactionException {     ConnectionHolder conHolder = getConnectionHolderForSavepoint().     try {         conHolder.getConnection().rollback((Savepoint) savepoint).         conHolder.resetRollbackOnly().     } catch (Throwable ex) {         throw new TransactionSystemException("Could not roll back to JDBC savepoint", ex).     } }
true;public;1;10;/**  * This implementation releases the given JDBC 3.0 Savepoint.  * @see java.sql.Connection#releaseSavepoint  */ ;/**  * This implementation releases the given JDBC 3.0 Savepoint.  * @see java.sql.Connection#releaseSavepoint  */ @Override public void releaseSavepoint(Object savepoint) throws TransactionException {     ConnectionHolder conHolder = getConnectionHolderForSavepoint().     try {         conHolder.getConnection().releaseSavepoint((Savepoint) savepoint).     } catch (Throwable ex) {         logger.debug("Could not explicitly release JDBC savepoint", ex).     } }
false;protected;0;11;;protected ConnectionHolder getConnectionHolderForSavepoint() throws TransactionException {     if (!isSavepointAllowed()) {         throw new NestedTransactionNotSupportedException("Transaction manager does not allow nested transactions").     }     if (!hasConnectionHolder()) {         throw new TransactionUsageException("Cannot create nested transaction when not exposing a JDBC transaction").     }     return getConnectionHolder(). }
