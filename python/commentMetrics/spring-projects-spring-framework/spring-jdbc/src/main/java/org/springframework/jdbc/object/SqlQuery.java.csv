commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the number of rows expected.  * <p>This can be used to ensure efficient storage of results. The  * default behavior is not to expect any specific number of rows.  */ ;/**  * Set the number of rows expected.  * <p>This can be used to ensure efficient storage of results. The  * default behavior is not to expect any specific number of rows.  */ public void setRowsExpected(int rowsExpected) {     this.rowsExpected = rowsExpected. }
true;public;0;3;/**  * Get the number of rows expected.  */ ;/**  * Get the number of rows expected.  */ public int getRowsExpected() {     return this.rowsExpected. }
true;public;2;5;/**  * Central execution method. All un-named parameter execution goes through this method.  * @param params parameters, similar to JDO query parameters.  * Primitive parameters must be represented by their Object wrapper type.  * The ordering of parameters is significant.  * @param context contextual information passed to the {@code mapRow}  * callback method. The JDBC operation itself doesn't rely on this parameter,  * but it can be useful for creating the objects of the result list.  * @return a List of objects, one per row of the ResultSet. Normally all these  * will be of the same class, although it is possible to use different types.  */ ;/**  * Central execution method. All un-named parameter execution goes through this method.  * @param params parameters, similar to JDO query parameters.  * Primitive parameters must be represented by their Object wrapper type.  * The ordering of parameters is significant.  * @param context contextual information passed to the {@code mapRow}  * callback method. The JDBC operation itself doesn't rely on this parameter,  * but it can be useful for creating the objects of the result list.  * @return a List of objects, one per row of the ResultSet. Normally all these  * will be of the same class, although it is possible to use different types.  */ public List<T> execute(@Nullable Object[] params, @Nullable Map<?, ?> context) throws DataAccessException {     validateParameters(params).     RowMapper<T> rowMapper = newRowMapper(params, context).     return getJdbcTemplate().query(newPreparedStatementCreator(params), rowMapper). }
true;public;1;3;/**  * Convenient method to execute without context.  * @param params parameters for the query. Primitive parameters must  * be represented by their Object wrapper type. The ordering of parameters is  * significant.  */ ;/**  * Convenient method to execute without context.  * @param params parameters for the query. Primitive parameters must  * be represented by their Object wrapper type. The ordering of parameters is  * significant.  */ public List<T> execute(Object... params) throws DataAccessException {     return execute(params, null). }
true;public;1;3;/**  * Convenient method to execute without parameters.  * @param context the contextual information for object creation  */ ;/**  * Convenient method to execute without parameters.  * @param context the contextual information for object creation  */ public List<T> execute(Map<?, ?> context) throws DataAccessException {     return execute((Object[]) null, context). }
true;public;0;3;/**  * Convenient method to execute without parameters nor context.  */ ;/**  * Convenient method to execute without parameters nor context.  */ public List<T> execute() throws DataAccessException {     return execute((Object[]) null, null). }
true;public;2;3;/**  * Convenient method to execute with a single int parameter and context.  * @param p1 single int parameter  * @param context the contextual information for object creation  */ ;/**  * Convenient method to execute with a single int parameter and context.  * @param p1 single int parameter  * @param context the contextual information for object creation  */ public List<T> execute(int p1, @Nullable Map<?, ?> context) throws DataAccessException {     return execute(new Object[] { p1 }, context). }
true;public;1;3;/**  * Convenient method to execute with a single int parameter.  * @param p1 single int parameter  */ ;/**  * Convenient method to execute with a single int parameter.  * @param p1 single int parameter  */ public List<T> execute(int p1) throws DataAccessException {     return execute(p1, null). }
true;public;3;3;/**  * Convenient method to execute with two int parameters and context.  * @param p1 first int parameter  * @param p2 second int parameter  * @param context the contextual information for object creation  */ ;/**  * Convenient method to execute with two int parameters and context.  * @param p1 first int parameter  * @param p2 second int parameter  * @param context the contextual information for object creation  */ public List<T> execute(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {     return execute(new Object[] { p1, p2 }, context). }
true;public;2;3;/**  * Convenient method to execute with two int parameters.  * @param p1 first int parameter  * @param p2 second int parameter  */ ;/**  * Convenient method to execute with two int parameters.  * @param p1 first int parameter  * @param p2 second int parameter  */ public List<T> execute(int p1, int p2) throws DataAccessException {     return execute(p1, p2, null). }
true;public;2;3;/**  * Convenient method to execute with a single long parameter and context.  * @param p1 single long parameter  * @param context the contextual information for object creation  */ ;/**  * Convenient method to execute with a single long parameter and context.  * @param p1 single long parameter  * @param context the contextual information for object creation  */ public List<T> execute(long p1, @Nullable Map<?, ?> context) throws DataAccessException {     return execute(new Object[] { p1 }, context). }
true;public;1;3;/**  * Convenient method to execute with a single long parameter.  * @param p1 single long parameter  */ ;/**  * Convenient method to execute with a single long parameter.  * @param p1 single long parameter  */ public List<T> execute(long p1) throws DataAccessException {     return execute(p1, null). }
true;public;2;3;/**  * Convenient method to execute with a single String parameter and context.  * @param p1 single String parameter  * @param context the contextual information for object creation  */ ;/**  * Convenient method to execute with a single String parameter and context.  * @param p1 single String parameter  * @param context the contextual information for object creation  */ public List<T> execute(String p1, @Nullable Map<?, ?> context) throws DataAccessException {     return execute(new Object[] { p1 }, context). }
true;public;1;3;/**  * Convenient method to execute with a single String parameter.  * @param p1 single String parameter  */ ;/**  * Convenient method to execute with a single String parameter.  * @param p1 single String parameter  */ public List<T> execute(String p1) throws DataAccessException {     return execute(p1, null). }
true;public;2;9;/**  * Central execution method. All named parameter execution goes through this method.  * @param paramMap parameters associated with the name specified while declaring  * the SqlParameters. Primitive parameters must be represented by their Object wrapper  * type. The ordering of parameters is not significant since they are supplied in a  * SqlParameterMap which is an implementation of the Map interface.  * @param context contextual information passed to the {@code mapRow}  * callback method. The JDBC operation itself doesn't rely on this parameter,  * but it can be useful for creating the objects of the result list.  * @return a List of objects, one per row of the ResultSet. Normally all these  * will be of the same class, although it is possible to use different types.  */ ;/**  * Central execution method. All named parameter execution goes through this method.  * @param paramMap parameters associated with the name specified while declaring  * the SqlParameters. Primitive parameters must be represented by their Object wrapper  * type. The ordering of parameters is not significant since they are supplied in a  * SqlParameterMap which is an implementation of the Map interface.  * @param context contextual information passed to the {@code mapRow}  * callback method. The JDBC operation itself doesn't rely on this parameter,  * but it can be useful for creating the objects of the result list.  * @return a List of objects, one per row of the ResultSet. Normally all these  * will be of the same class, although it is possible to use different types.  */ public List<T> executeByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {     validateNamedParameters(paramMap).     ParsedSql parsedSql = getParsedSql().     MapSqlParameterSource paramSource = new MapSqlParameterSource(paramMap).     String sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource).     Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, getDeclaredParameters()).     RowMapper<T> rowMapper = newRowMapper(params, context).     return getJdbcTemplate().query(newPreparedStatementCreator(sqlToUse, params), rowMapper). }
true;public;1;3;/**  * Convenient method to execute without context.  * @param paramMap parameters associated with the name specified while declaring  * the SqlParameters. Primitive parameters must be represented by their Object wrapper  * type. The ordering of parameters is not significant.  */ ;/**  * Convenient method to execute without context.  * @param paramMap parameters associated with the name specified while declaring  * the SqlParameters. Primitive parameters must be represented by their Object wrapper  * type. The ordering of parameters is not significant.  */ public List<T> executeByNamedParam(Map<String, ?> paramMap) throws DataAccessException {     return executeByNamedParam(paramMap, null). }
true;public;2;5;/**  * Generic object finder method, used by all other {@code findObject} methods.  * Object finder methods are like EJB entity bean finders, in that it is  * considered an error if they return more than one result.  * @return the result object, or {@code null} if not found. Subclasses may  * choose to treat this as an error and throw an exception.  * @see org.springframework.dao.support.DataAccessUtils#singleResult  */ ;/**  * Generic object finder method, used by all other {@code findObject} methods.  * Object finder methods are like EJB entity bean finders, in that it is  * considered an error if they return more than one result.  * @return the result object, or {@code null} if not found. Subclasses may  * choose to treat this as an error and throw an exception.  * @see org.springframework.dao.support.DataAccessUtils#singleResult  */ @Nullable public T findObject(@Nullable Object[] params, @Nullable Map<?, ?> context) throws DataAccessException {     List<T> results = execute(params, context).     return DataAccessUtils.singleResult(results). }
true;public;1;4;/**  * Convenient method to find a single object without context.  */ ;/**  * Convenient method to find a single object without context.  */ @Nullable public T findObject(Object... params) throws DataAccessException {     return findObject(params, null). }
true;public;2;4;/**  * Convenient method to find a single object given a single int parameter  * and a context.  */ ;/**  * Convenient method to find a single object given a single int parameter  * and a context.  */ @Nullable public T findObject(int p1, @Nullable Map<?, ?> context) throws DataAccessException {     return findObject(new Object[] { p1 }, context). }
true;public;1;4;/**  * Convenient method to find a single object given a single int parameter.  */ ;/**  * Convenient method to find a single object given a single int parameter.  */ @Nullable public T findObject(int p1) throws DataAccessException {     return findObject(p1, null). }
true;public;3;4;/**  * Convenient method to find a single object given two int parameters  * and a context.  */ ;/**  * Convenient method to find a single object given two int parameters  * and a context.  */ @Nullable public T findObject(int p1, int p2, @Nullable Map<?, ?> context) throws DataAccessException {     return findObject(new Object[] { p1, p2 }, context). }
true;public;2;4;/**  * Convenient method to find a single object given two int parameters.  */ ;/**  * Convenient method to find a single object given two int parameters.  */ @Nullable public T findObject(int p1, int p2) throws DataAccessException {     return findObject(p1, p2, null). }
true;public;2;4;/**  * Convenient method to find a single object given a single long parameter  * and a context.  */ ;/**  * Convenient method to find a single object given a single long parameter  * and a context.  */ @Nullable public T findObject(long p1, @Nullable Map<?, ?> context) throws DataAccessException {     return findObject(new Object[] { p1 }, context). }
true;public;1;4;/**  * Convenient method to find a single object given a single long parameter.  */ ;/**  * Convenient method to find a single object given a single long parameter.  */ @Nullable public T findObject(long p1) throws DataAccessException {     return findObject(p1, null). }
true;public;2;4;/**  * Convenient method to find a single object given a single String parameter  * and a context.  */ ;/**  * Convenient method to find a single object given a single String parameter  * and a context.  */ @Nullable public T findObject(String p1, @Nullable Map<?, ?> context) throws DataAccessException {     return findObject(new Object[] { p1 }, context). }
true;public;1;4;/**  * Convenient method to find a single object given a single String parameter.  */ ;/**  * Convenient method to find a single object given a single String parameter.  */ @Nullable public T findObject(String p1) throws DataAccessException {     return findObject(p1, null). }
true;public;2;5;/**  * Generic object finder method for named parameters.  * @param paramMap a Map of parameter name to parameter object,  * matching named parameters specified in the SQL statement.  * Ordering is not significant.  * @param context contextual information passed to the {@code mapRow}  * callback method. The JDBC operation itself doesn't rely on this parameter,  * but it can be useful for creating the objects of the result list.  * @return a List of objects, one per row of the ResultSet. Normally all these  * will be of the same class, although it is possible to use different types.  */ ;/**  * Generic object finder method for named parameters.  * @param paramMap a Map of parameter name to parameter object,  * matching named parameters specified in the SQL statement.  * Ordering is not significant.  * @param context contextual information passed to the {@code mapRow}  * callback method. The JDBC operation itself doesn't rely on this parameter,  * but it can be useful for creating the objects of the result list.  * @return a List of objects, one per row of the ResultSet. Normally all these  * will be of the same class, although it is possible to use different types.  */ @Nullable public T findObjectByNamedParam(Map<String, ?> paramMap, @Nullable Map<?, ?> context) throws DataAccessException {     List<T> results = executeByNamedParam(paramMap, context).     return DataAccessUtils.singleResult(results). }
true;public;1;4;/**  * Convenient method to execute without context.  * @param paramMap a Map of parameter name to parameter object,  * matching named parameters specified in the SQL statement.  * Ordering is not significant.  */ ;/**  * Convenient method to execute without context.  * @param paramMap a Map of parameter name to parameter object,  * matching named parameters specified in the SQL statement.  * Ordering is not significant.  */ @Nullable public T findObjectByNamedParam(Map<String, ?> paramMap) throws DataAccessException {     return findObjectByNamedParam(paramMap, null). }
true;protected,abstract;2;1;/**  * Subclasses must implement this method to extract an object per row, to be  * returned by the {@code execute} method as an aggregated {@link List}.  * @param parameters the parameters to the {@code execute()} method,  * in case subclass is interested. may be {@code null} if there  * were no parameters.  * @param context contextual information passed to the {@code mapRow}  * callback method. The JDBC operation itself doesn't rely on this parameter,  * but it can be useful for creating the objects of the result list.  * @see #execute  */ ;/**  * Subclasses must implement this method to extract an object per row, to be  * returned by the {@code execute} method as an aggregated {@link List}.  * @param parameters the parameters to the {@code execute()} method,  * in case subclass is interested. may be {@code null} if there  * were no parameters.  * @param context contextual information passed to the {@code mapRow}  * callback method. The JDBC operation itself doesn't rely on this parameter,  * but it can be useful for creating the objects of the result list.  * @see #execute  */ protected abstract RowMapper<T> newRowMapper(@Nullable Object[] parameters, @Nullable Map<?, ?> context).
