commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the JDBC DataSource to obtain connections from.  */ ;/**  * Set the JDBC DataSource to obtain connections from.  */ public void setDataSource(@Nullable DataSource dataSource) {     this.dataSource = dataSource. }
true;public;0;4;/**  * Return the DataSource used by this template.  */ ;/**  * Return the DataSource used by this template.  */ @Nullable public DataSource getDataSource() {     return this.dataSource. }
true;protected;0;5;/**  * Obtain the DataSource for actual use.  * @return the DataSource (never {@code null})  * @throws IllegalStateException in case of no DataSource set  * @since 5.0  */ ;/**  * Obtain the DataSource for actual use.  * @return the DataSource (never {@code null})  * @throws IllegalStateException in case of no DataSource set  * @since 5.0  */ protected DataSource obtainDataSource() {     DataSource dataSource = getDataSource().     Assert.state(dataSource != null, "No DataSource set").     return dataSource. }
true;public;1;3;/**  * Specify the database product name for the DataSource that this accessor uses.  * This allows to initialize a SQLErrorCodeSQLExceptionTranslator without  * obtaining a Connection from the DataSource to get the meta-data.  * @param dbName the database product name that identifies the error codes entry  * @see SQLErrorCodeSQLExceptionTranslator#setDatabaseProductName  * @see java.sql.DatabaseMetaData#getDatabaseProductName()  */ ;/**  * Specify the database product name for the DataSource that this accessor uses.  * This allows to initialize a SQLErrorCodeSQLExceptionTranslator without  * obtaining a Connection from the DataSource to get the meta-data.  * @param dbName the database product name that identifies the error codes entry  * @see SQLErrorCodeSQLExceptionTranslator#setDatabaseProductName  * @see java.sql.DatabaseMetaData#getDatabaseProductName()  */ public void setDatabaseProductName(String dbName) {     this.exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dbName). }
true;public;1;3;/**  * Set the exception translator for this instance.  * <p>If no custom translator is provided, a default  * {@link SQLErrorCodeSQLExceptionTranslator} is used  * which examines the SQLException's vendor-specific error code.  * @see org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator  * @see org.springframework.jdbc.support.SQLStateSQLExceptionTranslator  */ ;/**  * Set the exception translator for this instance.  * <p>If no custom translator is provided, a default  * {@link SQLErrorCodeSQLExceptionTranslator} is used  * which examines the SQLException's vendor-specific error code.  * @see org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator  * @see org.springframework.jdbc.support.SQLStateSQLExceptionTranslator  */ public void setExceptionTranslator(SQLExceptionTranslator exceptionTranslator) {     this.exceptionTranslator = exceptionTranslator. }
true;public;0;20;/**  * Return the exception translator for this instance.  * <p>Creates a default {@link SQLErrorCodeSQLExceptionTranslator}  * for the specified DataSource if none set, or a  * {@link SQLStateSQLExceptionTranslator} in case of no DataSource.  * @see #getDataSource()  */ ;/**  * Return the exception translator for this instance.  * <p>Creates a default {@link SQLErrorCodeSQLExceptionTranslator}  * for the specified DataSource if none set, or a  * {@link SQLStateSQLExceptionTranslator} in case of no DataSource.  * @see #getDataSource()  */ public SQLExceptionTranslator getExceptionTranslator() {     SQLExceptionTranslator exceptionTranslator = this.exceptionTranslator.     if (exceptionTranslator != null) {         return exceptionTranslator.     }     synchronized (this) {         exceptionTranslator = this.exceptionTranslator.         if (exceptionTranslator == null) {             DataSource dataSource = getDataSource().             if (dataSource != null) {                 exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource).             } else {                 exceptionTranslator = new SQLStateSQLExceptionTranslator().             }             this.exceptionTranslator = exceptionTranslator.         }         return exceptionTranslator.     } }
true;public;1;3;/**  * Set whether to lazily initialize the SQLExceptionTranslator for this accessor,  * on first encounter of a SQLException. Default is "true". can be switched to  * "false" for initialization on startup.  * <p>Early initialization just applies if {@code afterPropertiesSet()} is called.  * @see #getExceptionTranslator()  * @see #afterPropertiesSet()  */ ;/**  * Set whether to lazily initialize the SQLExceptionTranslator for this accessor,  * on first encounter of a SQLException. Default is "true". can be switched to  * "false" for initialization on startup.  * <p>Early initialization just applies if {@code afterPropertiesSet()} is called.  * @see #getExceptionTranslator()  * @see #afterPropertiesSet()  */ public void setLazyInit(boolean lazyInit) {     this.lazyInit = lazyInit. }
true;public;0;3;/**  * Return whether to lazily initialize the SQLExceptionTranslator for this accessor.  * @see #getExceptionTranslator()  */ ;/**  * Return whether to lazily initialize the SQLExceptionTranslator for this accessor.  * @see #getExceptionTranslator()  */ public boolean isLazyInit() {     return this.lazyInit. }
true;public;0;9;/**  * Eagerly initialize the exception translator, if demanded,  * creating a default one for the specified DataSource if none set.  */ ;/**  * Eagerly initialize the exception translator, if demanded,  * creating a default one for the specified DataSource if none set.  */ @Override public void afterPropertiesSet() {     if (getDataSource() == null) {         throw new IllegalArgumentException("Property 'dataSource' is required").     }     if (!isLazyInit()) {         getExceptionTranslator().     } }
