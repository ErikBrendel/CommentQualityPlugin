# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1328020251;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1349872132;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1356735495;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1357119239;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1368482696;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1385412762;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1467730834;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1496837955;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1497362807;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDefaultTargetDataSource(Object defaultTargetDataSource);1498780456;Specify the default target DataSource, if any._<p>The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>This DataSource will be used as target if none of the keyed_{@link #setTargetDataSources targetDataSources} match the_{@link #determineCurrentLookupKey()} current lookup key.;public void setDefaultTargetDataSource(Object defaultTargetDataSource) {_		this.defaultTargetDataSource = defaultTargetDataSource__	};specify,the,default,target,data,source,if,any,p,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,this,data,source,will,be,used,as,target,if,none,of,the,keyed,link,set,target,data,sources,target,data,sources,match,the,link,determine,current,lookup,key,current,lookup,key;public,void,set,default,target,data,source,object,default,target,data,source,this,default,target,data,source,default,target,data,source
AbstractRoutingDataSource -> public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup);1496837955;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,nullable,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup);1497362807;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,nullable,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup);1498780456;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,nullable,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1328020251;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was <code>null</code>. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,code,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1349872132;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was <code>null</code>. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,code,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1356735495;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was {@code null}. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1357119239;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was {@code null}. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1368482696;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was {@code null}. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1385412762;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was {@code null}. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1467730834;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was {@code null}. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1496837955;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was {@code null}. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1497362807;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was {@code null}. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> public void setLenientFallback(boolean lenientFallback);1498780456;Specify whether to apply a lenient fallback to the default DataSource_if no specific DataSource could be found for the current lookup key._<p>Default is "true", accepting lookup keys without a corresponding entry_in the target DataSource map - simply falling back to the default DataSource_in that case._<p>Switch this flag to "false" if you would prefer the fallback to only apply_if the lookup key was {@code null}. Lookup keys without a DataSource_entry will then lead to an IllegalStateException._@see #setTargetDataSources_@see #setDefaultTargetDataSource_@see #determineCurrentLookupKey();public void setLenientFallback(boolean lenientFallback) {_		this.lenientFallback = lenientFallback__	};specify,whether,to,apply,a,lenient,fallback,to,the,default,data,source,if,no,specific,data,source,could,be,found,for,the,current,lookup,key,p,default,is,true,accepting,lookup,keys,without,a,corresponding,entry,in,the,target,data,source,map,simply,falling,back,to,the,default,data,source,in,that,case,p,switch,this,flag,to,false,if,you,would,prefer,the,fallback,to,only,apply,if,the,lookup,key,was,code,null,lookup,keys,without,a,data,source,entry,will,then,lead,to,an,illegal,state,exception,see,set,target,data,sources,see,set,default,target,data,source,see,determine,current,lookup,key;public,void,set,lenient,fallback,boolean,lenient,fallback,this,lenient,fallback,lenient,fallback
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1328020251;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1349872132;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1356735495;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1357119239;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1368482696;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1385412762;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1467730834;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1496837955;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1497362807;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> protected DataSource determineTargetDataSource();1498780456;Retrieve the current target DataSource. Determines the_{@link #determineCurrentLookupKey() current lookup key}, performs_a lookup in the {@link #setTargetDataSources targetDataSources} map,_falls back to the specified_{@link #setDefaultTargetDataSource default target DataSource} if necessary._@see #determineCurrentLookupKey();protected DataSource determineTargetDataSource() {_		Assert.notNull(this.resolvedDataSources, "DataSource router not initialized")__		Object lookupKey = determineCurrentLookupKey()__		DataSource dataSource = this.resolvedDataSources.get(lookupKey)__		if (dataSource == null && (this.lenientFallback || lookupKey == null)) {_			dataSource = this.resolvedDefaultDataSource__		}_		if (dataSource == null) {_			throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]")__		}_		return dataSource__	};retrieve,the,current,target,data,source,determines,the,link,determine,current,lookup,key,current,lookup,key,performs,a,lookup,in,the,link,set,target,data,sources,target,data,sources,map,falls,back,to,the,specified,link,set,default,target,data,source,default,target,data,source,if,necessary,see,determine,current,lookup,key;protected,data,source,determine,target,data,source,assert,not,null,this,resolved,data,sources,data,source,router,not,initialized,object,lookup,key,determine,current,lookup,key,data,source,data,source,this,resolved,data,sources,get,lookup,key,if,data,source,null,this,lenient,fallback,lookup,key,null,data,source,this,resolved,default,data,source,if,data,source,null,throw,new,illegal,state,exception,cannot,determine,target,data,source,for,lookup,key,lookup,key,return,data,source
AbstractRoutingDataSource -> @Nullable 	protected abstract Object determineCurrentLookupKey()_;1496837955;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;@Nullable_	protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;nullable,protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> @Nullable 	protected abstract Object determineCurrentLookupKey()_;1497362807;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;@Nullable_	protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;nullable,protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> @Nullable 	protected abstract Object determineCurrentLookupKey()_;1498780456;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;@Nullable_	protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;nullable,protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> public void setDataSourceLookup(DataSourceLookup dataSourceLookup);1328020251;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> public void setDataSourceLookup(DataSourceLookup dataSourceLookup);1349872132;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> public void setDataSourceLookup(DataSourceLookup dataSourceLookup);1356735495;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> public void setDataSourceLookup(DataSourceLookup dataSourceLookup);1357119239;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> public void setDataSourceLookup(DataSourceLookup dataSourceLookup);1368482696;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> public void setDataSourceLookup(DataSourceLookup dataSourceLookup);1385412762;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> public void setDataSourceLookup(DataSourceLookup dataSourceLookup);1467730834;Set the DataSourceLookup implementation to use for resolving data source_name Strings in the {@link #setTargetDataSources targetDataSources} map._<p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names_of application server DataSources to be specified directly.;public void setDataSourceLookup(DataSourceLookup dataSourceLookup) {_		this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup())__	};set,the,data,source,lookup,implementation,to,use,for,resolving,data,source,name,strings,in,the,link,set,target,data,sources,target,data,sources,map,p,default,is,a,link,jndi,data,source,lookup,allowing,the,jndi,names,of,application,server,data,sources,to,be,specified,directly;public,void,set,data,source,lookup,data,source,lookup,data,source,lookup,this,data,source,lookup,data,source,lookup,null,data,source,lookup,new,jndi,data,source,lookup
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1328020251;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never <code>null</code>)_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,code,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1349872132;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never <code>null</code>)_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,code,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1356735495;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never {@code null})_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1357119239;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never {@code null})_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1368482696;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never {@code null})_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1385412762;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never {@code null})_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1467730834;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never {@code null})_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1496837955;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never {@code null})_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1497362807;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never {@code null})_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException;1498780456;Resolve the specified data source object into a DataSource instance._<p>The default implementation handles DataSource instances and data source_names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup})._@param dataSource the data source value object as specified in the_{@link #setTargetDataSources targetDataSources} map_@return the resolved DataSource (never {@code null})_@throws IllegalArgumentException in case of an unsupported value type;protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {_		if (dataSource instanceof DataSource) {_			return (DataSource) dataSource__		}_		else if (dataSource instanceof String) {_			return this.dataSourceLookup.getDataSource((String) dataSource)__		}_		else {_			throw new IllegalArgumentException(_					"Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource)__		}_	};resolve,the,specified,data,source,object,into,a,data,source,instance,p,the,default,implementation,handles,data,source,instances,and,data,source,names,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,param,data,source,the,data,source,value,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,return,the,resolved,data,source,never,code,null,throws,illegal,argument,exception,in,case,of,an,unsupported,value,type;protected,data,source,resolve,specified,data,source,object,data,source,throws,illegal,argument,exception,if,data,source,instanceof,data,source,return,data,source,data,source,else,if,data,source,instanceof,string,return,this,data,source,lookup,get,data,source,string,data,source,else,throw,new,illegal,argument,exception,illegal,data,source,value,only,javax,sql,data,source,and,string,supported,data,source
AbstractRoutingDataSource -> protected abstract Object determineCurrentLookupKey()_;1328020251;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> protected abstract Object determineCurrentLookupKey()_;1349872132;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> protected abstract Object determineCurrentLookupKey()_;1356735495;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> protected abstract Object determineCurrentLookupKey()_;1357119239;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> protected abstract Object determineCurrentLookupKey()_;1368482696;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> protected abstract Object determineCurrentLookupKey()_;1385412762;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> protected abstract Object determineCurrentLookupKey()_;1467730834;Determine the current lookup key. This will typically be_implemented to check a thread-bound transaction context._<p>Allows for arbitrary keys. The returned key needs_to match the stored lookup key type, as resolved by the_{@link #resolveSpecifiedLookupKey} method.;protected abstract Object determineCurrentLookupKey()_;determine,the,current,lookup,key,this,will,typically,be,implemented,to,check,a,thread,bound,transaction,context,p,allows,for,arbitrary,keys,the,returned,key,needs,to,match,the,stored,lookup,key,type,as,resolved,by,the,link,resolve,specified,lookup,key,method;protected,abstract,object,determine,current,lookup,key
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1328020251;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1349872132;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1356735495;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1357119239;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1368482696;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1385412762;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1467730834;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1496837955;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1497362807;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> public void setTargetDataSources(Map<Object, Object> targetDataSources);1498780456;Specify the map of target DataSources, with the lookup key as key._The mapped value can either be a corresponding {@link javax.sql.DataSource}_instance or a data source name String (to be resolved via a_{@link #setDataSourceLookup DataSourceLookup})._<p>The key can be of arbitrary type_ this class implements the_generic lookup process only. The concrete key representation will_be handled by {@link #resolveSpecifiedLookupKey(Object)} and_{@link #determineCurrentLookupKey()}.;public void setTargetDataSources(Map<Object, Object> targetDataSources) {_		this.targetDataSources = targetDataSources__	};specify,the,map,of,target,data,sources,with,the,lookup,key,as,key,the,mapped,value,can,either,be,a,corresponding,link,javax,sql,data,source,instance,or,a,data,source,name,string,to,be,resolved,via,a,link,set,data,source,lookup,data,source,lookup,p,the,key,can,be,of,arbitrary,type,this,class,implements,the,generic,lookup,process,only,the,concrete,key,representation,will,be,handled,by,link,resolve,specified,lookup,key,object,and,link,determine,current,lookup,key;public,void,set,target,data,sources,map,object,object,target,data,sources,this,target,data,sources,target,data,sources
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1328020251;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1349872132;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1356735495;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1357119239;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1368482696;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1385412762;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1467730834;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1496837955;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1497362807;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
AbstractRoutingDataSource -> protected Object resolveSpecifiedLookupKey(Object lookupKey);1498780456;Resolve the given lookup key object, as specified in the_{@link #setTargetDataSources targetDataSources} map, into_the actual lookup key to be used for matching with the_{@link #determineCurrentLookupKey() current lookup key}._<p>The default implementation simply returns the given key as-is._@param lookupKey the lookup key object as specified by the user_@return the lookup key as needed for matching;protected Object resolveSpecifiedLookupKey(Object lookupKey) {_		return lookupKey__	};resolve,the,given,lookup,key,object,as,specified,in,the,link,set,target,data,sources,target,data,sources,map,into,the,actual,lookup,key,to,be,used,for,matching,with,the,link,determine,current,lookup,key,current,lookup,key,p,the,default,implementation,simply,returns,the,given,key,as,is,param,lookup,key,the,lookup,key,object,as,specified,by,the,user,return,the,lookup,key,as,needed,for,matching;protected,object,resolve,specified,lookup,key,object,lookup,key,return,lookup,key
