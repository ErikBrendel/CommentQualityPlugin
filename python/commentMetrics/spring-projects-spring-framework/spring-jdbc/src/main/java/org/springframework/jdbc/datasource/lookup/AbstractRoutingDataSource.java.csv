commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the map of target DataSources, with the lookup key as key.  * The mapped value can either be a corresponding {@link javax.sql.DataSource}  * instance or a data source name String (to be resolved via a  * {@link #setDataSourceLookup DataSourceLookup}).  * <p>The key can be of arbitrary type. this class implements the  * generic lookup process only. The concrete key representation will  * be handled by {@link #resolveSpecifiedLookupKey(Object)} and  * {@link #determineCurrentLookupKey()}.  */ ;/**  * Specify the map of target DataSources, with the lookup key as key.  * The mapped value can either be a corresponding {@link javax.sql.DataSource}  * instance or a data source name String (to be resolved via a  * {@link #setDataSourceLookup DataSourceLookup}).  * <p>The key can be of arbitrary type. this class implements the  * generic lookup process only. The concrete key representation will  * be handled by {@link #resolveSpecifiedLookupKey(Object)} and  * {@link #determineCurrentLookupKey()}.  */ public void setTargetDataSources(Map<Object, Object> targetDataSources) {     this.targetDataSources = targetDataSources. }
true;public;1;3;/**  * Specify the default target DataSource, if any.  * <p>The mapped value can either be a corresponding {@link javax.sql.DataSource}  * instance or a data source name String (to be resolved via a  * {@link #setDataSourceLookup DataSourceLookup}).  * <p>This DataSource will be used as target if none of the keyed  * {@link #setTargetDataSources targetDataSources} match the  * {@link #determineCurrentLookupKey()} current lookup key.  */ ;/**  * Specify the default target DataSource, if any.  * <p>The mapped value can either be a corresponding {@link javax.sql.DataSource}  * instance or a data source name String (to be resolved via a  * {@link #setDataSourceLookup DataSourceLookup}).  * <p>This DataSource will be used as target if none of the keyed  * {@link #setTargetDataSources targetDataSources} match the  * {@link #determineCurrentLookupKey()} current lookup key.  */ public void setDefaultTargetDataSource(Object defaultTargetDataSource) {     this.defaultTargetDataSource = defaultTargetDataSource. }
true;public;1;3;/**  * Specify whether to apply a lenient fallback to the default DataSource  * if no specific DataSource could be found for the current lookup key.  * <p>Default is "true", accepting lookup keys without a corresponding entry  * in the target DataSource map - simply falling back to the default DataSource  * in that case.  * <p>Switch this flag to "false" if you would prefer the fallback to only apply  * if the lookup key was {@code null}. Lookup keys without a DataSource  * entry will then lead to an IllegalStateException.  * @see #setTargetDataSources  * @see #setDefaultTargetDataSource  * @see #determineCurrentLookupKey()  */ ;/**  * Specify whether to apply a lenient fallback to the default DataSource  * if no specific DataSource could be found for the current lookup key.  * <p>Default is "true", accepting lookup keys without a corresponding entry  * in the target DataSource map - simply falling back to the default DataSource  * in that case.  * <p>Switch this flag to "false" if you would prefer the fallback to only apply  * if the lookup key was {@code null}. Lookup keys without a DataSource  * entry will then lead to an IllegalStateException.  * @see #setTargetDataSources  * @see #setDefaultTargetDataSource  * @see #determineCurrentLookupKey()  */ public void setLenientFallback(boolean lenientFallback) {     this.lenientFallback = lenientFallback. }
true;public;1;3;/**  * Set the DataSourceLookup implementation to use for resolving data source  * name Strings in the {@link #setTargetDataSources targetDataSources} map.  * <p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names  * of application server DataSources to be specified directly.  */ ;/**  * Set the DataSourceLookup implementation to use for resolving data source  * name Strings in the {@link #setTargetDataSources targetDataSources} map.  * <p>Default is a {@link JndiDataSourceLookup}, allowing the JNDI names  * of application server DataSources to be specified directly.  */ public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup) {     this.dataSourceLookup = (dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup()). }
false;public;0;15;;@Override public void afterPropertiesSet() {     if (this.targetDataSources == null) {         throw new IllegalArgumentException("Property 'targetDataSources' is required").     }     this.resolvedDataSources = new HashMap<>(this.targetDataSources.size()).     this.targetDataSources.forEach((key, value) -> {         Object lookupKey = resolveSpecifiedLookupKey(key).         DataSource dataSource = resolveSpecifiedDataSource(value).         this.resolvedDataSources.put(lookupKey, dataSource).     }).     if (this.defaultTargetDataSource != null) {         this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource).     } }
true;protected;1;3;/**  * Resolve the given lookup key object, as specified in the  * {@link #setTargetDataSources targetDataSources} map, into  * the actual lookup key to be used for matching with the  * {@link #determineCurrentLookupKey() current lookup key}.  * <p>The default implementation simply returns the given key as-is.  * @param lookupKey the lookup key object as specified by the user  * @return the lookup key as needed for matching  */ ;/**  * Resolve the given lookup key object, as specified in the  * {@link #setTargetDataSources targetDataSources} map, into  * the actual lookup key to be used for matching with the  * {@link #determineCurrentLookupKey() current lookup key}.  * <p>The default implementation simply returns the given key as-is.  * @param lookupKey the lookup key object as specified by the user  * @return the lookup key as needed for matching  */ protected Object resolveSpecifiedLookupKey(Object lookupKey) {     return lookupKey. }
true;protected;1;12;/**  * Resolve the specified data source object into a DataSource instance.  * <p>The default implementation handles DataSource instances and data source  * names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup}).  * @param dataSource the data source value object as specified in the  * {@link #setTargetDataSources targetDataSources} map  * @return the resolved DataSource (never {@code null})  * @throws IllegalArgumentException in case of an unsupported value type  */ ;/**  * Resolve the specified data source object into a DataSource instance.  * <p>The default implementation handles DataSource instances and data source  * names (to be resolved via a {@link #setDataSourceLookup DataSourceLookup}).  * @param dataSource the data source value object as specified in the  * {@link #setTargetDataSources targetDataSources} map  * @return the resolved DataSource (never {@code null})  * @throws IllegalArgumentException in case of an unsupported value type  */ protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {     if (dataSource instanceof DataSource) {         return (DataSource) dataSource.     } else if (dataSource instanceof String) {         return this.dataSourceLookup.getDataSource((String) dataSource).     } else {         throw new IllegalArgumentException("Illegal data source value - only [javax.sql.DataSource] and String supported: " + dataSource).     } }
false;public;0;4;;@Override public Connection getConnection() throws SQLException {     return determineTargetDataSource().getConnection(). }
false;public;2;4;;@Override public Connection getConnection(String username, String password) throws SQLException {     return determineTargetDataSource().getConnection(username, password). }
false;public;1;8;;@Override @SuppressWarnings("unchecked") public <T> T unwrap(Class<T> iface) throws SQLException {     if (iface.isInstance(this)) {         return (T) this.     }     return determineTargetDataSource().unwrap(iface). }
false;public;1;4;;@Override public boolean isWrapperFor(Class<?> iface) throws SQLException {     return (iface.isInstance(this) || determineTargetDataSource().isWrapperFor(iface)). }
true;protected;0;12;/**  * Retrieve the current target DataSource. Determines the  * {@link #determineCurrentLookupKey() current lookup key}, performs  * a lookup in the {@link #setTargetDataSources targetDataSources} map,  * falls back to the specified  * {@link #setDefaultTargetDataSource default target DataSource} if necessary.  * @see #determineCurrentLookupKey()  */ ;/**  * Retrieve the current target DataSource. Determines the  * {@link #determineCurrentLookupKey() current lookup key}, performs  * a lookup in the {@link #setTargetDataSources targetDataSources} map,  * falls back to the specified  * {@link #setDefaultTargetDataSource default target DataSource} if necessary.  * @see #determineCurrentLookupKey()  */ protected DataSource determineTargetDataSource() {     Assert.notNull(this.resolvedDataSources, "DataSource router not initialized").     Object lookupKey = determineCurrentLookupKey().     DataSource dataSource = this.resolvedDataSources.get(lookupKey).     if (dataSource == null && (this.lenientFallback || lookupKey == null)) {         dataSource = this.resolvedDefaultDataSource.     }     if (dataSource == null) {         throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]").     }     return dataSource. }
true;protected,abstract;0;2;/**  * Determine the current lookup key. This will typically be  * implemented to check a thread-bound transaction context.  * <p>Allows for arbitrary keys. The returned key needs  * to match the stored lookup key type, as resolved by the  * {@link #resolveSpecifiedLookupKey} method.  */ ;/**  * Determine the current lookup key. This will typically be  * implemented to check a thread-bound transaction context.  * <p>Allows for arbitrary keys. The returned key needs  * to match the stored lookup key type, as resolved by the  * {@link #resolveSpecifiedLookupKey} method.  */ @Nullable protected abstract Object determineCurrentLookupKey().
