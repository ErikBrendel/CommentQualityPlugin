commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the default auto-commit mode to expose when no target Connection  * has been fetched yet (-> actual JDBC Connection default not known yet).  * <p>If not specified, the default gets determined by checking a target  * Connection on startup. If that check fails, the default will be determined  * lazily on first access of a Connection.  * @see java.sql.Connection#setAutoCommit  */ ;/**  * Set the default auto-commit mode to expose when no target Connection  * has been fetched yet (-> actual JDBC Connection default not known yet).  * <p>If not specified, the default gets determined by checking a target  * Connection on startup. If that check fails, the default will be determined  * lazily on first access of a Connection.  * @see java.sql.Connection#setAutoCommit  */ public void setDefaultAutoCommit(boolean defaultAutoCommit) {     this.defaultAutoCommit = defaultAutoCommit. }
true;public;1;3;/**  * Set the default transaction isolation level to expose when no target Connection  * has been fetched yet (-> actual JDBC Connection default not known yet).  * <p>This property accepts the int constant value (e.g. 8) as defined in the  * {@link java.sql.Connection} interface. it is mainly intended for programmatic  * use. Consider using the "defaultTransactionIsolationName" property for setting  * the value by name (e.g. "TRANSACTION_SERIALIZABLE").  * <p>If not specified, the default gets determined by checking a target  * Connection on startup. If that check fails, the default will be determined  * lazily on first access of a Connection.  * @see #setDefaultTransactionIsolationName  * @see java.sql.Connection#setTransactionIsolation  */ ;/**  * Set the default transaction isolation level to expose when no target Connection  * has been fetched yet (-> actual JDBC Connection default not known yet).  * <p>This property accepts the int constant value (e.g. 8) as defined in the  * {@link java.sql.Connection} interface. it is mainly intended for programmatic  * use. Consider using the "defaultTransactionIsolationName" property for setting  * the value by name (e.g. "TRANSACTION_SERIALIZABLE").  * <p>If not specified, the default gets determined by checking a target  * Connection on startup. If that check fails, the default will be determined  * lazily on first access of a Connection.  * @see #setDefaultTransactionIsolationName  * @see java.sql.Connection#setTransactionIsolation  */ public void setDefaultTransactionIsolation(int defaultTransactionIsolation) {     this.defaultTransactionIsolation = defaultTransactionIsolation. }
true;public;1;3;/**  * Set the default transaction isolation level by the name of the corresponding  * constant in {@link java.sql.Connection}, e.g. "TRANSACTION_SERIALIZABLE".  * @param constantName name of the constant  * @see #setDefaultTransactionIsolation  * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED  * @see java.sql.Connection#TRANSACTION_READ_COMMITTED  * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ  * @see java.sql.Connection#TRANSACTION_SERIALIZABLE  */ ;/**  * Set the default transaction isolation level by the name of the corresponding  * constant in {@link java.sql.Connection}, e.g. "TRANSACTION_SERIALIZABLE".  * @param constantName name of the constant  * @see #setDefaultTransactionIsolation  * @see java.sql.Connection#TRANSACTION_READ_UNCOMMITTED  * @see java.sql.Connection#TRANSACTION_READ_COMMITTED  * @see java.sql.Connection#TRANSACTION_REPEATABLE_READ  * @see java.sql.Connection#TRANSACTION_SERIALIZABLE  */ public void setDefaultTransactionIsolationName(String constantName) {     setDefaultTransactionIsolation(constants.asNumber(constantName).intValue()). }
false;public;0;17;;@Override public void afterPropertiesSet() {     super.afterPropertiesSet().     // via a Connection from the target DataSource, if possible.     if (this.defaultAutoCommit == null || this.defaultTransactionIsolation == null) {         try {             try (Connection con = obtainTargetDataSource().getConnection()) {                 checkDefaultConnectionProperties(con).             }         } catch (SQLException ex) {             logger.debug("Could not retrieve default auto-commit and transaction isolation settings", ex).         }     } }
true;protected,synchronized;1;8;/**  * Check the default connection properties (auto-commit, transaction isolation),  * keeping them to be able to expose them correctly without fetching an actual  * JDBC Connection from the target DataSource.  * <p>This will be invoked once on startup, but also for each retrieval of a  * target Connection. If the check failed on startup (because the database was  * down), we'll lazily retrieve those settings.  * @param con the Connection to use for checking  * @throws SQLException if thrown by Connection methods  */ ;/**  * Check the default connection properties (auto-commit, transaction isolation),  * keeping them to be able to expose them correctly without fetching an actual  * JDBC Connection from the target DataSource.  * <p>This will be invoked once on startup, but also for each retrieval of a  * target Connection. If the check failed on startup (because the database was  * down), we'll lazily retrieve those settings.  * @param con the Connection to use for checking  * @throws SQLException if thrown by Connection methods  */ protected synchronized void checkDefaultConnectionProperties(Connection con) throws SQLException {     if (this.defaultAutoCommit == null) {         this.defaultAutoCommit = con.getAutoCommit().     }     if (this.defaultTransactionIsolation == null) {         this.defaultTransactionIsolation = con.getTransactionIsolation().     } }
true;protected;0;4;/**  * Expose the default auto-commit value.  */ ;/**  * Expose the default auto-commit value.  */ @Nullable protected Boolean defaultAutoCommit() {     return this.defaultAutoCommit. }
true;protected;0;4;/**  * Expose the default transaction isolation value.  */ ;/**  * Expose the default transaction isolation value.  */ @Nullable protected Integer defaultTransactionIsolation() {     return this.defaultTransactionIsolation. }
true;public;0;7;/**  * Return a Connection handle that lazily fetches an actual JDBC Connection  * when asked for a Statement (or PreparedStatement or CallableStatement).  * <p>The returned Connection handle implements the ConnectionProxy interface,  * allowing to retrieve the underlying target Connection.  * @return a lazy Connection handle  * @see ConnectionProxy#getTargetConnection()  */ ;/**  * Return a Connection handle that lazily fetches an actual JDBC Connection  * when asked for a Statement (or PreparedStatement or CallableStatement).  * <p>The returned Connection handle implements the ConnectionProxy interface,  * allowing to retrieve the underlying target Connection.  * @return a lazy Connection handle  * @see ConnectionProxy#getTargetConnection()  */ @Override public Connection getConnection() throws SQLException {     return (Connection) Proxy.newProxyInstance(ConnectionProxy.class.getClassLoader(), new Class<?>[] { ConnectionProxy.class }, new LazyConnectionInvocationHandler()). }
true;public;2;7;/**  * Return a Connection handle that lazily fetches an actual JDBC Connection  * when asked for a Statement (or PreparedStatement or CallableStatement).  * <p>The returned Connection handle implements the ConnectionProxy interface,  * allowing to retrieve the underlying target Connection.  * @param username the per-Connection username  * @param password the per-Connection password  * @return a lazy Connection handle  * @see ConnectionProxy#getTargetConnection()  */ ;/**  * Return a Connection handle that lazily fetches an actual JDBC Connection  * when asked for a Statement (or PreparedStatement or CallableStatement).  * <p>The returned Connection handle implements the ConnectionProxy interface,  * allowing to retrieve the underlying target Connection.  * @param username the per-Connection username  * @param password the per-Connection password  * @return a lazy Connection handle  * @see ConnectionProxy#getTargetConnection()  */ @Override public Connection getConnection(String username, String password) throws SQLException {     return (Connection) Proxy.newProxyInstance(ConnectionProxy.class.getClassLoader(), new Class<?>[] { ConnectionProxy.class }, new LazyConnectionInvocationHandler(username, password)). }
false;public;3;114;;@Override @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Connection has been fetched: use hashCode of Connection proxy.         return System.identityHashCode(proxy).     } else if (method.getName().equals("unwrap")) {         if (((Class<?>) args[0]).isInstance(proxy)) {             return proxy.         }     } else if (method.getName().equals("isWrapperFor")) {         if (((Class<?>) args[0]).isInstance(proxy)) {             return true.         }     } else if (method.getName().equals("getTargetConnection")) {         // Handle getTargetConnection method: return underlying connection.         return getTargetConnection(method).     }     if (!hasTargetConnection()) {         if (method.getName().equals("toString")) {             return "Lazy Connection proxy for target DataSource [" + getTargetDataSource() + "]".         } else if (method.getName().equals("getAutoCommit")) {             if (this.autoCommit != null) {                 return this.autoCommit.             }         // Else fetch actual Connection and check there,         // because we didn't have a default specified.         } else if (method.getName().equals("setAutoCommit")) {             this.autoCommit = (Boolean) args[0].             return null.         } else if (method.getName().equals("getTransactionIsolation")) {             if (this.transactionIsolation != null) {                 return this.transactionIsolation.             }         // Else fetch actual Connection and check there,         // because we didn't have a default specified.         } else if (method.getName().equals("setTransactionIsolation")) {             this.transactionIsolation = (Integer) args[0].             return null.         } else if (method.getName().equals("isReadOnly")) {             return this.readOnly.         } else if (method.getName().equals("setReadOnly")) {             this.readOnly = (Boolean) args[0].             return null.         } else if (method.getName().equals("getHoldability")) {             return this.holdability.         } else if (method.getName().equals("setHoldability")) {             this.holdability = (Integer) args[0].             return null.         } else if (method.getName().equals("commit")) {             // Ignore: no statements created yet.             return null.         } else if (method.getName().equals("rollback")) {             // Ignore: no statements created yet.             return null.         } else if (method.getName().equals("getWarnings")) {             return null.         } else if (method.getName().equals("clearWarnings")) {             return null.         } else if (method.getName().equals("close")) {             // Ignore: no target connection yet.             this.closed = true.             return null.         } else if (method.getName().equals("isClosed")) {             return this.closed.         } else if (this.closed) {             // physical JDBC Connection: throw corresponding SQLException.             throw new SQLException("Illegal operation: connection is closed").         }     }     // invoke method on target connection.     try {         return method.invoke(getTargetConnection(method), args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
true;private;0;3;/**  * Return whether the proxy currently holds a target Connection.  */ ;/**  * Return whether the proxy currently holds a target Connection.  */ private boolean hasTargetConnection() {     return (this.target != null). }
true;private;1;43;/**  * Return the target Connection, fetching it and initializing it if necessary.  */ ;/**  * Return the target Connection, fetching it and initializing it if necessary.  */ private Connection getTargetConnection(Method operation) throws SQLException {     if (this.target == null) {         // No target Connection held -> fetch one.         if (logger.isTraceEnabled()) {             logger.trace("Connecting to database for operation '" + operation.getName() + "'").         }         // Fetch physical Connection from DataSource.         this.target = (this.username != null) ? obtainTargetDataSource().getConnection(this.username, this.password) : obtainTargetDataSource().getConnection().         // If we still lack default connection properties, check them now.         checkDefaultConnectionProperties(this.target).         // Apply kept transaction settings, if any.         if (this.readOnly) {             try {                 this.target.setReadOnly(true).             } catch (Exception ex) {                 // "read-only not supported" -> ignore, it's just a hint anyway                 logger.debug("Could not set JDBC Connection read-only", ex).             }         }         if (this.transactionIsolation != null && !this.transactionIsolation.equals(defaultTransactionIsolation())) {             this.target.setTransactionIsolation(this.transactionIsolation).         }         if (this.autoCommit != null && this.autoCommit != this.target.getAutoCommit()) {             this.target.setAutoCommit(this.autoCommit).         }     } else {         // Target Connection already held -> return it.         if (logger.isTraceEnabled()) {             logger.trace("Using existing database connection for operation '" + operation.getName() + "'").         }     }     return this.target. }
