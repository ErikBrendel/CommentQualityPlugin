commented;modifiers;parameterAmount;loc;comment;code
true;protected,final;0;12;/**  * Overridden method to configure the PreparedStatementCreatorFactory  * based on our declared parameters.  */ ;/**  * Overridden method to configure the PreparedStatementCreatorFactory  * based on our declared parameters.  */ @Override protected final void compileInternal() {     this.preparedStatementFactory = new PreparedStatementCreatorFactory(resolveSql(), getDeclaredParameters()).     this.preparedStatementFactory.setResultSetType(getResultSetType()).     this.preparedStatementFactory.setUpdatableResults(isUpdatableResults()).     this.preparedStatementFactory.setReturnGeneratedKeys(isReturnGeneratedKeys()).     if (getGeneratedKeysColumnNames() != null) {         this.preparedStatementFactory.setGeneratedKeysColumnNames(getGeneratedKeysColumnNames()).     }     onCompileInternal(). }
true;protected;0;2;/**  * Hook method that subclasses may override to post-process compilation.  * This implementation does nothing.  * @see #compileInternal  */ ;/**  * Hook method that subclasses may override to post-process compilation.  * This implementation does nothing.  * @see #compileInternal  */ protected void onCompileInternal() { }
true;protected;0;8;/**  * Obtain a parsed representation of this operation's SQL statement.  * <p>Typically used for named parameter parsing.  */ ;/**  * Obtain a parsed representation of this operation's SQL statement.  * <p>Typically used for named parameter parsing.  */ protected ParsedSql getParsedSql() {     synchronized (this.parsedSqlMonitor) {         if (this.cachedSql == null) {             this.cachedSql = NamedParameterUtils.parseSqlStatement(resolveSql()).         }         return this.cachedSql.     } }
true;protected,final;1;4;/**  * Return a PreparedStatementSetter to perform an operation  * with the given parameters.  * @param params the parameter array (may be {@code null})  */ ;/**  * Return a PreparedStatementSetter to perform an operation  * with the given parameters.  * @param params the parameter array (may be {@code null})  */ protected final PreparedStatementSetter newPreparedStatementSetter(@Nullable Object[] params) {     Assert.state(this.preparedStatementFactory != null, "No PreparedStatementFactory available").     return this.preparedStatementFactory.newPreparedStatementSetter(params). }
true;protected,final;1;4;/**  * Return a PreparedStatementCreator to perform an operation  * with the given parameters.  * @param params the parameter array (may be {@code null})  */ ;/**  * Return a PreparedStatementCreator to perform an operation  * with the given parameters.  * @param params the parameter array (may be {@code null})  */ protected final PreparedStatementCreator newPreparedStatementCreator(@Nullable Object[] params) {     Assert.state(this.preparedStatementFactory != null, "No PreparedStatementFactory available").     return this.preparedStatementFactory.newPreparedStatementCreator(params). }
true;protected,final;2;4;/**  * Return a PreparedStatementCreator to perform an operation  * with the given parameters.  * @param sqlToUse the actual SQL statement to use (if different from  * the factory's, for example because of named parameter expanding)  * @param params the parameter array (may be {@code null})  */ ;/**  * Return a PreparedStatementCreator to perform an operation  * with the given parameters.  * @param sqlToUse the actual SQL statement to use (if different from  * the factory's, for example because of named parameter expanding)  * @param params the parameter array (may be {@code null})  */ protected final PreparedStatementCreator newPreparedStatementCreator(String sqlToUse, @Nullable Object[] params) {     Assert.state(this.preparedStatementFactory != null, "No PreparedStatementFactory available").     return this.preparedStatementFactory.newPreparedStatementCreator(sqlToUse, params). }
