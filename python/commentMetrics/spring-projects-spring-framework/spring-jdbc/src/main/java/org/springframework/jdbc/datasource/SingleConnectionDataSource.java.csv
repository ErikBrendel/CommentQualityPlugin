commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether the returned Connection should be a close-suppressing proxy  * or the physical Connection.  */ ;/**  * Set whether the returned Connection should be a close-suppressing proxy  * or the physical Connection.  */ public void setSuppressClose(boolean suppressClose) {     this.suppressClose = suppressClose. }
true;protected;0;3;/**  * Return whether the returned Connection will be a close-suppressing proxy  * or the physical Connection.  */ ;/**  * Return whether the returned Connection will be a close-suppressing proxy  * or the physical Connection.  */ protected boolean isSuppressClose() {     return this.suppressClose. }
true;public;1;3;/**  * Set whether the returned Connection's "autoCommit" setting should be overridden.  */ ;/**  * Set whether the returned Connection's "autoCommit" setting should be overridden.  */ public void setAutoCommit(boolean autoCommit) {     this.autoCommit = (autoCommit). }
true;protected;0;4;/**  * Return whether the returned Connection's "autoCommit" setting should be overridden.  * @return the "autoCommit" value, or {@code null} if none to be applied  */ ;/**  * Return whether the returned Connection's "autoCommit" setting should be overridden.  * @return the "autoCommit" value, or {@code null} if none to be applied  */ @Nullable protected Boolean getAutoCommitValue() {     return this.autoCommit. }
false;public;0;15;;@Override public Connection getConnection() throws SQLException {     synchronized (this.connectionMonitor) {         if (this.connection == null) {             // No underlying Connection -> lazy init via DriverManager.             initConnection().         }         if (this.connection.isClosed()) {             throw new SQLException("Connection was closed in SingleConnectionDataSource. Check that user code checks " + "shouldClose() before closing Connections, or set 'suppressClose' to 'true'").         }         return this.connection.     } }
true;public;2;10;/**  * Specifying a custom username and password doesn't make sense  * with a single Connection. Returns the single Connection if given  * the same username and password. throws a SQLException else.  */ ;/**  * Specifying a custom username and password doesn't make sense  * with a single Connection. Returns the single Connection if given  * the same username and password. throws a SQLException else.  */ @Override public Connection getConnection(String username, String password) throws SQLException {     if (ObjectUtils.nullSafeEquals(username, getUsername()) && ObjectUtils.nullSafeEquals(password, getPassword())) {         return getConnection().     } else {         throw new SQLException("SingleConnectionDataSource does not support custom username and password").     } }
true;public;1;6;/**  * This is a single Connection: Do not close it when returning to the "pool".  */ ;/**  * This is a single Connection: Do not close it when returning to the "pool".  */ @Override public boolean shouldClose(Connection con) {     synchronized (this.connectionMonitor) {         return (con != this.connection && con != this.target).     } }
true;public;0;6;/**  * Close the underlying Connection.  * The provider of this DataSource needs to care for proper shutdown.  * <p>As this bean implements DisposableBean, a bean factory will  * automatically invoke this on destruction of its cached singletons.  */ ;/**  * Close the underlying Connection.  * The provider of this DataSource needs to care for proper shutdown.  * <p>As this bean implements DisposableBean, a bean factory will  * automatically invoke this on destruction of its cached singletons.  */ @Override public void destroy() {     synchronized (this.connectionMonitor) {         closeConnection().     } }
true;public;0;14;/**  * Initialize the underlying Connection via the DriverManager.  */ ;/**  * Initialize the underlying Connection via the DriverManager.  */ public void initConnection() throws SQLException {     if (getUrl() == null) {         throw new IllegalStateException("'url' property is required for lazily initializing a Connection").     }     synchronized (this.connectionMonitor) {         closeConnection().         this.target = getConnectionFromDriver(getUsername(), getPassword()).         prepareConnection(this.target).         if (logger.isDebugEnabled()) {             logger.debug("Established shared JDBC Connection: " + this.target).         }         this.connection = (isSuppressClose() ? getCloseSuppressingConnectionProxy(this.target) : this.target).     } }
true;public;0;7;/**  * Reset the underlying shared Connection, to be reinitialized on next access.  */ ;/**  * Reset the underlying shared Connection, to be reinitialized on next access.  */ public void resetConnection() {     synchronized (this.connectionMonitor) {         closeConnection().         this.target = null.         this.connection = null.     } }
true;protected;1;6;/**  * Prepare the given Connection before it is exposed.  * <p>The default implementation applies the auto-commit flag, if necessary.  * Can be overridden in subclasses.  * @param con the Connection to prepare  * @see #setAutoCommit  */ ;/**  * Prepare the given Connection before it is exposed.  * <p>The default implementation applies the auto-commit flag, if necessary.  * Can be overridden in subclasses.  * @param con the Connection to prepare  * @see #setAutoCommit  */ protected void prepareConnection(Connection con) throws SQLException {     Boolean autoCommit = getAutoCommitValue().     if (autoCommit != null && con.getAutoCommit() != autoCommit) {         con.setAutoCommit(autoCommit).     } }
true;private;0;10;/**  * Close the underlying shared Connection.  */ ;/**  * Close the underlying shared Connection.  */ private void closeConnection() {     if (this.target != null) {         try {             this.target.close().         } catch (Throwable ex) {             logger.info("Could not close shared JDBC Connection", ex).         }     } }
true;protected;1;6;/**  * Wrap the given Connection with a proxy that delegates every method call to it  * but suppresses close calls.  * @param target the original Connection to wrap  * @return the wrapped Connection  */ ;/**  * Wrap the given Connection with a proxy that delegates every method call to it  * but suppresses close calls.  * @param target the original Connection to wrap  * @return the wrapped Connection  */ protected Connection getCloseSuppressingConnectionProxy(Connection target) {     return (Connection) Proxy.newProxyInstance(ConnectionProxy.class.getClassLoader(), new Class<?>[] { ConnectionProxy.class }, new CloseSuppressingInvocationHandler(target)). }
false;public;3;43;;@Override @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Use hashCode of Connection proxy.         return System.identityHashCode(proxy).     } else if (method.getName().equals("unwrap")) {         if (((Class<?>) args[0]).isInstance(proxy)) {             return proxy.         }     } else if (method.getName().equals("isWrapperFor")) {         if (((Class<?>) args[0]).isInstance(proxy)) {             return true.         }     } else if (method.getName().equals("close")) {         // Handle close method: don't pass the call on.         return null.     } else if (method.getName().equals("isClosed")) {         return false.     } else if (method.getName().equals("getTargetConnection")) {         // Handle getTargetConnection method: return underlying Connection.         return this.target.     }     // Invoke method on target Connection.     try {         return method.invoke(this.target, args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
