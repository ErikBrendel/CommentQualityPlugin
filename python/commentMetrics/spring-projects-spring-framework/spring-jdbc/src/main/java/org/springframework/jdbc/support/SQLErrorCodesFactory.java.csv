commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;3;/**  * Return the singleton instance.  */ ;/**  * Return the singleton instance.  */ public static SQLErrorCodesFactory getInstance() {     return instance. }
true;protected;1;4;/**  * Load the given resource from the class path.  * <p><b>Not to be overridden by application developers, who should obtain  * instances of this class from the static {@link #getInstance()} method.</b>  * <p>Protected for testability.  * @param path resource path. either a custom path or one of either  * {@link #SQL_ERROR_CODE_DEFAULT_PATH} or  * {@link #SQL_ERROR_CODE_OVERRIDE_PATH}.  * @return the resource, or {@code null} if the resource wasn't found  * @see #getInstance  */ ;/**  * Load the given resource from the class path.  * <p><b>Not to be overridden by application developers, who should obtain  * instances of this class from the static {@link #getInstance()} method.</b>  * <p>Protected for testability.  * @param path resource path. either a custom path or one of either  * {@link #SQL_ERROR_CODE_DEFAULT_PATH} or  * {@link #SQL_ERROR_CODE_OVERRIDE_PATH}.  * @return the resource, or {@code null} if the resource wasn't found  * @see #getInstance  */ @Nullable protected Resource loadResource(String path) {     return new ClassPathResource(path, getClass().getClassLoader()). }
true;public;1;26;/**  * Return the {@link SQLErrorCodes} instance for the given database.  * <p>No need for a database meta-data lookup.  * @param databaseName the database name (must not be {@code null})  * @return the {@code SQLErrorCodes} instance for the given database  * @throws IllegalArgumentException if the supplied database name is {@code null}  */ ;/**  * Return the {@link SQLErrorCodes} instance for the given database.  * <p>No need for a database meta-data lookup.  * @param databaseName the database name (must not be {@code null})  * @return the {@code SQLErrorCodes} instance for the given database  * @throws IllegalArgumentException if the supplied database name is {@code null}  */ public SQLErrorCodes getErrorCodes(String databaseName) {     Assert.notNull(databaseName, "Database product name must not be null").     SQLErrorCodes sec = this.errorCodesMap.get(databaseName).     if (sec == null) {         for (SQLErrorCodes candidate : this.errorCodesMap.values()) {             if (PatternMatchUtils.simpleMatch(candidate.getDatabaseProductNames(), databaseName)) {                 sec = candidate.                 break.             }         }     }     if (sec != null) {         checkCustomTranslatorRegistry(databaseName, sec).         if (logger.isDebugEnabled()) {             logger.debug("SQL error codes for '" + databaseName + "' found").         }         return sec.     }     // Could not find the database among the defined ones.     if (logger.isDebugEnabled()) {         logger.debug("SQL error codes for '" + databaseName + "' not found").     }     return new SQLErrorCodes(). }
true;public;1;35;/**  * Return {@link SQLErrorCodes} for the given {@link DataSource},  * evaluating "databaseProductName" from the  * {@link java.sql.DatabaseMetaData}, or an empty error codes  * instance if no {@code SQLErrorCodes} were found.  * @param dataSource the {@code DataSource} identifying the database  * @return the corresponding {@code SQLErrorCodes} object  * @see java.sql.DatabaseMetaData#getDatabaseProductName()  */ ;/**  * Return {@link SQLErrorCodes} for the given {@link DataSource},  * evaluating "databaseProductName" from the  * {@link java.sql.DatabaseMetaData}, or an empty error codes  * instance if no {@code SQLErrorCodes} were found.  * @param dataSource the {@code DataSource} identifying the database  * @return the corresponding {@code SQLErrorCodes} object  * @see java.sql.DatabaseMetaData#getDatabaseProductName()  */ public SQLErrorCodes getErrorCodes(DataSource dataSource) {     Assert.notNull(dataSource, "DataSource must not be null").     if (logger.isDebugEnabled()) {         logger.debug("Looking up default SQLErrorCodes for DataSource [" + identify(dataSource) + "]").     }     // Try efficient lock-free access for existing cache entry     SQLErrorCodes sec = this.dataSourceCache.get(dataSource).     if (sec == null) {         synchronized (this.dataSourceCache) {             // Double-check within full dataSourceCache lock             sec = this.dataSourceCache.get(dataSource).             if (sec == null) {                 // We could not find it - got to look it up.                 try {                     String name = JdbcUtils.extractDatabaseMetaData(dataSource, "getDatabaseProductName").                     if (StringUtils.hasLength(name)) {                         return registerDatabase(dataSource, name).                     }                 } catch (MetaDataAccessException ex) {                     logger.warn("Error while extracting database name - falling back to empty error codes", ex).                 }                 // Fallback is to return an empty SQLErrorCodes instance.                 return new SQLErrorCodes().             }         }     }     if (logger.isDebugEnabled()) {         logger.debug("SQLErrorCodes found in cache for DataSource [" + identify(dataSource) + "]").     }     return sec. }
true;public;2;9;/**  * Associate the specified database name with the given {@link DataSource}.  * @param dataSource the {@code DataSource} identifying the database  * @param databaseName the corresponding database name as stated in the error codes  * definition file (must not be {@code null})  * @return the corresponding {@code SQLErrorCodes} object (never {@code null})  * @see #unregisterDatabase(DataSource)  */ ;/**  * Associate the specified database name with the given {@link DataSource}.  * @param dataSource the {@code DataSource} identifying the database  * @param databaseName the corresponding database name as stated in the error codes  * definition file (must not be {@code null})  * @return the corresponding {@code SQLErrorCodes} object (never {@code null})  * @see #unregisterDatabase(DataSource)  */ public SQLErrorCodes registerDatabase(DataSource dataSource, String databaseName) {     SQLErrorCodes sec = getErrorCodes(databaseName).     if (logger.isDebugEnabled()) {         logger.debug("Caching SQL error codes for DataSource [" + identify(dataSource) + "]: database product name is '" + databaseName + "'").     }     this.dataSourceCache.put(dataSource, sec).     return sec. }
true;public;1;4;/**  * Clear the cache for the specified {@link DataSource}, if registered.  * @param dataSource the {@code DataSource} identifying the database  * @return the corresponding {@code SQLErrorCodes} object that got removed,  * or {@code null} if not registered  * @since 4.3.5  * @see #registerDatabase(DataSource, String)  */ ;/**  * Clear the cache for the specified {@link DataSource}, if registered.  * @param dataSource the {@code DataSource} identifying the database  * @return the corresponding {@code SQLErrorCodes} object that got removed,  * or {@code null} if not registered  * @since 4.3.5  * @see #registerDatabase(DataSource, String)  */ @Nullable public SQLErrorCodes unregisterDatabase(DataSource dataSource) {     return this.dataSourceCache.remove(dataSource). }
true;private;1;3;/**  * Build an identification String for the given {@link DataSource},  * primarily for logging purposes.  * @param dataSource the {@code DataSource} to introspect  * @return the identification String  */ ;/**  * Build an identification String for the given {@link DataSource},  * primarily for logging purposes.  * @param dataSource the {@code DataSource} to introspect  * @return the identification String  */ private String identify(DataSource dataSource) {     return dataSource.getClass().getName() + '@' + Integer.toHexString(dataSource.hashCode()). }
true;private;2;17;/**  * Check the {@link CustomSQLExceptionTranslatorRegistry} for any entries.  */ ;/**  * Check the {@link CustomSQLExceptionTranslatorRegistry} for any entries.  */ private void checkCustomTranslatorRegistry(String databaseName, SQLErrorCodes errorCodes) {     SQLExceptionTranslator customTranslator = CustomSQLExceptionTranslatorRegistry.getInstance().findTranslatorForDatabase(databaseName).     if (customTranslator != null) {         if (errorCodes.getCustomSqlExceptionTranslator() != null && logger.isDebugEnabled()) {             logger.debug("Overriding already defined custom translator '" + errorCodes.getCustomSqlExceptionTranslator().getClass().getSimpleName() + " with '" + customTranslator.getClass().getSimpleName() + "' found in the CustomSQLExceptionTranslatorRegistry for database '" + databaseName + "'").         } else if (logger.isTraceEnabled()) {             logger.trace("Using custom translator '" + customTranslator.getClass().getSimpleName() + "' found in the CustomSQLExceptionTranslatorRegistry for database '" + databaseName + "'").         }         errorCodes.setCustomSqlExceptionTranslator(customTranslator).     } }
