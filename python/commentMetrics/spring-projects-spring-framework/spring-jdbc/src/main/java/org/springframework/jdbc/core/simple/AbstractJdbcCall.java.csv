commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Get the configured {@link JdbcTemplate}.  */ ;/**  * Get the configured {@link JdbcTemplate}.  */ public JdbcTemplate getJdbcTemplate() {     return this.jdbcTemplate. }
true;public;1;3;/**  * Set the name of the stored procedure.  */ ;/**  * Set the name of the stored procedure.  */ public void setProcedureName(@Nullable String procedureName) {     this.callMetaDataContext.setProcedureName(procedureName). }
true;public;0;4;/**  * Get the name of the stored procedure.  */ ;/**  * Get the name of the stored procedure.  */ @Nullable public String getProcedureName() {     return this.callMetaDataContext.getProcedureName(). }
true;public;1;3;/**  * Set the names of in parameters to be used.  */ ;/**  * Set the names of in parameters to be used.  */ public void setInParameterNames(Set<String> inParameterNames) {     this.callMetaDataContext.setLimitedInParameterNames(inParameterNames). }
true;public;0;3;/**  * Get the names of in parameters to be used.  */ ;/**  * Get the names of in parameters to be used.  */ public Set<String> getInParameterNames() {     return this.callMetaDataContext.getLimitedInParameterNames(). }
true;public;1;3;/**  * Set the catalog name to use.  */ ;/**  * Set the catalog name to use.  */ public void setCatalogName(@Nullable String catalogName) {     this.callMetaDataContext.setCatalogName(catalogName). }
true;public;0;4;/**  * Get the catalog name used.  */ ;/**  * Get the catalog name used.  */ @Nullable public String getCatalogName() {     return this.callMetaDataContext.getCatalogName(). }
true;public;1;3;/**  * Set the schema name to use.  */ ;/**  * Set the schema name to use.  */ public void setSchemaName(@Nullable String schemaName) {     this.callMetaDataContext.setSchemaName(schemaName). }
true;public;0;4;/**  * Get the schema name used.  */ ;/**  * Get the schema name used.  */ @Nullable public String getSchemaName() {     return this.callMetaDataContext.getSchemaName(). }
true;public;1;3;/**  * Specify whether this call is a function call.  * The default is {@code false}.  */ ;/**  * Specify whether this call is a function call.  * The default is {@code false}.  */ public void setFunction(boolean function) {     this.callMetaDataContext.setFunction(function). }
true;public;0;3;/**  * Is this call a function call?  */ ;/**  * Is this call a function call?  */ public boolean isFunction() {     return this.callMetaDataContext.isFunction(). }
true;public;1;3;/**  * Specify whether the call requires a return value.  * The default is {@code false}.  */ ;/**  * Specify whether the call requires a return value.  * The default is {@code false}.  */ public void setReturnValueRequired(boolean returnValueRequired) {     this.callMetaDataContext.setReturnValueRequired(returnValueRequired). }
true;public;0;3;/**  * Does the call require a return value?  */ ;/**  * Does the call require a return value?  */ public boolean isReturnValueRequired() {     return this.callMetaDataContext.isReturnValueRequired(). }
true;public;1;3;/**  * Specify whether parameters should be bound by name.  * The default is {@code false}.  * @since 4.2  */ ;/**  * Specify whether parameters should be bound by name.  * The default is {@code false}.  * @since 4.2  */ public void setNamedBinding(boolean namedBinding) {     this.callMetaDataContext.setNamedBinding(namedBinding). }
true;public;0;3;/**  * Should parameters be bound by name?  * @since 4.2  */ ;/**  * Should parameters be bound by name?  * @since 4.2  */ public boolean isNamedBinding() {     return this.callMetaDataContext.isNamedBinding(). }
true;public;1;3;/**  * Specify whether the parameter meta-data for the call should be used.  * The default is {@code true}.  */ ;/**  * Specify whether the parameter meta-data for the call should be used.  * The default is {@code true}.  */ public void setAccessCallParameterMetaData(boolean accessCallParameterMetaData) {     this.callMetaDataContext.setAccessCallParameterMetaData(accessCallParameterMetaData). }
true;public;0;4;/**  * Get the call string that should be used based on parameters and meta-data.  */ ;/**  * Get the call string that should be used based on parameters and meta-data.  */ @Nullable public String getCallString() {     return this.callString. }
true;protected;0;4;/**  * Get the {@link CallableStatementCreatorFactory} being used.  */ ;/**  * Get the {@link CallableStatementCreatorFactory} being used.  */ protected CallableStatementCreatorFactory getCallableStatementFactory() {     Assert.state(this.callableStatementFactory != null, "No CallableStatementCreatorFactory available").     return this.callableStatementFactory. }
true;public;1;11;/**  * Add a declared parameter to the list of parameters for the call.  * <p>Only parameters declared as {@code SqlParameter} and {@code SqlInOutParameter} will  * be used to provide input values. This is different from the {@code StoredProcedure}  * class which - for backwards compatibility reasons - allows input values to be provided  * for parameters declared as {@code SqlOutParameter}.  * @param parameter the {@link SqlParameter} to add  */ ;/**  * Add a declared parameter to the list of parameters for the call.  * <p>Only parameters declared as {@code SqlParameter} and {@code SqlInOutParameter} will  * be used to provide input values. This is different from the {@code StoredProcedure}  * class which - for backwards compatibility reasons - allows input values to be provided  * for parameters declared as {@code SqlOutParameter}.  * @param parameter the {@link SqlParameter} to add  */ public void addDeclaredParameter(SqlParameter parameter) {     Assert.notNull(parameter, "The supplied parameter must not be null").     if (!StringUtils.hasText(parameter.getName())) {         throw new InvalidDataAccessApiUsageException("You must specify a parameter name when declaring parameters for \"" + getProcedureName() + "\"").     }     this.declaredParameters.add(parameter).     if (logger.isDebugEnabled()) {         logger.debug("Added declared parameter for [" + getProcedureName() + "]: " + parameter.getName()).     } }
true;public;2;6;/**  * Add a {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.  * @param parameterName name of parameter or column  * @param rowMapper the RowMapper implementation to use  */ ;/**  * Add a {@link org.springframework.jdbc.core.RowMapper} for the specified parameter or column.  * @param parameterName name of parameter or column  * @param rowMapper the RowMapper implementation to use  */ public void addDeclaredRowMapper(String parameterName, RowMapper<?> rowMapper) {     this.declaredRowMappers.put(parameterName, rowMapper).     if (logger.isDebugEnabled()) {         logger.debug("Added row mapper for [" + getProcedureName() + "]: " + parameterName).     } }
true;public,final,synchronized;0;19;/**  * Compile this JdbcCall using provided parameters and meta-data plus other settings.  * <p>This finalizes the configuration for this object and subsequent attempts to compile are  * ignored. This will be implicitly called the first time an un-compiled call is executed.  * @throws org.springframework.dao.InvalidDataAccessApiUsageException if the object hasn't  * been correctly initialized, for example if no DataSource has been provided  */ ;// ------------------------------------------------------------------------- // Methods handling compilation issues // ------------------------------------------------------------------------- /**  * Compile this JdbcCall using provided parameters and meta-data plus other settings.  * <p>This finalizes the configuration for this object and subsequent attempts to compile are  * ignored. This will be implicitly called the first time an un-compiled call is executed.  * @throws org.springframework.dao.InvalidDataAccessApiUsageException if the object hasn't  * been correctly initialized, for example if no DataSource has been provided  */ public final synchronized void compile() throws InvalidDataAccessApiUsageException {     if (!isCompiled()) {         if (getProcedureName() == null) {             throw new InvalidDataAccessApiUsageException("Procedure or Function name is required").         }         try {             this.jdbcTemplate.afterPropertiesSet().         } catch (IllegalArgumentException ex) {             throw new InvalidDataAccessApiUsageException(ex.getMessage()).         }         compileInternal().         this.compiled = true.         if (logger.isDebugEnabled()) {             logger.debug("SqlCall for " + (isFunction() ? "function" : "procedure") + " [" + getProcedureName() + "] compiled").         }     } }
true;protected;0;21;/**  * Delegate method to perform the actual compilation.  * <p>Subclasses can override this template method to perform their own compilation.  * Invoked after this base class's compilation is complete.  */ ;/**  * Delegate method to perform the actual compilation.  * <p>Subclasses can override this template method to perform their own compilation.  * Invoked after this base class's compilation is complete.  */ protected void compileInternal() {     DataSource dataSource = getJdbcTemplate().getDataSource().     Assert.state(dataSource != null, "No DataSource set").     this.callMetaDataContext.initializeMetaData(dataSource).     // Iterate over the declared RowMappers and register the corresponding SqlParameter     this.declaredRowMappers.forEach((key, value) -> {         this.declaredParameters.add(this.callMetaDataContext.createReturnResultSetParameter(key, value)).     }).     this.callMetaDataContext.processParameters(this.declaredParameters).     this.callString = this.callMetaDataContext.createCallString().     if (logger.isDebugEnabled()) {         logger.debug("Compiled stored procedure. Call string is [" + this.callString + "]").     }     this.callableStatementFactory = new CallableStatementCreatorFactory(this.callString, this.callMetaDataContext.getCallParameters()).     onCompileInternal(). }
true;protected;0;2;/**  * Hook method that subclasses may override to react to compilation.  * This implementation does nothing.  */ ;/**  * Hook method that subclasses may override to react to compilation.  * This implementation does nothing.  */ protected void onCompileInternal() { }
true;public;0;3;/**  * Is this operation "compiled"?  * @return whether this operation is compiled and ready to use  */ ;/**  * Is this operation "compiled"?  * @return whether this operation is compiled and ready to use  */ public boolean isCompiled() {     return this.compiled. }
true;protected;0;6;/**  * Check whether this operation has been compiled already.  * lazily compile it if not already compiled.  * <p>Automatically called by {@code doExecute}.  */ ;/**  * Check whether this operation has been compiled already.  * lazily compile it if not already compiled.  * <p>Automatically called by {@code doExecute}.  */ protected void checkCompiled() {     if (!isCompiled()) {         logger.debug("JdbcCall call not compiled before execution - invoking compile").         compile().     } }
true;protected;1;5;/**  * Delegate method that executes the call using the passed-in {@link SqlParameterSource}.  * @param parameterSource parameter names and values to be used in call  * @return a Map of out parameters  */ ;// ------------------------------------------------------------------------- // Methods handling execution // ------------------------------------------------------------------------- /**  * Delegate method that executes the call using the passed-in {@link SqlParameterSource}.  * @param parameterSource parameter names and values to be used in call  * @return a Map of out parameters  */ protected Map<String, Object> doExecute(SqlParameterSource parameterSource) {     checkCompiled().     Map<String, Object> params = matchInParameterValuesWithCallParameters(parameterSource).     return executeCallInternal(params). }
true;protected;1;5;/**  * Delegate method that executes the call using the passed-in array of parameters.  * @param args array of parameter values. The order of values must match the order  * declared for the stored procedure.  * @return a Map of out parameters  */ ;/**  * Delegate method that executes the call using the passed-in array of parameters.  * @param args array of parameter values. The order of values must match the order  * declared for the stored procedure.  * @return a Map of out parameters  */ protected Map<String, Object> doExecute(Object... args) {     checkCompiled().     Map<String, ?> params = matchInParameterValuesWithCallParameters(args).     return executeCallInternal(params). }
true;protected;1;5;/**  * Delegate method that executes the call using the passed-in Map of parameters.  * @param args a Map of parameter name and values  * @return a Map of out parameters  */ ;/**  * Delegate method that executes the call using the passed-in Map of parameters.  * @param args a Map of parameter name and values  * @return a Map of out parameters  */ protected Map<String, Object> doExecute(Map<String, ?> args) {     checkCompiled().     Map<String, ?> params = matchInParameterValuesWithCallParameters(args).     return executeCallInternal(params). }
true;private;1;13;/**  * Delegate method to perform the actual call processing.  */ ;/**  * Delegate method to perform the actual call processing.  */ private Map<String, Object> executeCallInternal(Map<String, ?> args) {     CallableStatementCreator csc = getCallableStatementFactory().newCallableStatementCreator(args).     if (logger.isDebugEnabled()) {         logger.debug("The following parameters are used for call " + getCallString() + " with " + args).         int i = 1.         for (SqlParameter param : getCallParameters()) {             logger.debug(i + ": " + param.getName() + ", SQL type " + param.getSqlType() + ", type name " + param.getTypeName() + ", parameter class [" + param.getClass().getName() + "]").             i++.         }     }     return getJdbcTemplate().call(csc, getCallParameters()). }
true;protected;0;4;/**  * Get the name of a single out parameter or return value.  * Used for functions or procedures with one out parameter.  */ ;/**  * Get the name of a single out parameter or return value.  * Used for functions or procedures with one out parameter.  */ @Nullable protected String getScalarOutParameterName() {     return this.callMetaDataContext.getScalarOutParameterName(). }
true;protected;0;3;/**  * Get a List of all the call parameters to be used for call.  * This includes any parameters added based on meta-data processing.  */ ;/**  * Get a List of all the call parameters to be used for call.  * This includes any parameters added based on meta-data processing.  */ protected List<SqlParameter> getCallParameters() {     return this.callMetaDataContext.getCallParameters(). }
true;protected;1;3;/**  * Match the provided in parameter values with registered parameters and  * parameters defined via meta-data processing.  * @param parameterSource the parameter vakues provided as a {@link SqlParameterSource}  * @return a Map with parameter names and values  */ ;/**  * Match the provided in parameter values with registered parameters and  * parameters defined via meta-data processing.  * @param parameterSource the parameter vakues provided as a {@link SqlParameterSource}  * @return a Map with parameter names and values  */ protected Map<String, Object> matchInParameterValuesWithCallParameters(SqlParameterSource parameterSource) {     return this.callMetaDataContext.matchInParameterValuesWithCallParameters(parameterSource). }
true;private;1;3;/**  * Match the provided in parameter values with registered parameters and  * parameters defined via meta-data processing.  * @param args the parameter values provided as an array  * @return a Map with parameter names and values  */ ;/**  * Match the provided in parameter values with registered parameters and  * parameters defined via meta-data processing.  * @param args the parameter values provided as an array  * @return a Map with parameter names and values  */ private Map<String, ?> matchInParameterValuesWithCallParameters(Object[] args) {     return this.callMetaDataContext.matchInParameterValuesWithCallParameters(args). }
true;protected;1;3;/**  * Match the provided in parameter values with registered parameters and  * parameters defined via meta-data processing.  * @param args the parameter values provided in a Map  * @return a Map with parameter names and values  */ ;/**  * Match the provided in parameter values with registered parameters and  * parameters defined via meta-data processing.  * @param args the parameter values provided in a Map  * @return a Map with parameter names and values  */ protected Map<String, ?> matchInParameterValuesWithCallParameters(Map<String, ?> args) {     return this.callMetaDataContext.matchInParameterValuesWithCallParameters(args). }
