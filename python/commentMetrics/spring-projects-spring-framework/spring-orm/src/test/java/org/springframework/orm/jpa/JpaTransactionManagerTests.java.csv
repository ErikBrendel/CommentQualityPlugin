commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Before public void setup() {     factory = mock(EntityManagerFactory.class).     manager = mock(EntityManager.class).     tx = mock(EntityTransaction.class).     tm = new JpaTransactionManager(factory).     tt = new TransactionTemplate(tm).     given(factory.createEntityManager()).willReturn(manager).     given(manager.getTransaction()).willReturn(tx).     given(manager.isOpen()).willReturn(true). }
false;public;0;7;;@After public void verifyTransactionSynchronizationManagerState() {     assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty()).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertFalse(TransactionSynchronizationManager.isActualTransactionActive()). }
false;public;1;6;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return l. }
false;public;0;27;;@Test public void testTransactionCommit() {     given(manager.getTransaction()).willReturn(tx).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     Object result = tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.hasResource(factory)).             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             return l.         }     }).     assertSame(l, result).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(tx).commit().     verify(manager).flush().     verify(manager).close(). }
false;public;1;6;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return l. }
false;public;0;34;;@Test public void testTransactionCommitWithRollbackException() {     given(manager.getTransaction()).willReturn(tx).     given(tx.getRollbackOnly()).willReturn(true).     willThrow(new RollbackException()).given(tx).commit().     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     try {         Object result = tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                 return l.             }         }).         assertSame(l, result).     } catch (TransactionSystemException tse) {         // expected         assertTrue(tse.getCause() instanceof RollbackException).     }     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(manager).flush().     verify(manager).close(). }
false;public;1;6;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).     throw new RuntimeException("some exception"). }
false;public;0;33;;@Test public void testTransactionRollback() {     given(manager.getTransaction()).willReturn(tx).     given(tx.isActive()).willReturn(true).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 EntityManagerFactoryUtils.getTransactionalEntityManager(factory).                 throw new RuntimeException("some exception").             }         }).         fail("Should have propagated RuntimeException").     } catch (RuntimeException ex) {         // expected         assertEquals("some exception", ex.getMessage()).     }     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(tx).rollback().     verify(manager).close(). }
false;public;1;6;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).     throw new RuntimeException("some exception"). }
false;public;0;30;;@Test public void testTransactionRollbackWithAlreadyRolledBack() {     given(manager.getTransaction()).willReturn(tx).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 EntityManagerFactoryUtils.getTransactionalEntityManager(factory).                 throw new RuntimeException("some exception").             }         }).         fail("Should have propagated RuntimeException").     } catch (RuntimeException ex) {     // expected     }     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(manager).close(). }
false;public;1;9;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     status.setRollbackOnly().     return l. }
false;public;0;30;;@Test public void testTransactionRollbackOnly() {     given(manager.getTransaction()).willReturn(tx).     given(tx.isActive()).willReturn(true).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.hasResource(factory)).             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             status.setRollbackOnly().             return l.         }     }).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(manager).flush().     verify(tx).rollback().     verify(manager).close(). }
false;public;1;5;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return l. }
false;public;1;12;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     return tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             return l.         }     }). }
false;public;0;32;;@Test public void testParticipatingTransactionWithCommit() {     given(manager.getTransaction()).willReturn(tx).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.hasResource(factory)).             return tt.execute(new TransactionCallback() {                  @Override                 public Object doInTransaction(TransactionStatus status) {                     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                     return l.                 }             }).         }     }).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(manager).flush().     verify(tx).commit().     verify(manager).close(). }
false;public;1;5;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).     throw new RuntimeException("some exception"). }
false;public;1;11;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     return tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).             throw new RuntimeException("some exception").         }     }). }
false;public;0;38;;@Test public void testParticipatingTransactionWithRollback() {     given(manager.getTransaction()).willReturn(tx).     given(tx.isActive()).willReturn(true).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 return tt.execute(new TransactionCallback() {                      @Override                     public Object doInTransaction(TransactionStatus status) {                         EntityManagerFactoryUtils.getTransactionalEntityManager(factory).                         throw new RuntimeException("some exception").                     }                 }).             }         }).         fail("Should have propagated RuntimeException").     } catch (RuntimeException ex) {     // expected     }     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(tx).setRollbackOnly().     verify(tx).rollback().     verify(manager).close(). }
false;public;1;6;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     status.setRollbackOnly().     return null. }
false;public;1;13;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     return tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             status.setRollbackOnly().             return null.         }     }). }
false;public;0;43;;@Test public void testParticipatingTransactionWithRollbackOnly() {     given(manager.getTransaction()).willReturn(tx).     given(tx.isActive()).willReturn(true).     given(tx.getRollbackOnly()).willReturn(true).     willThrow(new RollbackException()).given(tx).commit().     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 return tt.execute(new TransactionCallback() {                      @Override                     public Object doInTransaction(TransactionStatus status) {                         EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                         status.setRollbackOnly().                         return null.                     }                 }).             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException tse) {         // expected         assertTrue(tse.getCause() instanceof RollbackException).     }     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(manager).flush().     verify(tx).setRollbackOnly().     verify(manager).close(). }
false;public;1;5;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return l. }
false;public;1;11;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     return tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             return l.         }     }). }
false;public;0;36;;@Test public void testParticipatingTransactionWithRequiresNew() {     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     given(factory.createEntityManager()).willReturn(manager).     given(manager.getTransaction()).willReturn(tx).     given(manager.isOpen()).willReturn(true).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     Object result = tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.hasResource(factory)).             return tt.execute(new TransactionCallback() {                  @Override                 public Object doInTransaction(TransactionStatus status) {                     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                     return l.                 }             }).         }     }).     assertSame(l, result).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(manager).flush().     verify(manager, times(2)).close().     verify(tx, times(2)).begin(). }
false;public;1;5;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return l. }
false;public;1;13;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     return tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             return l.         }     }). }
false;public;0;44;;@Test public void testParticipatingTransactionWithRequiresNewAndPrebound() {     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     given(manager.getTransaction()).willReturn(tx).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.bindResource(factory, new EntityManagerHolder(manager)).     try {         Object result = tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 EntityManagerFactoryUtils.getTransactionalEntityManager(factory).                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 return tt.execute(new TransactionCallback() {                      @Override                     public Object doInTransaction(TransactionStatus status) {                         EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                         return l.                     }                 }).             }         }).         assertSame(l, result).     } finally {         TransactionSynchronizationManager.unbindResource(factory).     }     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(tx, times(2)).begin().     verify(tx, times(2)).commit().     verify(manager).flush().     verify(manager).close(). }
false;public;1;5;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return l. }
false;public;1;13;;@Override public Object doInTransaction(TransactionStatus status) {     assertFalse(TransactionSynchronizationManager.hasResource(factory)).     TransactionTemplate tt2 = new TransactionTemplate(tm).     tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     return tt2.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             return l.         }     }). }
false;public;0;36;;@Test public void testPropagationSupportsAndRequiresNew() {     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     given(manager.getTransaction()).willReturn(tx).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     Object result = tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             assertFalse(TransactionSynchronizationManager.hasResource(factory)).             TransactionTemplate tt2 = new TransactionTemplate(tm).             tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).             return tt2.execute(new TransactionCallback() {                  @Override                 public Object doInTransaction(TransactionStatus status) {                     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                     return l.                 }             }).         }     }).     assertSame(l, result).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(tx).commit().     verify(manager).flush().     verify(manager).close(). }
false;public;1;5;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return l. }
false;public;1;15;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     TransactionTemplate tt2 = new TransactionTemplate(tm).     tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     return tt2.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             return l.         }     }). }
false;public;0;40;;@Test public void testPropagationSupportsAndRequiresNewAndEarlyAccess() {     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     given(factory.createEntityManager()).willReturn(manager).     given(manager.getTransaction()).willReturn(tx).     given(manager.isOpen()).willReturn(true).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     Object result = tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).             assertTrue(TransactionSynchronizationManager.hasResource(factory)).             TransactionTemplate tt2 = new TransactionTemplate(tm).             tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).             return tt2.execute(new TransactionCallback() {                  @Override                 public Object doInTransaction(TransactionStatus status) {                     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                     return l.                 }             }).         }     }).     assertSame(l, result).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(tx).commit().     verify(manager).flush().     verify(manager, times(2)).close(). }
false;public;1;5;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return null. }
false;public;1;10;;@Override public void afterCompletion(int status) {     tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             return null.         }     }). }
false;public;1;17;;@Override public Object doInTransaction(TransactionStatus status) {     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {          @Override         public void afterCompletion(int status) {             tt.execute(new TransactionCallback() {                  @Override                 public Object doInTransaction(TransactionStatus status) {                     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                     return null.                 }             }).         }     }).     return null. }
false;public;0;46;;@Test public void testTransactionWithRequiresNewInAfterCompletion() {     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     EntityManager manager2 = mock(EntityManager.class).     EntityTransaction tx2 = mock(EntityTransaction.class).     given(manager.getTransaction()).willReturn(tx).     given(factory.createEntityManager()).willReturn(manager, manager2).     given(manager2.getTransaction()).willReturn(tx2).     given(manager2.isOpen()).willReturn(true).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                  @Override                 public void afterCompletion(int status) {                     tt.execute(new TransactionCallback() {                          @Override                         public Object doInTransaction(TransactionStatus status) {                             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                             return null.                         }                     }).                 }             }).             return null.         }     }).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(tx).commit().     verify(tx2).begin().     verify(tx2).commit().     verify(manager).flush().     verify(manager).close().     verify(manager2).flush().     verify(manager2).close(). }
false;public;1;8;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue(!status.isNewTransaction()).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return l. }
false;public;0;30;;@Test public void testTransactionCommitWithPropagationSupports() {     given(manager.isOpen()).willReturn(true).     final List<String> l = new ArrayList<>().     l.add("test").     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     Object result = tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             assertTrue(!TransactionSynchronizationManager.hasResource(factory)).             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue(!status.isNewTransaction()).             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             return l.         }     }).     assertSame(l, result).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(manager).flush().     verify(manager).close(). }
false;public;1;9;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue(!status.isNewTransaction()).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     status.setRollbackOnly().     return null. }
false;public;0;27;;@Test public void testTransactionRollbackWithPropagationSupports() {     given(manager.isOpen()).willReturn(true).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallback() {          @Override         public Object doInTransaction(TransactionStatus status) {             assertTrue(!TransactionSynchronizationManager.hasResource(factory)).             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             assertTrue(!status.isNewTransaction()).             EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().             status.setRollbackOnly().             return null.         }     }).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(manager).flush().     verify(manager).close(). }
false;public;1;7;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).     return l. }
false;public;0;33;;@Test public void testTransactionCommitWithPrebound() {     given(manager.getTransaction()).willReturn(tx).     final List<String> l = new ArrayList<>().     l.add("test").     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.bindResource(factory, new EntityManagerHolder(manager)).     try {         Object result = tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).                 EntityManagerFactoryUtils.getTransactionalEntityManager(factory).                 return l.             }         }).         assertSame(l, result).         assertTrue(TransactionSynchronizationManager.hasResource(factory)).         assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     } finally {         TransactionSynchronizationManager.unbindResource(factory).     }     verify(tx).begin().     verify(tx).commit(). }
false;public;1;8;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).     status.setRollbackOnly().     return null. }
false;public;0;32;;@Test public void testTransactionRollbackWithPrebound() {     given(manager.getTransaction()).willReturn(tx).     given(tx.isActive()).willReturn(true).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.bindResource(factory, new EntityManagerHolder(manager)).     try {         tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).                 EntityManagerFactoryUtils.getTransactionalEntityManager(factory).                 status.setRollbackOnly().                 return null.             }         }).         assertTrue(TransactionSynchronizationManager.hasResource(factory)).         assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     } finally {         TransactionSynchronizationManager.unbindResource(factory).     }     verify(tx).begin().     verify(tx).rollback().     verify(manager).clear(). }
false;public;1;8;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue(!status.isNewTransaction()).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     return l. }
false;public;0;33;;@Test public void testTransactionCommitWithPreboundAndPropagationSupports() {     final List<String> l = new ArrayList<>().     l.add("test").     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.bindResource(factory, new EntityManagerHolder(manager)).     try {         Object result = tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).                 assertTrue(!status.isNewTransaction()).                 EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                 return l.             }         }).         assertSame(l, result).         assertTrue(TransactionSynchronizationManager.hasResource(factory)).         assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     } finally {         TransactionSynchronizationManager.unbindResource(factory).     }     verify(manager).flush(). }
false;public;1;9;;@Override public Object doInTransaction(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertTrue(!status.isNewTransaction()).     EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().     status.setRollbackOnly().     return null. }
false;public;0;31;;@Test public void testTransactionRollbackWithPreboundAndPropagationSupports() {     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.bindResource(factory, new EntityManagerHolder(manager)).     try {         tt.execute(new TransactionCallback() {              @Override             public Object doInTransaction(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.hasResource(factory)).                 assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).                 assertTrue(!status.isNewTransaction()).                 EntityManagerFactoryUtils.getTransactionalEntityManager(factory).flush().                 status.setRollbackOnly().                 return null.             }         }).         assertTrue(TransactionSynchronizationManager.hasResource(factory)).         assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     } finally {         TransactionSynchronizationManager.unbindResource(factory).     }     verify(manager).flush().     verify(manager).clear(). }
false;protected;1;3;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { }
false;public;0;20;;@Test public void testInvalidIsolation() {     tt.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE).     given(manager.isOpen()).willReturn(true).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             }         }).         fail("Should have thrown InvalidIsolationLevelException").     } catch (InvalidIsolationLevelException ex) {     // expected     }     verify(manager).close(). }
false;public;1;5;;@Override public void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.hasResource(factory)).     status.flush(). }
false;public;0;22;;@Test public void testTransactionFlush() {     given(manager.getTransaction()).willReturn(tx).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         public void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.hasResource(factory)).             status.flush().         }     }).     assertTrue(!TransactionSynchronizationManager.hasResource(factory)).     assertTrue(!TransactionSynchronizationManager.isSynchronizationActive()).     verify(tx).commit().     verify(manager).flush().     verify(manager).close(). }
