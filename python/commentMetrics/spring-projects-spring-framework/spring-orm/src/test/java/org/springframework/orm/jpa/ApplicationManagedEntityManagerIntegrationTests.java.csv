commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Test @SuppressWarnings("unchecked") public void testEntityManagerProxyIsProxy() {     EntityManager em = entityManagerFactory.createEntityManager().     assertTrue(Proxy.isProxyClass(em.getClass())).     Query q = em.createQuery("select p from Person as p").     List<Person> people = q.getResultList().     assertNotNull(people).     assertTrue("Should be open to start with", em.isOpen()).     em.close().     assertFalse("Close should work on application managed EM", em.isOpen()). }
false;public;0;5;;@Test public void testEntityManagerProxyAcceptsProgrammaticTxJoining() {     EntityManager em = entityManagerFactory.createEntityManager().     em.joinTransaction(). }
false;public;0;6;;@Test public void testInstantiateAndSave() {     EntityManager em = entityManagerFactory.createEntityManager().     em.joinTransaction().     doInstantiateAndSave(em). }
false;public;0;18;;@Test public void testCannotFlushWithoutGettingTransaction() {     EntityManager em = entityManagerFactory.createEntityManager().     try {         doInstantiateAndSave(em).         fail("Should have thrown TransactionRequiredException").     } catch (TransactionRequiredException ex) {     // expected     }     // TODO following lines are a workaround for Hibernate bug     // If Hibernate throws an exception due to flush(),     // it actually HAS flushed, meaning that the database     // was updated outside the transaction     deleteAllPeopleUsingEntityManager(sharedEntityManager).     setComplete(). }
false;protected;1;11;;protected void doInstantiateAndSave(EntityManager em) {     testStateClean().     Person p = new Person().     p.setFirstName("Tony").     p.setLastName("Blair").     em.persist(p).     em.flush().     assertEquals("1 row must have been inserted", 1, countRowsInTable(em, "person")). }
false;public;0;4;;@Test public void testStateClean() {     assertEquals("Should be no people from previous transactions", 0, countRowsInTable("person")). }
false;public;0;31;;@Test public void testReuseInNewTransaction() {     EntityManager em = entityManagerFactory.createEntityManager().     em.joinTransaction().     doInstantiateAndSave(em).     endTransaction().     assertFalse(em.getTransaction().isActive()).     startNewTransaction().     // Call any method: should cause automatic tx invocation     assertFalse(em.contains(new Person())).     assertFalse(em.getTransaction().isActive()).     em.joinTransaction().     assertTrue(em.getTransaction().isActive()).     doInstantiateAndSave(em).     setComplete().     // Should rollback     endTransaction().     assertEquals("Tx must have committed back", 1, countRowsInTable(em, "person")).     // Now clean up the database     startNewTransaction().     em.joinTransaction().     deleteAllPeopleUsingEntityManager(em).     assertEquals("People have been killed", 0, countRowsInTable(em, "person")).     setComplete(). }
false;protected;1;3;;protected void deleteAllPeopleUsingEntityManager(EntityManager em) {     em.createQuery("delete from Person p").executeUpdate(). }
false;public;0;8;;@Test public void testRollbackOccurs() {     EntityManager em = entityManagerFactory.createEntityManager().     em.joinTransaction().     doInstantiateAndSave(em).     // Should rollback     endTransaction().     assertEquals("Tx must have been rolled back", 0, countRowsInTable(em, "person")). }
false;public;0;13;;@Test public void testCommitOccurs() {     EntityManager em = entityManagerFactory.createEntityManager().     em.joinTransaction().     doInstantiateAndSave(em).     setComplete().     // Should rollback     endTransaction().     assertEquals("Tx must have committed back", 1, countRowsInTable(em, "person")).     // Now clean up the database     deleteFromTables("person"). }
