commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the PersistenceProvider implementation class to use for creating the  * EntityManagerFactory. If not specified, the persistence provider will be  * taken from the JpaVendorAdapter (if any) or retrieved through scanning  * (as far as possible).  * @see JpaVendorAdapter#getPersistenceProvider()  * @see javax.persistence.spi.PersistenceProvider  * @see javax.persistence.Persistence  */ ;/**  * Set the PersistenceProvider implementation class to use for creating the  * EntityManagerFactory. If not specified, the persistence provider will be  * taken from the JpaVendorAdapter (if any) or retrieved through scanning  * (as far as possible).  * @see JpaVendorAdapter#getPersistenceProvider()  * @see javax.persistence.spi.PersistenceProvider  * @see javax.persistence.Persistence  */ public void setPersistenceProviderClass(Class<? extends PersistenceProvider> persistenceProviderClass) {     this.persistenceProvider = BeanUtils.instantiateClass(persistenceProviderClass). }
true;public;1;3;/**  * Set the PersistenceProvider instance to use for creating the  * EntityManagerFactory. If not specified, the persistence provider  * will be taken from the JpaVendorAdapter (if any) or determined  * by the persistence unit deployment descriptor (as far as possible).  * @see JpaVendorAdapter#getPersistenceProvider()  * @see javax.persistence.spi.PersistenceProvider  * @see javax.persistence.Persistence  */ ;/**  * Set the PersistenceProvider instance to use for creating the  * EntityManagerFactory. If not specified, the persistence provider  * will be taken from the JpaVendorAdapter (if any) or determined  * by the persistence unit deployment descriptor (as far as possible).  * @see JpaVendorAdapter#getPersistenceProvider()  * @see javax.persistence.spi.PersistenceProvider  * @see javax.persistence.Persistence  */ public void setPersistenceProvider(@Nullable PersistenceProvider persistenceProvider) {     this.persistenceProvider = persistenceProvider. }
false;public;0;5;;@Override @Nullable public PersistenceProvider getPersistenceProvider() {     return this.persistenceProvider. }
true;public;1;3;/**  * Specify the name of the EntityManagerFactory configuration.  * <p>Default is none, indicating the default EntityManagerFactory  * configuration. The persistence provider will throw an exception if  * ambiguous EntityManager configurations are found.  * @see javax.persistence.Persistence#createEntityManagerFactory(String)  */ ;/**  * Specify the name of the EntityManagerFactory configuration.  * <p>Default is none, indicating the default EntityManagerFactory  * configuration. The persistence provider will throw an exception if  * ambiguous EntityManager configurations are found.  * @see javax.persistence.Persistence#createEntityManagerFactory(String)  */ public void setPersistenceUnitName(@Nullable String persistenceUnitName) {     this.persistenceUnitName = persistenceUnitName. }
false;public;0;5;;@Override @Nullable public String getPersistenceUnitName() {     return this.persistenceUnitName. }
true;public;1;3;/**  * Specify JPA properties, to be passed into  * {@code Persistence.createEntityManagerFactory} (if any).  * <p>Can be populated with a String "value" (parsed via PropertiesEditor) or a  * "props" element in XML bean definitions.  * @see javax.persistence.Persistence#createEntityManagerFactory(String, java.util.Map)  * @see javax.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory(javax.persistence.spi.PersistenceUnitInfo, java.util.Map)  */ ;/**  * Specify JPA properties, to be passed into  * {@code Persistence.createEntityManagerFactory} (if any).  * <p>Can be populated with a String "value" (parsed via PropertiesEditor) or a  * "props" element in XML bean definitions.  * @see javax.persistence.Persistence#createEntityManagerFactory(String, java.util.Map)  * @see javax.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory(javax.persistence.spi.PersistenceUnitInfo, java.util.Map)  */ public void setJpaProperties(Properties jpaProperties) {     CollectionUtils.mergePropertiesIntoMap(jpaProperties, this.jpaPropertyMap). }
true;public;1;5;/**  * Specify JPA properties as a Map, to be passed into  * {@code Persistence.createEntityManagerFactory} (if any).  * <p>Can be populated with a "map" or "props" element in XML bean definitions.  * @see javax.persistence.Persistence#createEntityManagerFactory(String, java.util.Map)  * @see javax.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory(javax.persistence.spi.PersistenceUnitInfo, java.util.Map)  */ ;/**  * Specify JPA properties as a Map, to be passed into  * {@code Persistence.createEntityManagerFactory} (if any).  * <p>Can be populated with a "map" or "props" element in XML bean definitions.  * @see javax.persistence.Persistence#createEntityManagerFactory(String, java.util.Map)  * @see javax.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory(javax.persistence.spi.PersistenceUnitInfo, java.util.Map)  */ public void setJpaPropertyMap(@Nullable Map<String, ?> jpaProperties) {     if (jpaProperties != null) {         this.jpaPropertyMap.putAll(jpaProperties).     } }
true;public;0;3;/**  * Allow Map access to the JPA properties to be passed to the persistence  * provider, with the option to add or override specific entries.  * <p>Useful for specifying entries directly, for example via  * "jpaPropertyMap[myKey]".  */ ;/**  * Allow Map access to the JPA properties to be passed to the persistence  * provider, with the option to add or override specific entries.  * <p>Useful for specifying entries directly, for example via  * "jpaPropertyMap[myKey]".  */ public Map<String, Object> getJpaPropertyMap() {     return this.jpaPropertyMap. }
true;public;1;3;/**  * Specify the (potentially vendor-specific) EntityManagerFactory interface  * that this EntityManagerFactory proxy is supposed to implement.  * <p>The default will be taken from the specific JpaVendorAdapter, if any,  * or set to the standard {@code javax.persistence.EntityManagerFactory}  * interface else.  * @see JpaVendorAdapter#getEntityManagerFactoryInterface()  */ ;/**  * Specify the (potentially vendor-specific) EntityManagerFactory interface  * that this EntityManagerFactory proxy is supposed to implement.  * <p>The default will be taken from the specific JpaVendorAdapter, if any,  * or set to the standard {@code javax.persistence.EntityManagerFactory}  * interface else.  * @see JpaVendorAdapter#getEntityManagerFactoryInterface()  */ public void setEntityManagerFactoryInterface(Class<? extends EntityManagerFactory> emfInterface) {     this.entityManagerFactoryInterface = emfInterface. }
true;public;1;3;/**  * Specify the (potentially vendor-specific) EntityManager interface  * that this factory's EntityManagers are supposed to implement.  * <p>The default will be taken from the specific JpaVendorAdapter, if any,  * or set to the standard {@code javax.persistence.EntityManager}  * interface else.  * @see JpaVendorAdapter#getEntityManagerInterface()  * @see EntityManagerFactoryInfo#getEntityManagerInterface()  */ ;/**  * Specify the (potentially vendor-specific) EntityManager interface  * that this factory's EntityManagers are supposed to implement.  * <p>The default will be taken from the specific JpaVendorAdapter, if any,  * or set to the standard {@code javax.persistence.EntityManager}  * interface else.  * @see JpaVendorAdapter#getEntityManagerInterface()  * @see EntityManagerFactoryInfo#getEntityManagerInterface()  */ public void setEntityManagerInterface(@Nullable Class<? extends EntityManager> emInterface) {     this.entityManagerInterface = emInterface. }
false;public;0;5;;@Override @Nullable public Class<? extends EntityManager> getEntityManagerInterface() {     return this.entityManagerInterface. }
true;public;1;3;/**  * Specify the vendor-specific JpaDialect implementation to associate with  * this EntityManagerFactory. This will be exposed through the  * EntityManagerFactoryInfo interface, to be picked up as default dialect by  * accessors that intend to use JpaDialect functionality.  * @see EntityManagerFactoryInfo#getJpaDialect()  */ ;/**  * Specify the vendor-specific JpaDialect implementation to associate with  * this EntityManagerFactory. This will be exposed through the  * EntityManagerFactoryInfo interface, to be picked up as default dialect by  * accessors that intend to use JpaDialect functionality.  * @see EntityManagerFactoryInfo#getJpaDialect()  */ public void setJpaDialect(@Nullable JpaDialect jpaDialect) {     this.jpaDialect = jpaDialect. }
false;public;0;5;;@Override @Nullable public JpaDialect getJpaDialect() {     return this.jpaDialect. }
true;public;1;3;/**  * Specify the JpaVendorAdapter implementation for the desired JPA provider,  * if any. This will initialize appropriate defaults for the given provider,  * such as persistence provider class and JpaDialect, unless locally  * overridden in this FactoryBean.  */ ;/**  * Specify the JpaVendorAdapter implementation for the desired JPA provider,  * if any. This will initialize appropriate defaults for the given provider,  * such as persistence provider class and JpaDialect, unless locally  * overridden in this FactoryBean.  */ public void setJpaVendorAdapter(@Nullable JpaVendorAdapter jpaVendorAdapter) {     this.jpaVendorAdapter = jpaVendorAdapter. }
true;public;0;4;/**  * Return the JpaVendorAdapter implementation for this EntityManagerFactory,  * or {@code null} if not known.  */ ;/**  * Return the JpaVendorAdapter implementation for this EntityManagerFactory,  * or {@code null} if not known.  */ @Nullable public JpaVendorAdapter getJpaVendorAdapter() {     return this.jpaVendorAdapter. }
true;public;1;3;/**  * Specify an asynchronous executor for background bootstrapping,  * e.g. a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}.  * <p>{@code EntityManagerFactory} initialization will then switch into background  * bootstrap mode, with a {@code EntityManagerFactory} proxy immediately returned for  * injection purposes instead of waiting for the JPA provider's bootstrapping to complete.  * However, note that the first actual call to a {@code EntityManagerFactory} method will  * then block until the JPA provider's bootstrapping completed, if not ready by then.  * For maximum benefit, make sure to avoid early {@code EntityManagerFactory} calls  * in init methods of related beans, even for metadata introspection purposes.  * @since 4.3  */ ;/**  * Specify an asynchronous executor for background bootstrapping,  * e.g. a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}.  * <p>{@code EntityManagerFactory} initialization will then switch into background  * bootstrap mode, with a {@code EntityManagerFactory} proxy immediately returned for  * injection purposes instead of waiting for the JPA provider's bootstrapping to complete.  * However, note that the first actual call to a {@code EntityManagerFactory} method will  * then block until the JPA provider's bootstrapping completed, if not ready by then.  * For maximum benefit, make sure to avoid early {@code EntityManagerFactory} calls  * in init methods of related beans, even for metadata introspection purposes.  * @since 4.3  */ public void setBootstrapExecutor(@Nullable AsyncTaskExecutor bootstrapExecutor) {     this.bootstrapExecutor = bootstrapExecutor. }
true;public;0;4;/**  * Return the asynchronous executor for background bootstrapping, if any.  * @since 4.3  */ ;/**  * Return the asynchronous executor for background bootstrapping, if any.  * @since 4.3  */ @Nullable public AsyncTaskExecutor getBootstrapExecutor() {     return this.bootstrapExecutor. }
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
false;public;0;4;;@Override public ClassLoader getBeanClassLoader() {     return this.beanClassLoader. }
false;public;1;4;;@Override public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory. }
false;public;1;4;;@Override public void setBeanName(String name) {     this.beanName = name. }
false;public;0;48;;@Override public void afterPropertiesSet() throws PersistenceException {     JpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter().     if (jpaVendorAdapter != null) {         if (this.persistenceProvider == null) {             this.persistenceProvider = jpaVendorAdapter.getPersistenceProvider().         }         PersistenceUnitInfo pui = getPersistenceUnitInfo().         Map<String, ?> vendorPropertyMap = (pui != null ? jpaVendorAdapter.getJpaPropertyMap(pui) : jpaVendorAdapter.getJpaPropertyMap()).         if (!CollectionUtils.isEmpty(vendorPropertyMap)) {             vendorPropertyMap.forEach((key, value) -> {                 if (!this.jpaPropertyMap.containsKey(key)) {                     this.jpaPropertyMap.put(key, value).                 }             }).         }         if (this.entityManagerFactoryInterface == null) {             this.entityManagerFactoryInterface = jpaVendorAdapter.getEntityManagerFactoryInterface().             if (!ClassUtils.isVisible(this.entityManagerFactoryInterface, this.beanClassLoader)) {                 this.entityManagerFactoryInterface = EntityManagerFactory.class.             }         }         if (this.entityManagerInterface == null) {             this.entityManagerInterface = jpaVendorAdapter.getEntityManagerInterface().             if (!ClassUtils.isVisible(this.entityManagerInterface, this.beanClassLoader)) {                 this.entityManagerInterface = EntityManager.class.             }         }         if (this.jpaDialect == null) {             this.jpaDialect = jpaVendorAdapter.getJpaDialect().         }     }     AsyncTaskExecutor bootstrapExecutor = getBootstrapExecutor().     if (bootstrapExecutor != null) {         this.nativeEntityManagerFactoryFuture = bootstrapExecutor.submit(this::buildNativeEntityManagerFactory).     } else {         this.nativeEntityManagerFactory = buildNativeEntityManagerFactory().     }     // Wrap the EntityManagerFactory in a factory implementing all its interfaces.     // This allows interception of createEntityManager methods to return an     // application-managed EntityManager proxy that automatically joins     // existing transactions.     this.entityManagerFactory = createEntityManagerFactoryProxy(this.nativeEntityManagerFactory). }
false;private;0;32;;private EntityManagerFactory buildNativeEntityManagerFactory() {     EntityManagerFactory emf.     try {         emf = createNativeEntityManagerFactory().     } catch (PersistenceException ex) {         if (ex.getClass() == PersistenceException.class) {             // Plain PersistenceException wrapper for underlying exception?             // Make sure the nested exception message is properly exposed,             // along the lines of Spring's NestedRuntimeException.getMessage()             Throwable cause = ex.getCause().             if (cause != null) {                 String message = ex.getMessage().                 String causeString = cause.toString().                 if (!message.endsWith(causeString)) {                     throw new PersistenceException(message + ". nested exception is " + causeString, cause).                 }             }         }         throw ex.     }     JpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter().     if (jpaVendorAdapter != null) {         jpaVendorAdapter.postProcessEntityManagerFactory(emf).     }     if (logger.isInfoEnabled()) {         logger.info("Initialized JPA EntityManagerFactory for persistence unit '" + getPersistenceUnitName() + "'").     }     return emf. }
true;protected;1;31;/**  * Create a proxy for the given {@link EntityManagerFactory}. We do this to be able to  * return a transaction-aware proxy for an application-managed {@link EntityManager}.  * @param emf the EntityManagerFactory as returned by the persistence provider,  * if initialized already  * @return the EntityManagerFactory proxy  */ ;/**  * Create a proxy for the given {@link EntityManagerFactory}. We do this to be able to  * return a transaction-aware proxy for an application-managed {@link EntityManager}.  * @param emf the EntityManagerFactory as returned by the persistence provider,  * if initialized already  * @return the EntityManagerFactory proxy  */ protected EntityManagerFactory createEntityManagerFactoryProxy(@Nullable EntityManagerFactory emf) {     Set<Class<?>> ifcs = new LinkedHashSet<>().     Class<?> entityManagerFactoryInterface = this.entityManagerFactoryInterface.     if (entityManagerFactoryInterface != null) {         ifcs.add(entityManagerFactoryInterface).     } else if (emf != null) {         ifcs.addAll(ClassUtils.getAllInterfacesForClassAsSet(emf.getClass(), this.beanClassLoader)).     } else {         ifcs.add(EntityManagerFactory.class).     }     ifcs.add(EntityManagerFactoryInfo.class).     try {         return (EntityManagerFactory) Proxy.newProxyInstance(this.beanClassLoader, ClassUtils.toClassArray(ifcs), new ManagedEntityManagerFactoryInvocationHandler(this)).     } catch (IllegalArgumentException ex) {         if (entityManagerFactoryInterface != null) {             throw new IllegalStateException("EntityManagerFactory interface [" + entityManagerFactoryInterface + "] seems to conflict with Spring's EntityManagerFactoryInfo mixin - consider resetting the " + "'entityManagerFactoryInterface' property to plain [javax.persistence.EntityManagerFactory]", ex).         } else {             throw new IllegalStateException("Conflicting EntityManagerFactory interfaces - " + "consider specifying the 'jpaVendorAdapter' or 'entityManagerFactoryInterface' property " + "to select a specific EntityManagerFactory interface to proceed with", ex).         }     } }
true;;2;41;/**  * Delegate an incoming invocation from the proxy, dispatching to EntityManagerFactoryInfo  * or the native EntityManagerFactory accordingly.  */ ;/**  * Delegate an incoming invocation from the proxy, dispatching to EntityManagerFactoryInfo  * or the native EntityManagerFactory accordingly.  */ Object invokeProxyMethod(Method method, @Nullable Object[] args) throws Throwable {     if (method.getDeclaringClass().isAssignableFrom(EntityManagerFactoryInfo.class)) {         return method.invoke(this, args).     } else if (method.getName().equals("createEntityManager") && args != null && args.length > 0 && args[0] == SynchronizationType.SYNCHRONIZED) {         // JPA 2.1's createEntityManager(SynchronizationType, Map)         // Redirect to plain createEntityManager and add synchronization semantics through Spring proxy         EntityManager rawEntityManager = (args.length > 1 ? getNativeEntityManagerFactory().createEntityManager((Map<?, ?>) args[1]) : getNativeEntityManagerFactory().createEntityManager()).         return ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, true).     }     // Look for Query arguments, primarily JPA 2.1's addNamedQuery(String, Query)     if (args != null) {         for (int i = 0. i < args.length. i++) {             Object arg = args[i].             if (arg instanceof Query && Proxy.isProxyClass(arg.getClass())) {                 // let's unwrap it to the original Query object from the provider.                 try {                     args[i] = ((Query) arg).unwrap(null).                 } catch (RuntimeException ex) {                 // Ignore - simply proceed with given Query object then                 }             }         }     }     // Standard delegation to the native factory, just post-processing EntityManager return values     Object retVal = method.invoke(getNativeEntityManagerFactory(), args).     if (retVal instanceof EntityManager) {         // Any other createEntityManager variant - expecting non-synchronized semantics         EntityManager rawEntityManager = (EntityManager) retVal.         retVal = ExtendedEntityManagerCreator.createApplicationManagedEntityManager(rawEntityManager, this, false).     }     return retVal. }
true;protected,abstract;0;1;/**  * Subclasses must implement this method to create the EntityManagerFactory  * that will be returned by the {@code getObject()} method.  * @return the EntityManagerFactory instance returned by this FactoryBean  * @throws PersistenceException if the EntityManager cannot be created  */ ;/**  * Subclasses must implement this method to create the EntityManagerFactory  * that will be returned by the {@code getObject()} method.  * @return the EntityManagerFactory instance returned by this FactoryBean  * @throws PersistenceException if the EntityManager cannot be created  */ protected abstract EntityManagerFactory createNativeEntityManagerFactory() throws PersistenceException.
true;public;1;7;/**  * Implementation of the PersistenceExceptionTranslator interface, as  * autodetected by Spring's PersistenceExceptionTranslationPostProcessor.  * <p>Uses the dialect's conversion if possible. otherwise falls back to  * standard JPA exception conversion.  * @see org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor  * @see JpaDialect#translateExceptionIfPossible  * @see EntityManagerFactoryUtils#convertJpaAccessExceptionIfPossible  */ ;/**  * Implementation of the PersistenceExceptionTranslator interface, as  * autodetected by Spring's PersistenceExceptionTranslationPostProcessor.  * <p>Uses the dialect's conversion if possible. otherwise falls back to  * standard JPA exception conversion.  * @see org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor  * @see JpaDialect#translateExceptionIfPossible  * @see EntityManagerFactoryUtils#convertJpaAccessExceptionIfPossible  */ @Override @Nullable public DataAccessException translateExceptionIfPossible(RuntimeException ex) {     JpaDialect jpaDialect = getJpaDialect().     return (jpaDialect != null ? jpaDialect.translateExceptionIfPossible(ex) : EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(ex)). }
false;public;0;25;;@Override public EntityManagerFactory getNativeEntityManagerFactory() {     if (this.nativeEntityManagerFactory != null) {         return this.nativeEntityManagerFactory.     } else {         Assert.state(this.nativeEntityManagerFactoryFuture != null, "No native EntityManagerFactory available").         try {             return this.nativeEntityManagerFactoryFuture.get().         } catch (InterruptedException ex) {             Thread.currentThread().interrupt().             throw new IllegalStateException("Interrupted during initialization of native EntityManagerFactory", ex).         } catch (ExecutionException ex) {             Throwable cause = ex.getCause().             if (cause instanceof PersistenceException) {                 // Rethrow a provider configuration exception (possibly with a nested cause) directly                 throw (PersistenceException) cause.             }             throw new IllegalStateException("Failed to asynchronously initialize native EntityManagerFactory: " + ex.getMessage(), cause).         }     } }
false;public;0;5;;@Override @Nullable public PersistenceUnitInfo getPersistenceUnitInfo() {     return null. }
false;public;0;5;;@Override @Nullable public DataSource getDataSource() {     return null. }
true;public;0;5;/**  * Return the singleton EntityManagerFactory.  */ ;/**  * Return the singleton EntityManagerFactory.  */ @Override @Nullable public EntityManagerFactory getObject() {     return this.entityManagerFactory. }
false;public;0;4;;@Override public Class<? extends EntityManagerFactory> getObjectType() {     return (this.entityManagerFactory != null ? this.entityManagerFactory.getClass() : EntityManagerFactory.class). }
false;public;0;4;;@Override public boolean isSingleton() {     return true. }
true;public;0;9;/**  * Close the EntityManagerFactory on bean factory shutdown.  */ ;/**  * Close the EntityManagerFactory on bean factory shutdown.  */ @Override public void destroy() {     if (this.entityManagerFactory != null) {         if (logger.isInfoEnabled()) {             logger.info("Closing JPA EntityManagerFactory for persistence unit '" + getPersistenceUnitName() + "'").         }         this.entityManagerFactory.close().     } }
false;private;1;4;;// --------------------------------------------------------------------- // Serialization support // --------------------------------------------------------------------- private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {     throw new NotSerializableException("An EntityManagerFactoryBean itself is not deserializable - " + "just a SerializedEntityManagerFactoryBeanReference is"). }
false;protected;0;8;;protected Object writeReplace() throws ObjectStreamException {     if (this.beanFactory != null && this.beanName != null) {         return new SerializedEntityManagerFactoryBeanReference(this.beanFactory, this.beanName).     } else {         throw new NotSerializableException("EntityManagerFactoryBean does not run within a BeanFactory").     } }
false;private;0;3;;private Object readResolve() {     return this.beanFactory.getBean(this.lookupName, AbstractEntityManagerFactoryBean.class). }
false;public;3;27;;@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     try {         if (method.getName().equals("equals")) {             // Only consider equal when proxies are identical.             return (proxy == args[0]).         } else if (method.getName().equals("hashCode")) {             // Use hashCode of EntityManagerFactory proxy.             return System.identityHashCode(proxy).         } else if (method.getName().equals("unwrap")) {             // Handle JPA 2.1 unwrap method - could be a proxy match.             Class<?> targetClass = (Class<?>) args[0].             if (targetClass == null) {                 return this.entityManagerFactoryBean.getNativeEntityManagerFactory().             } else if (targetClass.isInstance(proxy)) {                 return proxy.             }         }         return this.entityManagerFactoryBean.invokeProxyMethod(method, args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
