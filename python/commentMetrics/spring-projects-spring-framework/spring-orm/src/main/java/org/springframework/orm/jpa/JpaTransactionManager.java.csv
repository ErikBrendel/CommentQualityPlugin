commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the EntityManagerFactory that this instance should manage transactions for.  * <p>Alternatively, specify the persistence unit name of the target EntityManagerFactory.  * By default, a default EntityManagerFactory will be retrieved by finding a  * single unique bean of type EntityManagerFactory in the containing BeanFactory.  * @see #setPersistenceUnitName  */ ;/**  * Set the EntityManagerFactory that this instance should manage transactions for.  * <p>Alternatively, specify the persistence unit name of the target EntityManagerFactory.  * By default, a default EntityManagerFactory will be retrieved by finding a  * single unique bean of type EntityManagerFactory in the containing BeanFactory.  * @see #setPersistenceUnitName  */ public void setEntityManagerFactory(@Nullable EntityManagerFactory emf) {     this.entityManagerFactory = emf. }
true;public;0;4;/**  * Return the EntityManagerFactory that this instance should manage transactions for.  */ ;/**  * Return the EntityManagerFactory that this instance should manage transactions for.  */ @Nullable public EntityManagerFactory getEntityManagerFactory() {     return this.entityManagerFactory. }
true;protected,final;0;5;/**  * Obtain the EntityManagerFactory for actual use.  * @return the EntityManagerFactory (never {@code null})  * @throws IllegalStateException in case of no EntityManagerFactory set  * @since 5.0  */ ;/**  * Obtain the EntityManagerFactory for actual use.  * @return the EntityManagerFactory (never {@code null})  * @throws IllegalStateException in case of no EntityManagerFactory set  * @since 5.0  */ protected final EntityManagerFactory obtainEntityManagerFactory() {     EntityManagerFactory emf = getEntityManagerFactory().     Assert.state(emf != null, "No EntityManagerFactory set").     return emf. }
true;public;1;3;/**  * Set the name of the persistence unit to manage transactions for.  * <p>This is an alternative to specifying the EntityManagerFactory by direct reference,  * resolving it by its persistence unit name instead. If no EntityManagerFactory and  * no persistence unit name have been specified, a default EntityManagerFactory will  * be retrieved by finding a single unique bean of type EntityManagerFactory.  * @see #setEntityManagerFactory  */ ;/**  * Set the name of the persistence unit to manage transactions for.  * <p>This is an alternative to specifying the EntityManagerFactory by direct reference,  * resolving it by its persistence unit name instead. If no EntityManagerFactory and  * no persistence unit name have been specified, a default EntityManagerFactory will  * be retrieved by finding a single unique bean of type EntityManagerFactory.  * @see #setEntityManagerFactory  */ public void setPersistenceUnitName(@Nullable String persistenceUnitName) {     this.persistenceUnitName = persistenceUnitName. }
true;public;0;4;/**  * Return the name of the persistence unit to manage transactions for, if any.  */ ;/**  * Return the name of the persistence unit to manage transactions for, if any.  */ @Nullable public String getPersistenceUnitName() {     return this.persistenceUnitName. }
true;public;1;3;/**  * Specify JPA properties, to be passed into  * {@code EntityManagerFactory.createEntityManager(Map)} (if any).  * <p>Can be populated with a String "value" (parsed via PropertiesEditor)  * or a "props" element in XML bean definitions.  * @see javax.persistence.EntityManagerFactory#createEntityManager(java.util.Map)  */ ;/**  * Specify JPA properties, to be passed into  * {@code EntityManagerFactory.createEntityManager(Map)} (if any).  * <p>Can be populated with a String "value" (parsed via PropertiesEditor)  * or a "props" element in XML bean definitions.  * @see javax.persistence.EntityManagerFactory#createEntityManager(java.util.Map)  */ public void setJpaProperties(@Nullable Properties jpaProperties) {     CollectionUtils.mergePropertiesIntoMap(jpaProperties, this.jpaPropertyMap). }
true;public;1;5;/**  * Specify JPA properties as a Map, to be passed into  * {@code EntityManagerFactory.createEntityManager(Map)} (if any).  * <p>Can be populated with a "map" or "props" element in XML bean definitions.  * @see javax.persistence.EntityManagerFactory#createEntityManager(java.util.Map)  */ ;/**  * Specify JPA properties as a Map, to be passed into  * {@code EntityManagerFactory.createEntityManager(Map)} (if any).  * <p>Can be populated with a "map" or "props" element in XML bean definitions.  * @see javax.persistence.EntityManagerFactory#createEntityManager(java.util.Map)  */ public void setJpaPropertyMap(@Nullable Map<String, ?> jpaProperties) {     if (jpaProperties != null) {         this.jpaPropertyMap.putAll(jpaProperties).     } }
true;public;0;3;/**  * Allow Map access to the JPA properties to be passed to the persistence  * provider, with the option to add or override specific entries.  * <p>Useful for specifying entries directly, for example via "jpaPropertyMap[myKey]".  */ ;/**  * Allow Map access to the JPA properties to be passed to the persistence  * provider, with the option to add or override specific entries.  * <p>Useful for specifying entries directly, for example via "jpaPropertyMap[myKey]".  */ public Map<String, Object> getJpaPropertyMap() {     return this.jpaPropertyMap. }
true;public;1;11;/**  * Set the JDBC DataSource that this instance should manage transactions for.  * The DataSource should match the one used by the JPA EntityManagerFactory:  * for example, you could specify the same JNDI DataSource for both.  * <p>If the EntityManagerFactory uses a known DataSource as its connection factory,  * the DataSource will be autodetected: You can still explicitly specify the  * DataSource, but you don't need to in this case.  * <p>A transactional JDBC Connection for this DataSource will be provided to  * application code accessing this DataSource directly via DataSourceUtils  * or JdbcTemplate. The Connection will be taken from the JPA EntityManager.  * <p>Note that you need to use a JPA dialect for a specific JPA implementation  * to allow for exposing JPA transactions as JDBC transactions.  * <p>The DataSource specified here should be the target DataSource to manage  * transactions for, not a TransactionAwareDataSourceProxy. Only data access  * code may work with TransactionAwareDataSourceProxy, while the transaction  * manager needs to work on the underlying target DataSource. If there's  * nevertheless a TransactionAwareDataSourceProxy passed in, it will be  * unwrapped to extract its target DataSource.  * @see EntityManagerFactoryInfo#getDataSource()  * @see #setJpaDialect  * @see org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy  * @see org.springframework.jdbc.datasource.DataSourceUtils  * @see org.springframework.jdbc.core.JdbcTemplate  */ ;/**  * Set the JDBC DataSource that this instance should manage transactions for.  * The DataSource should match the one used by the JPA EntityManagerFactory:  * for example, you could specify the same JNDI DataSource for both.  * <p>If the EntityManagerFactory uses a known DataSource as its connection factory,  * the DataSource will be autodetected: You can still explicitly specify the  * DataSource, but you don't need to in this case.  * <p>A transactional JDBC Connection for this DataSource will be provided to  * application code accessing this DataSource directly via DataSourceUtils  * or JdbcTemplate. The Connection will be taken from the JPA EntityManager.  * <p>Note that you need to use a JPA dialect for a specific JPA implementation  * to allow for exposing JPA transactions as JDBC transactions.  * <p>The DataSource specified here should be the target DataSource to manage  * transactions for, not a TransactionAwareDataSourceProxy. Only data access  * code may work with TransactionAwareDataSourceProxy, while the transaction  * manager needs to work on the underlying target DataSource. If there's  * nevertheless a TransactionAwareDataSourceProxy passed in, it will be  * unwrapped to extract its target DataSource.  * @see EntityManagerFactoryInfo#getDataSource()  * @see #setJpaDialect  * @see org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy  * @see org.springframework.jdbc.datasource.DataSourceUtils  * @see org.springframework.jdbc.core.JdbcTemplate  */ public void setDataSource(@Nullable DataSource dataSource) {     if (dataSource instanceof TransactionAwareDataSourceProxy) {         // If we got a TransactionAwareDataSourceProxy, we need to perform transactions         // for its underlying target DataSource, else data access code won't see         // properly exposed transactions (i.e. transactions for the target DataSource).         this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource().     } else {         this.dataSource = dataSource.     } }
true;public;0;4;/**  * Return the JDBC DataSource that this instance manages transactions for.  */ ;/**  * Return the JDBC DataSource that this instance manages transactions for.  */ @Nullable public DataSource getDataSource() {     return this.dataSource. }
true;public;1;3;/**  * Set the JPA dialect to use for this transaction manager.  * Used for vendor-specific transaction management and JDBC connection exposure.  * <p>If the EntityManagerFactory uses a known JpaDialect, it will be autodetected:  * You can still explicitly specify the DataSource, but you don't need to in this case.  * <p>The dialect object can be used to retrieve the underlying JDBC connection  * and thus allows for exposing JPA transactions as JDBC transactions.  * @see EntityManagerFactoryInfo#getJpaDialect()  * @see JpaDialect#beginTransaction  * @see JpaDialect#getJdbcConnection  */ ;/**  * Set the JPA dialect to use for this transaction manager.  * Used for vendor-specific transaction management and JDBC connection exposure.  * <p>If the EntityManagerFactory uses a known JpaDialect, it will be autodetected:  * You can still explicitly specify the DataSource, but you don't need to in this case.  * <p>The dialect object can be used to retrieve the underlying JDBC connection  * and thus allows for exposing JPA transactions as JDBC transactions.  * @see EntityManagerFactoryInfo#getJpaDialect()  * @see JpaDialect#beginTransaction  * @see JpaDialect#getJdbcConnection  */ public void setJpaDialect(@Nullable JpaDialect jpaDialect) {     this.jpaDialect = (jpaDialect != null ? jpaDialect : new DefaultJpaDialect()). }
true;public;0;3;/**  * Return the JPA dialect to use for this transaction manager.  */ ;/**  * Return the JPA dialect to use for this transaction manager.  */ public JpaDialect getJpaDialect() {     return this.jpaDialect. }
true;public;1;11;/**  * Retrieves an EntityManagerFactory by persistence unit name, if none set explicitly.  * Falls back to a default EntityManagerFactory bean if no persistence unit specified.  * @see #setPersistenceUnitName  */ ;/**  * Retrieves an EntityManagerFactory by persistence unit name, if none set explicitly.  * Falls back to a default EntityManagerFactory bean if no persistence unit specified.  * @see #setPersistenceUnitName  */ @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException {     if (getEntityManagerFactory() == null) {         if (!(beanFactory instanceof ListableBeanFactory)) {             throw new IllegalStateException("Cannot retrieve EntityManagerFactory by persistence unit name " + "in a non-listable BeanFactory: " + beanFactory).         }         ListableBeanFactory lbf = (ListableBeanFactory) beanFactory.         setEntityManagerFactory(EntityManagerFactoryUtils.findEntityManagerFactory(lbf, getPersistenceUnitName())).     } }
true;public;0;17;/**  * Eagerly initialize the JPA dialect, creating a default one  * for the specified EntityManagerFactory if none set.  * Auto-detect the EntityManagerFactory's DataSource, if any.  */ ;/**  * Eagerly initialize the JPA dialect, creating a default one  * for the specified EntityManagerFactory if none set.  * Auto-detect the EntityManagerFactory's DataSource, if any.  */ @Override public void afterPropertiesSet() {     if (getEntityManagerFactory() == null) {         throw new IllegalArgumentException("'entityManagerFactory' or 'persistenceUnitName' is required").     }     if (getEntityManagerFactory() instanceof EntityManagerFactoryInfo) {         EntityManagerFactoryInfo emfInfo = (EntityManagerFactoryInfo) getEntityManagerFactory().         DataSource dataSource = emfInfo.getDataSource().         if (dataSource != null) {             setDataSource(dataSource).         }         JpaDialect jpaDialect = emfInfo.getJpaDialect().         if (jpaDialect != null) {             setJpaDialect(jpaDialect).         }     } }
false;public;0;4;;@Override public Object getResourceFactory() {     return obtainEntityManagerFactory(). }
false;protected;0;23;;@Override protected Object doGetTransaction() {     JpaTransactionObject txObject = new JpaTransactionObject().     txObject.setSavepointAllowed(isNestedTransactionAllowed()).     EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(obtainEntityManagerFactory()).     if (emHolder != null) {         if (logger.isDebugEnabled()) {             logger.debug("Found thread-bound EntityManager [" + emHolder.getEntityManager() + "] for JPA transaction").         }         txObject.setEntityManagerHolder(emHolder, false).     }     if (getDataSource() != null) {         ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(getDataSource()).         txObject.setConnectionHolder(conHolder).     }     return txObject. }
false;protected;1;4;;@Override protected boolean isExistingTransaction(Object transaction) {     return ((JpaTransactionObject) transaction).hasTransaction(). }
false;protected;2;74;;@Override protected void doBegin(Object transaction, TransactionDefinition definition) {     JpaTransactionObject txObject = (JpaTransactionObject) transaction.     if (txObject.hasConnectionHolder() && !txObject.getConnectionHolder().isSynchronizedWithTransaction()) {         throw new IllegalTransactionStateException("Pre-bound JDBC Connection found! JpaTransactionManager does not support " + "running within DataSourceTransactionManager if told to manage the DataSource itself. " + "It is recommended to use a single JpaTransactionManager for all transactions " + "on a single DataSource, no matter whether JPA or JDBC access.").     }     try {         if (!txObject.hasEntityManagerHolder() || txObject.getEntityManagerHolder().isSynchronizedWithTransaction()) {             EntityManager newEm = createEntityManagerForTransaction().             if (logger.isDebugEnabled()) {                 logger.debug("Opened new EntityManager [" + newEm + "] for JPA transaction").             }             txObject.setEntityManagerHolder(new EntityManagerHolder(newEm), true).         }         EntityManager em = txObject.getEntityManagerHolder().getEntityManager().         // Delegate to JpaDialect for actual transaction begin.         final int timeoutToUse = determineTimeout(definition).         Object transactionData = getJpaDialect().beginTransaction(em, new JpaTransactionDefinition(definition, timeoutToUse, txObject.isNewEntityManagerHolder())).         txObject.setTransactionData(transactionData).         // Register transaction timeout.         if (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {             txObject.getEntityManagerHolder().setTimeoutInSeconds(timeoutToUse).         }         // Register the JPA EntityManager's JDBC Connection for the DataSource, if set.         if (getDataSource() != null) {             ConnectionHandle conHandle = getJpaDialect().getJdbcConnection(em, definition.isReadOnly()).             if (conHandle != null) {                 ConnectionHolder conHolder = new ConnectionHolder(conHandle).                 if (timeoutToUse != TransactionDefinition.TIMEOUT_DEFAULT) {                     conHolder.setTimeoutInSeconds(timeoutToUse).                 }                 if (logger.isDebugEnabled()) {                     logger.debug("Exposing JPA transaction as JDBC [" + conHandle + "]").                 }                 TransactionSynchronizationManager.bindResource(getDataSource(), conHolder).                 txObject.setConnectionHolder(conHolder).             } else {                 if (logger.isDebugEnabled()) {                     logger.debug("Not exposing JPA transaction [" + em + "] as JDBC transaction because " + "JpaDialect [" + getJpaDialect() + "] does not support JDBC Connection retrieval").                 }             }         }         // Bind the entity manager holder to the thread.         if (txObject.isNewEntityManagerHolder()) {             TransactionSynchronizationManager.bindResource(obtainEntityManagerFactory(), txObject.getEntityManagerHolder()).         }         txObject.getEntityManagerHolder().setSynchronizedWithTransaction(true).     } catch (TransactionException ex) {         closeEntityManagerAfterFailedBegin(txObject).         throw ex.     } catch (Throwable ex) {         closeEntityManagerAfterFailedBegin(txObject).         throw new CannotCreateTransactionException("Could not open JPA EntityManager for transaction", ex).     } }
true;protected;0;9;/**  * Create a JPA EntityManager to be used for a transaction.  * <p>The default implementation checks whether the EntityManagerFactory  * is a Spring proxy and unwraps it first.  * @see javax.persistence.EntityManagerFactory#createEntityManager()  * @see EntityManagerFactoryInfo#getNativeEntityManagerFactory()  */ ;/**  * Create a JPA EntityManager to be used for a transaction.  * <p>The default implementation checks whether the EntityManagerFactory  * is a Spring proxy and unwraps it first.  * @see javax.persistence.EntityManagerFactory#createEntityManager()  * @see EntityManagerFactoryInfo#getNativeEntityManagerFactory()  */ protected EntityManager createEntityManagerForTransaction() {     EntityManagerFactory emf = obtainEntityManagerFactory().     if (emf instanceof EntityManagerFactoryInfo) {         emf = ((EntityManagerFactoryInfo) emf).getNativeEntityManagerFactory().     }     Map<String, Object> properties = getJpaPropertyMap().     return (!CollectionUtils.isEmpty(properties) ? emf.createEntityManager(properties) : emf.createEntityManager()). }
true;protected;1;17;/**  * Close the current transaction's EntityManager.  * Called after a transaction begin attempt failed.  * @param txObject the current transaction  */ ;/**  * Close the current transaction's EntityManager.  * Called after a transaction begin attempt failed.  * @param txObject the current transaction  */ protected void closeEntityManagerAfterFailedBegin(JpaTransactionObject txObject) {     if (txObject.isNewEntityManagerHolder()) {         EntityManager em = txObject.getEntityManagerHolder().getEntityManager().         try {             if (em.getTransaction().isActive()) {                 em.getTransaction().rollback().             }         } catch (Throwable ex) {             logger.debug("Could not rollback EntityManager after failed transaction begin", ex).         } finally {             EntityManagerFactoryUtils.closeEntityManager(em).         }         txObject.setEntityManagerHolder(null, false).     } }
false;protected;1;13;;@Override protected Object doSuspend(Object transaction) {     JpaTransactionObject txObject = (JpaTransactionObject) transaction.     txObject.setEntityManagerHolder(null, false).     EntityManagerHolder entityManagerHolder = (EntityManagerHolder) TransactionSynchronizationManager.unbindResource(obtainEntityManagerFactory()).     txObject.setConnectionHolder(null).     ConnectionHolder connectionHolder = null.     if (getDataSource() != null && TransactionSynchronizationManager.hasResource(getDataSource())) {         connectionHolder = (ConnectionHolder) TransactionSynchronizationManager.unbindResource(getDataSource()).     }     return new SuspendedResourcesHolder(entityManagerHolder, connectionHolder). }
false;protected;2;9;;@Override protected void doResume(@Nullable Object transaction, Object suspendedResources) {     SuspendedResourcesHolder resourcesHolder = (SuspendedResourcesHolder) suspendedResources.     TransactionSynchronizationManager.bindResource(obtainEntityManagerFactory(), resourcesHolder.getEntityManagerHolder()).     if (getDataSource() != null && resourcesHolder.getConnectionHolder() != null) {         TransactionSynchronizationManager.bindResource(getDataSource(), resourcesHolder.getConnectionHolder()).     } }
true;protected;0;4;/**  * This implementation returns "true": a JPA commit will properly handle  * transactions that have been marked rollback-only at a global level.  */ ;/**  * This implementation returns "true": a JPA commit will properly handle  * transactions that have been marked rollback-only at a global level.  */ @Override protected boolean shouldCommitOnGlobalRollbackOnly() {     return true. }
false;protected;1;25;;@Override protected void doCommit(DefaultTransactionStatus status) {     JpaTransactionObject txObject = (JpaTransactionObject) status.getTransaction().     if (status.isDebug()) {         logger.debug("Committing JPA transaction on EntityManager [" + txObject.getEntityManagerHolder().getEntityManager() + "]").     }     try {         EntityTransaction tx = txObject.getEntityManagerHolder().getEntityManager().getTransaction().         tx.commit().     } catch (RollbackException ex) {         if (ex.getCause() instanceof RuntimeException) {             DataAccessException dae = getJpaDialect().translateExceptionIfPossible((RuntimeException) ex.getCause()).             if (dae != null) {                 throw dae.             }         }         throw new TransactionSystemException("Could not commit JPA transaction", ex).     } catch (RuntimeException ex) {         // Assumably failed to flush changes to database.         throw DataAccessUtils.translateIfNecessary(ex, getJpaDialect()).     } }
false;protected;1;24;;@Override protected void doRollback(DefaultTransactionStatus status) {     JpaTransactionObject txObject = (JpaTransactionObject) status.getTransaction().     if (status.isDebug()) {         logger.debug("Rolling back JPA transaction on EntityManager [" + txObject.getEntityManagerHolder().getEntityManager() + "]").     }     try {         EntityTransaction tx = txObject.getEntityManagerHolder().getEntityManager().getTransaction().         if (tx.isActive()) {             tx.rollback().         }     } catch (PersistenceException ex) {         throw new TransactionSystemException("Could not roll back JPA transaction", ex).     } finally {         if (!txObject.isNewEntityManagerHolder()) {             // Clear all pending inserts/updates/deletes in the EntityManager.             // Necessary for pre-bound EntityManagers, to avoid inconsistent state.             txObject.getEntityManagerHolder().getEntityManager().clear().         }     } }
false;protected;1;9;;@Override protected void doSetRollbackOnly(DefaultTransactionStatus status) {     JpaTransactionObject txObject = (JpaTransactionObject) status.getTransaction().     if (status.isDebug()) {         logger.debug("Setting JPA transaction on EntityManager [" + txObject.getEntityManagerHolder().getEntityManager() + "] rollback-only").     }     txObject.setRollbackOnly(). }
false;protected;1;42;;@Override protected void doCleanupAfterCompletion(Object transaction) {     JpaTransactionObject txObject = (JpaTransactionObject) transaction.     // to replace it with an unsynchronized EntityManager).     if (txObject.isNewEntityManagerHolder()) {         TransactionSynchronizationManager.unbindResourceIfPossible(obtainEntityManagerFactory()).     }     txObject.getEntityManagerHolder().clear().     // Remove the JDBC connection holder from the thread, if exposed.     if (getDataSource() != null && txObject.hasConnectionHolder()) {         TransactionSynchronizationManager.unbindResource(getDataSource()).         ConnectionHandle conHandle = txObject.getConnectionHolder().getConnectionHandle().         if (conHandle != null) {             try {                 getJpaDialect().releaseJdbcConnection(conHandle, txObject.getEntityManagerHolder().getEntityManager()).             } catch (Exception ex) {                 // Just log it, to keep a transaction-related exception.                 logger.error("Could not close JDBC connection after transaction", ex).             }         }     }     getJpaDialect().cleanupTransaction(txObject.getTransactionData()).     // Remove the entity manager holder from the thread.     if (txObject.isNewEntityManagerHolder()) {         EntityManager em = txObject.getEntityManagerHolder().getEntityManager().         if (logger.isDebugEnabled()) {             logger.debug("Closing JPA EntityManager [" + em + "] after transaction").         }         EntityManagerFactoryUtils.closeEntityManager(em).     } else {         logger.debug("Not closing pre-bound JPA EntityManager after transaction").     } }
false;public;2;6;;public void setEntityManagerHolder(@Nullable EntityManagerHolder entityManagerHolder, boolean newEntityManagerHolder) {     this.entityManagerHolder = entityManagerHolder.     this.newEntityManagerHolder = newEntityManagerHolder. }
false;public;0;4;;public EntityManagerHolder getEntityManagerHolder() {     Assert.state(this.entityManagerHolder != null, "No EntityManagerHolder available").     return this.entityManagerHolder. }
false;public;0;3;;public boolean hasEntityManagerHolder() {     return (this.entityManagerHolder != null). }
false;public;0;3;;public boolean isNewEntityManagerHolder() {     return this.newEntityManagerHolder. }
false;public;0;3;;public boolean hasTransaction() {     return (this.entityManagerHolder != null && this.entityManagerHolder.isTransactionActive()). }
false;public;1;7;;public void setTransactionData(@Nullable Object transactionData) {     this.transactionData = transactionData.     getEntityManagerHolder().setTransactionActive(true).     if (transactionData instanceof SavepointManager) {         getEntityManagerHolder().setSavepointManager((SavepointManager) transactionData).     } }
false;public;0;4;;@Nullable public Object getTransactionData() {     return this.transactionData. }
false;public;0;9;;public void setRollbackOnly() {     EntityTransaction tx = getEntityManagerHolder().getEntityManager().getTransaction().     if (tx.isActive()) {         tx.setRollbackOnly().     }     if (hasConnectionHolder()) {         getConnectionHolder().setRollbackOnly().     } }
false;public;0;5;;@Override public boolean isRollbackOnly() {     EntityTransaction tx = getEntityManagerHolder().getEntityManager().getTransaction().     return tx.getRollbackOnly(). }
false;public;0;9;;@Override public void flush() {     try {         getEntityManagerHolder().getEntityManager().flush().     } catch (RuntimeException ex) {         throw DataAccessUtils.translateIfNecessary(ex, getJpaDialect()).     } }
false;public;0;8;;@Override public Object createSavepoint() throws TransactionException {     if (getEntityManagerHolder().isRollbackOnly()) {         throw new CannotCreateTransactionException("Cannot create savepoint for transaction which is already marked as rollback-only").     }     return getSavepointManager().createSavepoint(). }
false;public;1;5;;@Override public void rollbackToSavepoint(Object savepoint) throws TransactionException {     getSavepointManager().rollbackToSavepoint(savepoint).     getEntityManagerHolder().resetRollbackOnly(). }
false;public;1;4;;@Override public void releaseSavepoint(Object savepoint) throws TransactionException {     getSavepointManager().releaseSavepoint(savepoint). }
false;private;0;12;;private SavepointManager getSavepointManager() {     if (!isSavepointAllowed()) {         throw new NestedTransactionNotSupportedException("Transaction manager does not allow nested transactions").     }     SavepointManager savepointManager = getEntityManagerHolder().getSavepointManager().     if (savepointManager == null) {         throw new NestedTransactionNotSupportedException("JpaDialect does not support savepoints - check your JPA provider's capabilities").     }     return savepointManager. }
false;public;0;4;;@Override public int getTimeout() {     return this.timeout. }
false;public;0;4;;@Override public boolean isLocalResource() {     return this.localResource. }
false;private;0;3;;private EntityManagerHolder getEntityManagerHolder() {     return this.entityManagerHolder. }
false;private;0;4;;@Nullable private ConnectionHolder getConnectionHolder() {     return this.connectionHolder. }
