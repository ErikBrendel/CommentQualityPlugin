commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the JNDI template to use for JNDI lookups.  * @see org.springframework.jndi.JndiAccessor#setJndiTemplate  */ ;/**  * Set the JNDI template to use for JNDI lookups.  * @see org.springframework.jndi.JndiAccessor#setJndiTemplate  */ public void setJndiTemplate(Object jndiTemplate) {     this.jndiEnvironment = jndiTemplate. }
true;public;1;3;/**  * Set the JNDI environment to use for JNDI lookups.  * @see org.springframework.jndi.JndiAccessor#setJndiEnvironment  */ ;/**  * Set the JNDI environment to use for JNDI lookups.  * @see org.springframework.jndi.JndiAccessor#setJndiEnvironment  */ public void setJndiEnvironment(Properties jndiEnvironment) {     this.jndiEnvironment = jndiEnvironment. }
true;public;1;3;/**  * Set whether the lookup occurs in a Java EE container, i.e. if the prefix  * "java:comp/env/" needs to be added if the JNDI name doesn't already  * contain it. PersistenceAnnotationBeanPostProcessor's default is "true".  * @see org.springframework.jndi.JndiLocatorSupport#setResourceRef  */ ;/**  * Set whether the lookup occurs in a Java EE container, i.e. if the prefix  * "java:comp/env/" needs to be added if the JNDI name doesn't already  * contain it. PersistenceAnnotationBeanPostProcessor's default is "true".  * @see org.springframework.jndi.JndiLocatorSupport#setResourceRef  */ public void setResourceRef(boolean resourceRef) {     this.resourceRef = resourceRef. }
true;public;1;3;/**  * Specify the persistence units for EntityManagerFactory lookups,  * as a Map from persistence unit name to persistence unit JNDI name  * (which needs to resolve to an EntityManagerFactory instance).  * <p>JNDI names specified here should refer to {@code persistence-unit-ref}  * entries in the Java EE deployment descriptor, matching the target persistence unit.  * <p>In case of no unit name specified in the annotation, the specified value  * for the {@link #setDefaultPersistenceUnitName default persistence unit}  * will be taken (by default, the value mapped to the empty String),  * or simply the single persistence unit if there is only one.  * <p>This is mainly intended for use in a Java EE environment, with all lookup  * driven by the standard JPA annotations, and all EntityManagerFactory  * references obtained from JNDI. No separate EntityManagerFactory bean  * definitions are necessary in such a scenario.  * <p>If no corresponding "persistenceContexts"/"extendedPersistenceContexts"  * are specified, {@code @PersistenceContext} will be resolved to  * EntityManagers built on top of the EntityManagerFactory defined here.  * Note that those will be Spring-managed EntityManagers, which implement  * transaction synchronization based on Spring's facilities.  * If you prefer the Java EE server's own EntityManager handling,  * specify corresponding "persistenceContexts"/"extendedPersistenceContexts".  */ ;/**  * Specify the persistence units for EntityManagerFactory lookups,  * as a Map from persistence unit name to persistence unit JNDI name  * (which needs to resolve to an EntityManagerFactory instance).  * <p>JNDI names specified here should refer to {@code persistence-unit-ref}  * entries in the Java EE deployment descriptor, matching the target persistence unit.  * <p>In case of no unit name specified in the annotation, the specified value  * for the {@link #setDefaultPersistenceUnitName default persistence unit}  * will be taken (by default, the value mapped to the empty String),  * or simply the single persistence unit if there is only one.  * <p>This is mainly intended for use in a Java EE environment, with all lookup  * driven by the standard JPA annotations, and all EntityManagerFactory  * references obtained from JNDI. No separate EntityManagerFactory bean  * definitions are necessary in such a scenario.  * <p>If no corresponding "persistenceContexts"/"extendedPersistenceContexts"  * are specified, {@code @PersistenceContext} will be resolved to  * EntityManagers built on top of the EntityManagerFactory defined here.  * Note that those will be Spring-managed EntityManagers, which implement  * transaction synchronization based on Spring's facilities.  * If you prefer the Java EE server's own EntityManager handling,  * specify corresponding "persistenceContexts"/"extendedPersistenceContexts".  */ public void setPersistenceUnits(Map<String, String> persistenceUnits) {     this.persistenceUnits = persistenceUnits. }
true;public;1;3;/**  * Specify the <i>transactional</i> persistence contexts for EntityManager lookups,  * as a Map from persistence unit name to persistence context JNDI name  * (which needs to resolve to an EntityManager instance).  * <p>JNDI names specified here should refer to {@code persistence-context-ref}  * entries in the Java EE deployment descriptors, matching the target persistence unit  * and being set up with persistence context type {@code Transaction}.  * <p>In case of no unit name specified in the annotation, the specified value  * for the {@link #setDefaultPersistenceUnitName default persistence unit}  * will be taken (by default, the value mapped to the empty String),  * or simply the single persistence unit if there is only one.  * <p>This is mainly intended for use in a Java EE environment, with all  * lookup driven by the standard JPA annotations, and all EntityManager  * references obtained from JNDI. No separate EntityManagerFactory bean  * definitions are necessary in such a scenario, and all EntityManager  * handling is done by the Java EE server itself.  */ ;/**  * Specify the <i>transactional</i> persistence contexts for EntityManager lookups,  * as a Map from persistence unit name to persistence context JNDI name  * (which needs to resolve to an EntityManager instance).  * <p>JNDI names specified here should refer to {@code persistence-context-ref}  * entries in the Java EE deployment descriptors, matching the target persistence unit  * and being set up with persistence context type {@code Transaction}.  * <p>In case of no unit name specified in the annotation, the specified value  * for the {@link #setDefaultPersistenceUnitName default persistence unit}  * will be taken (by default, the value mapped to the empty String),  * or simply the single persistence unit if there is only one.  * <p>This is mainly intended for use in a Java EE environment, with all  * lookup driven by the standard JPA annotations, and all EntityManager  * references obtained from JNDI. No separate EntityManagerFactory bean  * definitions are necessary in such a scenario, and all EntityManager  * handling is done by the Java EE server itself.  */ public void setPersistenceContexts(Map<String, String> persistenceContexts) {     this.persistenceContexts = persistenceContexts. }
true;public;1;3;/**  * Specify the <i>extended</i> persistence contexts for EntityManager lookups,  * as a Map from persistence unit name to persistence context JNDI name  * (which needs to resolve to an EntityManager instance).  * <p>JNDI names specified here should refer to {@code persistence-context-ref}  * entries in the Java EE deployment descriptors, matching the target persistence unit  * and being set up with persistence context type {@code Extended}.  * <p>In case of no unit name specified in the annotation, the specified value  * for the {@link #setDefaultPersistenceUnitName default persistence unit}  * will be taken (by default, the value mapped to the empty String),  * or simply the single persistence unit if there is only one.  * <p>This is mainly intended for use in a Java EE environment, with all  * lookup driven by the standard JPA annotations, and all EntityManager  * references obtained from JNDI. No separate EntityManagerFactory bean  * definitions are necessary in such a scenario, and all EntityManager  * handling is done by the Java EE server itself.  */ ;/**  * Specify the <i>extended</i> persistence contexts for EntityManager lookups,  * as a Map from persistence unit name to persistence context JNDI name  * (which needs to resolve to an EntityManager instance).  * <p>JNDI names specified here should refer to {@code persistence-context-ref}  * entries in the Java EE deployment descriptors, matching the target persistence unit  * and being set up with persistence context type {@code Extended}.  * <p>In case of no unit name specified in the annotation, the specified value  * for the {@link #setDefaultPersistenceUnitName default persistence unit}  * will be taken (by default, the value mapped to the empty String),  * or simply the single persistence unit if there is only one.  * <p>This is mainly intended for use in a Java EE environment, with all  * lookup driven by the standard JPA annotations, and all EntityManager  * references obtained from JNDI. No separate EntityManagerFactory bean  * definitions are necessary in such a scenario, and all EntityManager  * handling is done by the Java EE server itself.  */ public void setExtendedPersistenceContexts(Map<String, String> extendedPersistenceContexts) {     this.extendedPersistenceContexts = extendedPersistenceContexts. }
true;public;1;3;/**  * Specify the default persistence unit name, to be used in case  * of no unit name specified in an {@code @PersistenceUnit} /  * {@code @PersistenceContext} annotation.  * <p>This is mainly intended for lookups in the application context,  * indicating the target persistence unit name (typically matching  * the bean name), but also applies to lookups in the  * {@link #setPersistenceUnits "persistenceUnits"} /  * {@link #setPersistenceContexts "persistenceContexts"} /  * {@link #setExtendedPersistenceContexts "extendedPersistenceContexts"} map,  * avoiding the need for duplicated mappings for the empty String there.  * <p>Default is to check for a single EntityManagerFactory bean  * in the Spring application context, if any. If there are multiple  * such factories, either specify this default persistence unit name  * or explicitly refer to named persistence units in your annotations.  */ ;/**  * Specify the default persistence unit name, to be used in case  * of no unit name specified in an {@code @PersistenceUnit} /  * {@code @PersistenceContext} annotation.  * <p>This is mainly intended for lookups in the application context,  * indicating the target persistence unit name (typically matching  * the bean name), but also applies to lookups in the  * {@link #setPersistenceUnits "persistenceUnits"} /  * {@link #setPersistenceContexts "persistenceContexts"} /  * {@link #setExtendedPersistenceContexts "extendedPersistenceContexts"} map,  * avoiding the need for duplicated mappings for the empty String there.  * <p>Default is to check for a single EntityManagerFactory bean  * in the Spring application context, if any. If there are multiple  * such factories, either specify this default persistence unit name  * or explicitly refer to named persistence units in your annotations.  */ public void setDefaultPersistenceUnitName(@Nullable String unitName) {     this.defaultPersistenceUnitName = (unitName != null ? unitName : ""). }
false;public;1;3;;public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
false;public;1;6;;@Override public void setBeanFactory(BeanFactory beanFactory) {     if (beanFactory instanceof ListableBeanFactory) {         this.beanFactory = (ListableBeanFactory) beanFactory.     } }
false;public;3;5;;@Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {     InjectionMetadata metadata = findPersistenceMetadata(beanName, beanType, null).     metadata.checkConfigMembers(beanDefinition). }
false;public;1;4;;@Override public void resetBeanDefinition(String beanName) {     this.injectionMetadataCache.remove(beanName). }
false;public;2;4;;@Override public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {     return null. }
false;public;2;4;;@Override public boolean postProcessAfterInstantiation(Object bean, String beanName) {     return true. }
false;public;3;11;;@Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {     InjectionMetadata metadata = findPersistenceMetadata(beanName, bean.getClass(), pvs).     try {         metadata.inject(bean, beanName, pvs).     } catch (Throwable ex) {         throw new BeanCreationException(beanName, "Injection of persistence dependencies failed", ex).     }     return pvs. }
false;public;4;7;;@Deprecated @Override public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) {     return postProcessProperties(pvs, bean, beanName). }
false;public;2;4;;@Override public Object postProcessBeforeInitialization(Object bean, String beanName) {     return bean. }
false;public;2;4;;@Override public Object postProcessAfterInitialization(Object bean, String beanName) {     return bean. }
false;public;2;5;;@Override public void postProcessBeforeDestruction(Object bean, String beanName) {     EntityManager emToClose = this.extendedEntityManagersToClose.remove(bean).     EntityManagerFactoryUtils.closeEntityManager(emToClose). }
false;public;1;4;;@Override public boolean requiresDestruction(Object bean) {     return this.extendedEntityManagersToClose.containsKey(bean). }
false;private;3;19;;private InjectionMetadata findPersistenceMetadata(String beanName, final Class<?> clazz, @Nullable PropertyValues pvs) {     // Fall back to class name as cache key, for backwards compatibility with custom callers.     String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName()).     // Quick check on the concurrent map first, with minimal locking.     InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey).     if (InjectionMetadata.needsRefresh(metadata, clazz)) {         synchronized (this.injectionMetadataCache) {             metadata = this.injectionMetadataCache.get(cacheKey).             if (InjectionMetadata.needsRefresh(metadata, clazz)) {                 if (metadata != null) {                     metadata.clear(pvs).                 }                 metadata = buildPersistenceMetadata(clazz).                 this.injectionMetadataCache.put(cacheKey, metadata).             }         }     }     return metadata. }
false;private;1;44;;private InjectionMetadata buildPersistenceMetadata(final Class<?> clazz) {     List<InjectionMetadata.InjectedElement> elements = new ArrayList<>().     Class<?> targetClass = clazz.     do {         final LinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<>().         ReflectionUtils.doWithLocalFields(targetClass, field -> {             if (field.isAnnotationPresent(PersistenceContext.class) || field.isAnnotationPresent(PersistenceUnit.class)) {                 if (Modifier.isStatic(field.getModifiers())) {                     throw new IllegalStateException("Persistence annotations are not supported on static fields").                 }                 currElements.add(new PersistenceElement(field, field, null)).             }         }).         ReflectionUtils.doWithLocalMethods(targetClass, method -> {             Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method).             if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {                 return.             }             if ((bridgedMethod.isAnnotationPresent(PersistenceContext.class) || bridgedMethod.isAnnotationPresent(PersistenceUnit.class)) && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {                 if (Modifier.isStatic(method.getModifiers())) {                     throw new IllegalStateException("Persistence annotations are not supported on static methods").                 }                 if (method.getParameterCount() != 1) {                     throw new IllegalStateException("Persistence annotation requires a single-arg method: " + method).                 }                 PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz).                 currElements.add(new PersistenceElement(method, bridgedMethod, pd)).             }         }).         elements.addAll(0, currElements).         targetClass = targetClass.getSuperclass().     } while (targetClass != null && targetClass != Object.class).     return new InjectionMetadata(clazz, elements). }
true;protected;1;22;/**  * Return a specified persistence unit for the given unit name,  * as defined through the "persistenceUnits" map.  * @param unitName the name of the persistence unit  * @return the corresponding EntityManagerFactory,  * or {@code null} if none found  * @see #setPersistenceUnits  */ ;/**  * Return a specified persistence unit for the given unit name,  * as defined through the "persistenceUnits" map.  * @param unitName the name of the persistence unit  * @return the corresponding EntityManagerFactory,  * or {@code null} if none found  * @see #setPersistenceUnits  */ @Nullable protected EntityManagerFactory getPersistenceUnit(@Nullable String unitName) {     if (this.persistenceUnits != null) {         String unitNameForLookup = (unitName != null ? unitName : "").         if (unitNameForLookup.isEmpty()) {             unitNameForLookup = this.defaultPersistenceUnitName.         }         String jndiName = this.persistenceUnits.get(unitNameForLookup).         if (jndiName == null && "".equals(unitNameForLookup) && this.persistenceUnits.size() == 1) {             jndiName = this.persistenceUnits.values().iterator().next().         }         if (jndiName != null) {             try {                 return lookup(jndiName, EntityManagerFactory.class).             } catch (Exception ex) {                 throw new IllegalStateException("Could not obtain EntityManagerFactory [" + jndiName + "] from JNDI", ex).             }         }     }     return null. }
true;protected;2;23;/**  * Return a specified persistence context for the given unit name, as defined  * through the "persistenceContexts" (or "extendedPersistenceContexts") map.  * @param unitName the name of the persistence unit  * @param extended whether to obtain an extended persistence context  * @return the corresponding EntityManager, or {@code null} if none found  * @see #setPersistenceContexts  * @see #setExtendedPersistenceContexts  */ ;/**  * Return a specified persistence context for the given unit name, as defined  * through the "persistenceContexts" (or "extendedPersistenceContexts") map.  * @param unitName the name of the persistence unit  * @param extended whether to obtain an extended persistence context  * @return the corresponding EntityManager, or {@code null} if none found  * @see #setPersistenceContexts  * @see #setExtendedPersistenceContexts  */ @Nullable protected EntityManager getPersistenceContext(@Nullable String unitName, boolean extended) {     Map<String, String> contexts = (extended ? this.extendedPersistenceContexts : this.persistenceContexts).     if (contexts != null) {         String unitNameForLookup = (unitName != null ? unitName : "").         if (unitNameForLookup.isEmpty()) {             unitNameForLookup = this.defaultPersistenceUnitName.         }         String jndiName = contexts.get(unitNameForLookup).         if (jndiName == null && "".equals(unitNameForLookup) && contexts.size() == 1) {             jndiName = contexts.values().iterator().next().         }         if (jndiName != null) {             try {                 return lookup(jndiName, EntityManager.class).             } catch (Exception ex) {                 throw new IllegalStateException("Could not obtain EntityManager [" + jndiName + "] from JNDI", ex).             }         }     }     return null. }
true;protected;2;14;/**  * Find an EntityManagerFactory with the given name in the current Spring  * application context, falling back to a single default EntityManagerFactory  * (if any) in case of no unit name specified.  * @param unitName the name of the persistence unit (may be {@code null} or empty)  * @param requestingBeanName the name of the requesting bean  * @return the EntityManagerFactory  * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context  */ ;/**  * Find an EntityManagerFactory with the given name in the current Spring  * application context, falling back to a single default EntityManagerFactory  * (if any) in case of no unit name specified.  * @param unitName the name of the persistence unit (may be {@code null} or empty)  * @param requestingBeanName the name of the requesting bean  * @return the EntityManagerFactory  * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context  */ protected EntityManagerFactory findEntityManagerFactory(@Nullable String unitName, @Nullable String requestingBeanName) throws NoSuchBeanDefinitionException {     String unitNameForLookup = (unitName != null ? unitName : "").     if (unitNameForLookup.isEmpty()) {         unitNameForLookup = this.defaultPersistenceUnitName.     }     if (!unitNameForLookup.isEmpty()) {         return findNamedEntityManagerFactory(unitNameForLookup, requestingBeanName).     } else {         return findDefaultEntityManagerFactory(requestingBeanName).     } }
true;protected;2;11;/**  * Find an EntityManagerFactory with the given name in the current  * Spring application context.  * @param unitName the name of the persistence unit (never empty)  * @param requestingBeanName the name of the requesting bean  * @return the EntityManagerFactory  * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context  */ ;/**  * Find an EntityManagerFactory with the given name in the current  * Spring application context.  * @param unitName the name of the persistence unit (never empty)  * @param requestingBeanName the name of the requesting bean  * @return the EntityManagerFactory  * @throws NoSuchBeanDefinitionException if there is no such EntityManagerFactory in the context  */ protected EntityManagerFactory findNamedEntityManagerFactory(String unitName, @Nullable String requestingBeanName) throws NoSuchBeanDefinitionException {     Assert.state(this.beanFactory != null, "ListableBeanFactory required for EntityManagerFactory bean lookup").     EntityManagerFactory emf = EntityManagerFactoryUtils.findEntityManagerFactory(this.beanFactory, unitName).     if (requestingBeanName != null && this.beanFactory instanceof ConfigurableBeanFactory) {         ((ConfigurableBeanFactory) this.beanFactory).registerDependentBean(unitName, requestingBeanName).     }     return emf. }
true;protected;1;19;/**  * Find a single default EntityManagerFactory in the Spring application context.  * @return the default EntityManagerFactory  * @throws NoSuchBeanDefinitionException if there is no single EntityManagerFactory in the context  */ ;/**  * Find a single default EntityManagerFactory in the Spring application context.  * @return the default EntityManagerFactory  * @throws NoSuchBeanDefinitionException if there is no single EntityManagerFactory in the context  */ protected EntityManagerFactory findDefaultEntityManagerFactory(@Nullable String requestingBeanName) throws NoSuchBeanDefinitionException {     Assert.state(this.beanFactory != null, "ListableBeanFactory required for EntityManagerFactory bean lookup").     if (this.beanFactory instanceof ConfigurableListableBeanFactory) {         // Fancy variant with dependency registration         ConfigurableListableBeanFactory clbf = (ConfigurableListableBeanFactory) this.beanFactory.         NamedBeanHolder<EntityManagerFactory> emfHolder = clbf.resolveNamedBean(EntityManagerFactory.class).         if (requestingBeanName != null) {             clbf.registerDependentBean(emfHolder.getBeanName(), requestingBeanName).         }         return emfHolder.getBeanInstance().     } else {         // Plain variant: just find a default bean         return this.beanFactory.getBean(EntityManagerFactory.class).     } }
true;protected;2;3;/**  * Perform a JNDI lookup for the given resource by name.  * <p>Called for EntityManagerFactory and EntityManager lookup  * when JNDI names are mapped for specific persistence units.  * @param jndiName the JNDI name to look up  * @param requiredType the required type of the object  * @return the obtained object  * @throws Exception if the JNDI lookup failed  */ ;/**  * Perform a JNDI lookup for the given resource by name.  * <p>Called for EntityManagerFactory and EntityManager lookup  * when JNDI names are mapped for specific persistence units.  * @param jndiName the JNDI name to look up  * @param requiredType the required type of the object  * @return the obtained object  * @throws Exception if the JNDI lookup failed  */ protected <T> T lookup(String jndiName, Class<T> requiredType) throws Exception {     return new LocatorDelegate().lookup(jndiName, requiredType). }
false;public;2;14;;public <T> T lookup(String jndiName, Class<T> requiredType) throws Exception {     JndiLocatorDelegate locator = new JndiLocatorDelegate().     if (jndiEnvironment instanceof JndiTemplate) {         locator.setJndiTemplate((JndiTemplate) jndiEnvironment).     } else if (jndiEnvironment instanceof Properties) {         locator.setJndiEnvironment((Properties) jndiEnvironment).     } else if (jndiEnvironment != null) {         throw new IllegalStateException("Illegal 'jndiEnvironment' type: " + jndiEnvironment.getClass()).     }     locator.setResourceRef(resourceRef).     return locator.lookup(jndiName, requiredType). }
true;protected;2;13;/**  * Resolve the object against the application context.  */ ;/**  * Resolve the object against the application context.  */ @Override protected Object getResourceToInject(Object target, @Nullable String requestingBeanName) {     // Resolves to EntityManagerFactory or EntityManager.     if (this.type != null) {         return (this.type == PersistenceContextType.EXTENDED ? resolveExtendedEntityManager(target, requestingBeanName) : resolveEntityManager(requestingBeanName)).     } else {         // OK, so we need an EntityManagerFactory...         return resolveEntityManagerFactory(requestingBeanName).     } }
false;private;1;9;;private EntityManagerFactory resolveEntityManagerFactory(@Nullable String requestingBeanName) {     // Obtain EntityManagerFactory from JNDI?     EntityManagerFactory emf = getPersistenceUnit(this.unitName).     if (emf == null) {         // Need to search for EntityManagerFactory beans.         emf = findEntityManagerFactory(this.unitName, requestingBeanName).     }     return emf. }
false;private;1;27;;private EntityManager resolveEntityManager(@Nullable String requestingBeanName) {     // Obtain EntityManager reference from JNDI?     EntityManager em = getPersistenceContext(this.unitName, false).     if (em == null) {         // No pre-built EntityManager found -> build one based on factory.         // Obtain EntityManagerFactory from JNDI?         EntityManagerFactory emf = getPersistenceUnit(this.unitName).         if (emf == null) {             // Need to search for EntityManagerFactory beans.             emf = findEntityManagerFactory(this.unitName, requestingBeanName).         }         // Inject a shared transactional EntityManager proxy.         if (emf instanceof EntityManagerFactoryInfo && ((EntityManagerFactoryInfo) emf).getEntityManagerInterface() != null) {             // Create EntityManager based on the info's vendor-specific type             // (which might be more specific than the field's type).             em = SharedEntityManagerCreator.createSharedEntityManager(emf, this.properties, this.synchronizedWithTransaction).         } else {             // Create EntityManager based on the field's type.             em = SharedEntityManagerCreator.createSharedEntityManager(emf, this.properties, this.synchronizedWithTransaction, getResourceType()).         }     }     return em. }
false;private;2;21;;private EntityManager resolveExtendedEntityManager(Object target, @Nullable String requestingBeanName) {     // Obtain EntityManager reference from JNDI?     EntityManager em = getPersistenceContext(this.unitName, true).     if (em == null) {         // No pre-built EntityManager found -> build one based on factory.         // Obtain EntityManagerFactory from JNDI?         EntityManagerFactory emf = getPersistenceUnit(this.unitName).         if (emf == null) {             // Need to search for EntityManagerFactory beans.             emf = findEntityManagerFactory(this.unitName, requestingBeanName).         }         // Inject a container-managed extended EntityManager.         em = ExtendedEntityManagerCreator.createContainerManagedEntityManager(emf, this.properties, this.synchronizedWithTransaction).     }     if (em instanceof EntityManagerProxy && beanFactory != null && requestingBeanName != null && beanFactory.containsBean(requestingBeanName) && !beanFactory.isPrototype(requestingBeanName)) {         extendedEntityManagersToClose.put(target, ((EntityManagerProxy) em).getTargetEntityManager()).     }     return em. }
