commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the bean name of the SessionFactory to fetch from Spring's  * root application context. Default is "sessionFactory".  * @see #DEFAULT_SESSION_FACTORY_BEAN_NAME  */ ;/**  * Set the bean name of the SessionFactory to fetch from Spring's  * root application context. Default is "sessionFactory".  * @see #DEFAULT_SESSION_FACTORY_BEAN_NAME  */ public void setSessionFactoryBeanName(String sessionFactoryBeanName) {     this.sessionFactoryBeanName = sessionFactoryBeanName. }
true;protected;0;3;/**  * Return the bean name of the SessionFactory to fetch from Spring's  * root application context.  */ ;/**  * Return the bean name of the SessionFactory to fetch from Spring's  * root application context.  */ protected String getSessionFactoryBeanName() {     return this.sessionFactoryBeanName. }
true;protected;0;4;/**  * Returns "false" so that the filter may re-bind the opened Hibernate  * {@code Session} to each asynchronously dispatched thread and postpone  * closing it until the very last asynchronous dispatch.  */ ;/**  * Returns "false" so that the filter may re-bind the opened Hibernate  * {@code Session} to each asynchronously dispatched thread and postpone  * closing it until the very last asynchronous dispatch.  */ @Override protected boolean shouldNotFilterAsyncDispatch() {     return false. }
true;protected;0;4;/**  * Returns "false" so that the filter may provide a Hibernate  * {@code Session} to each error dispatches.  */ ;/**  * Returns "false" so that the filter may provide a Hibernate  * {@code Session} to each error dispatches.  */ @Override protected boolean shouldNotFilterErrorDispatch() {     return false. }
false;protected;3;44;;@Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {     SessionFactory sessionFactory = lookupSessionFactory(request).     boolean participate = false.     WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request).     String key = getAlreadyFilteredAttributeName().     if (TransactionSynchronizationManager.hasResource(sessionFactory)) {         // Do not modify the Session: just set the participate flag.         participate = true.     } else {         boolean isFirstRequest = !isAsyncDispatch(request).         if (isFirstRequest || !applySessionBindingInterceptor(asyncManager, key)) {             logger.debug("Opening Hibernate Session in OpenSessionInViewFilter").             Session session = openSession(sessionFactory).             SessionHolder sessionHolder = new SessionHolder(session).             TransactionSynchronizationManager.bindResource(sessionFactory, sessionHolder).             AsyncRequestInterceptor interceptor = new AsyncRequestInterceptor(sessionFactory, sessionHolder).             asyncManager.registerCallableInterceptor(key, interceptor).             asyncManager.registerDeferredResultInterceptor(key, interceptor).         }     }     try {         filterChain.doFilter(request, response).     } finally {         if (!participate) {             SessionHolder sessionHolder = (SessionHolder) TransactionSynchronizationManager.unbindResource(sessionFactory).             if (!isAsyncStarted(request)) {                 logger.debug("Closing Hibernate Session in OpenSessionInViewFilter").                 SessionFactoryUtils.closeSession(sessionHolder.getSession()).             }         }     } }
true;protected;1;3;/**  * Look up the SessionFactory that this filter should use,  * taking the current HTTP request as argument.  * <p>The default implementation delegates to the {@link #lookupSessionFactory()}  * variant without arguments.  * @param request the current request  * @return the SessionFactory to use  */ ;/**  * Look up the SessionFactory that this filter should use,  * taking the current HTTP request as argument.  * <p>The default implementation delegates to the {@link #lookupSessionFactory()}  * variant without arguments.  * @param request the current request  * @return the SessionFactory to use  */ protected SessionFactory lookupSessionFactory(HttpServletRequest request) {     return lookupSessionFactory(). }
true;protected;0;7;/**  * Look up the SessionFactory that this filter should use.  * <p>The default implementation looks for a bean with the specified name  * in Spring's root application context.  * @return the SessionFactory to use  * @see #getSessionFactoryBeanName  */ ;/**  * Look up the SessionFactory that this filter should use.  * <p>The default implementation looks for a bean with the specified name  * in Spring's root application context.  * @return the SessionFactory to use  * @see #getSessionFactoryBeanName  */ protected SessionFactory lookupSessionFactory() {     if (logger.isDebugEnabled()) {         logger.debug("Using SessionFactory '" + getSessionFactoryBeanName() + "' for OpenSessionInViewFilter").     }     WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(getServletContext()).     return wac.getBean(getSessionFactoryBeanName(), SessionFactory.class). }
true;protected;1;11;/**  * Open a Session for the SessionFactory that this filter uses.  * <p>The default implementation delegates to the {@link SessionFactory#openSession}  * method and sets the {@link Session}'s flush mode to "MANUAL".  * @param sessionFactory the SessionFactory that this filter uses  * @return the Session to use  * @throws DataAccessResourceFailureException if the Session could not be created  * @see FlushMode#MANUAL  */ ;/**  * Open a Session for the SessionFactory that this filter uses.  * <p>The default implementation delegates to the {@link SessionFactory#openSession}  * method and sets the {@link Session}'s flush mode to "MANUAL".  * @param sessionFactory the SessionFactory that this filter uses  * @return the Session to use  * @throws DataAccessResourceFailureException if the Session could not be created  * @see FlushMode#MANUAL  */ @SuppressWarnings("deprecation") protected Session openSession(SessionFactory sessionFactory) throws DataAccessResourceFailureException {     try {         Session session = sessionFactory.openSession().         session.setFlushMode(FlushMode.MANUAL).         return session.     } catch (HibernateException ex) {         throw new DataAccessResourceFailureException("Could not open Hibernate Session", ex).     } }
false;private;2;8;;private boolean applySessionBindingInterceptor(WebAsyncManager asyncManager, String key) {     CallableProcessingInterceptor cpi = asyncManager.getCallableInterceptor(key).     if (cpi == null) {         return false.     }     ((AsyncRequestInterceptor) cpi).bindSession().     return true. }
