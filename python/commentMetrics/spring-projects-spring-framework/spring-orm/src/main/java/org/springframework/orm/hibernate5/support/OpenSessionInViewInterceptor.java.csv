commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the Hibernate SessionFactory that should be used to create Hibernate Sessions.  */ ;/**  * Set the Hibernate SessionFactory that should be used to create Hibernate Sessions.  */ public void setSessionFactory(@Nullable SessionFactory sessionFactory) {     this.sessionFactory = sessionFactory. }
true;public;0;4;/**  * Return the Hibernate SessionFactory that should be used to create Hibernate Sessions.  */ ;/**  * Return the Hibernate SessionFactory that should be used to create Hibernate Sessions.  */ @Nullable public SessionFactory getSessionFactory() {     return this.sessionFactory. }
false;private;0;5;;private SessionFactory obtainSessionFactory() {     SessionFactory sf = getSessionFactory().     Assert.state(sf != null, "No SessionFactory set").     return sf. }
true;public;1;26;/**  * Open a new Hibernate {@code Session} according and bind it to the thread via the  * {@link TransactionSynchronizationManager}.  */ ;/**  * Open a new Hibernate {@code Session} according and bind it to the thread via the  * {@link TransactionSynchronizationManager}.  */ @Override public void preHandle(WebRequest request) throws DataAccessException {     String key = getParticipateAttributeName().     WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request).     if (asyncManager.hasConcurrentResult() && applySessionBindingInterceptor(asyncManager, key)) {         return.     }     if (TransactionSynchronizationManager.hasResource(obtainSessionFactory())) {         // Do not modify the Session: just mark the request accordingly.         Integer count = (Integer) request.getAttribute(key, WebRequest.SCOPE_REQUEST).         int newCount = (count != null ? count + 1 : 1).         request.setAttribute(getParticipateAttributeName(), newCount, WebRequest.SCOPE_REQUEST).     } else {         logger.debug("Opening Hibernate Session in OpenSessionInViewInterceptor").         Session session = openSession().         SessionHolder sessionHolder = new SessionHolder(session).         TransactionSynchronizationManager.bindResource(obtainSessionFactory(), sessionHolder).         AsyncRequestInterceptor asyncRequestInterceptor = new AsyncRequestInterceptor(obtainSessionFactory(), sessionHolder).         asyncManager.registerCallableInterceptor(key, asyncRequestInterceptor).         asyncManager.registerDeferredResultInterceptor(key, asyncRequestInterceptor).     } }
false;public;2;3;;@Override public void postHandle(WebRequest request, @Nullable ModelMap model) { }
true;public;2;9;/**  * Unbind the Hibernate {@code Session} from the thread and close it).  * @see TransactionSynchronizationManager  */ ;/**  * Unbind the Hibernate {@code Session} from the thread and close it).  * @see TransactionSynchronizationManager  */ @Override public void afterCompletion(WebRequest request, @Nullable Exception ex) throws DataAccessException {     if (!decrementParticipateCount(request)) {         SessionHolder sessionHolder = (SessionHolder) TransactionSynchronizationManager.unbindResource(obtainSessionFactory()).         logger.debug("Closing Hibernate Session in OpenSessionInViewInterceptor").         SessionFactoryUtils.closeSession(sessionHolder.getSession()).     } }
false;private;1;15;;private boolean decrementParticipateCount(WebRequest request) {     String participateAttributeName = getParticipateAttributeName().     Integer count = (Integer) request.getAttribute(participateAttributeName, WebRequest.SCOPE_REQUEST).     if (count == null) {         return false.     }     // Do not modify the Session: just clear the marker.     if (count > 1) {         request.setAttribute(participateAttributeName, count - 1, WebRequest.SCOPE_REQUEST).     } else {         request.removeAttribute(participateAttributeName, WebRequest.SCOPE_REQUEST).     }     return true. }
false;public;1;6;;@Override public void afterConcurrentHandlingStarted(WebRequest request) {     if (!decrementParticipateCount(request)) {         TransactionSynchronizationManager.unbindResource(obtainSessionFactory()).     } }
true;protected;0;11;/**  * Open a Session for the SessionFactory that this interceptor uses.  * <p>The default implementation delegates to the {@link SessionFactory#openSession}  * method and sets the {@link Session}'s flush mode to "MANUAL".  * @return the Session to use  * @throws DataAccessResourceFailureException if the Session could not be created  * @see FlushMode#MANUAL  */ ;/**  * Open a Session for the SessionFactory that this interceptor uses.  * <p>The default implementation delegates to the {@link SessionFactory#openSession}  * method and sets the {@link Session}'s flush mode to "MANUAL".  * @return the Session to use  * @throws DataAccessResourceFailureException if the Session could not be created  * @see FlushMode#MANUAL  */ @SuppressWarnings("deprecation") protected Session openSession() throws DataAccessResourceFailureException {     try {         Session session = obtainSessionFactory().openSession().         session.setFlushMode(FlushMode.MANUAL).         return session.     } catch (HibernateException ex) {         throw new DataAccessResourceFailureException("Could not open Hibernate Session", ex).     } }
true;protected;0;3;/**  * Return the name of the request attribute that identifies that a request is  * already intercepted.  * <p>The default implementation takes the {@code toString()} representation  * of the {@code SessionFactory} instance and appends {@link #PARTICIPATE_SUFFIX}.  */ ;/**  * Return the name of the request attribute that identifies that a request is  * already intercepted.  * <p>The default implementation takes the {@code toString()} representation  * of the {@code SessionFactory} instance and appends {@link #PARTICIPATE_SUFFIX}.  */ protected String getParticipateAttributeName() {     return obtainSessionFactory().toString() + PARTICIPATE_SUFFIX. }
false;private;2;8;;private boolean applySessionBindingInterceptor(WebAsyncManager asyncManager, String key) {     CallableProcessingInterceptor cpi = asyncManager.getCallableInterceptor(key).     if (cpi == null) {         return false.     }     ((AsyncRequestInterceptor) cpi).bindSession().     return true. }
