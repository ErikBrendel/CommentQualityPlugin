commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the Hibernate SessionFactory that should be used to create  * Hibernate Sessions.  */ ;/**  * Set the Hibernate SessionFactory that should be used to create  * Hibernate Sessions.  */ public void setSessionFactory(@Nullable SessionFactory sessionFactory) {     this.sessionFactory = sessionFactory. }
true;public;0;4;/**  * Return the Hibernate SessionFactory that should be used to create  * Hibernate Sessions.  */ ;/**  * Return the Hibernate SessionFactory that should be used to create  * Hibernate Sessions.  */ @Nullable public SessionFactory getSessionFactory() {     return this.sessionFactory. }
true;protected,final;0;5;/**  * Obtain the SessionFactory for actual use.  * @return the SessionFactory (never {@code null})  * @throws IllegalStateException in case of no SessionFactory set  * @since 5.0  */ ;/**  * Obtain the SessionFactory for actual use.  * @return the SessionFactory (never {@code null})  * @throws IllegalStateException in case of no SessionFactory set  * @since 5.0  */ protected final SessionFactory obtainSessionFactory() {     SessionFactory sessionFactory = getSessionFactory().     Assert.state(sessionFactory != null, "No SessionFactory set").     return sessionFactory. }
true;public;1;3;/**  * Set one or more names of Hibernate filters to be activated for all  * Sessions that this accessor works with.  * <p>Each of those filters will be enabled at the beginning of each  * operation and correspondingly disabled at the end of the operation.  * This will work for newly opened Sessions as well as for existing  * Sessions (for example, within a transaction).  * @see #enableFilters(Session)  * @see Session#enableFilter(String)  */ ;/**  * Set one or more names of Hibernate filters to be activated for all  * Sessions that this accessor works with.  * <p>Each of those filters will be enabled at the beginning of each  * operation and correspondingly disabled at the end of the operation.  * This will work for newly opened Sessions as well as for existing  * Sessions (for example, within a transaction).  * @see #enableFilters(Session)  * @see Session#enableFilter(String)  */ public void setFilterNames(@Nullable String... filterNames) {     this.filterNames = filterNames. }
true;public;0;4;/**  * Return the names of Hibernate filters to be activated, if any.  */ ;/**  * Return the names of Hibernate filters to be activated, if any.  */ @Nullable public String[] getFilterNames() {     return this.filterNames. }
true;public;1;3;/**  * Set whether to expose the native Hibernate Session to  * HibernateCallback code.  * <p>Default is "false": a Session proxy will be returned, suppressing  * {@code close} calls and automatically applying query cache  * settings and transaction timeouts.  * @see HibernateCallback  * @see Session  * @see #setCacheQueries  * @see #setQueryCacheRegion  * @see #prepareQuery  * @see #prepareCriteria  */ ;/**  * Set whether to expose the native Hibernate Session to  * HibernateCallback code.  * <p>Default is "false": a Session proxy will be returned, suppressing  * {@code close} calls and automatically applying query cache  * settings and transaction timeouts.  * @see HibernateCallback  * @see Session  * @see #setCacheQueries  * @see #setQueryCacheRegion  * @see #prepareQuery  * @see #prepareCriteria  */ public void setExposeNativeSession(boolean exposeNativeSession) {     this.exposeNativeSession = exposeNativeSession. }
true;public;0;3;/**  * Return whether to expose the native Hibernate Session to  * HibernateCallback code, or rather a Session proxy.  */ ;/**  * Return whether to expose the native Hibernate Session to  * HibernateCallback code, or rather a Session proxy.  */ public boolean isExposeNativeSession() {     return this.exposeNativeSession. }
true;public;1;3;/**  * Set whether to check that the Hibernate Session is not in read-only mode  * in case of write operations (save/update/delete).  * <p>Default is "true", for fail-fast behavior when attempting write operations  * within a read-only transaction. Turn this off to allow save/update/delete  * on a Session with flush mode MANUAL.  * @see #checkWriteOperationAllowed  * @see org.springframework.transaction.TransactionDefinition#isReadOnly  */ ;/**  * Set whether to check that the Hibernate Session is not in read-only mode  * in case of write operations (save/update/delete).  * <p>Default is "true", for fail-fast behavior when attempting write operations  * within a read-only transaction. Turn this off to allow save/update/delete  * on a Session with flush mode MANUAL.  * @see #checkWriteOperationAllowed  * @see org.springframework.transaction.TransactionDefinition#isReadOnly  */ public void setCheckWriteOperations(boolean checkWriteOperations) {     this.checkWriteOperations = checkWriteOperations. }
true;public;0;3;/**  * Return whether to check that the Hibernate Session is not in read-only  * mode in case of write operations (save/update/delete).  */ ;/**  * Return whether to check that the Hibernate Session is not in read-only  * mode in case of write operations (save/update/delete).  */ public boolean isCheckWriteOperations() {     return this.checkWriteOperations. }
true;public;1;3;/**  * Set whether to cache all queries executed by this template.  * <p>If this is "true", all Query and Criteria objects created by  * this template will be marked as cacheable (including all  * queries through find methods).  * <p>To specify the query region to be used for queries cached  * by this template, set the "queryCacheRegion" property.  * @see #setQueryCacheRegion  * @see org.hibernate.Query#setCacheable  * @see Criteria#setCacheable  */ ;/**  * Set whether to cache all queries executed by this template.  * <p>If this is "true", all Query and Criteria objects created by  * this template will be marked as cacheable (including all  * queries through find methods).  * <p>To specify the query region to be used for queries cached  * by this template, set the "queryCacheRegion" property.  * @see #setQueryCacheRegion  * @see org.hibernate.Query#setCacheable  * @see Criteria#setCacheable  */ public void setCacheQueries(boolean cacheQueries) {     this.cacheQueries = cacheQueries. }
true;public;0;3;/**  * Return whether to cache all queries executed by this template.  */ ;/**  * Return whether to cache all queries executed by this template.  */ public boolean isCacheQueries() {     return this.cacheQueries. }
true;public;1;3;/**  * Set the name of the cache region for queries executed by this template.  * <p>If this is specified, it will be applied to all Query and Criteria objects  * created by this template (including all queries through find methods).  * <p>The cache region will not take effect unless queries created by this  * template are configured to be cached via the "cacheQueries" property.  * @see #setCacheQueries  * @see org.hibernate.Query#setCacheRegion  * @see Criteria#setCacheRegion  */ ;/**  * Set the name of the cache region for queries executed by this template.  * <p>If this is specified, it will be applied to all Query and Criteria objects  * created by this template (including all queries through find methods).  * <p>The cache region will not take effect unless queries created by this  * template are configured to be cached via the "cacheQueries" property.  * @see #setCacheQueries  * @see org.hibernate.Query#setCacheRegion  * @see Criteria#setCacheRegion  */ public void setQueryCacheRegion(@Nullable String queryCacheRegion) {     this.queryCacheRegion = queryCacheRegion. }
true;public;0;4;/**  * Return the name of the cache region for queries executed by this template.  */ ;/**  * Return the name of the cache region for queries executed by this template.  */ @Nullable public String getQueryCacheRegion() {     return this.queryCacheRegion. }
true;public;1;3;/**  * Set the fetch size for this HibernateTemplate. This is important for processing  * large result sets: Setting this higher than the default value will increase  * processing speed at the cost of memory consumption. setting this lower can  * avoid transferring row data that will never be read by the application.  * <p>Default is 0, indicating to use the JDBC driver's default.  */ ;/**  * Set the fetch size for this HibernateTemplate. This is important for processing  * large result sets: Setting this higher than the default value will increase  * processing speed at the cost of memory consumption. setting this lower can  * avoid transferring row data that will never be read by the application.  * <p>Default is 0, indicating to use the JDBC driver's default.  */ public void setFetchSize(int fetchSize) {     this.fetchSize = fetchSize. }
true;public;0;3;/**  * Return the fetch size specified for this HibernateTemplate.  */ ;/**  * Return the fetch size specified for this HibernateTemplate.  */ public int getFetchSize() {     return this.fetchSize. }
true;public;1;3;/**  * Set the maximum number of rows for this HibernateTemplate. This is important  * for processing subsets of large result sets, avoiding to read and hold  * the entire result set in the database or in the JDBC driver if we're  * never interested in the entire result in the first place (for example,  * when performing searches that might return a large number of matches).  * <p>Default is 0, indicating to use the JDBC driver's default.  */ ;/**  * Set the maximum number of rows for this HibernateTemplate. This is important  * for processing subsets of large result sets, avoiding to read and hold  * the entire result set in the database or in the JDBC driver if we're  * never interested in the entire result in the first place (for example,  * when performing searches that might return a large number of matches).  * <p>Default is 0, indicating to use the JDBC driver's default.  */ public void setMaxResults(int maxResults) {     this.maxResults = maxResults. }
true;public;0;3;/**  * Return the maximum number of rows specified for this HibernateTemplate.  */ ;/**  * Return the maximum number of rows specified for this HibernateTemplate.  */ public int getMaxResults() {     return this.maxResults. }
false;public;0;6;;@Override public void afterPropertiesSet() {     if (getSessionFactory() == null) {         throw new IllegalArgumentException("Property 'sessionFactory' is required").     } }
false;public;1;5;;@Override @Nullable public <T> T execute(HibernateCallback<T> action) throws DataAccessException {     return doExecute(action, false). }
true;public;1;4;/**  * Execute the action specified by the given action object within a  * native {@link Session}.  * <p>This execute variant overrides the template-wide  * {@link #isExposeNativeSession() "exposeNativeSession"} setting.  * @param action callback object that specifies the Hibernate action  * @return a result object returned by the action, or {@code null}  * @throws DataAccessException in case of Hibernate errors  */ ;/**  * Execute the action specified by the given action object within a  * native {@link Session}.  * <p>This execute variant overrides the template-wide  * {@link #isExposeNativeSession() "exposeNativeSession"} setting.  * @param action callback object that specifies the Hibernate action  * @return a result object returned by the action, or {@code null}  * @throws DataAccessException in case of Hibernate errors  */ @Nullable public <T> T executeWithNativeSession(HibernateCallback<T> action) {     return doExecute(action, true). }
true;protected;2;47;/**  * Execute the action specified by the given action object within a Session.  * @param action callback object that specifies the Hibernate action  * @param enforceNativeSession whether to enforce exposure of the native  * Hibernate Session to callback code  * @return a result object returned by the action, or {@code null}  * @throws DataAccessException in case of Hibernate errors  */ ;/**  * Execute the action specified by the given action object within a Session.  * @param action callback object that specifies the Hibernate action  * @param enforceNativeSession whether to enforce exposure of the native  * Hibernate Session to callback code  * @return a result object returned by the action, or {@code null}  * @throws DataAccessException in case of Hibernate errors  */ @SuppressWarnings("deprecation") @Nullable protected <T> T doExecute(HibernateCallback<T> action, boolean enforceNativeSession) throws DataAccessException {     Assert.notNull(action, "Callback object must not be null").     Session session = null.     boolean isNew = false.     try {         session = obtainSessionFactory().getCurrentSession().     } catch (HibernateException ex) {         logger.debug("Could not retrieve pre-bound Hibernate session", ex).     }     if (session == null) {         session = obtainSessionFactory().openSession().         session.setFlushMode(FlushMode.MANUAL).         isNew = true.     }     try {         enableFilters(session).         Session sessionToExpose = (enforceNativeSession || isExposeNativeSession() ? session : createSessionProxy(session)).         return action.doInHibernate(sessionToExpose).     } catch (HibernateException ex) {         throw SessionFactoryUtils.convertHibernateAccessException(ex).     } catch (PersistenceException ex) {         if (ex.getCause() instanceof HibernateException) {             throw SessionFactoryUtils.convertHibernateAccessException((HibernateException) ex.getCause()).         }         throw ex.     } catch (RuntimeException ex) {         // Callback code threw application exception...         throw ex.     } finally {         if (isNew) {             SessionFactoryUtils.closeSession(session).         } else {             disableFilters(session).         }     } }
true;protected;1;5;/**  * Create a close-suppressing proxy for the given Hibernate Session.  * The proxy also prepares returned Query and Criteria objects.  * @param session the Hibernate Session to create a proxy for  * @return the Session proxy  * @see Session#close()  * @see #prepareQuery  * @see #prepareCriteria  */ ;/**  * Create a close-suppressing proxy for the given Hibernate Session.  * The proxy also prepares returned Query and Criteria objects.  * @param session the Hibernate Session to create a proxy for  * @return the Session proxy  * @see Session#close()  * @see #prepareQuery  * @see #prepareCriteria  */ protected Session createSessionProxy(Session session) {     return (Session) Proxy.newProxyInstance(session.getClass().getClassLoader(), new Class<?>[] { Session.class }, new CloseSuppressingInvocationHandler(session)). }
true;protected;1;8;/**  * Enable the specified filters on the given Session.  * @param session the current Hibernate Session  * @see #setFilterNames  * @see Session#enableFilter(String)  */ ;/**  * Enable the specified filters on the given Session.  * @param session the current Hibernate Session  * @see #setFilterNames  * @see Session#enableFilter(String)  */ protected void enableFilters(Session session) {     String[] filterNames = getFilterNames().     if (filterNames != null) {         for (String filterName : filterNames) {             session.enableFilter(filterName).         }     } }
true;protected;1;8;/**  * Disable the specified filters on the given Session.  * @param session the current Hibernate Session  * @see #setFilterNames  * @see Session#disableFilter(String)  */ ;/**  * Disable the specified filters on the given Session.  * @param session the current Hibernate Session  * @see #setFilterNames  * @see Session#disableFilter(String)  */ protected void disableFilters(Session session) {     String[] filterNames = getFilterNames().     if (filterNames != null) {         for (String filterName : filterNames) {             session.disableFilter(filterName).         }     } }
false;public;2;5;;// ------------------------------------------------------------------------- // Convenience methods for loading individual objects // ------------------------------------------------------------------------- @Override @Nullable public <T> T get(Class<T> entityClass, Serializable id) throws DataAccessException {     return get(entityClass, id, null). }
false;public;3;14;;@Override @Nullable public <T> T get(final Class<T> entityClass, final Serializable id, @Nullable final LockMode lockMode) throws DataAccessException {     return executeWithNativeSession(session -> {         if (lockMode != null) {             return session.get(entityClass, id, new LockOptions(lockMode)).         } else {             return session.get(entityClass, id).         }     }). }
false;public;2;5;;@Override @Nullable public Object get(String entityName, Serializable id) throws DataAccessException {     return get(entityName, id, null). }
false;public;3;14;;@Override @Nullable public Object get(final String entityName, final Serializable id, @Nullable final LockMode lockMode) throws DataAccessException {     return executeWithNativeSession(session -> {         if (lockMode != null) {             return session.get(entityName, id, new LockOptions(lockMode)).         } else {             return session.get(entityName, id).         }     }). }
false;public;2;4;;@Override public <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException {     return load(entityClass, id, null). }
false;public;3;13;;@Override public <T> T load(final Class<T> entityClass, final Serializable id, @Nullable final LockMode lockMode) throws DataAccessException {     return nonNull(executeWithNativeSession(session -> {         if (lockMode != null) {             return session.load(entityClass, id, new LockOptions(lockMode)).         } else {             return session.load(entityClass, id).         }     })). }
false;public;2;4;;@Override public Object load(String entityName, Serializable id) throws DataAccessException {     return load(entityName, id, null). }
false;public;3;13;;@Override public Object load(final String entityName, final Serializable id, @Nullable final LockMode lockMode) throws DataAccessException {     return nonNull(executeWithNativeSession(session -> {         if (lockMode != null) {             return session.load(entityName, id, new LockOptions(lockMode)).         } else {             return session.load(entityName, id).         }     })). }
false;public;1;10;;@Override @SuppressWarnings({ "unchecked", "deprecation" }) public <T> List<T> loadAll(final Class<T> entityClass) throws DataAccessException {     return nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {         Criteria criteria = session.createCriteria(entityClass).         criteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY).         prepareCriteria(criteria).         return criteria.list().     })). }
false;public;2;8;;@Override @SuppressWarnings({ "deprecation" }) public void load(final Object entity, final Serializable id) throws DataAccessException {     executeWithNativeSession(session -> {         session.load(entity, id).         return null.     }). }
false;public;1;4;;@Override public void refresh(final Object entity) throws DataAccessException {     refresh(entity, null). }
false;public;2;12;;@Override public void refresh(final Object entity, @Nullable final LockMode lockMode) throws DataAccessException {     executeWithNativeSession(session -> {         if (lockMode != null) {             session.refresh(entity, new LockOptions(lockMode)).         } else {             session.refresh(entity).         }         return null.     }). }
false;public;1;6;;@Override public boolean contains(final Object entity) throws DataAccessException {     Boolean result = executeWithNativeSession(session -> session.contains(entity)).     Assert.state(result != null, "No contains result").     return result. }
false;public;1;7;;@Override public void evict(final Object entity) throws DataAccessException {     executeWithNativeSession(session -> {         session.evict(entity).         return null.     }). }
false;public;1;9;;@Override public void initialize(Object proxy) throws DataAccessException {     try {         Hibernate.initialize(proxy).     } catch (HibernateException ex) {         throw SessionFactoryUtils.convertHibernateAccessException(ex).     } }
false;public;1;9;;@Override public Filter enableFilter(String filterName) throws IllegalStateException {     Session session = obtainSessionFactory().getCurrentSession().     Filter filter = session.getEnabledFilter(filterName).     if (filter == null) {         filter = session.enableFilter(filterName).     }     return filter. }
false;public;2;7;;// ------------------------------------------------------------------------- // Convenience methods for storing individual objects // ------------------------------------------------------------------------- @Override public void lock(final Object entity, final LockMode lockMode) throws DataAccessException {     executeWithNativeSession(session -> {         session.buildLockRequest(new LockOptions(lockMode)).lock(entity).         return null.     }). }
false;public;3;9;;@Override public void lock(final String entityName, final Object entity, final LockMode lockMode) throws DataAccessException {     executeWithNativeSession(session -> {         session.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity).         return null.     }). }
false;public;1;7;;@Override public Serializable save(final Object entity) throws DataAccessException {     return nonNull(executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         return session.save(entity).     })). }
false;public;2;7;;@Override public Serializable save(final String entityName, final Object entity) throws DataAccessException {     return nonNull(executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         return session.save(entityName, entity).     })). }
false;public;1;4;;@Override public void update(Object entity) throws DataAccessException {     update(entity, null). }
false;public;2;11;;@Override public void update(final Object entity, @Nullable final LockMode lockMode) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         session.update(entity).         if (lockMode != null) {             session.buildLockRequest(new LockOptions(lockMode)).lock(entity).         }         return null.     }). }
false;public;2;4;;@Override public void update(String entityName, Object entity) throws DataAccessException {     update(entityName, entity, null). }
false;public;3;13;;@Override public void update(final String entityName, final Object entity, @Nullable final LockMode lockMode) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         session.update(entityName, entity).         if (lockMode != null) {             session.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity).         }         return null.     }). }
false;public;1;8;;@Override public void saveOrUpdate(final Object entity) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         session.saveOrUpdate(entity).         return null.     }). }
false;public;2;8;;@Override public void saveOrUpdate(final String entityName, final Object entity) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         session.saveOrUpdate(entityName, entity).         return null.     }). }
false;public;2;10;;@Override public void replicate(final Object entity, final ReplicationMode replicationMode) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         session.replicate(entity, replicationMode).         return null.     }). }
false;public;3;10;;@Override public void replicate(final String entityName, final Object entity, final ReplicationMode replicationMode) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         session.replicate(entityName, entity, replicationMode).         return null.     }). }
false;public;1;8;;@Override public void persist(final Object entity) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         session.persist(entity).         return null.     }). }
false;public;2;8;;@Override public void persist(final String entityName, final Object entity) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         session.persist(entityName, entity).         return null.     }). }
false;public;1;8;;@Override @SuppressWarnings("unchecked") public <T> T merge(final T entity) throws DataAccessException {     return nonNull(executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         return (T) session.merge(entity).     })). }
false;public;2;8;;@Override @SuppressWarnings("unchecked") public <T> T merge(final String entityName, final T entity) throws DataAccessException {     return nonNull(executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         return (T) session.merge(entityName, entity).     })). }
false;public;1;4;;@Override public void delete(Object entity) throws DataAccessException {     delete(entity, null). }
false;public;2;11;;@Override public void delete(final Object entity, @Nullable final LockMode lockMode) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         if (lockMode != null) {             session.buildLockRequest(new LockOptions(lockMode)).lock(entity).         }         session.delete(entity).         return null.     }). }
false;public;2;4;;@Override public void delete(String entityName, Object entity) throws DataAccessException {     delete(entityName, entity, null). }
false;public;3;13;;@Override public void delete(final String entityName, final Object entity, @Nullable final LockMode lockMode) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         if (lockMode != null) {             session.buildLockRequest(new LockOptions(lockMode)).lock(entityName, entity).         }         session.delete(entityName, entity).         return null.     }). }
false;public;1;10;;@Override public void deleteAll(final Collection<?> entities) throws DataAccessException {     executeWithNativeSession(session -> {         checkWriteOperationAllowed(session).         for (Object entity : entities) {             session.delete(entity).         }         return null.     }). }
false;public;0;7;;@Override public void flush() throws DataAccessException {     executeWithNativeSession(session -> {         session.flush().         return null.     }). }
false;public;0;7;;@Override public void clear() throws DataAccessException {     executeWithNativeSession(session -> {         session.clear().         return null.     }). }
false;public;1;4;;// ------------------------------------------------------------------------- // Convenience finder methods for detached criteria // ------------------------------------------------------------------------- @Override public List<?> findByCriteria(DetachedCriteria criteria) throws DataAccessException {     return findByCriteria(criteria, -1, -1). }
false;public;3;18;;@Override @SuppressWarnings("unchecked") public List<?> findByCriteria(final DetachedCriteria criteria, final int firstResult, final int maxResults) throws DataAccessException {     Assert.notNull(criteria, "DetachedCriteria must not be null").     return nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {         Criteria executableCriteria = criteria.getExecutableCriteria(session).         prepareCriteria(executableCriteria).         if (firstResult >= 0) {             executableCriteria.setFirstResult(firstResult).         }         if (maxResults > 0) {             executableCriteria.setMaxResults(maxResults).         }         return executableCriteria.list().     })). }
false;public;1;4;;@Override public <T> List<T> findByExample(T exampleEntity) throws DataAccessException {     return findByExample(null, exampleEntity, -1, -1). }
false;public;2;4;;@Override public <T> List<T> findByExample(String entityName, T exampleEntity) throws DataAccessException {     return findByExample(entityName, exampleEntity, -1, -1). }
false;public;3;4;;@Override public <T> List<T> findByExample(T exampleEntity, int firstResult, int maxResults) throws DataAccessException {     return findByExample(null, exampleEntity, firstResult, maxResults). }
false;public;4;21;;@Override @SuppressWarnings({ "unchecked", "deprecation" }) public <T> List<T> findByExample(@Nullable final String entityName, final T exampleEntity, final int firstResult, final int maxResults) throws DataAccessException {     Assert.notNull(exampleEntity, "Example entity must not be null").     return nonNull(executeWithNativeSession((HibernateCallback<List<T>>) session -> {         Criteria executableCriteria = (entityName != null ? session.createCriteria(entityName) : session.createCriteria(exampleEntity.getClass())).         executableCriteria.add(Example.create(exampleEntity)).         prepareCriteria(executableCriteria).         if (firstResult >= 0) {             executableCriteria.setFirstResult(firstResult).         }         if (maxResults > 0) {             executableCriteria.setMaxResults(maxResults).         }         return executableCriteria.list().     })). }
false;public;2;16;;// ------------------------------------------------------------------------- // Convenience finder methods for HQL strings // ------------------------------------------------------------------------- @Deprecated @Override @SuppressWarnings({ "rawtypes", "unchecked", "deprecation" }) public List<?> find(final String queryString, @Nullable final Object... values) throws DataAccessException {     return nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {         org.hibernate.Query queryObject = queryObject(ReflectionUtils.invokeMethod(createQueryMethod, session, queryString)).         prepareQuery(queryObject).         if (values != null) {             for (int i = 0. i < values.length. i++) {                 queryObject.setParameter(i, values[i]).             }         }         return queryObject.list().     })). }
false;public;3;7;;@Deprecated @Override public List<?> findByNamedParam(String queryString, String paramName, Object value) throws DataAccessException {     return findByNamedParam(queryString, new String[] { paramName }, new Object[] { value }). }
false;public;3;19;;@Deprecated @Override @SuppressWarnings({ "rawtypes", "unchecked", "deprecation" }) public List<?> findByNamedParam(final String queryString, final String[] paramNames, final Object[] values) throws DataAccessException {     if (paramNames.length != values.length) {         throw new IllegalArgumentException("Length of paramNames array must match length of values array").     }     return nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {         org.hibernate.Query queryObject = queryObject(ReflectionUtils.invokeMethod(createQueryMethod, session, queryString)).         prepareQuery(queryObject).         for (int i = 0. i < values.length. i++) {             applyNamedParameterToQuery(queryObject, paramNames[i], values[i]).         }         return queryObject.list().     })). }
false;public;2;14;;@Deprecated @Override @SuppressWarnings({ "rawtypes", "unchecked", "deprecation" }) public List<?> findByValueBean(final String queryString, final Object valueBean) throws DataAccessException {     return nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {         org.hibernate.Query queryObject = queryObject(ReflectionUtils.invokeMethod(createQueryMethod, session, queryString)).         prepareQuery(queryObject).         queryObject.setProperties(valueBean).         return queryObject.list().     })). }
false;public;2;16;;// ------------------------------------------------------------------------- // Convenience finder methods for named queries // ------------------------------------------------------------------------- @Deprecated @Override @SuppressWarnings({ "rawtypes", "unchecked", "deprecation" }) public List<?> findByNamedQuery(final String queryName, @Nullable final Object... values) throws DataAccessException {     return nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {         org.hibernate.Query queryObject = queryObject(ReflectionUtils.invokeMethod(getNamedQueryMethod, session, queryName)).         prepareQuery(queryObject).         if (values != null) {             for (int i = 0. i < values.length. i++) {                 queryObject.setParameter(i, values[i]).             }         }         return queryObject.list().     })). }
false;public;3;7;;@Deprecated @Override public List<?> findByNamedQueryAndNamedParam(String queryName, String paramName, Object value) throws DataAccessException {     return findByNamedQueryAndNamedParam(queryName, new String[] { paramName }, new Object[] { value }). }
false;public;3;22;;@Deprecated @Override @SuppressWarnings({ "rawtypes", "unchecked", "deprecation" }) public List<?> findByNamedQueryAndNamedParam(final String queryName, @Nullable final String[] paramNames, @Nullable final Object[] values) throws DataAccessException {     if (values != null && (paramNames == null || paramNames.length != values.length)) {         throw new IllegalArgumentException("Length of paramNames array must match length of values array").     }     return nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {         org.hibernate.Query queryObject = (org.hibernate.Query) nonNull(ReflectionUtils.invokeMethod(getNamedQueryMethod, session, queryName)).         prepareQuery(queryObject).         if (values != null) {             for (int i = 0. i < values.length. i++) {                 applyNamedParameterToQuery(queryObject, paramNames[i], values[i]).             }         }         return queryObject.list().     })). }
false;public;2;14;;@Deprecated @Override @SuppressWarnings({ "rawtypes", "unchecked", "deprecation" }) public List<?> findByNamedQueryAndValueBean(final String queryName, final Object valueBean) throws DataAccessException {     return nonNull(executeWithNativeSession((HibernateCallback<List<?>>) session -> {         org.hibernate.Query queryObject = queryObject(ReflectionUtils.invokeMethod(getNamedQueryMethod, session, queryName)).         prepareQuery(queryObject).         queryObject.setProperties(valueBean).         return queryObject.list().     })). }
false;public;2;16;;// ------------------------------------------------------------------------- // Convenience query methods for iteration and bulk updates/deletes // ------------------------------------------------------------------------- @Deprecated @Override @SuppressWarnings({ "rawtypes", "deprecation" }) public Iterator<?> iterate(final String queryString, @Nullable final Object... values) throws DataAccessException {     return nonNull(executeWithNativeSession((HibernateCallback<Iterator<?>>) session -> {         org.hibernate.Query queryObject = queryObject(ReflectionUtils.invokeMethod(createQueryMethod, session, queryString)).         prepareQuery(queryObject).         if (values != null) {             for (int i = 0. i < values.length. i++) {                 queryObject.setParameter(i, values[i]).             }         }         return queryObject.iterate().     })). }
false;public;1;10;;@Deprecated @Override public void closeIterator(Iterator<?> it) throws DataAccessException {     try {         Hibernate.close(it).     } catch (HibernateException ex) {         throw SessionFactoryUtils.convertHibernateAccessException(ex).     } }
false;public;2;18;;@Deprecated @Override @SuppressWarnings({ "rawtypes", "deprecation" }) public int bulkUpdate(final String queryString, @Nullable final Object... values) throws DataAccessException {     Integer result = executeWithNativeSession(session -> {         org.hibernate.Query queryObject = queryObject(ReflectionUtils.invokeMethod(createQueryMethod, session, queryString)).         prepareQuery(queryObject).         if (values != null) {             for (int i = 0. i < values.length. i++) {                 queryObject.setParameter(i, values[i]).             }         }         return queryObject.executeUpdate().     }).     Assert.state(result != null, "No update count").     return result. }
true;protected;1;7;/**  * Check whether write operations are allowed on the given Session.  * <p>Default implementation throws an InvalidDataAccessApiUsageException in  * case of {@code FlushMode.MANUAL}. Can be overridden in subclasses.  * @param session current Hibernate Session  * @throws InvalidDataAccessApiUsageException if write operations are not allowed  * @see #setCheckWriteOperations  * @see Session#getFlushMode()  * @see FlushMode#MANUAL  */ ;// ------------------------------------------------------------------------- // Helper methods used by the operations above // ------------------------------------------------------------------------- /**  * Check whether write operations are allowed on the given Session.  * <p>Default implementation throws an InvalidDataAccessApiUsageException in  * case of {@code FlushMode.MANUAL}. Can be overridden in subclasses.  * @param session current Hibernate Session  * @throws InvalidDataAccessApiUsageException if write operations are not allowed  * @see #setCheckWriteOperations  * @see Session#getFlushMode()  * @see FlushMode#MANUAL  */ protected void checkWriteOperationAllowed(Session session) throws InvalidDataAccessApiUsageException {     if (isCheckWriteOperations() && SessionFactoryUtils.getFlushMode(session).lessThan(FlushMode.COMMIT)) {         throw new InvalidDataAccessApiUsageException("Write operations are not allowed in read-only mode (FlushMode.MANUAL): " + "Turn your Session into FlushMode.COMMIT/AUTO or remove 'readOnly' marker from transaction definition.").     } }
true;protected;1;20;/**  * Prepare the given Criteria object, applying cache settings and/or  * a transaction timeout.  * @param criteria the Criteria object to prepare  * @see #setCacheQueries  * @see #setQueryCacheRegion  */ ;/**  * Prepare the given Criteria object, applying cache settings and/or  * a transaction timeout.  * @param criteria the Criteria object to prepare  * @see #setCacheQueries  * @see #setQueryCacheRegion  */ protected void prepareCriteria(Criteria criteria) {     if (isCacheQueries()) {         criteria.setCacheable(true).         if (getQueryCacheRegion() != null) {             criteria.setCacheRegion(getQueryCacheRegion()).         }     }     if (getFetchSize() > 0) {         criteria.setFetchSize(getFetchSize()).     }     if (getMaxResults() > 0) {         criteria.setMaxResults(getMaxResults()).     }     ResourceHolderSupport sessionHolder = (ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory()).     if (sessionHolder != null && sessionHolder.hasTimeout()) {         criteria.setTimeout(sessionHolder.getTimeToLiveInSeconds()).     } }
true;protected;1;21;/**  * Prepare the given Query object, applying cache settings and/or  * a transaction timeout.  * @param queryObject the Query object to prepare  * @see #setCacheQueries  * @see #setQueryCacheRegion  */ ;/**  * Prepare the given Query object, applying cache settings and/or  * a transaction timeout.  * @param queryObject the Query object to prepare  * @see #setCacheQueries  * @see #setQueryCacheRegion  */ @SuppressWarnings({ "rawtypes", "deprecation" }) protected void prepareQuery(org.hibernate.Query queryObject) {     if (isCacheQueries()) {         queryObject.setCacheable(true).         if (getQueryCacheRegion() != null) {             queryObject.setCacheRegion(getQueryCacheRegion()).         }     }     if (getFetchSize() > 0) {         queryObject.setFetchSize(getFetchSize()).     }     if (getMaxResults() > 0) {         queryObject.setMaxResults(getMaxResults()).     }     ResourceHolderSupport sessionHolder = (ResourceHolderSupport) TransactionSynchronizationManager.getResource(obtainSessionFactory()).     if (sessionHolder != null && sessionHolder.hasTimeout()) {         queryObject.setTimeout(sessionHolder.getTimeToLiveInSeconds()).     } }
true;protected;3;15;/**  * Apply the given name parameter to the given Query object.  * @param queryObject the Query object  * @param paramName the name of the parameter  * @param value the value of the parameter  * @throws HibernateException if thrown by the Query object  */ ;/**  * Apply the given name parameter to the given Query object.  * @param queryObject the Query object  * @param paramName the name of the parameter  * @param value the value of the parameter  * @throws HibernateException if thrown by the Query object  */ @Deprecated @SuppressWarnings({ "rawtypes", "deprecation" }) protected void applyNamedParameterToQuery(org.hibernate.Query queryObject, String paramName, Object value) throws HibernateException {     if (value instanceof Collection) {         queryObject.setParameterList(paramName, (Collection<?>) value).     } else if (value instanceof Object[]) {         queryObject.setParameterList(paramName, (Object[]) value).     } else {         queryObject.setParameter(paramName, value).     } }
false;private,static;1;6;;@Deprecated @SuppressWarnings({ "rawtypes", "deprecation" }) private static org.hibernate.Query queryObject(@Nullable Object result) {     Assert.state(result != null, "No Hibernate Query").     return (org.hibernate.Query) result. }
false;private,static;1;4;;private static <T> T nonNull(@Nullable T result) {     Assert.state(result != null, "No result").     return result. }
false;public;3;38;;@Override @SuppressWarnings({ "rawtypes", "deprecation" }) @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Use hashCode of Session proxy.         return System.identityHashCode(proxy).     } else if (method.getName().equals("close")) {         // Handle close method: suppress, not valid.         return null.     }     // Invoke method on target Session.     try {         Object retVal = method.invoke(this.target, args).         // Applies to createQuery, getNamedQuery, createCriteria.         if (retVal instanceof Criteria) {             prepareCriteria(((Criteria) retVal)).         } else if (retVal instanceof org.hibernate.Query) {             prepareQuery(((org.hibernate.Query) retVal)).         }         return retVal.     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
