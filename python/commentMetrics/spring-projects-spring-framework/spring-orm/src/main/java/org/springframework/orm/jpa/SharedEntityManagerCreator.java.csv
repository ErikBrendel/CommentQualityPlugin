commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to delegate to.  * @return a shareable transaction EntityManager proxy  */ ;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to delegate to.  * @return a shareable transaction EntityManager proxy  */ public static EntityManager createSharedEntityManager(EntityManagerFactory emf) {     return createSharedEntityManager(emf, null, true). }
true;public,static;2;3;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to delegate to.  * @param properties the properties to be passed into the  * {@code createEntityManager} call (may be {@code null})  * @return a shareable transaction EntityManager proxy  */ ;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to delegate to.  * @param properties the properties to be passed into the  * {@code createEntityManager} call (may be {@code null})  * @return a shareable transaction EntityManager proxy  */ public static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties) {     return createSharedEntityManager(emf, properties, true). }
true;public,static;3;8;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to delegate to.  * @param properties the properties to be passed into the  * {@code createEntityManager} call (may be {@code null})  * @param synchronizedWithTransaction whether to automatically join ongoing  * transactions (according to the JPA 2.1 SynchronizationType rules)  * @return a shareable transaction EntityManager proxy  * @since 4.0  */ ;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to delegate to.  * @param properties the properties to be passed into the  * {@code createEntityManager} call (may be {@code null})  * @param synchronizedWithTransaction whether to automatically join ongoing  * transactions (according to the JPA 2.1 SynchronizationType rules)  * @return a shareable transaction EntityManager proxy  * @since 4.0  */ public static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction) {     Class<?> emIfc = (emf instanceof EntityManagerFactoryInfo ? ((EntityManagerFactoryInfo) emf).getEntityManagerInterface() : EntityManager.class).     return createSharedEntityManager(emf, properties, synchronizedWithTransaction, (emIfc == null ? NO_ENTITY_MANAGER_INTERFACES : new Class<?>[] { emIfc })). }
true;public,static;3;5;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to obtain EntityManagers from as needed  * @param properties the properties to be passed into the  * {@code createEntityManager} call (may be {@code null})  * @param entityManagerInterfaces the interfaces to be implemented by the  * EntityManager. Allows the addition or specification of proprietary interfaces.  * @return a shareable transactional EntityManager proxy  */ ;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to obtain EntityManagers from as needed  * @param properties the properties to be passed into the  * {@code createEntityManager} call (may be {@code null})  * @param entityManagerInterfaces the interfaces to be implemented by the  * EntityManager. Allows the addition or specification of proprietary interfaces.  * @return a shareable transactional EntityManager proxy  */ public static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, Class<?>... entityManagerInterfaces) {     return createSharedEntityManager(emf, properties, true, entityManagerInterfaces). }
true;public,static;4;14;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to obtain EntityManagers from as needed  * @param properties the properties to be passed into the  * {@code createEntityManager} call (may be {@code null})  * @param synchronizedWithTransaction whether to automatically join ongoing  * transactions (according to the JPA 2.1 SynchronizationType rules)  * @param entityManagerInterfaces the interfaces to be implemented by the  * EntityManager. Allows the addition or specification of proprietary interfaces.  * @return a shareable transactional EntityManager proxy  * @since 4.0  */ ;/**  * Create a transactional EntityManager proxy for the given EntityManagerFactory.  * @param emf the EntityManagerFactory to obtain EntityManagers from as needed  * @param properties the properties to be passed into the  * {@code createEntityManager} call (may be {@code null})  * @param synchronizedWithTransaction whether to automatically join ongoing  * transactions (according to the JPA 2.1 SynchronizationType rules)  * @param entityManagerInterfaces the interfaces to be implemented by the  * EntityManager. Allows the addition or specification of proprietary interfaces.  * @return a shareable transactional EntityManager proxy  * @since 4.0  */ public static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction, Class<?>... entityManagerInterfaces) {     ClassLoader cl = null.     if (emf instanceof EntityManagerFactoryInfo) {         cl = ((EntityManagerFactoryInfo) emf).getBeanClassLoader().     }     Class<?>[] ifcs = new Class<?>[entityManagerInterfaces.length + 1].     System.arraycopy(entityManagerInterfaces, 0, ifcs, 0, entityManagerInterfaces.length).     ifcs[entityManagerInterfaces.length] = EntityManagerProxy.class.     return (EntityManager) Proxy.newProxyInstance((cl != null ? cl : SharedEntityManagerCreator.class.getClassLoader()), ifcs, new SharedEntityManagerInvocationHandler(emf, properties, synchronizedWithTransaction)). }
false;private;0;8;;private void initProxyClassLoader() {     if (this.targetFactory instanceof EntityManagerFactoryInfo) {         this.proxyClassLoader = ((EntityManagerFactoryInfo) this.targetFactory).getBeanClassLoader().     } else {         this.proxyClassLoader = this.targetFactory.getClass().getClassLoader().     } }
false;public;3;120;;@Override @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Use hashCode of EntityManager proxy.         return hashCode().     } else if (method.getName().equals("toString")) {         // Deliver toString without touching a target EntityManager.         return "Shared EntityManager proxy for target factory [" + this.targetFactory + "]".     } else if (method.getName().equals("getEntityManagerFactory")) {         // JPA 2.0: return EntityManagerFactory without creating an EntityManager.         return this.targetFactory.     } else if (method.getName().equals("getCriteriaBuilder") || method.getName().equals("getMetamodel")) {         // JPA 2.0: return EntityManagerFactory's CriteriaBuilder/Metamodel (avoid creation of EntityManager)         try {             return EntityManagerFactory.class.getMethod(method.getName()).invoke(this.targetFactory).         } catch (InvocationTargetException ex) {             throw ex.getTargetException().         }     } else if (method.getName().equals("unwrap")) {         // JPA 2.0: handle unwrap method - could be a proxy match.         Class<?> targetClass = (Class<?>) args[0].         if (targetClass != null && targetClass.isInstance(proxy)) {             return proxy.         }     } else if (method.getName().equals("isOpen")) {         // Handle isOpen method: always return true.         return true.     } else if (method.getName().equals("close")) {         // Handle close method: suppress, not valid.         return null.     } else if (method.getName().equals("getTransaction")) {         throw new IllegalStateException("Not allowed to create transaction on shared EntityManager - " + "use Spring transactions or EJB CMT instead").     }     // Determine current EntityManager: either the transactional one     // managed by the factory or a temporary one for the given invocation.     EntityManager target = EntityManagerFactoryUtils.doGetTransactionalEntityManager(this.targetFactory, this.properties, this.synchronizedWithTransaction).     if (method.getName().equals("getTargetEntityManager")) {         // Handle EntityManagerProxy interface.         if (target == null) {             throw new IllegalStateException("No transactional EntityManager available").         }         return target.     } else if (method.getName().equals("unwrap")) {         Class<?> targetClass = (Class<?>) args[0].         if (targetClass == null) {             return (target != null ? target : proxy).         }         // We need a transactional target now.         if (target == null) {             throw new IllegalStateException("No transactional EntityManager available").         }     // Still perform unwrap call on target EntityManager.     } else if (transactionRequiringMethods.contains(method.getName())) {         // Otherwise, the operation would get accepted but remain unflushed...         if (target == null || (!TransactionSynchronizationManager.isActualTransactionActive() && !target.getTransaction().isActive())) {             throw new TransactionRequiredException("No EntityManager with actual transaction available " + "for current thread - cannot reliably process '" + method.getName() + "' call").         }     }     // Regular EntityManager operations.     boolean isNewEm = false.     if (target == null) {         logger.debug("Creating new EntityManager for shared EntityManager invocation").         target = (!CollectionUtils.isEmpty(this.properties) ? this.targetFactory.createEntityManager(this.properties) : this.targetFactory.createEntityManager()).         isNewEm = true.     }     // Invoke method on current EntityManager.     try {         Object result = method.invoke(target, args).         if (result instanceof Query) {             Query query = (Query) result.             if (isNewEm) {                 Class<?>[] ifcs = ClassUtils.getAllInterfacesForClass(query.getClass(), this.proxyClassLoader).                 result = Proxy.newProxyInstance(this.proxyClassLoader, ifcs, new DeferredQueryInvocationHandler(query, target)).                 isNewEm = false.             } else {                 EntityManagerFactoryUtils.applyTransactionTimeout(query, this.targetFactory).             }         }         return result.     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } finally {         if (isNewEm) {             EntityManagerFactoryUtils.closeEntityManager(target).         }     } }
false;private;1;6;;private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {     // Rely on default serialization, just initialize state after deserialization.     ois.defaultReadObject().     // Initialize transient fields.     initProxyClassLoader(). }
false;public;3;77;;@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Use hashCode of EntityManager proxy.         return hashCode().     } else if (method.getName().equals("unwrap")) {         // Handle JPA 2.0 unwrap method - could be a proxy match.         Class<?> targetClass = (Class<?>) args[0].         if (targetClass == null) {             return this.target.         } else if (targetClass.isInstance(proxy)) {             return proxy.         }     } else if (method.getName().equals("getOutputParameterValue")) {         if (this.entityManager == null) {             Object key = args[0].             if (this.outputParameters == null || !this.outputParameters.containsKey(key)) {                 throw new IllegalArgumentException("OUT/INOUT parameter not available: " + key).             }             Object value = this.outputParameters.get(key).             if (value instanceof IllegalArgumentException) {                 throw (IllegalArgumentException) value.             }             return value.         }     }     // Invoke method on actual Query object.     try {         Object retVal = method.invoke(this.target, args).         if (method.getName().equals("registerStoredProcedureParameter") && args.length == 3 && (args[2] == ParameterMode.OUT || args[2] == ParameterMode.INOUT)) {             if (this.outputParameters == null) {                 this.outputParameters = new LinkedHashMap<>().             }             this.outputParameters.put(args[0], null).         }         return (retVal == this.target ? proxy : retVal).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } finally {         if (queryTerminatingMethods.contains(method.getName())) {             // afterwards, since that was the only reason we kept it open.             if (this.outputParameters != null && this.target instanceof StoredProcedureQuery) {                 StoredProcedureQuery storedProc = (StoredProcedureQuery) this.target.                 for (Map.Entry<Object, Object> entry : this.outputParameters.entrySet()) {                     try {                         Object key = entry.getKey().                         if (key instanceof Integer) {                             entry.setValue(storedProc.getOutputParameterValue((Integer) key)).                         } else {                             entry.setValue(storedProc.getOutputParameterValue(key.toString())).                         }                     } catch (IllegalArgumentException ex) {                         entry.setValue(ex).                     }                 }             }             EntityManagerFactoryUtils.closeEntityManager(this.entityManager).             this.entityManager = null.         }     } }
