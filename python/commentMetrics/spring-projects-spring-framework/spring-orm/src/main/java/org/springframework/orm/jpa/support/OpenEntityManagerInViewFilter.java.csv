commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the bean name of the EntityManagerFactory to fetch from Spring's  * root application context.  * <p>Default is "entityManagerFactory". Note that this default only applies  * when no "persistenceUnitName" param has been specified.  * @see #setPersistenceUnitName  * @see #DEFAULT_ENTITY_MANAGER_FACTORY_BEAN_NAME  */ ;/**  * Set the bean name of the EntityManagerFactory to fetch from Spring's  * root application context.  * <p>Default is "entityManagerFactory". Note that this default only applies  * when no "persistenceUnitName" param has been specified.  * @see #setPersistenceUnitName  * @see #DEFAULT_ENTITY_MANAGER_FACTORY_BEAN_NAME  */ public void setEntityManagerFactoryBeanName(@Nullable String entityManagerFactoryBeanName) {     this.entityManagerFactoryBeanName = entityManagerFactoryBeanName. }
true;protected;0;4;/**  * Return the bean name of the EntityManagerFactory to fetch from Spring's  * root application context.  */ ;/**  * Return the bean name of the EntityManagerFactory to fetch from Spring's  * root application context.  */ @Nullable protected String getEntityManagerFactoryBeanName() {     return this.entityManagerFactoryBeanName. }
true;public;1;3;/**  * Set the name of the persistence unit to access the EntityManagerFactory for.  * <p>This is an alternative to specifying the EntityManagerFactory by bean name,  * resolving it by its persistence unit name instead. If no bean name and no persistence  * unit name have been specified, we'll check whether a bean exists for the default  * bean name "entityManagerFactory". if not, a default EntityManagerFactory will  * be retrieved through finding a single unique bean of type EntityManagerFactory.  * @see #setEntityManagerFactoryBeanName  * @see #DEFAULT_ENTITY_MANAGER_FACTORY_BEAN_NAME  */ ;/**  * Set the name of the persistence unit to access the EntityManagerFactory for.  * <p>This is an alternative to specifying the EntityManagerFactory by bean name,  * resolving it by its persistence unit name instead. If no bean name and no persistence  * unit name have been specified, we'll check whether a bean exists for the default  * bean name "entityManagerFactory". if not, a default EntityManagerFactory will  * be retrieved through finding a single unique bean of type EntityManagerFactory.  * @see #setEntityManagerFactoryBeanName  * @see #DEFAULT_ENTITY_MANAGER_FACTORY_BEAN_NAME  */ public void setPersistenceUnitName(@Nullable String persistenceUnitName) {     this.persistenceUnitName = persistenceUnitName. }
true;protected;0;4;/**  * Return the name of the persistence unit to access the EntityManagerFactory for, if any.  */ ;/**  * Return the name of the persistence unit to access the EntityManagerFactory for, if any.  */ @Nullable protected String getPersistenceUnitName() {     return this.persistenceUnitName. }
true;protected;0;4;/**  * Returns "false" so that the filter may re-bind the opened {@code EntityManager}  * to each asynchronously dispatched thread and postpone closing it until the very  * last asynchronous dispatch.  */ ;/**  * Returns "false" so that the filter may re-bind the opened {@code EntityManager}  * to each asynchronously dispatched thread and postpone closing it until the very  * last asynchronous dispatch.  */ @Override protected boolean shouldNotFilterAsyncDispatch() {     return false. }
true;protected;0;4;/**  * Returns "false" so that the filter may provide an {@code EntityManager}  * to each error dispatches.  */ ;/**  * Returns "false" so that the filter may provide an {@code EntityManager}  * to each error dispatches.  */ @Override protected boolean shouldNotFilterErrorDispatch() {     return false. }
false;protected;3;49;;@Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {     EntityManagerFactory emf = lookupEntityManagerFactory(request).     boolean participate = false.     WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request).     String key = getAlreadyFilteredAttributeName().     if (TransactionSynchronizationManager.hasResource(emf)) {         // Do not modify the EntityManager: just set the participate flag.         participate = true.     } else {         boolean isFirstRequest = !isAsyncDispatch(request).         if (isFirstRequest || !applyEntityManagerBindingInterceptor(asyncManager, key)) {             logger.debug("Opening JPA EntityManager in OpenEntityManagerInViewFilter").             try {                 EntityManager em = createEntityManager(emf).                 EntityManagerHolder emHolder = new EntityManagerHolder(em).                 TransactionSynchronizationManager.bindResource(emf, emHolder).                 AsyncRequestInterceptor interceptor = new AsyncRequestInterceptor(emf, emHolder).                 asyncManager.registerCallableInterceptor(key, interceptor).                 asyncManager.registerDeferredResultInterceptor(key, interceptor).             } catch (PersistenceException ex) {                 throw new DataAccessResourceFailureException("Could not create JPA EntityManager", ex).             }         }     }     try {         filterChain.doFilter(request, response).     } finally {         if (!participate) {             EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.unbindResource(emf).             if (!isAsyncStarted(request)) {                 logger.debug("Closing JPA EntityManager in OpenEntityManagerInViewFilter").                 EntityManagerFactoryUtils.closeEntityManager(emHolder.getEntityManager()).             }         }     } }
true;protected;1;8;/**  * Look up the EntityManagerFactory that this filter should use,  * taking the current HTTP request as argument.  * <p>The default implementation delegates to the {@code lookupEntityManagerFactory}  * without arguments, caching the EntityManagerFactory reference once obtained.  * @return the EntityManagerFactory to use  * @see #lookupEntityManagerFactory()  */ ;/**  * Look up the EntityManagerFactory that this filter should use,  * taking the current HTTP request as argument.  * <p>The default implementation delegates to the {@code lookupEntityManagerFactory}  * without arguments, caching the EntityManagerFactory reference once obtained.  * @return the EntityManagerFactory to use  * @see #lookupEntityManagerFactory()  */ protected EntityManagerFactory lookupEntityManagerFactory(HttpServletRequest request) {     EntityManagerFactory emf = this.entityManagerFactory.     if (emf == null) {         emf = lookupEntityManagerFactory().         this.entityManagerFactory = emf.     }     return emf. }
true;protected;0;15;/**  * Look up the EntityManagerFactory that this filter should use.  * <p>The default implementation looks for a bean with the specified name  * in Spring's root application context.  * @return the EntityManagerFactory to use  * @see #getEntityManagerFactoryBeanName  */ ;/**  * Look up the EntityManagerFactory that this filter should use.  * <p>The default implementation looks for a bean with the specified name  * in Spring's root application context.  * @return the EntityManagerFactory to use  * @see #getEntityManagerFactoryBeanName  */ protected EntityManagerFactory lookupEntityManagerFactory() {     WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(getServletContext()).     String emfBeanName = getEntityManagerFactoryBeanName().     String puName = getPersistenceUnitName().     if (StringUtils.hasLength(emfBeanName)) {         return wac.getBean(emfBeanName, EntityManagerFactory.class).     } else if (!StringUtils.hasLength(puName) && wac.containsBean(DEFAULT_ENTITY_MANAGER_FACTORY_BEAN_NAME)) {         return wac.getBean(DEFAULT_ENTITY_MANAGER_FACTORY_BEAN_NAME, EntityManagerFactory.class).     } else {         // Includes fallback search for single EntityManagerFactory bean by type.         return EntityManagerFactoryUtils.findEntityManagerFactory(wac, puName).     } }
true;protected;1;3;/**  * Create a JPA EntityManager to be bound to a request.  * <p>Can be overridden in subclasses.  * @param emf the EntityManagerFactory to use  * @see javax.persistence.EntityManagerFactory#createEntityManager()  */ ;/**  * Create a JPA EntityManager to be bound to a request.  * <p>Can be overridden in subclasses.  * @param emf the EntityManagerFactory to use  * @see javax.persistence.EntityManagerFactory#createEntityManager()  */ protected EntityManager createEntityManager(EntityManagerFactory emf) {     return emf.createEntityManager(). }
false;private;2;8;;private boolean applyEntityManagerBindingInterceptor(WebAsyncManager asyncManager, String key) {     CallableProcessingInterceptor cpi = asyncManager.getCallableInterceptor(key).     if (cpi == null) {         return false.     }     ((AsyncRequestInterceptor) cpi).bindEntityManager().     return true. }
