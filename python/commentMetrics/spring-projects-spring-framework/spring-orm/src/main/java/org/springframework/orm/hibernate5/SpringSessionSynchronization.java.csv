commented;modifiers;parameterAmount;loc;comment;code
false;private;0;3;;private Session getCurrentSession() {     return this.sessionHolder.getSession(). }
false;public;0;4;;@Override public int getOrder() {     return SessionFactoryUtils.SESSION_SYNCHRONIZATION_ORDER. }
false;public;0;8;;@Override public void suspend() {     if (this.holderActive) {         TransactionSynchronizationManager.unbindResource(this.sessionFactory).         // Eagerly disconnect the Session here, to make release mode "on_close" work on JBoss.         getCurrentSession().disconnect().     } }
false;public;0;6;;@Override public void resume() {     if (this.holderActive) {         TransactionSynchronizationManager.bindResource(this.sessionFactory, this.sessionHolder).     } }
false;public;0;4;;@Override public void flush() {     SessionFactoryUtils.flush(getCurrentSession(), false). }
false;public;1;11;;@Override public void beforeCommit(boolean readOnly) throws DataAccessException {     if (!readOnly) {         Session session = getCurrentSession().         // Further check: only flush when not FlushMode.MANUAL.         if (!FlushMode.MANUAL.equals(SessionFactoryUtils.getFlushMode(session))) {             SessionFactoryUtils.flush(getCurrentSession(), true).         }     } }
false;public;0;20;;@Override @SuppressWarnings("deprecation") public void beforeCompletion() {     try {         Session session = this.sessionHolder.getSession().         if (this.sessionHolder.getPreviousFlushMode() != null) {             // In case of pre-bound Session, restore previous flush mode.             session.setFlushMode(this.sessionHolder.getPreviousFlushMode()).         }         // Eagerly disconnect the Session here, to make release mode "on_close" work nicely.         session.disconnect().     } finally {         // Unbind at this point if it's a new Session...         if (this.newSession) {             TransactionSynchronizationManager.unbindResource(this.sessionFactory).             this.holderActive = false.         }     } }
false;public;0;3;;@Override public void afterCommit() { }
false;public;1;17;;@Override public void afterCompletion(int status) {     try {         if (status != STATUS_COMMITTED) {             // Clear all pending inserts/updates/deletes in the Session.             // Necessary for pre-bound Sessions, to avoid inconsistent state.             this.sessionHolder.getSession().clear().         }     } finally {         this.sessionHolder.setSynchronizedWithTransaction(false).         // Call close() at this point if it's a new Session...         if (this.newSession) {             SessionFactoryUtils.closeSession(this.sessionHolder.getSession()).         }     } }
