commented;modifiers;parameterAmount;loc;comment;code
true;public;2;13;/**  * This implementation invokes the standard JPA {@code Transaction.begin}  * method. Throws an InvalidIsolationLevelException if a non-default isolation  * level is set.  * <p>This implementation does not return any transaction data Object, since there  * is no state to be kept for a standard JPA transaction. Hence, subclasses do not  * have to care about the return value ({@code null}) of this implementation  * and are free to return their own transaction data Object.  * @see javax.persistence.EntityTransaction#begin  * @see org.springframework.transaction.InvalidIsolationLevelException  * @see #cleanupTransaction  */ ;/**  * This implementation invokes the standard JPA {@code Transaction.begin}  * method. Throws an InvalidIsolationLevelException if a non-default isolation  * level is set.  * <p>This implementation does not return any transaction data Object, since there  * is no state to be kept for a standard JPA transaction. Hence, subclasses do not  * have to care about the return value ({@code null}) of this implementation  * and are free to return their own transaction data Object.  * @see javax.persistence.EntityTransaction#begin  * @see org.springframework.transaction.InvalidIsolationLevelException  * @see #cleanupTransaction  */ @Override @Nullable public Object beginTransaction(EntityManager entityManager, TransactionDefinition definition) throws PersistenceException, SQLException, TransactionException {     if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {         throw new InvalidIsolationLevelException(getClass().getSimpleName() + " does not support custom isolation levels due to limitations in standard JPA. " + "Specific arrangements may be implemented in custom JpaDialect variants.").     }     entityManager.getTransaction().begin().     return null. }
false;public;3;7;;@Override @Nullable public Object prepareTransaction(EntityManager entityManager, boolean readOnly, @Nullable String name) throws PersistenceException {     return null. }
true;public;1;3;/**  * This implementation does nothing, since the default {@code beginTransaction}  * implementation does not require any cleanup.  * @see #beginTransaction  */ ;/**  * This implementation does nothing, since the default {@code beginTransaction}  * implementation does not require any cleanup.  * @see #beginTransaction  */ @Override public void cleanupTransaction(@Nullable Object transactionData) { }
true;public;2;7;/**  * This implementation always returns {@code null},  * indicating that no JDBC Connection can be provided.  */ ;/**  * This implementation always returns {@code null},  * indicating that no JDBC Connection can be provided.  */ @Override @Nullable public ConnectionHandle getJdbcConnection(EntityManager entityManager, boolean readOnly) throws PersistenceException, SQLException {     return null. }
true;public;2;4;/**  * This implementation does nothing, assuming that the Connection  * will implicitly be closed with the EntityManager.  * <p>If the JPA implementation returns a Connection handle that it expects  * the application to close after use, the dialect implementation needs to invoke  * {@code Connection.close()} (or some other method with similar effect) here.  * @see java.sql.Connection#close()  */ ;/**  * This implementation does nothing, assuming that the Connection  * will implicitly be closed with the EntityManager.  * <p>If the JPA implementation returns a Connection handle that it expects  * the application to close after use, the dialect implementation needs to invoke  * {@code Connection.close()} (or some other method with similar effect) here.  * @see java.sql.Connection#close()  */ @Override public void releaseJdbcConnection(ConnectionHandle conHandle, EntityManager em) throws PersistenceException, SQLException { }
true;public;1;5;/**  * This implementation delegates to EntityManagerFactoryUtils.  * @see EntityManagerFactoryUtils#convertJpaAccessExceptionIfPossible  */ ;// ----------------------------------------------------------------------------------- // Hook for exception translation (used by JpaTransactionManager) // ----------------------------------------------------------------------------------- /**  * This implementation delegates to EntityManagerFactoryUtils.  * @see EntityManagerFactoryUtils#convertJpaAccessExceptionIfPossible  */ @Override @Nullable public DataAccessException translateExceptionIfPossible(RuntimeException ex) {     return EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(ex). }
