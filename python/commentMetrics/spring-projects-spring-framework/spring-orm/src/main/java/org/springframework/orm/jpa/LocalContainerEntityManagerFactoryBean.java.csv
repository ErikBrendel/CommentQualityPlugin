commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the PersistenceUnitManager to use for obtaining the JPA persistence unit  * that this FactoryBean is supposed to build an EntityManagerFactory for.  * <p>The default is to rely on the local settings specified on this FactoryBean,  * such as "persistenceXmlLocation", "dataSource" and "loadTimeWeaver".  * <p>For reuse of existing persistence unit configuration or more advanced forms  * of custom persistence unit handling, consider defining a separate  * PersistenceUnitManager bean (typically a DefaultPersistenceUnitManager instance)  * and linking it in here. {@code persistence.xml} location, DataSource  * configuration and LoadTimeWeaver will be defined on that separate  * DefaultPersistenceUnitManager bean in such a scenario.  * @see #setPersistenceXmlLocation  * @see #setDataSource  * @see #setLoadTimeWeaver  * @see org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager  */ ;/**  * Set the PersistenceUnitManager to use for obtaining the JPA persistence unit  * that this FactoryBean is supposed to build an EntityManagerFactory for.  * <p>The default is to rely on the local settings specified on this FactoryBean,  * such as "persistenceXmlLocation", "dataSource" and "loadTimeWeaver".  * <p>For reuse of existing persistence unit configuration or more advanced forms  * of custom persistence unit handling, consider defining a separate  * PersistenceUnitManager bean (typically a DefaultPersistenceUnitManager instance)  * and linking it in here. {@code persistence.xml} location, DataSource  * configuration and LoadTimeWeaver will be defined on that separate  * DefaultPersistenceUnitManager bean in such a scenario.  * @see #setPersistenceXmlLocation  * @see #setDataSource  * @see #setLoadTimeWeaver  * @see org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager  */ public void setPersistenceUnitManager(PersistenceUnitManager persistenceUnitManager) {     this.persistenceUnitManager = persistenceUnitManager. }
true;public;1;3;/**  * Set the location of the {@code persistence.xml} file  * we want to use. This is a Spring resource location.  * <p>Default is "classpath:META-INF/persistence.xml".  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @param persistenceXmlLocation a Spring resource String  * identifying the location of the {@code persistence.xml} file  * that this LocalContainerEntityManagerFactoryBean should parse  * @see #setPersistenceUnitManager  */ ;/**  * Set the location of the {@code persistence.xml} file  * we want to use. This is a Spring resource location.  * <p>Default is "classpath:META-INF/persistence.xml".  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @param persistenceXmlLocation a Spring resource String  * identifying the location of the {@code persistence.xml} file  * that this LocalContainerEntityManagerFactoryBean should parse  * @see #setPersistenceUnitManager  */ public void setPersistenceXmlLocation(String persistenceXmlLocation) {     this.internalPersistenceUnitManager.setPersistenceXmlLocation(persistenceXmlLocation). }
true;public;1;7;/**  * Uses the specified persistence unit name as the name of the default  * persistence unit, if applicable.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see DefaultPersistenceUnitManager#setDefaultPersistenceUnitName  */ ;/**  * Uses the specified persistence unit name as the name of the default  * persistence unit, if applicable.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see DefaultPersistenceUnitManager#setDefaultPersistenceUnitName  */ @Override public void setPersistenceUnitName(@Nullable String persistenceUnitName) {     super.setPersistenceUnitName(persistenceUnitName).     if (persistenceUnitName != null) {         this.internalPersistenceUnitManager.setDefaultPersistenceUnitName(persistenceUnitName).     } }
true;public;1;3;/**  * Set a persistence unit root location for the default persistence unit.  * <p>Default is "classpath:", that is, the root of the current classpath  * (nearest root directory). To be overridden if unit-specific resolution  * does not work and the classpath root is not appropriate either.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @since 4.3.3  * @see DefaultPersistenceUnitManager#setDefaultPersistenceUnitRootLocation  */ ;/**  * Set a persistence unit root location for the default persistence unit.  * <p>Default is "classpath:", that is, the root of the current classpath  * (nearest root directory). To be overridden if unit-specific resolution  * does not work and the classpath root is not appropriate either.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @since 4.3.3  * @see DefaultPersistenceUnitManager#setDefaultPersistenceUnitRootLocation  */ public void setPersistenceUnitRootLocation(String defaultPersistenceUnitRootLocation) {     this.internalPersistenceUnitManager.setDefaultPersistenceUnitRootLocation(defaultPersistenceUnitRootLocation). }
true;public;1;3;/**  * Set whether to use Spring-based scanning for entity classes in the classpath  * instead of using JPA's standard scanning of jar files with {@code persistence.xml}  * markers in them. In case of Spring-based scanning, no {@code persistence.xml}  * is necessary. all you need to do is to specify base packages to search here.  * <p>Default is none. Specify packages to search for autodetection of your entity  * classes in the classpath. This is analogous to Spring's component-scan feature  * ({@link org.springframework.context.annotation.ClassPathBeanDefinitionScanner}).  * <p><b>Note: There may be limitations in comparison to regular JPA scanning.</b>  * In particular, JPA providers may pick up annotated packages for provider-specific  * annotations only when driven by {@code persistence.xml}. As of 4.1, Spring's  * scan can detect annotated packages as well if supported by the given  * {@link JpaVendorAdapter} (e.g. for Hibernate).  * <p>If no explicit {@link #setMappingResources mapping resources} have been  * specified in addition to these packages, Spring's setup looks for a default  * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping  * resource for the default unit if the mapping file is not co-located with a  * {@code persistence.xml} file (in which case we assume it is only meant to be  * used with the persistence units defined there, like in standard JPA).  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @param packagesToScan one or more base packages to search, analogous to  * Spring's component-scan configuration for regular Spring components  * @see #setPersistenceUnitManager  * @see DefaultPersistenceUnitManager#setPackagesToScan  */ ;/**  * Set whether to use Spring-based scanning for entity classes in the classpath  * instead of using JPA's standard scanning of jar files with {@code persistence.xml}  * markers in them. In case of Spring-based scanning, no {@code persistence.xml}  * is necessary. all you need to do is to specify base packages to search here.  * <p>Default is none. Specify packages to search for autodetection of your entity  * classes in the classpath. This is analogous to Spring's component-scan feature  * ({@link org.springframework.context.annotation.ClassPathBeanDefinitionScanner}).  * <p><b>Note: There may be limitations in comparison to regular JPA scanning.</b>  * In particular, JPA providers may pick up annotated packages for provider-specific  * annotations only when driven by {@code persistence.xml}. As of 4.1, Spring's  * scan can detect annotated packages as well if supported by the given  * {@link JpaVendorAdapter} (e.g. for Hibernate).  * <p>If no explicit {@link #setMappingResources mapping resources} have been  * specified in addition to these packages, Spring's setup looks for a default  * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping  * resource for the default unit if the mapping file is not co-located with a  * {@code persistence.xml} file (in which case we assume it is only meant to be  * used with the persistence units defined there, like in standard JPA).  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @param packagesToScan one or more base packages to search, analogous to  * Spring's component-scan configuration for regular Spring components  * @see #setPersistenceUnitManager  * @see DefaultPersistenceUnitManager#setPackagesToScan  */ public void setPackagesToScan(String... packagesToScan) {     this.internalPersistenceUnitManager.setPackagesToScan(packagesToScan). }
true;public;1;3;/**  * Specify one or more mapping resources (equivalent to {@code <mapping-file>}  * entries in {@code persistence.xml}) for the default persistence unit.  * Can be used on its own or in combination with entity scanning in the classpath,  * in both cases avoiding {@code persistence.xml}.  * <p>Note that mapping resources must be relative to the classpath root,  * e.g. "META-INF/mappings.xml" or "com/mycompany/repository/mappings.xml",  * so that they can be loaded through {@code ClassLoader.getResource}.  * <p>If no explicit mapping resources have been specified next to  * {@link #setPackagesToScan packages to scan}, Spring's setup looks for a default  * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping  * resource for the default unit if the mapping file is not co-located with a  * {@code persistence.xml} file (in which case we assume it is only meant to be  * used with the persistence units defined there, like in standard JPA).  * <p>Note that specifying an empty array/list here suppresses the default  * {@code META-INF/orm.xml} check. On the other hand, explicitly specifying  * {@code META-INF/orm.xml} here will register that file even if it happens  * to be co-located with a {@code persistence.xml} file.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see #setPersistenceUnitManager  * @see DefaultPersistenceUnitManager#setMappingResources  */ ;/**  * Specify one or more mapping resources (equivalent to {@code <mapping-file>}  * entries in {@code persistence.xml}) for the default persistence unit.  * Can be used on its own or in combination with entity scanning in the classpath,  * in both cases avoiding {@code persistence.xml}.  * <p>Note that mapping resources must be relative to the classpath root,  * e.g. "META-INF/mappings.xml" or "com/mycompany/repository/mappings.xml",  * so that they can be loaded through {@code ClassLoader.getResource}.  * <p>If no explicit mapping resources have been specified next to  * {@link #setPackagesToScan packages to scan}, Spring's setup looks for a default  * {@code META-INF/orm.xml} file in the classpath, registering it as a mapping  * resource for the default unit if the mapping file is not co-located with a  * {@code persistence.xml} file (in which case we assume it is only meant to be  * used with the persistence units defined there, like in standard JPA).  * <p>Note that specifying an empty array/list here suppresses the default  * {@code META-INF/orm.xml} check. On the other hand, explicitly specifying  * {@code META-INF/orm.xml} here will register that file even if it happens  * to be co-located with a {@code persistence.xml} file.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see #setPersistenceUnitManager  * @see DefaultPersistenceUnitManager#setMappingResources  */ public void setMappingResources(String... mappingResources) {     this.internalPersistenceUnitManager.setMappingResources(mappingResources). }
true;public;1;3;/**  * Specify the JPA 2.0 shared cache mode for this persistence unit,  * overriding a value in {@code persistence.xml} if set.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @since 4.0  * @see javax.persistence.spi.PersistenceUnitInfo#getSharedCacheMode()  * @see #setPersistenceUnitManager  */ ;/**  * Specify the JPA 2.0 shared cache mode for this persistence unit,  * overriding a value in {@code persistence.xml} if set.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @since 4.0  * @see javax.persistence.spi.PersistenceUnitInfo#getSharedCacheMode()  * @see #setPersistenceUnitManager  */ public void setSharedCacheMode(SharedCacheMode sharedCacheMode) {     this.internalPersistenceUnitManager.setSharedCacheMode(sharedCacheMode). }
true;public;1;3;/**  * Specify the JPA 2.0 validation mode for this persistence unit,  * overriding a value in {@code persistence.xml} if set.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @since 4.0  * @see javax.persistence.spi.PersistenceUnitInfo#getValidationMode()  * @see #setPersistenceUnitManager  */ ;/**  * Specify the JPA 2.0 validation mode for this persistence unit,  * overriding a value in {@code persistence.xml} if set.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @since 4.0  * @see javax.persistence.spi.PersistenceUnitInfo#getValidationMode()  * @see #setPersistenceUnitManager  */ public void setValidationMode(ValidationMode validationMode) {     this.internalPersistenceUnitManager.setValidationMode(validationMode). }
true;public;1;4;/**  * Specify the JDBC DataSource that the JPA persistence provider is supposed  * to use for accessing the database. This is an alternative to keeping the  * JDBC configuration in {@code persistence.xml}, passing in a Spring-managed  * DataSource instead.  * <p>In JPA speak, a DataSource passed in here will be used as "nonJtaDataSource"  * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as  * overriding data source configuration in {@code persistence.xml} (if any).  * Note that this variant typically works for JTA transaction management as well.  * if it does not, consider using the explicit {@link #setJtaDataSource} instead.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see javax.persistence.spi.PersistenceUnitInfo#getNonJtaDataSource()  * @see #setPersistenceUnitManager  */ ;/**  * Specify the JDBC DataSource that the JPA persistence provider is supposed  * to use for accessing the database. This is an alternative to keeping the  * JDBC configuration in {@code persistence.xml}, passing in a Spring-managed  * DataSource instead.  * <p>In JPA speak, a DataSource passed in here will be used as "nonJtaDataSource"  * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as  * overriding data source configuration in {@code persistence.xml} (if any).  * Note that this variant typically works for JTA transaction management as well.  * if it does not, consider using the explicit {@link #setJtaDataSource} instead.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see javax.persistence.spi.PersistenceUnitInfo#getNonJtaDataSource()  * @see #setPersistenceUnitManager  */ public void setDataSource(DataSource dataSource) {     this.internalPersistenceUnitManager.setDataSourceLookup(new SingleDataSourceLookup(dataSource)).     this.internalPersistenceUnitManager.setDefaultDataSource(dataSource). }
true;public;1;4;/**  * Specify the JDBC DataSource that the JPA persistence provider is supposed  * to use for accessing the database. This is an alternative to keeping the  * JDBC configuration in {@code persistence.xml}, passing in a Spring-managed  * DataSource instead.  * <p>In JPA speak, a DataSource passed in here will be used as "jtaDataSource"  * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as  * overriding data source configuration in {@code persistence.xml} (if any).  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see javax.persistence.spi.PersistenceUnitInfo#getJtaDataSource()  * @see #setPersistenceUnitManager  */ ;/**  * Specify the JDBC DataSource that the JPA persistence provider is supposed  * to use for accessing the database. This is an alternative to keeping the  * JDBC configuration in {@code persistence.xml}, passing in a Spring-managed  * DataSource instead.  * <p>In JPA speak, a DataSource passed in here will be used as "jtaDataSource"  * on the PersistenceUnitInfo passed to the PersistenceProvider, as well as  * overriding data source configuration in {@code persistence.xml} (if any).  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see javax.persistence.spi.PersistenceUnitInfo#getJtaDataSource()  * @see #setPersistenceUnitManager  */ public void setJtaDataSource(DataSource jtaDataSource) {     this.internalPersistenceUnitManager.setDataSourceLookup(new SingleDataSourceLookup(jtaDataSource)).     this.internalPersistenceUnitManager.setDefaultJtaDataSource(jtaDataSource). }
true;public;1;3;/**  * Set the PersistenceUnitPostProcessors to be applied to the  * PersistenceUnitInfo used for creating this EntityManagerFactory.  * <p>Such post-processors can, for example, register further entity  * classes and jar files, in addition to the metadata read from  * {@code persistence.xml}.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see #setPersistenceUnitManager  */ ;/**  * Set the PersistenceUnitPostProcessors to be applied to the  * PersistenceUnitInfo used for creating this EntityManagerFactory.  * <p>Such post-processors can, for example, register further entity  * classes and jar files, in addition to the metadata read from  * {@code persistence.xml}.  * <p><b>NOTE: Only applied if no external PersistenceUnitManager specified.</b>  * @see #setPersistenceUnitManager  */ public void setPersistenceUnitPostProcessors(PersistenceUnitPostProcessor... postProcessors) {     this.internalPersistenceUnitManager.setPersistenceUnitPostProcessors(postProcessors). }
true;public;1;4;/**  * Specify the Spring LoadTimeWeaver to use for class instrumentation according  * to the JPA class transformer contract.  * <p>It is a not required to specify a LoadTimeWeaver: Most providers will be  * able to provide a subset of their functionality without class instrumentation  * as well, or operate with their VM agent specified on JVM startup.  * <p>In terms of Spring-provided weaving options, the most important ones are  * InstrumentationLoadTimeWeaver, which requires a Spring-specific (but very general)  * VM agent specified on JVM startup, and ReflectiveLoadTimeWeaver, which interacts  * with an underlying ClassLoader based on specific extended methods being available  * on it.  * <p><b>NOTE:</b> As of Spring 2.5, the context's default LoadTimeWeaver (defined  * as bean with name "loadTimeWeaver") will be picked up automatically, if available,  * removing the need for LoadTimeWeaver configuration on each affected target bean.  * Consider using the {@code context:load-time-weaver} XML tag for creating  * such a shared LoadTimeWeaver (autodetecting the environment by default).  * <p><b>NOTE:</b> Only applied if no external PersistenceUnitManager specified.  * Otherwise, the external {@link #setPersistenceUnitManager PersistenceUnitManager}  * is responsible for the weaving configuration.  * @see org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver  * @see org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver  */ ;/**  * Specify the Spring LoadTimeWeaver to use for class instrumentation according  * to the JPA class transformer contract.  * <p>It is a not required to specify a LoadTimeWeaver: Most providers will be  * able to provide a subset of their functionality without class instrumentation  * as well, or operate with their VM agent specified on JVM startup.  * <p>In terms of Spring-provided weaving options, the most important ones are  * InstrumentationLoadTimeWeaver, which requires a Spring-specific (but very general)  * VM agent specified on JVM startup, and ReflectiveLoadTimeWeaver, which interacts  * with an underlying ClassLoader based on specific extended methods being available  * on it.  * <p><b>NOTE:</b> As of Spring 2.5, the context's default LoadTimeWeaver (defined  * as bean with name "loadTimeWeaver") will be picked up automatically, if available,  * removing the need for LoadTimeWeaver configuration on each affected target bean.  * Consider using the {@code context:load-time-weaver} XML tag for creating  * such a shared LoadTimeWeaver (autodetecting the environment by default).  * <p><b>NOTE:</b> Only applied if no external PersistenceUnitManager specified.  * Otherwise, the external {@link #setPersistenceUnitManager PersistenceUnitManager}  * is responsible for the weaving configuration.  * @see org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver  * @see org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver  */ @Override public void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver) {     this.internalPersistenceUnitManager.setLoadTimeWeaver(loadTimeWeaver). }
false;public;1;4;;@Override public void setResourceLoader(ResourceLoader resourceLoader) {     this.internalPersistenceUnitManager.setResourceLoader(resourceLoader). }
false;public;0;19;;@Override public void afterPropertiesSet() throws PersistenceException {     PersistenceUnitManager managerToUse = this.persistenceUnitManager.     if (this.persistenceUnitManager == null) {         this.internalPersistenceUnitManager.afterPropertiesSet().         managerToUse = this.internalPersistenceUnitManager.     }     this.persistenceUnitInfo = determinePersistenceUnitInfo(managerToUse).     JpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter().     if (jpaVendorAdapter != null && this.persistenceUnitInfo instanceof SmartPersistenceUnitInfo) {         String rootPackage = jpaVendorAdapter.getPersistenceProviderRootPackage().         if (rootPackage != null) {             ((SmartPersistenceUnitInfo) this.persistenceUnitInfo).setPersistenceProviderPackageName(rootPackage).         }     }     super.afterPropertiesSet(). }
false;protected;0;26;;@Override protected EntityManagerFactory createNativeEntityManagerFactory() throws PersistenceException {     Assert.state(this.persistenceUnitInfo != null, "PersistenceUnitInfo not initialized").     PersistenceProvider provider = getPersistenceProvider().     if (provider == null) {         String providerClassName = this.persistenceUnitInfo.getPersistenceProviderClassName().         if (providerClassName == null) {             throw new IllegalArgumentException("No PersistenceProvider specified in EntityManagerFactory configuration, " + "and chosen PersistenceUnitInfo does not specify a provider class name either").         }         Class<?> providerClass = ClassUtils.resolveClassName(providerClassName, getBeanClassLoader()).         provider = (PersistenceProvider) BeanUtils.instantiateClass(providerClass).     }     if (logger.isDebugEnabled()) {         logger.debug("Building JPA container EntityManagerFactory for persistence unit '" + this.persistenceUnitInfo.getPersistenceUnitName() + "'").     }     EntityManagerFactory emf = provider.createContainerEntityManagerFactory(this.persistenceUnitInfo, getJpaPropertyMap()).     postProcessEntityManagerFactory(emf, this.persistenceUnitInfo).     return emf. }
true;protected;1;8;/**  * Determine the PersistenceUnitInfo to use for the EntityManagerFactory  * created by this bean.  * <p>The default implementation reads in all persistence unit infos from  * {@code persistence.xml}, as defined in the JPA specification.  * If no entity manager name was specified, it takes the first info in the  * array as returned by the reader. Otherwise, it checks for a matching name.  * @param persistenceUnitManager the PersistenceUnitManager to obtain from  * @return the chosen PersistenceUnitInfo  */ ;/**  * Determine the PersistenceUnitInfo to use for the EntityManagerFactory  * created by this bean.  * <p>The default implementation reads in all persistence unit infos from  * {@code persistence.xml}, as defined in the JPA specification.  * If no entity manager name was specified, it takes the first info in the  * array as returned by the reader. Otherwise, it checks for a matching name.  * @param persistenceUnitManager the PersistenceUnitManager to obtain from  * @return the chosen PersistenceUnitInfo  */ protected PersistenceUnitInfo determinePersistenceUnitInfo(PersistenceUnitManager persistenceUnitManager) {     if (getPersistenceUnitName() != null) {         return persistenceUnitManager.obtainPersistenceUnitInfo(getPersistenceUnitName()).     } else {         return persistenceUnitManager.obtainDefaultPersistenceUnitInfo().     } }
true;protected;2;2;/**  * Hook method allowing subclasses to customize the EntityManagerFactory  * after its creation via the PersistenceProvider.  * <p>The default implementation is empty.  * @param emf the newly created EntityManagerFactory we are working with  * @param pui the PersistenceUnitInfo used to configure the EntityManagerFactory  * @see javax.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory  */ ;/**  * Hook method allowing subclasses to customize the EntityManagerFactory  * after its creation via the PersistenceProvider.  * <p>The default implementation is empty.  * @param emf the newly created EntityManagerFactory we are working with  * @param pui the PersistenceUnitInfo used to configure the EntityManagerFactory  * @see javax.persistence.spi.PersistenceProvider#createContainerEntityManagerFactory  */ protected void postProcessEntityManagerFactory(EntityManagerFactory emf, PersistenceUnitInfo pui) { }
false;public;0;5;;@Override @Nullable public PersistenceUnitInfo getPersistenceUnitInfo() {     return this.persistenceUnitInfo. }
false;public;0;8;;@Override @Nullable public String getPersistenceUnitName() {     if (this.persistenceUnitInfo != null) {         return this.persistenceUnitInfo.getPersistenceUnitName().     }     return super.getPersistenceUnitName(). }
false;public;0;11;;@Override public DataSource getDataSource() {     if (this.persistenceUnitInfo != null) {         return (this.persistenceUnitInfo.getJtaDataSource() != null ? this.persistenceUnitInfo.getJtaDataSource() : this.persistenceUnitInfo.getNonJtaDataSource()).     }     return (this.internalPersistenceUnitManager.getDefaultJtaDataSource() != null ? this.internalPersistenceUnitManager.getDefaultJtaDataSource() : this.internalPersistenceUnitManager.getDefaultDataSource()). }
