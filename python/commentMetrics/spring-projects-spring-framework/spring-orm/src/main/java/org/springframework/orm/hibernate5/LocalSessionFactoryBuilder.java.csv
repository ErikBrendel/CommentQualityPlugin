commented;modifiers;parameterAmount;loc;comment;code
true;public;1;48;/**  * Set the Spring {@link JtaTransactionManager} or the JTA {@link TransactionManager}  * to be used with Hibernate, if any. Allows for using a Spring-managed transaction  * manager for Hibernate 5's session and cache synchronization, with the  * "hibernate.transaction.jta.platform" automatically set to it.  * <p>A passed-in Spring {@link JtaTransactionManager} needs to contain a JTA  * {@link TransactionManager} reference to be usable here, except for the WebSphere  * case where we'll automatically set {@code WebSphereExtendedJtaPlatform} accordingly.  * <p>Note: If this is set, the Hibernate settings should not contain a JTA platform  * setting to avoid meaningless double configuration.  */ ;/**  * Set the Spring {@link JtaTransactionManager} or the JTA {@link TransactionManager}  * to be used with Hibernate, if any. Allows for using a Spring-managed transaction  * manager for Hibernate 5's session and cache synchronization, with the  * "hibernate.transaction.jta.platform" automatically set to it.  * <p>A passed-in Spring {@link JtaTransactionManager} needs to contain a JTA  * {@link TransactionManager} reference to be usable here, except for the WebSphere  * case where we'll automatically set {@code WebSphereExtendedJtaPlatform} accordingly.  * <p>Note: If this is set, the Hibernate settings should not contain a JTA platform  * setting to avoid meaningless double configuration.  */ public LocalSessionFactoryBuilder setJtaTransactionManager(Object jtaTransactionManager) {     Assert.notNull(jtaTransactionManager, "Transaction manager reference must not be null").     if (jtaTransactionManager instanceof JtaTransactionManager) {         boolean webspherePresent = ClassUtils.isPresent("com.ibm.wsspi.uow.UOWManager", getClass().getClassLoader()).         if (webspherePresent) {             getProperties().put(AvailableSettings.JTA_PLATFORM, "org.hibernate.engine.transaction.jta.platform.internal.WebSphereExtendedJtaPlatform").         } else {             JtaTransactionManager jtaTm = (JtaTransactionManager) jtaTransactionManager.             if (jtaTm.getTransactionManager() == null) {                 throw new IllegalArgumentException("Can only apply JtaTransactionManager which has a TransactionManager reference set").             }             getProperties().put(AvailableSettings.JTA_PLATFORM, new ConfigurableJtaPlatform(jtaTm.getTransactionManager(), jtaTm.getUserTransaction(), jtaTm.getTransactionSynchronizationRegistry())).         }     } else if (jtaTransactionManager instanceof TransactionManager) {         getProperties().put(AvailableSettings.JTA_PLATFORM, new ConfigurableJtaPlatform((TransactionManager) jtaTransactionManager, null, null)).     } else {         throw new IllegalArgumentException("Unknown transaction manager type: " + jtaTransactionManager.getClass().getName()).     }     // Hibernate 5.1/5.2: manually enforce connection release mode AFTER_STATEMENT (the JTA default)     try {         // Try Hibernate 5.2         AvailableSettings.class.getField("CONNECTION_HANDLING").         getProperties().put("hibernate.connection.handling_mode", "DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT").     } catch (NoSuchFieldException ex) {         // Try Hibernate 5.1         try {             AvailableSettings.class.getField("ACQUIRE_CONNECTIONS").             getProperties().put("hibernate.connection.release_mode", "AFTER_STATEMENT").         } catch (NoSuchFieldException ex2) {         // on Hibernate 5.0.x or lower - no need to change the default there         }     }     return this. }
true;public;1;4;/**  * Set a Hibernate {@link org.hibernate.resource.beans.container.spi.BeanContainer}  * for the given Spring {@link ConfigurableListableBeanFactory}.  * <p>Note: Bean container integration requires Hibernate 5.3 or higher.  * It enables autowiring of Hibernate attribute converters and entity listeners.  * @since 5.1  * @see SpringBeanContainer  * @see AvailableSettings#BEAN_CONTAINER  */ ;/**  * Set a Hibernate {@link org.hibernate.resource.beans.container.spi.BeanContainer}  * for the given Spring {@link ConfigurableListableBeanFactory}.  * <p>Note: Bean container integration requires Hibernate 5.3 or higher.  * It enables autowiring of Hibernate attribute converters and entity listeners.  * @since 5.1  * @see SpringBeanContainer  * @see AvailableSettings#BEAN_CONTAINER  */ public LocalSessionFactoryBuilder setBeanContainer(ConfigurableListableBeanFactory beanFactory) {     getProperties().put(AvailableSettings.BEAN_CONTAINER, new SpringBeanContainer(beanFactory)).     return this. }
true;public;1;4;/**  * Set the Hibernate {@link RegionFactory} to use for the SessionFactory.  * Allows for using a Spring-managed {@code RegionFactory} instance.  * <p>Note: If this is set, the Hibernate settings should not define a  * cache provider to avoid meaningless double configuration.  * @since 5.1  * @see AvailableSettings#CACHE_REGION_FACTORY  */ ;/**  * Set the Hibernate {@link RegionFactory} to use for the SessionFactory.  * Allows for using a Spring-managed {@code RegionFactory} instance.  * <p>Note: If this is set, the Hibernate settings should not define a  * cache provider to avoid meaningless double configuration.  * @since 5.1  * @see AvailableSettings#CACHE_REGION_FACTORY  */ public LocalSessionFactoryBuilder setCacheRegionFactory(RegionFactory cacheRegionFactory) {     getProperties().put(AvailableSettings.CACHE_REGION_FACTORY, cacheRegionFactory).     return this. }
true;public;1;4;/**  * Set a {@link MultiTenantConnectionProvider} to be passed on to the SessionFactory.  * @since 4.3  * @see AvailableSettings#MULTI_TENANT_CONNECTION_PROVIDER  */ ;/**  * Set a {@link MultiTenantConnectionProvider} to be passed on to the SessionFactory.  * @since 4.3  * @see AvailableSettings#MULTI_TENANT_CONNECTION_PROVIDER  */ public LocalSessionFactoryBuilder setMultiTenantConnectionProvider(MultiTenantConnectionProvider multiTenantConnectionProvider) {     getProperties().put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER, multiTenantConnectionProvider).     return this. }
true;public;1;5;/**  * Overridden to reliably pass a {@link CurrentTenantIdentifierResolver} to the SessionFactory.  * @since 4.3.2  * @see AvailableSettings#MULTI_TENANT_IDENTIFIER_RESOLVER  */ ;/**  * Overridden to reliably pass a {@link CurrentTenantIdentifierResolver} to the SessionFactory.  * @since 4.3.2  * @see AvailableSettings#MULTI_TENANT_IDENTIFIER_RESOLVER  */ @Override public void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver) {     getProperties().put(AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, currentTenantIdentifierResolver).     super.setCurrentTenantIdentifierResolver(currentTenantIdentifierResolver). }
true;public;1;4;/**  * Specify custom type filters for Spring-based scanning for entity classes.  * <p>Default is to search all specified packages for classes annotated with  * {@code @javax.persistence.Entity}, {@code @javax.persistence.Embeddable}  * or {@code @javax.persistence.MappedSuperclass}.  * @see #scanPackages  */ ;/**  * Specify custom type filters for Spring-based scanning for entity classes.  * <p>Default is to search all specified packages for classes annotated with  * {@code @javax.persistence.Entity}, {@code @javax.persistence.Embeddable}  * or {@code @javax.persistence.MappedSuperclass}.  * @see #scanPackages  */ public LocalSessionFactoryBuilder setEntityTypeFilters(TypeFilter... entityTypeFilters) {     this.entityTypeFilters = entityTypeFilters.     return this. }
true;public;1;6;/**  * Add the given annotated classes in a batch.  * @see #addAnnotatedClass  * @see #scanPackages  */ ;/**  * Add the given annotated classes in a batch.  * @see #addAnnotatedClass  * @see #scanPackages  */ public LocalSessionFactoryBuilder addAnnotatedClasses(Class<?>... annotatedClasses) {     for (Class<?> annotatedClass : annotatedClasses) {         addAnnotatedClass(annotatedClass).     }     return this. }
true;public;1;6;/**  * Add the given annotated packages in a batch.  * @see #addPackage  * @see #scanPackages  */ ;/**  * Add the given annotated packages in a batch.  * @see #addPackage  * @see #scanPackages  */ public LocalSessionFactoryBuilder addPackages(String... annotatedPackages) {     for (String annotatedPackage : annotatedPackages) {         addPackage(annotatedPackage).     }     return this. }
true;public;1;48;/**  * Perform Spring-based scanning for entity classes, registering them  * as annotated classes with this {@code Configuration}.  * @param packagesToScan one or more Java package names  * @throws HibernateException if scanning fails for any reason  */ ;/**  * Perform Spring-based scanning for entity classes, registering them  * as annotated classes with this {@code Configuration}.  * @param packagesToScan one or more Java package names  * @throws HibernateException if scanning fails for any reason  */ @SuppressWarnings("unchecked") public LocalSessionFactoryBuilder scanPackages(String... packagesToScan) throws HibernateException {     Set<String> entityClassNames = new TreeSet<>().     Set<String> converterClassNames = new TreeSet<>().     Set<String> packageNames = new TreeSet<>().     try {         for (String pkg : packagesToScan) {             String pattern = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + ClassUtils.convertClassNameToResourcePath(pkg) + RESOURCE_PATTERN.             Resource[] resources = this.resourcePatternResolver.getResources(pattern).             MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory(this.resourcePatternResolver).             for (Resource resource : resources) {                 if (resource.isReadable()) {                     MetadataReader reader = readerFactory.getMetadataReader(resource).                     String className = reader.getClassMetadata().getClassName().                     if (matchesEntityTypeFilter(reader, readerFactory)) {                         entityClassNames.add(className).                     } else if (CONVERTER_TYPE_FILTER.match(reader, readerFactory)) {                         converterClassNames.add(className).                     } else if (className.endsWith(PACKAGE_INFO_SUFFIX)) {                         packageNames.add(className.substring(0, className.length() - PACKAGE_INFO_SUFFIX.length())).                     }                 }             }         }     } catch (IOException ex) {         throw new MappingException("Failed to scan classpath for unlisted classes", ex).     }     try {         ClassLoader cl = this.resourcePatternResolver.getClassLoader().         for (String className : entityClassNames) {             addAnnotatedClass(ClassUtils.forName(className, cl)).         }         for (String className : converterClassNames) {             addAttributeConverter((Class<? extends AttributeConverter<?, ?>>) ClassUtils.forName(className, cl)).         }         for (String packageName : packageNames) {             addPackage(packageName).         }     } catch (ClassNotFoundException ex) {         throw new MappingException("Failed to load annotated classes from classpath", ex).     }     return this. }
true;private;2;10;/**  * Check whether any of the configured entity type filters matches  * the current class descriptor contained in the metadata reader.  */ ;/**  * Check whether any of the configured entity type filters matches  * the current class descriptor contained in the metadata reader.  */ private boolean matchesEntityTypeFilter(MetadataReader reader, MetadataReaderFactory readerFactory) throws IOException {     if (this.entityTypeFilters != null) {         for (TypeFilter filter : this.entityTypeFilters) {             if (filter.match(reader, readerFactory)) {                 return true.             }         }     }     return false. }
true;public;1;6;/**  * Build the Hibernate {@code SessionFactory} through background bootstrapping,  * using the given executor for a parallel initialization phase  * (e.g. a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}).  * <p>{@code SessionFactory} initialization will then switch into background  * bootstrap mode, with a {@code SessionFactory} proxy immediately returned for  * injection purposes instead of waiting for Hibernate's bootstrapping to complete.  * However, note that the first actual call to a {@code SessionFactory} method will  * then block until Hibernate's bootstrapping completed, if not ready by then.  * For maximum benefit, make sure to avoid early {@code SessionFactory} calls  * in init methods of related beans, even for metadata introspection purposes.  * @since 4.3  * @see #buildSessionFactory()  */ ;/**  * Build the Hibernate {@code SessionFactory} through background bootstrapping,  * using the given executor for a parallel initialization phase  * (e.g. a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}).  * <p>{@code SessionFactory} initialization will then switch into background  * bootstrap mode, with a {@code SessionFactory} proxy immediately returned for  * injection purposes instead of waiting for Hibernate's bootstrapping to complete.  * However, note that the first actual call to a {@code SessionFactory} method will  * then block until Hibernate's bootstrapping completed, if not ready by then.  * For maximum benefit, make sure to avoid early {@code SessionFactory} calls  * in init methods of related beans, even for metadata introspection purposes.  * @since 4.3  * @see #buildSessionFactory()  */ public SessionFactory buildSessionFactory(AsyncTaskExecutor bootstrapExecutor) {     Assert.notNull(bootstrapExecutor, "AsyncTaskExecutor must not be null").     return (SessionFactory) Proxy.newProxyInstance(this.resourcePatternResolver.getClassLoader(), new Class<?>[] { SessionFactoryImplementor.class, InfrastructureProxy.class }, new BootstrapSessionFactoryInvocationHandler(bootstrapExecutor)). }
false;public;3;26;;@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     try {         if (method.getName().equals("equals")) {             // Only consider equal when proxies are identical.             return (proxy == args[0]).         } else if (method.getName().equals("hashCode")) {             // Use hashCode of EntityManagerFactory proxy.             return System.identityHashCode(proxy).         } else if (method.getName().equals("getProperties")) {             return getProperties().         } else if (method.getName().equals("getWrappedObject")) {             // Call coming in through InfrastructureProxy interface...             return getSessionFactory().         }         // enforcing its full initialization...         return method.invoke(getSessionFactory(), args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
false;private;0;18;;private SessionFactory getSessionFactory() {     try {         return this.sessionFactoryFuture.get().     } catch (InterruptedException ex) {         Thread.currentThread().interrupt().         throw new IllegalStateException("Interrupted during initialization of Hibernate SessionFactory", ex).     } catch (ExecutionException ex) {         Throwable cause = ex.getCause().         if (cause instanceof HibernateException) {             // Rethrow a provider configuration exception (possibly with a nested cause) directly             throw (HibernateException) cause.         }         throw new IllegalStateException("Failed to asynchronously initialize Hibernate SessionFactory: " + ex.getMessage(), cause).     } }
