commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set if a singleton should be created, or a new object on each request  * otherwise. Default is {@code true} (a singleton).  */ ;/**  * Set if a singleton should be created, or a new object on each request  * otherwise. Default is {@code true} (a singleton).  */ public void setSingleton(boolean singleton) {     this.singleton = singleton. }
false;public;0;4;;@Override public boolean isSingleton() {     return this.singleton. }
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
false;public;1;4;;@Override public void setBeanFactory(@Nullable BeanFactory beanFactory) {     this.beanFactory = beanFactory. }
true;protected;0;4;/**  * Return the BeanFactory that this bean runs in.  */ ;/**  * Return the BeanFactory that this bean runs in.  */ @Nullable protected BeanFactory getBeanFactory() {     return this.beanFactory. }
true;protected;0;9;/**  * Obtain a bean type converter from the BeanFactory that this bean  * runs in. This is typically a fresh instance for each call,  * since TypeConverters are usually <i>not</i> thread-safe.  * <p>Falls back to a SimpleTypeConverter when not running in a BeanFactory.  * @see ConfigurableBeanFactory#getTypeConverter()  * @see org.springframework.beans.SimpleTypeConverter  */ ;/**  * Obtain a bean type converter from the BeanFactory that this bean  * runs in. This is typically a fresh instance for each call,  * since TypeConverters are usually <i>not</i> thread-safe.  * <p>Falls back to a SimpleTypeConverter when not running in a BeanFactory.  * @see ConfigurableBeanFactory#getTypeConverter()  * @see org.springframework.beans.SimpleTypeConverter  */ protected TypeConverter getBeanTypeConverter() {     BeanFactory beanFactory = getBeanFactory().     if (beanFactory instanceof ConfigurableBeanFactory) {         return ((ConfigurableBeanFactory) beanFactory).getTypeConverter().     } else {         return new SimpleTypeConverter().     } }
true;public;0;8;/**  * Eagerly create the singleton instance, if necessary.  */ ;/**  * Eagerly create the singleton instance, if necessary.  */ @Override public void afterPropertiesSet() throws Exception {     if (isSingleton()) {         this.initialized = true.         this.singletonInstance = createInstance().         this.earlySingletonInstance = null.     } }
true;public,final;0;9;/**  * Expose the singleton instance or create a new prototype instance.  * @see #createInstance()  * @see #getEarlySingletonInterfaces()  */ ;/**  * Expose the singleton instance or create a new prototype instance.  * @see #createInstance()  * @see #getEarlySingletonInterfaces()  */ @Override public final T getObject() throws Exception {     if (isSingleton()) {         return (this.initialized ? this.singletonInstance : getEarlySingletonInstance()).     } else {         return createInstance().     } }
true;private;0;13;/**  * Determine an 'early singleton' instance, exposed in case of a  * circular reference. Not called in a non-circular scenario.  */ ;/**  * Determine an 'early singleton' instance, exposed in case of a  * circular reference. Not called in a non-circular scenario.  */ @SuppressWarnings("unchecked") private T getEarlySingletonInstance() throws Exception {     Class<?>[] ifcs = getEarlySingletonInterfaces().     if (ifcs == null) {         throw new FactoryBeanNotInitializedException(getClass().getName() + " does not support circular references").     }     if (this.earlySingletonInstance == null) {         this.earlySingletonInstance = (T) Proxy.newProxyInstance(this.beanClassLoader, ifcs, new EarlySingletonInvocationHandler()).     }     return this.earlySingletonInstance. }
true;private;0;5;/**  * Expose the singleton instance (for access through the 'early singleton' proxy).  * @return the singleton instance that this FactoryBean holds  * @throws IllegalStateException if the singleton instance is not initialized  */ ;/**  * Expose the singleton instance (for access through the 'early singleton' proxy).  * @return the singleton instance that this FactoryBean holds  * @throws IllegalStateException if the singleton instance is not initialized  */ @Nullable private T getSingletonInstance() throws IllegalStateException {     Assert.state(this.initialized, "Singleton instance not initialized yet").     return this.singletonInstance. }
true;public;0;6;/**  * Destroy the singleton instance, if any.  * @see #destroyInstance(Object)  */ ;/**  * Destroy the singleton instance, if any.  * @see #destroyInstance(Object)  */ @Override public void destroy() throws Exception {     if (isSingleton()) {         destroyInstance(this.singletonInstance).     } }
true;public,abstract;0;3;/**  * This abstract method declaration mirrors the method in the FactoryBean  * interface, for a consistent offering of abstract template methods.  * @see org.springframework.beans.factory.FactoryBean#getObjectType()  */ ;/**  * This abstract method declaration mirrors the method in the FactoryBean  * interface, for a consistent offering of abstract template methods.  * @see org.springframework.beans.factory.FactoryBean#getObjectType()  */ @Override @Nullable public abstract Class<?> getObjectType().
true;protected,abstract;0;1;/**  * Template method that subclasses must override to construct  * the object returned by this factory.  * <p>Invoked on initialization of this FactoryBean in case of  * a singleton. else, on each {@link #getObject()} call.  * @return the object returned by this factory  * @throws Exception if an exception occurred during object creation  * @see #getObject()  */ ;/**  * Template method that subclasses must override to construct  * the object returned by this factory.  * <p>Invoked on initialization of this FactoryBean in case of  * a singleton. else, on each {@link #getObject()} call.  * @return the object returned by this factory  * @throws Exception if an exception occurred during object creation  * @see #getObject()  */ protected abstract T createInstance() throws Exception.
true;protected;0;5;/**  * Return an array of interfaces that a singleton object exposed by this  * FactoryBean is supposed to implement, for use with an 'early singleton  * proxy' that will be exposed in case of a circular reference.  * <p>The default implementation returns this FactoryBean's object type,  * provided that it is an interface, or {@code null} otherwise. The latter  * indicates that early singleton access is not supported by this FactoryBean.  * This will lead to a FactoryBeanNotInitializedException getting thrown.  * @return the interfaces to use for 'early singletons',  * or {@code null} to indicate a FactoryBeanNotInitializedException  * @see org.springframework.beans.factory.FactoryBeanNotInitializedException  */ ;/**  * Return an array of interfaces that a singleton object exposed by this  * FactoryBean is supposed to implement, for use with an 'early singleton  * proxy' that will be exposed in case of a circular reference.  * <p>The default implementation returns this FactoryBean's object type,  * provided that it is an interface, or {@code null} otherwise. The latter  * indicates that early singleton access is not supported by this FactoryBean.  * This will lead to a FactoryBeanNotInitializedException getting thrown.  * @return the interfaces to use for 'early singletons',  * or {@code null} to indicate a FactoryBeanNotInitializedException  * @see org.springframework.beans.factory.FactoryBeanNotInitializedException  */ @Nullable protected Class<?>[] getEarlySingletonInterfaces() {     Class<?> type = getObjectType().     return (type != null && type.isInterface() ? new Class<?>[] { type } : null). }
true;protected;1;2;/**  * Callback for destroying a singleton instance. Subclasses may  * override this to destroy the previously created instance.  * <p>The default implementation is empty.  * @param instance the singleton instance, as returned by  * {@link #createInstance()}  * @throws Exception in case of shutdown errors  * @see #createInstance()  */ ;/**  * Callback for destroying a singleton instance. Subclasses may  * override this to destroy the previously created instance.  * <p>The default implementation is empty.  * @param instance the singleton instance, as returned by  * {@link #createInstance()}  * @throws Exception in case of shutdown errors  * @see #createInstance()  */ protected void destroyInstance(@Nullable T instance) throws Exception { }
false;public;3;21;;@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (ReflectionUtils.isEqualsMethod(method)) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (ReflectionUtils.isHashCodeMethod(method)) {         // Use hashCode of reference proxy.         return System.identityHashCode(proxy).     } else if (!initialized && ReflectionUtils.isToStringMethod(method)) {         return "Early singleton proxy for interfaces " + ObjectUtils.nullSafeToString(getEarlySingletonInterfaces()).     }     try {         return method.invoke(getSingletonInstance(), args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
