commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify a target object to apply the property path to.  * Alternatively, specify a target bean name.  * @param targetObject a target object, for example a bean reference  * or an inner bean  * @see #setTargetBeanName  */ ;/**  * Specify a target object to apply the property path to.  * Alternatively, specify a target bean name.  * @param targetObject a target object, for example a bean reference  * or an inner bean  * @see #setTargetBeanName  */ public void setTargetObject(Object targetObject) {     this.targetBeanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(targetObject). }
true;public;1;3;/**  * Specify the name of a target bean to apply the property path to.  * Alternatively, specify a target object directly.  * @param targetBeanName the bean name to be looked up in the  * containing bean factory (e.g. "testBean")  * @see #setTargetObject  */ ;/**  * Specify the name of a target bean to apply the property path to.  * Alternatively, specify a target object directly.  * @param targetBeanName the bean name to be looked up in the  * containing bean factory (e.g. "testBean")  * @see #setTargetObject  */ public void setTargetBeanName(String targetBeanName) {     this.targetBeanName = StringUtils.trimAllWhitespace(targetBeanName). }
true;public;1;3;/**  * Specify the property path to apply to the target.  * @param propertyPath the property path, potentially nested  * (e.g. "age" or "spouse.age")  */ ;/**  * Specify the property path to apply to the target.  * @param propertyPath the property path, potentially nested  * (e.g. "age" or "spouse.age")  */ public void setPropertyPath(String propertyPath) {     this.propertyPath = StringUtils.trimAllWhitespace(propertyPath). }
true;public;1;3;/**  * Specify the type of the result from evaluating the property path.  * <p>Note: This is not necessary for directly specified target objects  * or singleton target beans, where the type can be determined through  * introspection. Just specify this in case of a prototype target,  * provided that you need matching by type (for example, for autowiring).  * @param resultType the result type, for example "java.lang.Integer"  */ ;/**  * Specify the type of the result from evaluating the property path.  * <p>Note: This is not necessary for directly specified target objects  * or singleton target beans, where the type can be determined through  * introspection. Just specify this in case of a prototype target,  * provided that you need matching by type (for example, for autowiring).  * @param resultType the result type, for example "java.lang.Integer"  */ public void setResultType(Class<?> resultType) {     this.resultType = resultType. }
true;public;1;4;/**  * The bean name of this PropertyPathFactoryBean will be interpreted  * as "beanName.property" pattern, if neither "targetObject" nor  * "targetBeanName" nor "propertyPath" have been specified.  * This allows for concise bean definitions with just an id/name.  */ ;/**  * The bean name of this PropertyPathFactoryBean will be interpreted  * as "beanName.property" pattern, if neither "targetObject" nor  * "targetBeanName" nor "propertyPath" have been specified.  * This allows for concise bean definitions with just an id/name.  */ @Override public void setBeanName(String beanName) {     this.beanName = StringUtils.trimAllWhitespace(BeanFactoryUtils.originalBeanName(beanName)). }
false;public;1;37;;@Override public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory.     if (this.targetBeanWrapper != null && this.targetBeanName != null) {         throw new IllegalArgumentException("Specify either 'targetObject' or 'targetBeanName', not both").     }     if (this.targetBeanWrapper == null && this.targetBeanName == null) {         if (this.propertyPath != null) {             throw new IllegalArgumentException("Specify 'targetObject' or 'targetBeanName' in combination with 'propertyPath'").         }         // No other properties specified: check bean name.         int dotIndex = (this.beanName != null ? this.beanName.indexOf('.') : -1).         if (dotIndex == -1) {             throw new IllegalArgumentException("Neither 'targetObject' nor 'targetBeanName' specified, and PropertyPathFactoryBean " + "bean name '" + this.beanName + "' does not follow 'beanName.property' syntax").         }         this.targetBeanName = this.beanName.substring(0, dotIndex).         this.propertyPath = this.beanName.substring(dotIndex + 1).     } else if (this.propertyPath == null) {         // either targetObject or targetBeanName specified         throw new IllegalArgumentException("'propertyPath' is required").     }     if (this.targetBeanWrapper == null && this.beanFactory.isSingleton(this.targetBeanName)) {         // Eagerly fetch singleton target bean, and determine result type.         Object bean = this.beanFactory.getBean(this.targetBeanName).         this.targetBeanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(bean).         this.resultType = this.targetBeanWrapper.getPropertyType(this.propertyPath).     } }
false;public;0;22;;@Override @Nullable public Object getObject() throws BeansException {     BeanWrapper target = this.targetBeanWrapper.     if (target != null) {         if (logger.isWarnEnabled() && this.targetBeanName != null && this.beanFactory instanceof ConfigurableBeanFactory && ((ConfigurableBeanFactory) this.beanFactory).isCurrentlyInCreation(this.targetBeanName)) {             logger.warn("Target bean '" + this.targetBeanName + "' is still in creation due to a circular " + "reference - obtained value for property '" + this.propertyPath + "' may be outdated!").         }     } else {         // Fetch prototype target bean...         Assert.state(this.beanFactory != null, "No BeanFactory available").         Assert.state(this.targetBeanName != null, "No target bean name specified").         Object bean = this.beanFactory.getBean(this.targetBeanName).         target = PropertyAccessorFactory.forBeanPropertyAccess(bean).     }     Assert.state(this.propertyPath != null, "No property path specified").     return target.getPropertyValue(this.propertyPath). }
false;public;0;4;;@Override public Class<?> getObjectType() {     return this.resultType. }
true;public;0;4;/**  * While this FactoryBean will often be used for singleton targets,  * the invoked getters for the property path might return a new object  * for each call, so we have to assume that we're not returning the  * same object for each {@link #getObject()} call.  */ ;/**  * While this FactoryBean will often be used for singleton targets,  * the invoked getters for the property path might return a new object  * for each call, so we have to assume that we're not returning the  * same object for each {@link #getObject()} call.  */ @Override public boolean isSingleton() {     return false. }
