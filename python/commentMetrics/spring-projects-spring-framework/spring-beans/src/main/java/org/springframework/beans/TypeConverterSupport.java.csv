commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override @Nullable public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {     return convertIfNecessary(value, requiredType, TypeDescriptor.valueOf(requiredType)). }
false;public;3;8;;@Override @Nullable public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable MethodParameter methodParam) throws TypeMismatchException {     return convertIfNecessary(value, requiredType, (methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType))). }
false;public;3;8;;@Override @Nullable public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field) throws TypeMismatchException {     return convertIfNecessary(value, requiredType, (field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType))). }
false;public;3;16;;@Nullable @Override public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {     Assert.state(this.typeConverterDelegate != null, "No TypeConverterDelegate").     try {         return this.typeConverterDelegate.convertIfNecessary(null, null, value, requiredType, typeDescriptor).     } catch (ConverterNotFoundException | IllegalStateException ex) {         throw new ConversionNotSupportedException(value, requiredType, ex).     } catch (ConversionException | IllegalArgumentException ex) {         throw new TypeMismatchException(value, requiredType, ex).     } }
