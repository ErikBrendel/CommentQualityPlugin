# id;timestamp;commentText;codeText;commentWords;codeWords
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, @Nullable Class<T> requiredType, @Nullable MethodParameter methodParam) 			throws IllegalArgumentException;1495868221;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, @Nullable Class<T> requiredType, @Nullable MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,nullable,class,t,required,type,nullable,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, @Nullable Class<T> requiredType, @Nullable MethodParameter methodParam) 			throws IllegalArgumentException;1496259743;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, @Nullable Class<T> requiredType, @Nullable MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,nullable,class,t,required,type,nullable,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType);1496837955;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;@Nullable_	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;nullable,private,property,editor,find,default,editor,nullable,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> @Nullable 	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType);1498780456;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;@Nullable_	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;nullable,private,property,editor,find,default,editor,nullable,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> @Nullable 	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType);1515363587;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;@Nullable_	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;nullable,private,property,editor,find,default,editor,nullable,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> @Nullable 	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType);1519588127;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;@Nullable_	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;nullable,private,property,editor,find,default,editor,nullable,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> @Nullable 	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType);1535316501;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;@Nullable_	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;nullable,private,property,editor,find,default,editor,nullable,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> @Nullable 	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType);1546963887;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;@Nullable_	private PropertyEditor findDefaultEditor(@Nullable Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;nullable,private,property,editor,find,default,editor,nullable,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1328020251;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1346774041;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1346774711;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1346790972;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1346799586;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1350077655;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1356735495;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1367574593;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1382141981;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1385412762;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1398638841;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1402942616;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1403205283;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1405696918;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1431462798;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1431986019;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1432125256;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1441034405;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1467288171;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1467677340;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1468948866;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1477690745;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1495868221;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject);1496259743;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> protected Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1328020251;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;protected Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;protected,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> protected Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1346774041;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;protected Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;protected,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> protected Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1346774711;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;protected Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;protected,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> protected Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1346790972;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;protected Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;protected,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject);1496837955;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,nullable,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject);1498780456;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,nullable,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject);1515363587;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,nullable,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject);1519588127;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,nullable,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject);1535316501;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,nullable,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject);1546963887;Create a new TypeConverterDelegate for the given editor registry and bean instance._@param propertyEditorRegistry the editor registry to use_@param targetObject the target object to work on (as context that can be passed to editors);public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry, @Nullable Object targetObject) {_		this.propertyEditorRegistry = propertyEditorRegistry__		this.targetObject = targetObject__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,and,bean,instance,param,property,editor,registry,the,editor,registry,to,use,param,target,object,the,target,object,to,work,on,as,context,that,can,be,passed,to,editors;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,nullable,object,target,object,this,property,editor,registry,property,editor,registry,this,target,object,target,object
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1328020251;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType, typeDescriptor)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection) convertedValue, propertyName, requiredType, typeDescriptor)__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map) convertedValue, propertyName, requiredType, typeDescriptor)__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (!requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor strCtor = requiredType.getConstructor(String.class)__							return (T) BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && convertedValue == newValue) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,type,descriptor,converted,value,do,convert,value,old,value,converted,value,required,type,editor,if,required,type,null,if,converted,value,null,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,required,type,is,interface,required,type,is,enum,try,constructor,str,ctor,required,type,get,constructor,string,class,return,t,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,converted,value,new,value,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1346774041;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType, typeDescriptor)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection) convertedValue, propertyName, requiredType, typeDescriptor)__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map) convertedValue, propertyName, requiredType, typeDescriptor)__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (!requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor strCtor = requiredType.getConstructor(String.class)__							return (T) BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && convertedValue == newValue && requiredType!=null && !ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,type,descriptor,converted,value,do,convert,value,old,value,converted,value,required,type,editor,if,required,type,null,if,converted,value,null,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,required,type,is,interface,required,type,is,enum,try,constructor,str,ctor,required,type,get,constructor,string,class,return,t,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,converted,value,new,value,required,type,null,class,utils,is,assignable,value,required,type,converted,value,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1346774711;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType, typeDescriptor)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection) convertedValue, propertyName, requiredType, typeDescriptor)__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map) convertedValue, propertyName, requiredType, typeDescriptor)__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (!requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor strCtor = requiredType.getConstructor(String.class)__							return (T) BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && convertedValue == newValue && requiredType != null &&_					!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,type,descriptor,converted,value,do,convert,value,old,value,converted,value,required,type,editor,if,required,type,null,if,converted,value,null,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,required,type,is,interface,required,type,is,enum,try,constructor,str,ctor,required,type,get,constructor,string,class,return,t,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,converted,value,new,value,required,type,null,class,utils,is,assignable,value,required,type,converted,value,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1346790972;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType, typeDescriptor)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection) convertedValue, propertyName, requiredType, typeDescriptor)__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map) convertedValue, propertyName, requiredType, typeDescriptor)__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (!requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor strCtor = requiredType.getConstructor(String.class)__							return (T) BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && convertedValue == newValue && requiredType != null &&_					!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,type,descriptor,converted,value,do,convert,value,old,value,converted,value,required,type,editor,if,required,type,null,if,converted,value,null,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,required,type,is,interface,required,type,is,enum,try,constructor,str,ctor,required,type,get,constructor,string,class,return,t,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,converted,value,new,value,required,type,null,class,utils,is,assignable,value,required,type,converted,value,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1346799586;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (!requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor strCtor = requiredType.getConstructor(String.class)__							return (T) BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,required,type,is,interface,required,type,is,enum,try,constructor,str,ctor,required,type,get,constructor,string,class,return,t,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1350077655;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor strCtor = requiredType.getConstructor(String.class)__							return (T) BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,str,ctor,required,type,get,constructor,string,class,return,t,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1356735495;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor strCtor = requiredType.getConstructor(String.class)__							return (T) BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,str,ctor,required,type,get,constructor,string,class,return,t,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1367574593;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor strCtor = requiredType.getConstructor(String.class)__							return (T) BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,str,ctor,required,type,get,constructor,string,class,return,t,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1382141981;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class.equals(requiredType)) {_					return (T) convertedValue__				}_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor strCtor = requiredType.getConstructor(String.class)__							return (T) BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,equals,required,type,return,t,converted,value,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,str,ctor,required,type,get,constructor,string,class,return,t,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1385412762;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class.equals(requiredType)) {_					return (T) convertedValue__				}_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,equals,required,type,return,t,converted,value,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1398638841;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class.equals(requiredType)) {_					return (T) convertedValue__				}_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,equals,required,type,return,t,converted,value,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1402942616;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class.equals(requiredType)) {_					return (T) convertedValue__				}_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}_			else if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {_				convertedValue = javaUtilOptionalEmpty__			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,equals,required,type,return,t,converted,value,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,required,type,equals,java,util,optional,empty,get,class,converted,value,java,util,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1403205283;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class.equals(requiredType)) {_					return (T) convertedValue__				}_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}_			else {_				_				if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {_					convertedValue = javaUtilOptionalEmpty__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,equals,required,type,return,t,converted,value,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,java,util,optional,empty,null,required,type,equals,java,util,optional,empty,get,class,converted,value,java,util,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1405696918;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class.equals(requiredType)) {_					return (T) convertedValue__				}_				if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_			}_			else {_				_				if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {_					convertedValue = javaUtilOptionalEmpty__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,equals,required,type,return,t,converted,value,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,java,util,optional,empty,null,required,type,equals,java,util,optional,empty,get,class,converted,value,java,util,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1431462798;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		Object convertedValue = newValue___		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException firstAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && convertedValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			TypeDescriptor targetTypeDesc = typeDescriptor__			if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {_				try {_					return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc)__				}_				catch (ConversionFailedException ex) {_					_					firstAttemptEx = ex__				}_			}_		}__		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class.equals(requiredType)) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (firstAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {_					convertedValue = javaUtilOptionalEmpty__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (firstAttemptEx != null) {_					throw firstAttemptEx__				}_				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (firstAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw firstAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", firstAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,object,converted,value,new,value,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,first,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,converted,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,type,descriptor,target,type,desc,type,descriptor,if,conversion,service,can,convert,source,type,desc,target,type,desc,try,return,t,conversion,service,convert,converted,value,source,type,desc,target,type,desc,catch,conversion,failed,exception,ex,first,attempt,ex,ex,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,equals,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,first,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,java,util,optional,empty,null,required,type,equals,java,util,optional,empty,get,class,converted,value,java,util,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,first,attempt,ex,null,throw,first,attempt,ex,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,first,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,first,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,first,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1431986019;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class.equals(requiredType)) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class.equals(requiredType) && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {_					convertedValue = javaUtilOptionalEmpty__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && !Object.class.equals(requiredType)) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,equals,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,equals,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,java,util,optional,empty,null,required,type,equals,java,util,optional,empty,get,class,converted,value,java,util,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,equals,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1432125256;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {_					convertedValue = javaUtilOptionalEmpty__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,java,util,optional,empty,null,required,type,equals,java,util,optional,empty,get,class,converted,value,java,util,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1441034405;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (requiredType != null && Collection.class.isAssignableFrom(requiredType) && convertedValue instanceof String) {_				TypeDescriptor elementType = typeDescriptor.getElementTypeDescriptor()__				if (elementType != null && Enum.class.isAssignableFrom(elementType.getType())) {_					convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {_					convertedValue = javaUtilOptionalEmpty__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,type,descriptor,get,element,type,descriptor,if,element,type,null,enum,class,is,assignable,from,element,type,get,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,java,util,optional,empty,null,required,type,equals,java,util,optional,empty,get,class,converted,value,java,util,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1467288171;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (javaUtilOptionalEmpty != null && requiredType.equals(javaUtilOptionalEmpty.getClass())) {_					convertedValue = javaUtilOptionalEmpty__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,java,util,optional,empty,null,required,type,equals,java,util,optional,empty,get,class,converted,value,java,util,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1467677340;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (requiredType == Optional.class) {_					convertedValue = Optional.empty()__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,required,type,optional,class,converted,value,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1468948866;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (requiredType == Optional.class) {_					convertedValue = Optional.empty()__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type [").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("] to required type [").append(ClassUtils.getQualifiedName(requiredType)).append("]")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type [").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("]")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,required,type,optional,class,converted,value,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue, 			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException;1477690745;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	public <T> T convertIfNecessary(String propertyName, Object oldValue, Object newValue,_			Class<T> requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (requiredType == Optional.class) {_					convertedValue = Optional.empty()__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type '").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("' to required type '").append(ClassUtils.getQualifiedName(requiredType)).append("'")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type '").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("'")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,required,type,optional,class,converted,value,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @Nullable 	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor);1496837955;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor) {__		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,private,object,do,convert,value,nullable,object,old,value,nullable,object,new,value,nullable,class,required,type,nullable,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> @Nullable 	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor);1498780456;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor) {__		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,private,object,do,convert,value,nullable,object,old,value,nullable,object,new,value,nullable,class,required,type,nullable,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> @Nullable 	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor);1515363587;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor) {__		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,private,object,do,convert,value,nullable,object,old,value,nullable,object,new,value,nullable,class,required,type,nullable,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> @Nullable 	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor);1519588127;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor) {__		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,private,object,do,convert,value,nullable,object,old,value,nullable,object,new,value,nullable,class,required,type,nullable,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> @Nullable 	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor);1535316501;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor) {__		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,private,object,do,convert,value,nullable,object,old,value,nullable,object,new,value,nullable,class,required,type,nullable,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> @Nullable 	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor);1546963887;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	private Object doConvertValue(@Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<?> requiredType, @Nullable PropertyEditor editor) {__		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,private,object,do,convert,value,nullable,object,old,value,nullable,object,new,value,nullable,class,required,type,nullable,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1385412762;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1398638841;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1402942616;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1403205283;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1405696918;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1431462798;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1431986019;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1432125256;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1441034405;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1467288171;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1467677340;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1468948866;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class<?> requiredType);1477690745;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1346799586;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue__		boolean sharedEditor = false___		if (editor != null) {_			sharedEditor = this.propertyEditorRegistry.isSharedEditor(editor)__		}__		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				Object newConvertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						editor.setValue(convertedValue)__						newConvertedValue = editor.getValue()__					}_				}_				else {_					_					editor.setValue(convertedValue)__					newConvertedValue = editor.getValue()__				}_				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						return doConvertTextValue(oldValue, newTextValue, editor)__					}_				}_				else {_					_					return doConvertTextValue(oldValue, newTextValue, editor)__				}_			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,boolean,shared,editor,false,if,editor,null,shared,editor,this,property,editor,registry,is,shared,editor,editor,if,editor,null,converted,value,instanceof,string,try,object,new,converted,value,if,shared,editor,synchronized,editor,editor,set,value,converted,value,new,converted,value,editor,get,value,else,editor,set,value,converted,value,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,if,shared,editor,synchronized,editor,return,do,convert,text,value,old,value,new,text,value,editor,else,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1350077655;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue__		boolean sharedEditor = false___		if (editor != null) {_			sharedEditor = this.propertyEditorRegistry.isSharedEditor(editor)__		}__		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				Object newConvertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						editor.setValue(convertedValue)__						newConvertedValue = editor.getValue()__					}_				}_				else {_					_					editor.setValue(convertedValue)__					newConvertedValue = editor.getValue()__				}_				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						return doConvertTextValue(oldValue, newTextValue, editor)__					}_				}_				else {_					_					return doConvertTextValue(oldValue, newTextValue, editor)__				}_			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,boolean,shared,editor,false,if,editor,null,shared,editor,this,property,editor,registry,is,shared,editor,editor,if,editor,null,converted,value,instanceof,string,try,object,new,converted,value,if,shared,editor,synchronized,editor,editor,set,value,converted,value,new,converted,value,editor,get,value,else,editor,set,value,converted,value,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,if,shared,editor,synchronized,editor,return,do,convert,text,value,old,value,new,text,value,editor,else,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1356735495;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue__		boolean sharedEditor = false___		if (editor != null) {_			sharedEditor = this.propertyEditorRegistry.isSharedEditor(editor)__		}__		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				Object newConvertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						editor.setValue(convertedValue)__						newConvertedValue = editor.getValue()__					}_				}_				else {_					_					editor.setValue(convertedValue)__					newConvertedValue = editor.getValue()__				}_				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						return doConvertTextValue(oldValue, newTextValue, editor)__					}_				}_				else {_					_					return doConvertTextValue(oldValue, newTextValue, editor)__				}_			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,boolean,shared,editor,false,if,editor,null,shared,editor,this,property,editor,registry,is,shared,editor,editor,if,editor,null,converted,value,instanceof,string,try,object,new,converted,value,if,shared,editor,synchronized,editor,editor,set,value,converted,value,new,converted,value,editor,get,value,else,editor,set,value,converted,value,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,if,shared,editor,synchronized,editor,return,do,convert,text,value,old,value,new,text,value,editor,else,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1367574593;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1382141981;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1385412762;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1398638841;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1402942616;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1403205283;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1405696918;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1431462798;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1431986019;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1432125256;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1441034405;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1467288171;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1467677340;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1468948866;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1477690745;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1346799586;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1350077655;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1356735495;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1367574593;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1382141981;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1385412762;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1398638841;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1402942616;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1403205283;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1405696918;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1431462798;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1431986019;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1432125256;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1441034405;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1467288171;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1467677340;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1468948866;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor);1477690745;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class<T> requiredType) 			throws IllegalArgumentException;1495868221;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,nullable,object,old,value,object,new,value,nullable,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class<T> requiredType) 			throws IllegalArgumentException;1496259743;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,nullable,object,old,value,object,new,value,nullable,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1346790972;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be <code>null</code>)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,code,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1346799586;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be <code>null</code>)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,code,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1350077655;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be <code>null</code>)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,code,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1356735495;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1367574593;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1382141981;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1385412762;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1398638841;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1402942616;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1403205283;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1405696918;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1431462798;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1431986019;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1432125256;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1441034405;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1467288171;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1467677340;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1468948866;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field) 			throws IllegalArgumentException;1477690745;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor);1495868221;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,nullable,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor);1496259743;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,nullable,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor);1496837955;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,nullable,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor);1498780456;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,nullable,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor);1515363587;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,nullable,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor);1519588127;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,nullable,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor);1535316501;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,nullable,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor);1546963887;Convert the given text value using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newTextValue the proposed text value_@param editor the PropertyEditor to use_@return the converted value;private Object doConvertTextValue(@Nullable Object oldValue, String newTextValue, PropertyEditor editor) {_		try {_			editor.setValue(oldValue)__		}_		catch (Exception ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__			}_			_		}_		editor.setAsText(newTextValue)__		return editor.getValue()__	};convert,the,given,text,value,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,text,value,the,proposed,text,value,param,editor,the,property,editor,to,use,return,the,converted,value;private,object,do,convert,text,value,nullable,object,old,value,string,new,text,value,property,editor,editor,try,editor,set,value,old,value,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,editor,set,as,text,new,text,value,return,editor,get,value
TypeConverterDelegate -> protected Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1328020251;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;protected Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue__		boolean sharedEditor = false___		if (editor != null) {_			sharedEditor = this.propertyEditorRegistry.isSharedEditor(editor)__		}__		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				Object newConvertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						editor.setValue(convertedValue)__						newConvertedValue = editor.getValue()__					}_				}_				else {_					_					editor.setValue(convertedValue)__					newConvertedValue = editor.getValue()__				}_				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						return doConvertTextValue(oldValue, newTextValue, editor)__					}_				}_				else {_					_					return doConvertTextValue(oldValue, newTextValue, editor)__				}_			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;protected,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,boolean,shared,editor,false,if,editor,null,shared,editor,this,property,editor,registry,is,shared,editor,editor,if,editor,null,converted,value,instanceof,string,try,object,new,converted,value,if,shared,editor,synchronized,editor,editor,set,value,converted,value,new,converted,value,editor,get,value,else,editor,set,value,converted,value,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,if,shared,editor,synchronized,editor,return,do,convert,text,value,old,value,new,text,value,editor,else,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> protected Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1346774041;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;protected Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue__		boolean sharedEditor = false___		if (editor != null) {_			sharedEditor = this.propertyEditorRegistry.isSharedEditor(editor)__		}__		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				Object newConvertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						editor.setValue(convertedValue)__						newConvertedValue = editor.getValue()__					}_				}_				else {_					_					editor.setValue(convertedValue)__					newConvertedValue = editor.getValue()__				}_				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						return doConvertTextValue(oldValue, newTextValue, editor)__					}_				}_				else {_					_					return doConvertTextValue(oldValue, newTextValue, editor)__				}_			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;protected,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,boolean,shared,editor,false,if,editor,null,shared,editor,this,property,editor,registry,is,shared,editor,editor,if,editor,null,converted,value,instanceof,string,try,object,new,converted,value,if,shared,editor,synchronized,editor,editor,set,value,converted,value,new,converted,value,editor,get,value,else,editor,set,value,converted,value,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,if,shared,editor,synchronized,editor,return,do,convert,text,value,old,value,new,text,value,editor,else,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> protected Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1346774711;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;protected Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue__		boolean sharedEditor = false___		if (editor != null) {_			sharedEditor = this.propertyEditorRegistry.isSharedEditor(editor)__		}__		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				Object newConvertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						editor.setValue(convertedValue)__						newConvertedValue = editor.getValue()__					}_				}_				else {_					_					editor.setValue(convertedValue)__					newConvertedValue = editor.getValue()__				}_				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						return doConvertTextValue(oldValue, newTextValue, editor)__					}_				}_				else {_					_					return doConvertTextValue(oldValue, newTextValue, editor)__				}_			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;protected,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,boolean,shared,editor,false,if,editor,null,shared,editor,this,property,editor,registry,is,shared,editor,editor,if,editor,null,converted,value,instanceof,string,try,object,new,converted,value,if,shared,editor,synchronized,editor,editor,set,value,converted,value,new,converted,value,editor,get,value,else,editor,set,value,converted,value,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,if,shared,editor,synchronized,editor,return,do,convert,text,value,old,value,new,text,value,editor,else,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> protected Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor);1346790972;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;protected Object doConvertValue(Object oldValue, Object newValue, Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue__		boolean sharedEditor = false___		if (editor != null) {_			sharedEditor = this.propertyEditorRegistry.isSharedEditor(editor)__		}__		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				Object newConvertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						editor.setValue(convertedValue)__						newConvertedValue = editor.getValue()__					}_				}_				else {_					_					editor.setValue(convertedValue)__					newConvertedValue = editor.getValue()__				}_				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				if (sharedEditor) {_					_					synchronized (editor) {_						return doConvertTextValue(oldValue, newTextValue, editor)__					}_				}_				else {_					_					return doConvertTextValue(oldValue, newTextValue, editor)__				}_			}_			else if (String.class.equals(requiredType)) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;protected,object,do,convert,value,object,old,value,object,new,value,class,required,type,property,editor,editor,object,converted,value,new,value,boolean,shared,editor,false,if,editor,null,shared,editor,this,property,editor,registry,is,shared,editor,editor,if,editor,null,converted,value,instanceof,string,try,object,new,converted,value,if,shared,editor,synchronized,editor,editor,set,value,converted,value,new,converted,value,editor,get,value,else,editor,set,value,converted,value,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,if,shared,editor,synchronized,editor,return,do,convert,text,value,old,value,new,text,value,editor,else,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,equals,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> @Nullable 	private PropertyEditor findDefaultEditor(Class<?> requiredType);1495868221;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;@Nullable_	private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;nullable,private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> @Nullable 	private PropertyEditor findDefaultEditor(Class<?> requiredType);1496259743;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;@Nullable_	private PropertyEditor findDefaultEditor(Class<?> requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && String.class != requiredType) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;nullable,private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, 			@Nullable MethodParameter methodParam) throws IllegalArgumentException;1496837955;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType,_			@Nullable MethodParameter methodParam) throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, 			@Nullable MethodParameter methodParam) throws IllegalArgumentException;1498780456;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType,_			@Nullable MethodParameter methodParam) throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, 			@Nullable MethodParameter methodParam) throws IllegalArgumentException;1515363587;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType,_			@Nullable MethodParameter methodParam) throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, 			@Nullable MethodParameter methodParam) throws IllegalArgumentException;1519588127;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType,_			@Nullable MethodParameter methodParam) throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, 			@Nullable MethodParameter methodParam) throws IllegalArgumentException;1535316501;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType,_			@Nullable MethodParameter methodParam) throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> private Object doConvertValue(@Nullable Object oldValue, Object newValue, @Nullable Class<?> requiredType, PropertyEditor editor);1495868221;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(@Nullable Object oldValue, Object newValue, @Nullable Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,nullable,object,old,value,object,new,value,nullable,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> private Object doConvertValue(@Nullable Object oldValue, Object newValue, @Nullable Class<?> requiredType, PropertyEditor editor);1496259743;Convert the value to the required type (if necessary from a String),_using the given property editor._@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param editor the PropertyEditor to use_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;private Object doConvertValue(@Nullable Object oldValue, Object newValue, @Nullable Class<?> requiredType, PropertyEditor editor) {_		Object convertedValue = newValue___		if (editor != null && !(convertedValue instanceof String)) {_			_			_			_			_			try {_				editor.setValue(convertedValue)__				Object newConvertedValue = editor.getValue()__				if (newConvertedValue != convertedValue) {_					convertedValue = newConvertedValue__					_					_					editor = null__				}_			}_			catch (Exception ex) {_				if (logger.isDebugEnabled()) {_					logger.debug("PropertyEditor [" + editor.getClass().getName() + "] does not support setValue call", ex)__				}_				_			}_		}__		Object returnValue = convertedValue___		if (requiredType != null && !requiredType.isArray() && convertedValue instanceof String[]) {_			_			_			_			if (logger.isTraceEnabled()) {_				logger.trace("Converting String array to comma-delimited String [" + convertedValue + "]")__			}_			convertedValue = StringUtils.arrayToCommaDelimitedString((String[]) convertedValue)__		}__		if (convertedValue instanceof String) {_			if (editor != null) {_				_				if (logger.isTraceEnabled()) {_					logger.trace("Converting String to [" + requiredType + "] using property editor [" + editor + "]")__				}_				String newTextValue = (String) convertedValue__				return doConvertTextValue(oldValue, newTextValue, editor)__			}_			else if (String.class == requiredType) {_				returnValue = convertedValue__			}_		}__		return returnValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,using,the,given,property,editor,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,editor,the,property,editor,to,use,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;private,object,do,convert,value,nullable,object,old,value,object,new,value,nullable,class,required,type,property,editor,editor,object,converted,value,new,value,if,editor,null,converted,value,instanceof,string,try,editor,set,value,converted,value,object,new,converted,value,editor,get,value,if,new,converted,value,converted,value,converted,value,new,converted,value,editor,null,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,property,editor,editor,get,class,get,name,does,not,support,set,value,call,ex,object,return,value,converted,value,if,required,type,null,required,type,is,array,converted,value,instanceof,string,if,logger,is,trace,enabled,logger,trace,converting,string,array,to,comma,delimited,string,converted,value,converted,value,string,utils,array,to,comma,delimited,string,string,converted,value,if,converted,value,instanceof,string,if,editor,null,if,logger,is,trace,enabled,logger,trace,converting,string,to,required,type,using,property,editor,editor,string,new,text,value,string,converted,value,return,do,convert,text,value,old,value,new,text,value,editor,else,if,string,class,required,type,return,value,converted,value,return,return,value
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field) 			throws IllegalArgumentException;1496837955;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field) 			throws IllegalArgumentException;1498780456;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field) 			throws IllegalArgumentException;1515363587;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field) 			throws IllegalArgumentException;1519588127;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field) 			throws IllegalArgumentException;1535316501;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,object,new,value,nullable,class,t,required,type,nullable,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> protected PropertyEditor findDefaultEditor(Class requiredType, TypeDescriptor typeDescriptor);1328020251;Find a default editor for the given type._@param requiredType the type to find an editor for_@param descriptor the JavaBeans descriptor for the property_@return the corresponding editor, or <code>null</code> if none;protected PropertyEditor findDefaultEditor(Class requiredType, TypeDescriptor typeDescriptor) {_		PropertyEditor editor = null__		_			_			_		_		if (editor == null && requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,param,descriptor,the,java,beans,descriptor,for,the,property,return,the,corresponding,editor,or,code,null,code,if,none;protected,property,editor,find,default,editor,class,required,type,type,descriptor,type,descriptor,property,editor,editor,null,if,editor,null,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> protected PropertyEditor findDefaultEditor(Class requiredType, TypeDescriptor typeDescriptor);1346774041;Find a default editor for the given type._@param requiredType the type to find an editor for_@param descriptor the JavaBeans descriptor for the property_@return the corresponding editor, or <code>null</code> if none;protected PropertyEditor findDefaultEditor(Class requiredType, TypeDescriptor typeDescriptor) {_		PropertyEditor editor = null__		_			_			_		_		if (editor == null && requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,param,descriptor,the,java,beans,descriptor,for,the,property,return,the,corresponding,editor,or,code,null,code,if,none;protected,property,editor,find,default,editor,class,required,type,type,descriptor,type,descriptor,property,editor,editor,null,if,editor,null,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> protected PropertyEditor findDefaultEditor(Class requiredType, TypeDescriptor typeDescriptor);1346774711;Find a default editor for the given type._@param requiredType the type to find an editor for_@param descriptor the JavaBeans descriptor for the property_@return the corresponding editor, or <code>null</code> if none;protected PropertyEditor findDefaultEditor(Class requiredType, TypeDescriptor typeDescriptor) {_		PropertyEditor editor = null__		_			_			_		_		if (editor == null && requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,param,descriptor,the,java,beans,descriptor,for,the,property,return,the,corresponding,editor,or,code,null,code,if,none;protected,property,editor,find,default,editor,class,required,type,type,descriptor,type,descriptor,property,editor,editor,null,if,editor,null,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> protected PropertyEditor findDefaultEditor(Class requiredType, TypeDescriptor typeDescriptor);1346790972;Find a default editor for the given type._@param requiredType the type to find an editor for_@param descriptor the JavaBeans descriptor for the property_@return the corresponding editor, or <code>null</code> if none;protected PropertyEditor findDefaultEditor(Class requiredType, TypeDescriptor typeDescriptor) {_		PropertyEditor editor = null__		_			_			_		_		if (editor == null && requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,param,descriptor,the,java,beans,descriptor,for,the,property,return,the,corresponding,editor,or,code,null,code,if,none;protected,property,editor,find,default,editor,class,required,type,type,descriptor,type,descriptor,property,editor,editor,null,if,editor,null,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1328020251;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be <code>null</code>)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,code,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1346774041;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be <code>null</code>)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,code,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1346774711;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be <code>null</code>)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,code,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1346790972;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be <code>null</code>)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,code,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1346799586;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be <code>null</code>)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,code,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1350077655;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be <code>null</code>)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,code,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1356735495;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1367574593;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1382141981;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1385412762;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1398638841;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1402942616;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1403205283;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1405696918;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1431462798;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1431986019;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1432125256;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1441034405;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1467288171;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1467677340;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1468948866;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam) 			throws IllegalArgumentException;1477690745;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param methodParam the method parameter that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, Class<T> requiredType, MethodParameter methodParam)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(methodParam != null ? new TypeDescriptor(methodParam) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,method,param,the,method,parameter,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,class,t,required,type,method,parameter,method,param,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,method,param,null,new,type,descriptor,method,param,type,descriptor,value,of,required,type
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class requiredType);1346799586;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or <code>null</code> if none;private PropertyEditor findDefaultEditor(Class requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,code,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class requiredType);1350077655;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or <code>null</code> if none;private PropertyEditor findDefaultEditor(Class requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,code,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class requiredType);1356735495;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class requiredType);1367574593;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> private PropertyEditor findDefaultEditor(Class requiredType);1382141981;Find a default editor for the given type._@param requiredType the type to find an editor for_@return the corresponding editor, or {@code null} if none;private PropertyEditor findDefaultEditor(Class requiredType) {_		PropertyEditor editor = null__		if (requiredType != null) {_			_			editor = this.propertyEditorRegistry.getDefaultEditor(requiredType)__			if (editor == null && !String.class.equals(requiredType)) {_				_				editor = BeanUtils.findEditorByConvention(requiredType)__			}_		}_		return editor__	};find,a,default,editor,for,the,given,type,param,required,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none;private,property,editor,find,default,editor,class,required,type,property,editor,editor,null,if,required,type,null,editor,this,property,editor,registry,get,default,editor,required,type,if,editor,null,string,class,equals,required,type,editor,bean,utils,find,editor,by,convention,required,type,return,editor
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, 			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException;1496837955;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,_			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,object,new,value,nullable,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, 			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException;1498780456;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,_			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,object,new,value,nullable,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, 			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException;1515363587;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,_			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,object,new,value,nullable,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, 			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException;1519588127;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,_			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,object,new,value,nullable,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, 			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException;1535316501;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,_			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,object,new,value,nullable,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> @Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, 			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException;1546963887;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue,_			Object newValue, @Nullable Class<T> requiredType) throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,object,new,value,nullable,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	@Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException;1496837955;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (requiredType == Optional.class) {_					convertedValue = Optional.empty()__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null && typeDescriptor != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type '").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("' to required type '").append(ClassUtils.getQualifiedName(requiredType)).append("'")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type '").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("'")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,nullable,object,new,value,nullable,class,t,required,type,nullable,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,required,type,optional,class,converted,value,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	@Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException;1498780456;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (requiredType == Optional.class) {_					convertedValue = Optional.empty()__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null && typeDescriptor != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type '").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("' to required type '").append(ClassUtils.getQualifiedName(requiredType)).append("'")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type '").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("'")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,nullable,object,new,value,nullable,class,t,required,type,nullable,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,required,type,optional,class,converted,value,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	@Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException;1515363587;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (requiredType == Optional.class) {_					convertedValue = Optional.empty()__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null && typeDescriptor != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type '").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("' to required type '").append(ClassUtils.getQualifiedName(requiredType)).append("'")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type '").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("'")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,nullable,object,new,value,nullable,class,t,required,type,nullable,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,required,type,optional,class,converted,value,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	@Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException;1519588127;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && "".equals(trimmedValue)) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (requiredType == Optional.class) {_					convertedValue = Optional.empty()__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null && typeDescriptor != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type '").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("' to required type '").append(ClassUtils.getQualifiedName(requiredType)).append("'")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type '").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("'")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,nullable,object,new,value,nullable,class,t,required,type,nullable,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,equals,trimmed,value,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,required,type,optional,class,converted,value,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	@Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException;1535316501;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && trimmedValue.isEmpty()) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (requiredType == Optional.class) {_					convertedValue = Optional.empty()__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null && typeDescriptor != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type '").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("' to required type '").append(ClassUtils.getQualifiedName(requiredType)).append("'")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type '").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("'")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,nullable,object,new,value,nullable,class,t,required,type,nullable,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,trimmed,value,is,empty,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,required,type,optional,class,converted,value,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> @SuppressWarnings("unchecked") 	@Nullable 	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, 			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException;1546963887;Convert the value to the required type (if necessary from a String),_for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param typeDescriptor the descriptor for the target property or field_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;@SuppressWarnings("unchecked")_	@Nullable_	public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,_			@Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {__		_		PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName)___		ConversionFailedException conversionAttemptEx = null___		_		ConversionService conversionService = this.propertyEditorRegistry.getConversionService()__		if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {_			TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__			if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_				try {_					return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__				}_				catch (ConversionFailedException ex) {_					_					conversionAttemptEx = ex__				}_			}_		}__		Object convertedValue = newValue___		_		if (editor != null || (requiredType != null && !ClassUtils.isAssignableValue(requiredType, convertedValue))) {_			if (typeDescriptor != null && requiredType != null && Collection.class.isAssignableFrom(requiredType) &&_					convertedValue instanceof String) {_				TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor()__				if (elementTypeDesc != null) {_					Class<?> elementType = elementTypeDesc.getType()__					if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_				}_			}_			if (editor == null) {_				editor = findDefaultEditor(requiredType)__			}_			convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor)__		}__		boolean standardConversion = false___		if (requiredType != null) {_			__			if (convertedValue != null) {_				if (Object.class == requiredType) {_					return (T) convertedValue__				}_				else if (requiredType.isArray()) {_					_					if (convertedValue instanceof String && Enum.class.isAssignableFrom(requiredType.getComponentType())) {_						convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue)__					}_					return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType())__				}_				else if (convertedValue instanceof Collection) {_					_					convertedValue = convertToTypedCollection(_							(Collection<?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				else if (convertedValue instanceof Map) {_					_					convertedValue = convertToTypedMap(_							(Map<?, ?>) convertedValue, propertyName, requiredType, typeDescriptor)__					standardConversion = true__				}_				if (convertedValue.getClass().isArray() && Array.getLength(convertedValue) == 1) {_					convertedValue = Array.get(convertedValue, 0)__					standardConversion = true__				}_				if (String.class == requiredType && ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {_					_					return (T) convertedValue.toString()__				}_				else if (convertedValue instanceof String && !requiredType.isInstance(convertedValue)) {_					if (conversionAttemptEx == null && !requiredType.isInterface() && !requiredType.isEnum()) {_						try {_							Constructor<T> strCtor = requiredType.getConstructor(String.class)__							return BeanUtils.instantiateClass(strCtor, convertedValue)__						}_						catch (NoSuchMethodException ex) {_							_							if (logger.isTraceEnabled()) {_								logger.trace("No String constructor found on type [" + requiredType.getName() + "]", ex)__							}_						}_						catch (Exception ex) {_							if (logger.isDebugEnabled()) {_								logger.debug("Construction via String failed for type [" + requiredType.getName() + "]", ex)__							}_						}_					}_					String trimmedValue = ((String) convertedValue).trim()__					if (requiredType.isEnum() && trimmedValue.isEmpty()) {_						_						return null__					}_					convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue)__					standardConversion = true__				}_				else if (convertedValue instanceof Number && Number.class.isAssignableFrom(requiredType)) {_					convertedValue = NumberUtils.convertNumberToTargetClass(_							(Number) convertedValue, (Class<Number>) requiredType)__					standardConversion = true__				}_			}_			else {_				_				if (requiredType == Optional.class) {_					convertedValue = Optional.empty()__				}_			}__			if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {_				if (conversionAttemptEx != null) {_					_					throw conversionAttemptEx__				}_				else if (conversionService != null && typeDescriptor != null) {_					_					_					TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue)__					if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {_						return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor)__					}_				}__				_				StringBuilder msg = new StringBuilder()__				msg.append("Cannot convert value of type '").append(ClassUtils.getDescriptiveType(newValue))__				msg.append("' to required type '").append(ClassUtils.getQualifiedName(requiredType)).append("'")__				if (propertyName != null) {_					msg.append(" for property '").append(propertyName).append("'")__				}_				if (editor != null) {_					msg.append(": PropertyEditor [").append(editor.getClass().getName()).append(_							"] returned inappropriate value of type '").append(_							ClassUtils.getDescriptiveType(convertedValue)).append("'")__					throw new IllegalArgumentException(msg.toString())__				}_				else {_					msg.append(": no matching editors or conversion strategy found")__					throw new IllegalStateException(msg.toString())__				}_			}_		}__		if (conversionAttemptEx != null) {_			if (editor == null && !standardConversion && requiredType != null && Object.class != requiredType) {_				throw conversionAttemptEx__			}_			logger.debug("Original ConversionService attempt failed - ignored since " +_					"PropertyEditor based conversion eventually succeeded", conversionAttemptEx)__		}__		return (T) convertedValue__	};convert,the,value,to,the,required,type,if,necessary,from,a,string,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,type,descriptor,the,descriptor,for,the,target,property,or,field,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;suppress,warnings,unchecked,nullable,public,t,t,convert,if,necessary,nullable,string,property,name,nullable,object,old,value,nullable,object,new,value,nullable,class,t,required,type,nullable,type,descriptor,type,descriptor,throws,illegal,argument,exception,property,editor,editor,this,property,editor,registry,find,custom,editor,required,type,property,name,conversion,failed,exception,conversion,attempt,ex,null,conversion,service,conversion,service,this,property,editor,registry,get,conversion,service,if,editor,null,conversion,service,null,new,value,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,try,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,catch,conversion,failed,exception,ex,conversion,attempt,ex,ex,object,converted,value,new,value,if,editor,null,required,type,null,class,utils,is,assignable,value,required,type,converted,value,if,type,descriptor,null,required,type,null,collection,class,is,assignable,from,required,type,converted,value,instanceof,string,type,descriptor,element,type,desc,type,descriptor,get,element,type,descriptor,if,element,type,desc,null,class,element,type,element,type,desc,get,type,if,class,class,element,type,enum,class,is,assignable,from,element,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,if,editor,null,editor,find,default,editor,required,type,converted,value,do,convert,value,old,value,converted,value,required,type,editor,boolean,standard,conversion,false,if,required,type,null,if,converted,value,null,if,object,class,required,type,return,t,converted,value,else,if,required,type,is,array,if,converted,value,instanceof,string,enum,class,is,assignable,from,required,type,get,component,type,converted,value,string,utils,comma,delimited,list,to,string,array,string,converted,value,return,t,convert,to,typed,array,converted,value,property,name,required,type,get,component,type,else,if,converted,value,instanceof,collection,converted,value,convert,to,typed,collection,collection,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,else,if,converted,value,instanceof,map,converted,value,convert,to,typed,map,map,converted,value,property,name,required,type,type,descriptor,standard,conversion,true,if,converted,value,get,class,is,array,array,get,length,converted,value,1,converted,value,array,get,converted,value,0,standard,conversion,true,if,string,class,required,type,class,utils,is,primitive,or,wrapper,converted,value,get,class,return,t,converted,value,to,string,else,if,converted,value,instanceof,string,required,type,is,instance,converted,value,if,conversion,attempt,ex,null,required,type,is,interface,required,type,is,enum,try,constructor,t,str,ctor,required,type,get,constructor,string,class,return,bean,utils,instantiate,class,str,ctor,converted,value,catch,no,such,method,exception,ex,if,logger,is,trace,enabled,logger,trace,no,string,constructor,found,on,type,required,type,get,name,ex,catch,exception,ex,if,logger,is,debug,enabled,logger,debug,construction,via,string,failed,for,type,required,type,get,name,ex,string,trimmed,value,string,converted,value,trim,if,required,type,is,enum,trimmed,value,is,empty,return,null,converted,value,attempt,to,convert,string,to,enum,required,type,trimmed,value,converted,value,standard,conversion,true,else,if,converted,value,instanceof,number,number,class,is,assignable,from,required,type,converted,value,number,utils,convert,number,to,target,class,number,converted,value,class,number,required,type,standard,conversion,true,else,if,required,type,optional,class,converted,value,optional,empty,if,class,utils,is,assignable,value,required,type,converted,value,if,conversion,attempt,ex,null,throw,conversion,attempt,ex,else,if,conversion,service,null,type,descriptor,null,type,descriptor,source,type,desc,type,descriptor,for,object,new,value,if,conversion,service,can,convert,source,type,desc,type,descriptor,return,t,conversion,service,convert,new,value,source,type,desc,type,descriptor,string,builder,msg,new,string,builder,msg,append,cannot,convert,value,of,type,append,class,utils,get,descriptive,type,new,value,msg,append,to,required,type,append,class,utils,get,qualified,name,required,type,append,if,property,name,null,msg,append,for,property,append,property,name,append,if,editor,null,msg,append,property,editor,append,editor,get,class,get,name,append,returned,inappropriate,value,of,type,append,class,utils,get,descriptive,type,converted,value,append,throw,new,illegal,argument,exception,msg,to,string,else,msg,append,no,matching,editors,or,conversion,strategy,found,throw,new,illegal,state,exception,msg,to,string,if,conversion,attempt,ex,null,if,editor,null,standard,conversion,required,type,null,object,class,required,type,throw,conversion,attempt,ex,logger,debug,original,conversion,service,attempt,failed,ignored,since,property,editor,based,conversion,eventually,succeeded,conversion,attempt,ex,return,t,converted,value
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1328020251;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1346774041;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1346774711;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1346790972;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1346799586;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1350077655;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1356735495;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1367574593;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1382141981;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1385412762;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1398638841;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1402942616;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1403205283;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1405696918;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1431462798;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1431986019;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1432125256;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1441034405;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1467288171;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1467677340;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1468948866;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1477690745;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1495868221;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1496259743;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1496837955;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1498780456;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1515363587;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1519588127;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1535316501;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry);1546963887;Create a new TypeConverterDelegate for the given editor registry._@param propertyEditorRegistry the editor registry to use;public TypeConverterDelegate(PropertyEditorRegistrySupport propertyEditorRegistry) {_		this(propertyEditorRegistry, null)__	};create,a,new,type,converter,delegate,for,the,given,editor,registry,param,property,editor,registry,the,editor,registry,to,use;public,type,converter,delegate,property,editor,registry,support,property,editor,registry,this,property,editor,registry,null
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1328020251;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1346774041;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1346774711;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1346790972;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1346799586;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1350077655;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be <code>null</code>)_@param newValue the proposed new value_@param requiredType the type we must convert to_(or <code>null</code> if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,code,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,code,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1356735495;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1367574593;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1382141981;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1385412762;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1398638841;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1402942616;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1403205283;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1405696918;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1431462798;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1431986019;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1432125256;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1441034405;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1467288171;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1467677340;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1468948866;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary( 			String propertyName, Object oldValue, Object newValue, Class<T> requiredType) 			throws IllegalArgumentException;1477690745;Convert the value to the required type for the specified property._@param propertyName name of the property_@param oldValue the previous value, if available (may be {@code null})_@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(_			String propertyName, Object oldValue, Object newValue, Class<T> requiredType)_			throws IllegalArgumentException {__		return convertIfNecessary(propertyName, oldValue, newValue, requiredType, TypeDescriptor.valueOf(requiredType))__	};convert,the,value,to,the,required,type,for,the,specified,property,param,property,name,name,of,the,property,param,old,value,the,previous,value,if,available,may,be,code,null,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,string,property,name,object,old,value,object,new,value,class,t,required,type,throws,illegal,argument,exception,return,convert,if,necessary,property,name,old,value,new,value,required,type,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, @Nullable Class<T> requiredType, @Nullable Field field) 			throws IllegalArgumentException;1495868221;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, @Nullable Class<T> requiredType, @Nullable Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,nullable,class,t,required,type,nullable,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
TypeConverterDelegate -> public <T> T convertIfNecessary(Object newValue, @Nullable Class<T> requiredType, @Nullable Field field) 			throws IllegalArgumentException;1496259743;Convert the value to the specified required type._@param newValue the proposed new value_@param requiredType the type we must convert to_(or {@code null} if not known, for example in case of a collection element)_@param field the reflective field that is the target of the conversion_(may be {@code null})_@return the new value, possibly the result of type conversion_@throws IllegalArgumentException if type conversion failed;public <T> T convertIfNecessary(Object newValue, @Nullable Class<T> requiredType, @Nullable Field field)_			throws IllegalArgumentException {__		return convertIfNecessary(null, null, newValue, requiredType,_				(field != null ? new TypeDescriptor(field) : TypeDescriptor.valueOf(requiredType)))__	};convert,the,value,to,the,specified,required,type,param,new,value,the,proposed,new,value,param,required,type,the,type,we,must,convert,to,or,code,null,if,not,known,for,example,in,case,of,a,collection,element,param,field,the,reflective,field,that,is,the,target,of,the,conversion,may,be,code,null,return,the,new,value,possibly,the,result,of,type,conversion,throws,illegal,argument,exception,if,type,conversion,failed;public,t,t,convert,if,necessary,object,new,value,nullable,class,t,required,type,nullable,field,field,throws,illegal,argument,exception,return,convert,if,necessary,null,null,new,value,required,type,field,null,new,type,descriptor,field,type,descriptor,value,of,required,type
