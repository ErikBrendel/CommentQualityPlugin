commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Create PropertyMatches for the given bean property.  * @param propertyName the name of the property to find possible matches for  * @param beanClass the bean class to search for matches  */ ;// Static factory methods /**  * Create PropertyMatches for the given bean property.  * @param propertyName the name of the property to find possible matches for  * @param beanClass the bean class to search for matches  */ public static PropertyMatches forProperty(String propertyName, Class<?> beanClass) {     return forProperty(propertyName, beanClass, DEFAULT_MAX_DISTANCE). }
true;public,static;3;3;/**  * Create PropertyMatches for the given bean property.  * @param propertyName the name of the property to find possible matches for  * @param beanClass the bean class to search for matches  * @param maxDistance the maximum property distance allowed for matches  */ ;/**  * Create PropertyMatches for the given bean property.  * @param propertyName the name of the property to find possible matches for  * @param beanClass the bean class to search for matches  * @param maxDistance the maximum property distance allowed for matches  */ public static PropertyMatches forProperty(String propertyName, Class<?> beanClass, int maxDistance) {     return new BeanPropertyMatches(propertyName, beanClass, maxDistance). }
true;public,static;2;3;/**  * Create PropertyMatches for the given field property.  * @param propertyName the name of the field to find possible matches for  * @param beanClass the bean class to search for matches  */ ;/**  * Create PropertyMatches for the given field property.  * @param propertyName the name of the field to find possible matches for  * @param beanClass the bean class to search for matches  */ public static PropertyMatches forField(String propertyName, Class<?> beanClass) {     return forField(propertyName, beanClass, DEFAULT_MAX_DISTANCE). }
true;public,static;3;3;/**  * Create PropertyMatches for the given field property.  * @param propertyName the name of the field to find possible matches for  * @param beanClass the bean class to search for matches  * @param maxDistance the maximum property distance allowed for matches  */ ;/**  * Create PropertyMatches for the given field property.  * @param propertyName the name of the field to find possible matches for  * @param beanClass the bean class to search for matches  * @param maxDistance the maximum property distance allowed for matches  */ public static PropertyMatches forField(String propertyName, Class<?> beanClass, int maxDistance) {     return new FieldPropertyMatches(propertyName, beanClass, maxDistance). }
true;public;0;3;/**  * Return the name of the requested property.  */ ;/**  * Return the name of the requested property.  */ public String getPropertyName() {     return this.propertyName. }
true;public;0;3;/**  * Return the calculated possible matches.  */ ;/**  * Return the calculated possible matches.  */ public String[] getPossibleMatches() {     return this.possibleMatches. }
true;public,abstract;0;1;/**  * Build an error message for the given invalid property name,  * indicating the possible property matches.  */ ;/**  * Build an error message for the given invalid property name,  * indicating the possible property matches.  */ public abstract String buildErrorMessage().
false;protected;1;14;;// Implementation support for subclasses protected void appendHintMessage(StringBuilder msg) {     msg.append("Did you mean ").     for (int i = 0. i < this.possibleMatches.length. i++) {         msg.append('\'').         msg.append(this.possibleMatches[i]).         if (i < this.possibleMatches.length - 2) {             msg.append("', ").         } else if (i == this.possibleMatches.length - 2) {             msg.append("', or ").         }     }     msg.append("'?"). }
true;private,static;2;33;/**  * Calculate the distance between the given two Strings  * according to the Levenshtein algorithm.  * @param s1 the first String  * @param s2 the second String  * @return the distance value  */ ;/**  * Calculate the distance between the given two Strings  * according to the Levenshtein algorithm.  * @param s1 the first String  * @param s2 the second String  * @return the distance value  */ private static int calculateStringDistance(String s1, String s2) {     if (s1.isEmpty()) {         return s2.length().     }     if (s2.isEmpty()) {         return s1.length().     }     int[][] d = new int[s1.length() + 1][s2.length() + 1].     for (int i = 0. i <= s1.length(). i++) {         d[i][0] = i.     }     for (int j = 0. j <= s2.length(). j++) {         d[0][j] = j.     }     for (int i = 1. i <= s1.length(). i++) {         char c1 = s1.charAt(i - 1).         for (int j = 1. j <= s2.length(). j++) {             int cost.             char c2 = s2.charAt(j - 1).             if (c1 == c2) {                 cost = 0.             } else {                 cost = 1.             }             d[i][j] = Math.min(Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1), d[i - 1][j - 1] + cost).         }     }     return d[s1.length()][s2.length()]. }
true;private,static;3;13;/**  * Generate possible property alternatives for the given property and class.  * Internally uses the {@code getStringDistance} method, which in turn uses  * the Levenshtein algorithm to determine the distance between two Strings.  * @param descriptors the JavaBeans property descriptors to search  * @param maxDistance the maximum distance to accept  */ ;/**  * Generate possible property alternatives for the given property and class.  * Internally uses the {@code getStringDistance} method, which in turn uses  * the Levenshtein algorithm to determine the distance between two Strings.  * @param descriptors the JavaBeans property descriptors to search  * @param maxDistance the maximum distance to accept  */ private static String[] calculateMatches(String name, PropertyDescriptor[] descriptors, int maxDistance) {     List<String> candidates = new ArrayList<>().     for (PropertyDescriptor pd : descriptors) {         if (pd.getWriteMethod() != null) {             String possibleAlternative = pd.getName().             if (calculateStringDistance(name, possibleAlternative) <= maxDistance) {                 candidates.add(possibleAlternative).             }         }     }     Collections.sort(candidates).     return StringUtils.toStringArray(candidates). }
false;public;0;13;;@Override public String buildErrorMessage() {     StringBuilder msg = new StringBuilder(160).     msg.append("Bean property '").append(getPropertyName()).append("' is not writable or has an invalid setter method. ").     if (!ObjectUtils.isEmpty(getPossibleMatches())) {         appendHintMessage(msg).     } else {         msg.append("Does the parameter type of the setter match the return type of the getter?").     }     return msg.toString(). }
false;private,static;3;11;;private static String[] calculateMatches(final String name, Class<?> clazz, final int maxDistance) {     final List<String> candidates = new ArrayList<>().     ReflectionUtils.doWithFields(clazz, field -> {         String possibleAlternative = field.getName().         if (calculateStringDistance(name, possibleAlternative) <= maxDistance) {             candidates.add(possibleAlternative).         }     }).     Collections.sort(candidates).     return StringUtils.toStringArray(candidates). }
false;public;0;10;;@Override public String buildErrorMessage() {     StringBuilder msg = new StringBuilder(80).     msg.append("Bean property '").append(getPropertyName()).append("' has no matching field.").     if (!ObjectUtils.isEmpty(getPossibleMatches())) {         msg.append(' ').         appendHintMessage(msg).     }     return msg.toString(). }
