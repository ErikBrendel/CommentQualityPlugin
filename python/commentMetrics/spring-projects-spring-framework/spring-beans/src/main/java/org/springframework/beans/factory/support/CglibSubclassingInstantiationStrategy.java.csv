commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;4;;@Override protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {     return instantiateWithMethodInjection(bd, beanName, owner, null). }
false;protected;5;7;;@Override protected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner, @Nullable Constructor<?> ctor, Object... args) {     // Must generate CGLIB subclass...     return new CglibSubclassCreator(bd, owner).instantiate(ctor, args). }
true;public;2;24;/**  * Create a new instance of a dynamically generated subclass implementing the  * required lookups.  * @param ctor constructor to use. If this is {@code null}, use the  * no-arg constructor (no parameterization, or Setter Injection)  * @param args arguments to use for the constructor.  * Ignored if the {@code ctor} parameter is {@code null}.  * @return new instance of the dynamically generated subclass  */ ;/**  * Create a new instance of a dynamically generated subclass implementing the  * required lookups.  * @param ctor constructor to use. If this is {@code null}, use the  * no-arg constructor (no parameterization, or Setter Injection)  * @param args arguments to use for the constructor.  * Ignored if the {@code ctor} parameter is {@code null}.  * @return new instance of the dynamically generated subclass  */ public Object instantiate(@Nullable Constructor<?> ctor, Object... args) {     Class<?> subclass = createEnhancedSubclass(this.beanDefinition).     Object instance.     if (ctor == null) {         instance = BeanUtils.instantiateClass(subclass).     } else {         try {             Constructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes()).             instance = enhancedSubclassConstructor.newInstance(args).         } catch (Exception ex) {             throw new BeanInstantiationException(this.beanDefinition.getBeanClass(), "Failed to invoke constructor for CGLIB enhanced subclass [" + subclass.getName() + "]", ex).         }     }     // SPR-10785: set callbacks directly on the instance instead of in the     // enhanced class (via the Enhancer) in order to avoid memory leaks.     Factory factory = (Factory) instance.     factory.setCallbacks(new Callback[] { NoOp.INSTANCE, new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner), new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner) }).     return instance. }
true;private;1;12;/**  * Create an enhanced subclass of the bean class for the provided bean  * definition, using CGLIB.  */ ;/**  * Create an enhanced subclass of the bean class for the provided bean  * definition, using CGLIB.  */ private Class<?> createEnhancedSubclass(RootBeanDefinition beanDefinition) {     Enhancer enhancer = new Enhancer().     enhancer.setSuperclass(beanDefinition.getBeanClass()).     enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE).     if (this.owner instanceof ConfigurableBeanFactory) {         ClassLoader cl = ((ConfigurableBeanFactory) this.owner).getBeanClassLoader().         enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(cl)).     }     enhancer.setCallbackFilter(new MethodOverrideCallbackFilter(beanDefinition)).     enhancer.setCallbackTypes(CALLBACK_TYPES).     return enhancer.createClass(). }
false;public;0;3;;public RootBeanDefinition getBeanDefinition() {     return this.beanDefinition. }
false;public;1;5;;@Override public boolean equals(Object other) {     return (getClass() == other.getClass() && this.beanDefinition.equals(((CglibIdentitySupport) other).beanDefinition)). }
false;public;0;4;;@Override public int hashCode() {     return this.beanDefinition.hashCode(). }
false;public;1;30;;@Override public byte[] generate(ClassGenerator cg) throws Exception {     if (this.classLoader == null) {         return super.generate(cg).     }     Thread currentThread = Thread.currentThread().     ClassLoader threadContextClassLoader.     try {         threadContextClassLoader = currentThread.getContextClassLoader().     } catch (Throwable ex) {         // Cannot access thread context ClassLoader - falling back...         return super.generate(cg).     }     boolean overrideClassLoader = !this.classLoader.equals(threadContextClassLoader).     if (overrideClassLoader) {         currentThread.setContextClassLoader(this.classLoader).     }     try {         return super.generate(cg).     } finally {         if (overrideClassLoader) {             // Reset original thread context ClassLoader.             currentThread.setContextClassLoader(threadContextClassLoader).         }     } }
false;public;1;18;;@Override public int accept(Method method) {     MethodOverride methodOverride = getBeanDefinition().getMethodOverrides().getOverride(method).     if (logger.isTraceEnabled()) {         logger.trace("Override for '" + method.getName() + "' is [" + methodOverride + "]").     }     if (methodOverride == null) {         return PASSTHROUGH.     } else if (methodOverride instanceof LookupOverride) {         return LOOKUP_OVERRIDE.     } else if (methodOverride instanceof ReplaceOverride) {         return METHOD_REPLACER.     }     throw new UnsupportedOperationException("Unexpected MethodOverride subclass: " + methodOverride.getClass().getName()). }
false;public;4;15;;@Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {     // Cast is safe, as CallbackFilter filters are used selectively.     LookupOverride lo = (LookupOverride) getBeanDefinition().getMethodOverrides().getOverride(method).     Assert.state(lo != null, "LookupOverride not found").     // if no-arg, don't insist on args at all     Object[] argsToUse = (args.length > 0 ? args : null).     if (StringUtils.hasText(lo.getBeanName())) {         return (argsToUse != null ? this.owner.getBean(lo.getBeanName(), argsToUse) : this.owner.getBean(lo.getBeanName())).     } else {         return (argsToUse != null ? this.owner.getBean(method.getReturnType(), argsToUse) : this.owner.getBean(method.getReturnType())).     } }
false;public;4;8;;@Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {     ReplaceOverride ro = (ReplaceOverride) getBeanDefinition().getMethodOverrides().getOverride(method).     Assert.state(ro != null, "ReplaceOverride not found").     // TODO could cache if a singleton for minor performance optimization     MethodReplacer mr = this.owner.getBean(ro.getMethodReplacerBeanName(), MethodReplacer.class).     return mr.reimplement(obj, method, args). }
