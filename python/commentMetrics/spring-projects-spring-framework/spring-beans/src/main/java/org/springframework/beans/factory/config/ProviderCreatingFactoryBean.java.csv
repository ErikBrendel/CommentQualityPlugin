commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the name of the target bean.  * <p>The target does not <i>have</i> to be a non-singleton bean, but realistically  * always will be (because if the target bean were a singleton, then said singleton  * bean could simply be injected straight into the dependent object, thus obviating  * the need for the extra level of indirection afforded by this factory approach).  */ ;/**  * Set the name of the target bean.  * <p>The target does not <i>have</i> to be a non-singleton bean, but realistically  * always will be (because if the target bean were a singleton, then said singleton  * bean could simply be injected straight into the dependent object, thus obviating  * the need for the extra level of indirection afforded by this factory approach).  */ public void setTargetBeanName(String targetBeanName) {     this.targetBeanName = targetBeanName. }
false;public;0;5;;@Override public void afterPropertiesSet() throws Exception {     Assert.hasText(this.targetBeanName, "Property 'targetBeanName' is required").     super.afterPropertiesSet(). }
false;public;0;4;;@Override public Class<?> getObjectType() {     return Provider.class. }
false;protected;0;7;;@Override protected Provider<Object> createInstance() {     BeanFactory beanFactory = getBeanFactory().     Assert.state(beanFactory != null, "No BeanFactory available").     Assert.state(this.targetBeanName != null, "No target bean name specified").     return new TargetBeanProvider(beanFactory, this.targetBeanName). }
false;public;0;4;;@Override public Object get() throws BeansException {     return this.beanFactory.getBean(this.targetBeanName). }
