commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Set the 'autowired' annotation type, to be used on constructors, fields,  * setter methods and arbitrary config methods.  * <p>The default autowired annotation type is the Spring-provided {@link Autowired}  * annotation, as well as {@link Value}.  * <p>This setter property exists so that developers can provide their own  * (non-Spring-specific) annotation type to indicate that a member is supposed  * to be autowired.  */ ;/**  * Set the 'autowired' annotation type, to be used on constructors, fields,  * setter methods and arbitrary config methods.  * <p>The default autowired annotation type is the Spring-provided {@link Autowired}  * annotation, as well as {@link Value}.  * <p>This setter property exists so that developers can provide their own  * (non-Spring-specific) annotation type to indicate that a member is supposed  * to be autowired.  */ public void setAutowiredAnnotationType(Class<? extends Annotation> autowiredAnnotationType) {     Assert.notNull(autowiredAnnotationType, "'autowiredAnnotationType' must not be null").     this.autowiredAnnotationTypes.clear().     this.autowiredAnnotationTypes.add(autowiredAnnotationType). }
true;public;1;5;/**  * Set the 'autowired' annotation types, to be used on constructors, fields,  * setter methods and arbitrary config methods.  * <p>The default autowired annotation type is the Spring-provided {@link Autowired}  * annotation, as well as {@link Value}.  * <p>This setter property exists so that developers can provide their own  * (non-Spring-specific) annotation types to indicate that a member is supposed  * to be autowired.  */ ;/**  * Set the 'autowired' annotation types, to be used on constructors, fields,  * setter methods and arbitrary config methods.  * <p>The default autowired annotation type is the Spring-provided {@link Autowired}  * annotation, as well as {@link Value}.  * <p>This setter property exists so that developers can provide their own  * (non-Spring-specific) annotation types to indicate that a member is supposed  * to be autowired.  */ public void setAutowiredAnnotationTypes(Set<Class<? extends Annotation>> autowiredAnnotationTypes) {     Assert.notEmpty(autowiredAnnotationTypes, "'autowiredAnnotationTypes' must not be empty").     this.autowiredAnnotationTypes.clear().     this.autowiredAnnotationTypes.addAll(autowiredAnnotationTypes). }
true;public;1;3;/**  * Set the name of a parameter of the annotation that specifies whether it is required.  * @see #setRequiredParameterValue(boolean)  */ ;/**  * Set the name of a parameter of the annotation that specifies whether it is required.  * @see #setRequiredParameterValue(boolean)  */ public void setRequiredParameterName(String requiredParameterName) {     this.requiredParameterName = requiredParameterName. }
true;public;1;3;/**  * Set the boolean value that marks a dependency as required  * <p>For example if using 'required=true' (the default), this value should be  * {@code true}. but if using 'optional=false', this value should be {@code false}.  * @see #setRequiredParameterName(String)  */ ;/**  * Set the boolean value that marks a dependency as required  * <p>For example if using 'required=true' (the default), this value should be  * {@code true}. but if using 'optional=false', this value should be {@code false}.  * @see #setRequiredParameterName(String)  */ public void setRequiredParameterValue(boolean requiredParameterValue) {     this.requiredParameterValue = requiredParameterValue. }
false;public;1;3;;public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
false;public;1;8;;@Override public void setBeanFactory(BeanFactory beanFactory) {     if (!(beanFactory instanceof ConfigurableListableBeanFactory)) {         throw new IllegalArgumentException("AutowiredAnnotationBeanPostProcessor requires a ConfigurableListableBeanFactory: " + beanFactory).     }     this.beanFactory = (ConfigurableListableBeanFactory) beanFactory. }
false;public;3;5;;@Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {     InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null).     metadata.checkConfigMembers(beanDefinition). }
false;public;1;5;;@Override public void resetBeanDefinition(String beanName) {     this.lookupMethodsChecked.remove(beanName).     this.injectionMetadataCache.remove(beanName). }
false;public;2;129;;@Override @Nullable public Constructor<?>[] determineCandidateConstructors(Class<?> beanClass, final String beanName) throws BeanCreationException {     // Let's check for lookup methods here..     if (!this.lookupMethodsChecked.contains(beanName)) {         try {             ReflectionUtils.doWithMethods(beanClass, method -> {                 Lookup lookup = method.getAnnotation(Lookup.class).                 if (lookup != null) {                     Assert.state(this.beanFactory != null, "No BeanFactory available").                     LookupOverride override = new LookupOverride(method, lookup.value()).                     try {                         RootBeanDefinition mbd = (RootBeanDefinition) this.beanFactory.getMergedBeanDefinition(beanName).                         mbd.getMethodOverrides().addOverride(override).                     } catch (NoSuchBeanDefinitionException ex) {                         throw new BeanCreationException(beanName, "Cannot apply @Lookup to beans without corresponding bean definition").                     }                 }             }).         } catch (IllegalStateException ex) {             throw new BeanCreationException(beanName, "Lookup method resolution failed", ex).         }         this.lookupMethodsChecked.add(beanName).     }     // Quick check on the concurrent map first, with minimal locking.     Constructor<?>[] candidateConstructors = this.candidateConstructorsCache.get(beanClass).     if (candidateConstructors == null) {         // Fully synchronized resolution now...         synchronized (this.candidateConstructorsCache) {             candidateConstructors = this.candidateConstructorsCache.get(beanClass).             if (candidateConstructors == null) {                 Constructor<?>[] rawCandidates.                 try {                     rawCandidates = beanClass.getDeclaredConstructors().                 } catch (Throwable ex) {                     throw new BeanCreationException(beanName, "Resolution of declared constructors on bean Class [" + beanClass.getName() + "] from ClassLoader [" + beanClass.getClassLoader() + "] failed", ex).                 }                 List<Constructor<?>> candidates = new ArrayList<>(rawCandidates.length).                 Constructor<?> requiredConstructor = null.                 Constructor<?> defaultConstructor = null.                 Constructor<?> primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass).                 int nonSyntheticConstructors = 0.                 for (Constructor<?> candidate : rawCandidates) {                     if (!candidate.isSynthetic()) {                         nonSyntheticConstructors++.                     } else if (primaryConstructor != null) {                         continue.                     }                     AnnotationAttributes ann = findAutowiredAnnotation(candidate).                     if (ann == null) {                         Class<?> userClass = ClassUtils.getUserClass(beanClass).                         if (userClass != beanClass) {                             try {                                 Constructor<?> superCtor = userClass.getDeclaredConstructor(candidate.getParameterTypes()).                                 ann = findAutowiredAnnotation(superCtor).                             } catch (NoSuchMethodException ex) {                             // Simply proceed, no equivalent superclass constructor found...                             }                         }                     }                     if (ann != null) {                         if (requiredConstructor != null) {                             throw new BeanCreationException(beanName, "Invalid autowire-marked constructor: " + candidate + ". Found constructor with 'required' Autowired annotation already: " + requiredConstructor).                         }                         boolean required = determineRequiredStatus(ann).                         if (required) {                             if (!candidates.isEmpty()) {                                 throw new BeanCreationException(beanName, "Invalid autowire-marked constructors: " + candidates + ". Found constructor with 'required' Autowired annotation: " + candidate).                             }                             requiredConstructor = candidate.                         }                         candidates.add(candidate).                     } else if (candidate.getParameterCount() == 0) {                         defaultConstructor = candidate.                     }                 }                 if (!candidates.isEmpty()) {                     // Add default constructor to list of optional constructors, as fallback.                     if (requiredConstructor == null) {                         if (defaultConstructor != null) {                             candidates.add(defaultConstructor).                         } else if (candidates.size() == 1 && logger.isInfoEnabled()) {                             logger.info("Inconsistent constructor declaration on bean with name '" + beanName + "': single autowire-marked constructor flagged as optional - " + "this constructor is effectively required since there is no " + "default constructor to fall back to: " + candidates.get(0)).                         }                     }                     candidateConstructors = candidates.toArray(new Constructor<?>[0]).                 } else if (rawCandidates.length == 1 && rawCandidates[0].getParameterCount() > 0) {                     candidateConstructors = new Constructor<?>[] { rawCandidates[0] }.                 } else if (nonSyntheticConstructors == 2 && primaryConstructor != null && defaultConstructor != null && !primaryConstructor.equals(defaultConstructor)) {                     candidateConstructors = new Constructor<?>[] { primaryConstructor, defaultConstructor }.                 } else if (nonSyntheticConstructors == 1 && primaryConstructor != null) {                     candidateConstructors = new Constructor<?>[] { primaryConstructor }.                 } else {                     candidateConstructors = new Constructor<?>[0].                 }                 this.candidateConstructorsCache.put(beanClass, candidateConstructors).             }         }     }     return (candidateConstructors.length > 0 ? candidateConstructors : null). }
false;public;3;14;;@Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {     InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs).     try {         metadata.inject(bean, beanName, pvs).     } catch (BeanCreationException ex) {         throw ex.     } catch (Throwable ex) {         throw new BeanCreationException(beanName, "Injection of autowired dependencies failed", ex).     }     return pvs. }
false;public;4;7;;@Deprecated @Override public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) {     return postProcessProperties(pvs, bean, beanName). }
true;public;1;14;/**  * 'Native' processing method for direct calls with an arbitrary target instance,  * resolving all of its fields and methods which are annotated with {@code @Autowired}.  * @param bean the target instance to process  * @throws BeanCreationException if autowiring failed  */ ;/**  * 'Native' processing method for direct calls with an arbitrary target instance,  * resolving all of its fields and methods which are annotated with {@code @Autowired}.  * @param bean the target instance to process  * @throws BeanCreationException if autowiring failed  */ public void processInjection(Object bean) throws BeanCreationException {     Class<?> clazz = bean.getClass().     InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, null).     try {         metadata.inject(bean, null, null).     } catch (BeanCreationException ex) {         throw ex.     } catch (Throwable ex) {         throw new BeanCreationException("Injection of autowired dependencies failed for class [" + clazz + "]", ex).     } }
false;private;3;19;;private InjectionMetadata findAutowiringMetadata(String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {     // Fall back to class name as cache key, for backwards compatibility with custom callers.     String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName()).     // Quick check on the concurrent map first, with minimal locking.     InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey).     if (InjectionMetadata.needsRefresh(metadata, clazz)) {         synchronized (this.injectionMetadataCache) {             metadata = this.injectionMetadataCache.get(cacheKey).             if (InjectionMetadata.needsRefresh(metadata, clazz)) {                 if (metadata != null) {                     metadata.clear(pvs).                 }                 metadata = buildAutowiringMetadata(clazz).                 this.injectionMetadataCache.put(cacheKey, metadata).             }         }     }     return metadata. }
false;private;1;53;;private InjectionMetadata buildAutowiringMetadata(final Class<?> clazz) {     List<InjectionMetadata.InjectedElement> elements = new ArrayList<>().     Class<?> targetClass = clazz.     do {         final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>().         ReflectionUtils.doWithLocalFields(targetClass, field -> {             AnnotationAttributes ann = findAutowiredAnnotation(field).             if (ann != null) {                 if (Modifier.isStatic(field.getModifiers())) {                     if (logger.isInfoEnabled()) {                         logger.info("Autowired annotation is not supported on static fields: " + field).                     }                     return.                 }                 boolean required = determineRequiredStatus(ann).                 currElements.add(new AutowiredFieldElement(field, required)).             }         }).         ReflectionUtils.doWithLocalMethods(targetClass, method -> {             Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method).             if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {                 return.             }             AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod).             if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {                 if (Modifier.isStatic(method.getModifiers())) {                     if (logger.isInfoEnabled()) {                         logger.info("Autowired annotation is not supported on static methods: " + method).                     }                     return.                 }                 if (method.getParameterCount() == 0) {                     if (logger.isInfoEnabled()) {                         logger.info("Autowired annotation should only be used on methods with parameters: " + method).                     }                 }                 boolean required = determineRequiredStatus(ann).                 PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz).                 currElements.add(new AutowiredMethodElement(method, required, pd)).             }         }).         elements.addAll(0, currElements).         targetClass = targetClass.getSuperclass().     } while (targetClass != null && targetClass != Object.class).     return new InjectionMetadata(clazz, elements). }
false;private;1;12;;@Nullable private AnnotationAttributes findAutowiredAnnotation(AccessibleObject ao) {     if (ao.getAnnotations().length > 0) {         // autowiring annotations have to be local         for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {             AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type).             if (attributes != null) {                 return attributes.             }         }     }     return null. }
true;protected;1;4;/**  * Determine if the annotated field or method requires its dependency.  * <p>A 'required' dependency means that autowiring should fail when no beans  * are found. Otherwise, the autowiring process will simply bypass the field  * or method when no beans are found.  * @param ann the Autowired annotation  * @return whether the annotation indicates that a dependency is required  */ ;/**  * Determine if the annotated field or method requires its dependency.  * <p>A 'required' dependency means that autowiring should fail when no beans  * are found. Otherwise, the autowiring process will simply bypass the field  * or method when no beans are found.  * @param ann the Autowired annotation  * @return whether the annotation indicates that a dependency is required  */ protected boolean determineRequiredStatus(AnnotationAttributes ann) {     return (!ann.containsKey(this.requiredParameterName) || this.requiredParameterValue == ann.getBoolean(this.requiredParameterName)). }
true;protected;1;7;/**  * Obtain all beans of the given type as autowire candidates.  * @param type the type of the bean  * @return the target beans, or an empty Collection if no bean of this type is found  * @throws BeansException if bean retrieval failed  */ ;/**  * Obtain all beans of the given type as autowire candidates.  * @param type the type of the bean  * @return the target beans, or an empty Collection if no bean of this type is found  * @throws BeansException if bean retrieval failed  */ protected <T> Map<String, T> findAutowireCandidates(Class<T> type) throws BeansException {     if (this.beanFactory == null) {         throw new IllegalStateException("No BeanFactory configured - " + "override the getBeanOfType method or specify the 'beanFactory' property").     }     return BeanFactoryUtils.beansOfTypeIncludingAncestors(this.beanFactory, type). }
true;private;2;13;/**  * Register the specified bean as dependent on the autowired beans.  */ ;/**  * Register the specified bean as dependent on the autowired beans.  */ private void registerDependentBeans(@Nullable String beanName, Set<String> autowiredBeanNames) {     if (beanName != null) {         for (String autowiredBeanName : autowiredBeanNames) {             if (this.beanFactory != null && this.beanFactory.containsBean(autowiredBeanName)) {                 this.beanFactory.registerDependentBean(autowiredBeanName, beanName).             }             if (logger.isTraceEnabled()) {                 logger.trace("Autowiring by type from bean name '" + beanName + "' to bean named '" + autowiredBeanName + "'").             }         }     } }
true;private;2;11;/**  * Resolve the specified cached method argument or field value.  */ ;/**  * Resolve the specified cached method argument or field value.  */ @Nullable private Object resolvedCachedArgument(@Nullable String beanName, @Nullable Object cachedArgument) {     if (cachedArgument instanceof DependencyDescriptor) {         DependencyDescriptor descriptor = (DependencyDescriptor) cachedArgument.         Assert.state(this.beanFactory != null, "No BeanFactory available").         return this.beanFactory.resolveDependency(descriptor, beanName, null, null).     } else {         return cachedArgument.     } }
false;protected;3;45;;@Override protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {     Field field = (Field) this.member.     Object value.     if (this.cached) {         value = resolvedCachedArgument(beanName, this.cachedFieldValue).     } else {         DependencyDescriptor desc = new DependencyDescriptor(field, this.required).         desc.setContainingClass(bean.getClass()).         Set<String> autowiredBeanNames = new LinkedHashSet<>(1).         Assert.state(beanFactory != null, "No BeanFactory available").         TypeConverter typeConverter = beanFactory.getTypeConverter().         try {             value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter).         } catch (BeansException ex) {             throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex).         }         synchronized (this) {             if (!this.cached) {                 if (value != null || this.required) {                     this.cachedFieldValue = desc.                     registerDependentBeans(beanName, autowiredBeanNames).                     if (autowiredBeanNames.size() == 1) {                         String autowiredBeanName = autowiredBeanNames.iterator().next().                         if (beanFactory.containsBean(autowiredBeanName) && beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {                             this.cachedFieldValue = new ShortcutDependencyDescriptor(desc, autowiredBeanName, field.getType()).                         }                     }                 } else {                     this.cachedFieldValue = null.                 }                 this.cached = true.             }         }     }     if (value != null) {         ReflectionUtils.makeAccessible(field).         field.set(bean, value).     } }
false;protected;3;71;;@Override protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {     if (checkPropertySkipping(pvs)) {         return.     }     Method method = (Method) this.member.     Object[] arguments.     if (this.cached) {         // Shortcut for avoiding synchronization...         arguments = resolveCachedArguments(beanName).     } else {         Class<?>[] paramTypes = method.getParameterTypes().         arguments = new Object[paramTypes.length].         DependencyDescriptor[] descriptors = new DependencyDescriptor[paramTypes.length].         Set<String> autowiredBeans = new LinkedHashSet<>(paramTypes.length).         Assert.state(beanFactory != null, "No BeanFactory available").         TypeConverter typeConverter = beanFactory.getTypeConverter().         for (int i = 0. i < arguments.length. i++) {             MethodParameter methodParam = new MethodParameter(method, i).             DependencyDescriptor currDesc = new DependencyDescriptor(methodParam, this.required).             currDesc.setContainingClass(bean.getClass()).             descriptors[i] = currDesc.             try {                 Object arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter).                 if (arg == null && !this.required) {                     arguments = null.                     break.                 }                 arguments[i] = arg.             } catch (BeansException ex) {                 throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(methodParam), ex).             }         }         synchronized (this) {             if (!this.cached) {                 if (arguments != null) {                     Object[] cachedMethodArguments = new Object[paramTypes.length].                     System.arraycopy(descriptors, 0, cachedMethodArguments, 0, arguments.length).                     registerDependentBeans(beanName, autowiredBeans).                     if (autowiredBeans.size() == paramTypes.length) {                         Iterator<String> it = autowiredBeans.iterator().                         for (int i = 0. i < paramTypes.length. i++) {                             String autowiredBeanName = it.next().                             if (beanFactory.containsBean(autowiredBeanName) && beanFactory.isTypeMatch(autowiredBeanName, paramTypes[i])) {                                 cachedMethodArguments[i] = new ShortcutDependencyDescriptor(descriptors[i], autowiredBeanName, paramTypes[i]).                             }                         }                     }                     this.cachedMethodArguments = cachedMethodArguments.                 } else {                     this.cachedMethodArguments = null.                 }                 this.cached = true.             }         }     }     if (arguments != null) {         try {             ReflectionUtils.makeAccessible(method).             method.invoke(bean, arguments).         } catch (InvocationTargetException ex) {             throw ex.getTargetException().         }     } }
false;private;1;12;;@Nullable private Object[] resolveCachedArguments(@Nullable String beanName) {     Object[] cachedMethodArguments = this.cachedMethodArguments.     if (cachedMethodArguments == null) {         return null.     }     Object[] arguments = new Object[cachedMethodArguments.length].     for (int i = 0. i < arguments.length. i++) {         arguments[i] = resolvedCachedArgument(beanName, cachedMethodArguments[i]).     }     return arguments. }
false;public;1;4;;@Override public Object resolveShortcut(BeanFactory beanFactory) {     return beanFactory.getBean(this.shortcut, this.requiredType). }
