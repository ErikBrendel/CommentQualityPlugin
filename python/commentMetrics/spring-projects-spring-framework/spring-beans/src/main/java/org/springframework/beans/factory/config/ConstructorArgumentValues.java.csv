commented;modifiers;parameterAmount;loc;comment;code
true;public;1;10;/**  * Copy all given argument values into this object, using separate holder  * instances to keep the values independent from the original object.  * <p>Note: Identical ValueHolder instances will only be registered once,  * to allow for merging and re-merging of argument value definitions. Distinct  * ValueHolder instances carrying the same content are of course allowed.  */ ;/**  * Copy all given argument values into this object, using separate holder  * instances to keep the values independent from the original object.  * <p>Note: Identical ValueHolder instances will only be registered once,  * to allow for merging and re-merging of argument value definitions. Distinct  * ValueHolder instances carrying the same content are of course allowed.  */ public void addArgumentValues(@Nullable ConstructorArgumentValues other) {     if (other != null) {         other.indexedArgumentValues.forEach((index, argValue) -> addOrMergeIndexedArgumentValue(index, argValue.copy())).         other.genericArgumentValues.stream().filter(valueHolder -> !this.genericArgumentValues.contains(valueHolder)).forEach(valueHolder -> addOrMergeGenericArgumentValue(valueHolder.copy())).     } }
true;public;2;3;/**  * Add an argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param value the argument value  */ ;/**  * Add an argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param value the argument value  */ public void addIndexedArgumentValue(int index, @Nullable Object value) {     addIndexedArgumentValue(index, new ValueHolder(value)). }
true;public;3;3;/**  * Add an argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param value the argument value  * @param type the type of the constructor argument  */ ;/**  * Add an argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param value the argument value  * @param type the type of the constructor argument  */ public void addIndexedArgumentValue(int index, @Nullable Object value, String type) {     addIndexedArgumentValue(index, new ValueHolder(value, type)). }
true;public;2;5;/**  * Add an argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param newValue the argument value in the form of a ValueHolder  */ ;/**  * Add an argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param newValue the argument value in the form of a ValueHolder  */ public void addIndexedArgumentValue(int index, ValueHolder newValue) {     Assert.isTrue(index >= 0, "Index must not be negative").     Assert.notNull(newValue, "ValueHolder must not be null").     addOrMergeIndexedArgumentValue(index, newValue). }
true;private;2;10;/**  * Add an argument value for the given index in the constructor argument list,  * merging the new value (typically a collection) with the current value  * if demanded: see {@link org.springframework.beans.Mergeable}.  * @param key the index in the constructor argument list  * @param newValue the argument value in the form of a ValueHolder  */ ;/**  * Add an argument value for the given index in the constructor argument list,  * merging the new value (typically a collection) with the current value  * if demanded: see {@link org.springframework.beans.Mergeable}.  * @param key the index in the constructor argument list  * @param newValue the argument value in the form of a ValueHolder  */ private void addOrMergeIndexedArgumentValue(Integer key, ValueHolder newValue) {     ValueHolder currentValue = this.indexedArgumentValues.get(key).     if (currentValue != null && newValue.getValue() instanceof Mergeable) {         Mergeable mergeable = (Mergeable) newValue.getValue().         if (mergeable.isMergeEnabled()) {             newValue.setValue(mergeable.merge(currentValue.getValue())).         }     }     this.indexedArgumentValues.put(key, newValue). }
true;public;1;3;/**  * Check whether an argument value has been registered for the given index.  * @param index the index in the constructor argument list  */ ;/**  * Check whether an argument value has been registered for the given index.  * @param index the index in the constructor argument list  */ public boolean hasIndexedArgumentValue(int index) {     return this.indexedArgumentValues.containsKey(index). }
true;public;2;4;/**  * Get argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param requiredType the type to match (can be {@code null} to match  * untyped values only)  * @return the ValueHolder for the argument, or {@code null} if none set  */ ;/**  * Get argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param requiredType the type to match (can be {@code null} to match  * untyped values only)  * @return the ValueHolder for the argument, or {@code null} if none set  */ @Nullable public ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType) {     return getIndexedArgumentValue(index, requiredType, null). }
true;public;3;13;/**  * Get argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param requiredType the type to match (can be {@code null} to match  * untyped values only)  * @param requiredName the type to match (can be {@code null} to match  * unnamed values only, or empty String to match any name)  * @return the ValueHolder for the argument, or {@code null} if none set  */ ;/**  * Get argument value for the given index in the constructor argument list.  * @param index the index in the constructor argument list  * @param requiredType the type to match (can be {@code null} to match  * untyped values only)  * @param requiredName the type to match (can be {@code null} to match  * unnamed values only, or empty String to match any name)  * @return the ValueHolder for the argument, or {@code null} if none set  */ @Nullable public ValueHolder getIndexedArgumentValue(int index, @Nullable Class<?> requiredType, @Nullable String requiredName) {     Assert.isTrue(index >= 0, "Index must not be negative").     ValueHolder valueHolder = this.indexedArgumentValues.get(index).     if (valueHolder != null && (valueHolder.getType() == null || (requiredType != null && ClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) && (valueHolder.getName() == null || "".equals(requiredName) || (requiredName != null && requiredName.equals(valueHolder.getName())))) {         return valueHolder.     }     return null. }
true;public;0;3;/**  * Return the map of indexed argument values.  * @return unmodifiable Map with Integer index as key and ValueHolder as value  * @see ValueHolder  */ ;/**  * Return the map of indexed argument values.  * @return unmodifiable Map with Integer index as key and ValueHolder as value  * @see ValueHolder  */ public Map<Integer, ValueHolder> getIndexedArgumentValues() {     return Collections.unmodifiableMap(this.indexedArgumentValues). }
true;public;1;3;/**  * Add a generic argument value to be matched by type.  * <p>Note: A single generic argument value will just be used once,  * rather than matched multiple times.  * @param value the argument value  */ ;/**  * Add a generic argument value to be matched by type.  * <p>Note: A single generic argument value will just be used once,  * rather than matched multiple times.  * @param value the argument value  */ public void addGenericArgumentValue(Object value) {     this.genericArgumentValues.add(new ValueHolder(value)). }
true;public;2;3;/**  * Add a generic argument value to be matched by type.  * <p>Note: A single generic argument value will just be used once,  * rather than matched multiple times.  * @param value the argument value  * @param type the type of the constructor argument  */ ;/**  * Add a generic argument value to be matched by type.  * <p>Note: A single generic argument value will just be used once,  * rather than matched multiple times.  * @param value the argument value  * @param type the type of the constructor argument  */ public void addGenericArgumentValue(Object value, String type) {     this.genericArgumentValues.add(new ValueHolder(value, type)). }
true;public;1;6;/**  * Add a generic argument value to be matched by type or name (if available).  * <p>Note: A single generic argument value will just be used once,  * rather than matched multiple times.  * @param newValue the argument value in the form of a ValueHolder  * <p>Note: Identical ValueHolder instances will only be registered once,  * to allow for merging and re-merging of argument value definitions. Distinct  * ValueHolder instances carrying the same content are of course allowed.  */ ;/**  * Add a generic argument value to be matched by type or name (if available).  * <p>Note: A single generic argument value will just be used once,  * rather than matched multiple times.  * @param newValue the argument value in the form of a ValueHolder  * <p>Note: Identical ValueHolder instances will only be registered once,  * to allow for merging and re-merging of argument value definitions. Distinct  * ValueHolder instances carrying the same content are of course allowed.  */ public void addGenericArgumentValue(ValueHolder newValue) {     Assert.notNull(newValue, "ValueHolder must not be null").     if (!this.genericArgumentValues.contains(newValue)) {         addOrMergeGenericArgumentValue(newValue).     } }
true;private;1;17;/**  * Add a generic argument value, merging the new value (typically a collection)  * with the current value if demanded: see {@link org.springframework.beans.Mergeable}.  * @param newValue the argument value in the form of a ValueHolder  */ ;/**  * Add a generic argument value, merging the new value (typically a collection)  * with the current value if demanded: see {@link org.springframework.beans.Mergeable}.  * @param newValue the argument value in the form of a ValueHolder  */ private void addOrMergeGenericArgumentValue(ValueHolder newValue) {     if (newValue.getName() != null) {         for (Iterator<ValueHolder> it = this.genericArgumentValues.iterator(). it.hasNext(). ) {             ValueHolder currentValue = it.next().             if (newValue.getName().equals(currentValue.getName())) {                 if (newValue.getValue() instanceof Mergeable) {                     Mergeable mergeable = (Mergeable) newValue.getValue().                     if (mergeable.isMergeEnabled()) {                         newValue.setValue(mergeable.merge(currentValue.getValue())).                     }                 }                 it.remove().             }         }     }     this.genericArgumentValues.add(newValue). }
true;public;1;4;/**  * Look for a generic argument value that matches the given type.  * @param requiredType the type to match  * @return the ValueHolder for the argument, or {@code null} if none set  */ ;/**  * Look for a generic argument value that matches the given type.  * @param requiredType the type to match  * @return the ValueHolder for the argument, or {@code null} if none set  */ @Nullable public ValueHolder getGenericArgumentValue(Class<?> requiredType) {     return getGenericArgumentValue(requiredType, null, null). }
true;public;2;4;/**  * Look for a generic argument value that matches the given type.  * @param requiredType the type to match  * @param requiredName the name to match  * @return the ValueHolder for the argument, or {@code null} if none set  */ ;/**  * Look for a generic argument value that matches the given type.  * @param requiredType the type to match  * @param requiredName the name to match  * @return the ValueHolder for the argument, or {@code null} if none set  */ @Nullable public ValueHolder getGenericArgumentValue(Class<?> requiredType, String requiredName) {     return getGenericArgumentValue(requiredType, requiredName, null). }
true;public;3;22;/**  * Look for the next generic argument value that matches the given type,  * ignoring argument values that have already been used in the current  * resolution process.  * @param requiredType the type to match (can be {@code null} to find  * an arbitrary next generic argument value)  * @param requiredName the name to match (can be {@code null} to not  * match argument values by name, or empty String to match any name)  * @param usedValueHolders a Set of ValueHolder objects that have already been used  * in the current resolution process and should therefore not be returned again  * @return the ValueHolder for the argument, or {@code null} if none found  */ ;/**  * Look for the next generic argument value that matches the given type,  * ignoring argument values that have already been used in the current  * resolution process.  * @param requiredType the type to match (can be {@code null} to find  * an arbitrary next generic argument value)  * @param requiredName the name to match (can be {@code null} to not  * match argument values by name, or empty String to match any name)  * @param usedValueHolders a Set of ValueHolder objects that have already been used  * in the current resolution process and should therefore not be returned again  * @return the ValueHolder for the argument, or {@code null} if none found  */ @Nullable public ValueHolder getGenericArgumentValue(@Nullable Class<?> requiredType, @Nullable String requiredName, @Nullable Set<ValueHolder> usedValueHolders) {     for (ValueHolder valueHolder : this.genericArgumentValues) {         if (usedValueHolders != null && usedValueHolders.contains(valueHolder)) {             continue.         }         if (valueHolder.getName() != null && !"".equals(requiredName) && (requiredName == null || !valueHolder.getName().equals(requiredName))) {             continue.         }         if (valueHolder.getType() != null && (requiredType == null || !ClassUtils.matchesTypeName(requiredType, valueHolder.getType()))) {             continue.         }         if (requiredType != null && valueHolder.getType() == null && valueHolder.getName() == null && !ClassUtils.isAssignableValue(requiredType, valueHolder.getValue())) {             continue.         }         return valueHolder.     }     return null. }
true;public;0;3;/**  * Return the list of generic argument values.  * @return unmodifiable List of ValueHolders  * @see ValueHolder  */ ;/**  * Return the list of generic argument values.  * @return unmodifiable List of ValueHolders  * @see ValueHolder  */ public List<ValueHolder> getGenericArgumentValues() {     return Collections.unmodifiableList(this.genericArgumentValues). }
true;public;2;4;/**  * Look for an argument value that either corresponds to the given index  * in the constructor argument list or generically matches by type.  * @param index the index in the constructor argument list  * @param requiredType the parameter type to match  * @return the ValueHolder for the argument, or {@code null} if none set  */ ;/**  * Look for an argument value that either corresponds to the given index  * in the constructor argument list or generically matches by type.  * @param index the index in the constructor argument list  * @param requiredType the parameter type to match  * @return the ValueHolder for the argument, or {@code null} if none set  */ @Nullable public ValueHolder getArgumentValue(int index, Class<?> requiredType) {     return getArgumentValue(index, requiredType, null, null). }
true;public;3;4;/**  * Look for an argument value that either corresponds to the given index  * in the constructor argument list or generically matches by type.  * @param index the index in the constructor argument list  * @param requiredType the parameter type to match  * @param requiredName the parameter name to match  * @return the ValueHolder for the argument, or {@code null} if none set  */ ;/**  * Look for an argument value that either corresponds to the given index  * in the constructor argument list or generically matches by type.  * @param index the index in the constructor argument list  * @param requiredType the parameter type to match  * @param requiredName the parameter name to match  * @return the ValueHolder for the argument, or {@code null} if none set  */ @Nullable public ValueHolder getArgumentValue(int index, Class<?> requiredType, String requiredName) {     return getArgumentValue(index, requiredType, requiredName, null). }
true;public;4;9;/**  * Look for an argument value that either corresponds to the given index  * in the constructor argument list or generically matches by type.  * @param index the index in the constructor argument list  * @param requiredType the parameter type to match (can be {@code null}  * to find an untyped argument value)  * @param requiredName the parameter name to match (can be {@code null}  * to find an unnamed argument value, or empty String to match any name)  * @param usedValueHolders a Set of ValueHolder objects that have already  * been used in the current resolution process and should therefore not  * be returned again (allowing to return the next generic argument match  * in case of multiple generic argument values of the same type)  * @return the ValueHolder for the argument, or {@code null} if none set  */ ;/**  * Look for an argument value that either corresponds to the given index  * in the constructor argument list or generically matches by type.  * @param index the index in the constructor argument list  * @param requiredType the parameter type to match (can be {@code null}  * to find an untyped argument value)  * @param requiredName the parameter name to match (can be {@code null}  * to find an unnamed argument value, or empty String to match any name)  * @param usedValueHolders a Set of ValueHolder objects that have already  * been used in the current resolution process and should therefore not  * be returned again (allowing to return the next generic argument match  * in case of multiple generic argument values of the same type)  * @return the ValueHolder for the argument, or {@code null} if none set  */ @Nullable public ValueHolder getArgumentValue(int index, @Nullable Class<?> requiredType, @Nullable String requiredName, @Nullable Set<ValueHolder> usedValueHolders) {     Assert.isTrue(index >= 0, "Index must not be negative").     ValueHolder valueHolder = getIndexedArgumentValue(index, requiredType, requiredName).     if (valueHolder == null) {         valueHolder = getGenericArgumentValue(requiredType, requiredName, usedValueHolders).     }     return valueHolder. }
true;public;0;3;/**  * Return the number of argument values held in this instance,  * counting both indexed and generic argument values.  */ ;/**  * Return the number of argument values held in this instance,  * counting both indexed and generic argument values.  */ public int getArgumentCount() {     return (this.indexedArgumentValues.size() + this.genericArgumentValues.size()). }
true;public;0;3;/**  * Return if this holder does not contain any argument values,  * neither indexed ones nor generic ones.  */ ;/**  * Return if this holder does not contain any argument values,  * neither indexed ones nor generic ones.  */ public boolean isEmpty() {     return (this.indexedArgumentValues.isEmpty() && this.genericArgumentValues.isEmpty()). }
true;public;0;4;/**  * Clear this holder, removing all argument values.  */ ;/**  * Clear this holder, removing all argument values.  */ public void clear() {     this.indexedArgumentValues.clear().     this.genericArgumentValues.clear(). }
false;public;1;31;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof ConstructorArgumentValues)) {         return false.     }     ConstructorArgumentValues that = (ConstructorArgumentValues) other.     if (this.genericArgumentValues.size() != that.genericArgumentValues.size() || this.indexedArgumentValues.size() != that.indexedArgumentValues.size()) {         return false.     }     Iterator<ValueHolder> it1 = this.genericArgumentValues.iterator().     Iterator<ValueHolder> it2 = that.genericArgumentValues.iterator().     while (it1.hasNext() && it2.hasNext()) {         ValueHolder vh1 = it1.next().         ValueHolder vh2 = it2.next().         if (!vh1.contentEquals(vh2)) {             return false.         }     }     for (Map.Entry<Integer, ValueHolder> entry : this.indexedArgumentValues.entrySet()) {         ValueHolder vh1 = entry.getValue().         ValueHolder vh2 = that.indexedArgumentValues.get(entry.getKey()).         if (!vh1.contentEquals(vh2)) {             return false.         }     }     return true. }
false;public;0;12;;@Override public int hashCode() {     int hashCode = 7.     for (ValueHolder valueHolder : this.genericArgumentValues) {         hashCode = 31 * hashCode + valueHolder.contentHashCode().     }     hashCode = 29 * hashCode.     for (Map.Entry<Integer, ValueHolder> entry : this.indexedArgumentValues.entrySet()) {         hashCode = 31 * hashCode + (entry.getValue().contentHashCode() ^ entry.getKey().hashCode()).     }     return hashCode. }
true;public;1;3;/**  * Set the value for the constructor argument.  */ ;/**  * Set the value for the constructor argument.  */ public void setValue(@Nullable Object value) {     this.value = value. }
true;public;0;4;/**  * Return the value for the constructor argument.  */ ;/**  * Return the value for the constructor argument.  */ @Nullable public Object getValue() {     return this.value. }
true;public;1;3;/**  * Set the type of the constructor argument.  */ ;/**  * Set the type of the constructor argument.  */ public void setType(@Nullable String type) {     this.type = type. }
true;public;0;4;/**  * Return the type of the constructor argument.  */ ;/**  * Return the type of the constructor argument.  */ @Nullable public String getType() {     return this.type. }
true;public;1;3;/**  * Set the name of the constructor argument.  */ ;/**  * Set the name of the constructor argument.  */ public void setName(@Nullable String name) {     this.name = name. }
true;public;0;4;/**  * Return the name of the constructor argument.  */ ;/**  * Return the name of the constructor argument.  */ @Nullable public String getName() {     return this.name. }
true;public;1;3;/**  * Set the configuration source {@code Object} for this metadata element.  * <p>The exact type of the object will depend on the configuration mechanism used.  */ ;/**  * Set the configuration source {@code Object} for this metadata element.  * <p>The exact type of the object will depend on the configuration mechanism used.  */ public void setSource(@Nullable Object source) {     this.source = source. }
false;public;0;5;;@Override @Nullable public Object getSource() {     return this.source. }
true;public,synchronized;0;3;/**  * Return whether this holder contains a converted value already ({@code true}),  * or whether the value still needs to be converted ({@code false}).  */ ;/**  * Return whether this holder contains a converted value already ({@code true}),  * or whether the value still needs to be converted ({@code false}).  */ public synchronized boolean isConverted() {     return this.converted. }
true;public,synchronized;1;4;/**  * Set the converted value of the constructor argument,  * after processed type conversion.  */ ;/**  * Set the converted value of the constructor argument,  * after processed type conversion.  */ public synchronized void setConvertedValue(@Nullable Object value) {     this.converted = (value != null).     this.convertedValue = value. }
true;public,synchronized;0;4;/**  * Return the converted value of the constructor argument,  * after processed type conversion.  */ ;/**  * Return the converted value of the constructor argument,  * after processed type conversion.  */ @Nullable public synchronized Object getConvertedValue() {     return this.convertedValue. }
true;private;1;4;/**  * Determine whether the content of this ValueHolder is equal  * to the content of the given other ValueHolder.  * <p>Note that ValueHolder does not implement {@code equals}  * directly, to allow for multiple ValueHolder instances with the  * same content to reside in the same Set.  */ ;/**  * Determine whether the content of this ValueHolder is equal  * to the content of the given other ValueHolder.  * <p>Note that ValueHolder does not implement {@code equals}  * directly, to allow for multiple ValueHolder instances with the  * same content to reside in the same Set.  */ private boolean contentEquals(ValueHolder other) {     return (this == other || (ObjectUtils.nullSafeEquals(this.value, other.value) && ObjectUtils.nullSafeEquals(this.type, other.type))). }
true;private;0;3;/**  * Determine whether the hash code of the content of this ValueHolder.  * <p>Note that ValueHolder does not implement {@code hashCode}  * directly, to allow for multiple ValueHolder instances with the  * same content to reside in the same Set.  */ ;/**  * Determine whether the hash code of the content of this ValueHolder.  * <p>Note that ValueHolder does not implement {@code hashCode}  * directly, to allow for multiple ValueHolder instances with the  * same content to reside in the same Set.  */ private int contentHashCode() {     return ObjectUtils.nullSafeHashCode(this.value) * 29 + ObjectUtils.nullSafeHashCode(this.type). }
true;public;0;5;/**  * Create a copy of this ValueHolder: that is, an independent  * ValueHolder instance with the same contents.  */ ;/**  * Create a copy of this ValueHolder: that is, an independent  * ValueHolder instance with the same contents.  */ public ValueHolder copy() {     ValueHolder copy = new ValueHolder(this.value, this.type, this.name).     copy.setSource(this.source).     return copy. }
