# id;timestamp;commentText;codeText;commentWords;codeWords
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1328020251;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1356735495;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1357119239;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1368482696;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1381787404;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1381843307;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1382826936;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1382905564;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1382912267;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1382963145;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1385412762;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1414498942;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1467846264;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1482012648;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1496837955;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1498780456;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1506097334;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1518770299;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1530174524;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1542613849;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1545401405;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1546963894;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1548002286;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;public static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;public,static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1498780456;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1506097334;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1518770299;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1530174524;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1542613849;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code createProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,create,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1545401405;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code createProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,create,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1546963894;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code createProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,create,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1548002286;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code createProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,create,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> private static AnnotatedElement getEffectiveAnnotatedParameter(Parameter parameter, int index);1551276945;Due to a bug in {@code javac} on JDK versions prior to JDK 9, looking up_annotations directly on a {@link Parameter} will fail for inner class_constructors._<h4>Bug in javac in JDK &lt_ 9</h4>_<p>The parameter annotations array in the compiled byte code excludes an entry_for the implicit <em>enclosing instance</em> parameter for an inner class_constructor._<h4>Workaround</h4>_<p>This method provides a workaround for this off-by-one error by allowing the_caller to access annotations on the preceding {@link Parameter} object (i.e.,_{@code index - 1}). If the supplied {@code index} is zero, this method returns_an empty {@code AnnotatedElement}._<h4>WARNING</h4>_<p>The {@code AnnotatedElement} returned by this method should never be cast and_treated as a {@code Parameter} since the metadata (e.g., {@link Parameter#getName()},_{@link Parameter#getType()}, etc.) will not match those for the declared parameter_at the given index in an inner class constructor._@return the supplied {@code parameter} or the <em>effective</em> {@code Parameter}_if the aforementioned bug is in effect;private static AnnotatedElement getEffectiveAnnotatedParameter(Parameter parameter, int index) {_		Executable executable = parameter.getDeclaringExecutable()__		if (executable instanceof Constructor && ClassUtils.isInnerClass(executable.getDeclaringClass()) &&_				executable.getParameterAnnotations().length == executable.getParameterCount() - 1) {_			_			_			return (index == 0 ? EMPTY_ANNOTATED_ELEMENT : executable.getParameters()[index - 1])__		}_		return parameter__	};due,to,a,bug,in,code,javac,on,jdk,versions,prior,to,jdk,9,looking,up,annotations,directly,on,a,link,parameter,will,fail,for,inner,class,constructors,h4,bug,in,javac,in,jdk,lt,9,h4,p,the,parameter,annotations,array,in,the,compiled,byte,code,excludes,an,entry,for,the,implicit,em,enclosing,instance,em,parameter,for,an,inner,class,constructor,h4,workaround,h4,p,this,method,provides,a,workaround,for,this,off,by,one,error,by,allowing,the,caller,to,access,annotations,on,the,preceding,link,parameter,object,i,e,code,index,1,if,the,supplied,code,index,is,zero,this,method,returns,an,empty,code,annotated,element,h4,warning,h4,p,the,code,annotated,element,returned,by,this,method,should,never,be,cast,and,treated,as,a,code,parameter,since,the,metadata,e,g,link,parameter,get,name,link,parameter,get,type,etc,will,not,match,those,for,the,declared,parameter,at,the,given,index,in,an,inner,class,constructor,return,the,supplied,code,parameter,or,the,em,effective,em,code,parameter,if,the,aforementioned,bug,is,in,effect;private,static,annotated,element,get,effective,annotated,parameter,parameter,parameter,int,index,executable,executable,parameter,get,declaring,executable,if,executable,instanceof,constructor,class,utils,is,inner,class,executable,get,declaring,class,executable,get,parameter,annotations,length,executable,get,parameter,count,1,return,index,0,executable,get,parameters,index,1,return,parameter
AutowireUtils -> private static AnnotatedElement getEffectiveAnnotatedParameter(Parameter parameter, int index);1551281134;Due to a bug in {@code javac} on JDK versions prior to JDK 9, looking up_annotations directly on a {@link Parameter} will fail for inner class_constructors._<h4>Bug in javac in JDK &lt_ 9</h4>_<p>The parameter annotations array in the compiled byte code excludes an entry_for the implicit <em>enclosing instance</em> parameter for an inner class_constructor._<h4>Workaround</h4>_<p>This method provides a workaround for this off-by-one error by allowing the_caller to access annotations on the preceding {@link Parameter} object (i.e.,_{@code index - 1}). If the supplied {@code index} is zero, this method returns_an empty {@code AnnotatedElement}._<h4>WARNING</h4>_<p>The {@code AnnotatedElement} returned by this method should never be cast and_treated as a {@code Parameter} since the metadata (e.g., {@link Parameter#getName()},_{@link Parameter#getType()}, etc.) will not match those for the declared parameter_at the given index in an inner class constructor._@return the supplied {@code parameter} or the <em>effective</em> {@code Parameter}_if the aforementioned bug is in effect;private static AnnotatedElement getEffectiveAnnotatedParameter(Parameter parameter, int index) {_		Executable executable = parameter.getDeclaringExecutable()__		if (executable instanceof Constructor && ClassUtils.isInnerClass(executable.getDeclaringClass()) &&_				executable.getParameterAnnotations().length == executable.getParameterCount() - 1) {_			_			_			return (index == 0 ? EMPTY_ANNOTATED_ELEMENT : executable.getParameters()[index - 1])__		}_		return parameter__	};due,to,a,bug,in,code,javac,on,jdk,versions,prior,to,jdk,9,looking,up,annotations,directly,on,a,link,parameter,will,fail,for,inner,class,constructors,h4,bug,in,javac,in,jdk,lt,9,h4,p,the,parameter,annotations,array,in,the,compiled,byte,code,excludes,an,entry,for,the,implicit,em,enclosing,instance,em,parameter,for,an,inner,class,constructor,h4,workaround,h4,p,this,method,provides,a,workaround,for,this,off,by,one,error,by,allowing,the,caller,to,access,annotations,on,the,preceding,link,parameter,object,i,e,code,index,1,if,the,supplied,code,index,is,zero,this,method,returns,an,empty,code,annotated,element,h4,warning,h4,p,the,code,annotated,element,returned,by,this,method,should,never,be,cast,and,treated,as,a,code,parameter,since,the,metadata,e,g,link,parameter,get,name,link,parameter,get,type,etc,will,not,match,those,for,the,declared,parameter,at,the,given,index,in,an,inner,class,constructor,return,the,supplied,code,parameter,or,the,em,effective,em,code,parameter,if,the,aforementioned,bug,is,in,effect;private,static,annotated,element,get,effective,annotated,parameter,parameter,parameter,int,index,executable,executable,parameter,get,declaring,executable,if,executable,instanceof,constructor,class,utils,is,inner,class,executable,get,declaring,class,executable,get,parameter,annotations,length,executable,get,parameter,count,1,return,index,0,executable,get,parameters,index,1,return,parameter
AutowireUtils -> private static AnnotatedElement getEffectiveAnnotatedParameter(Parameter parameter, int index);1551282060;Due to a bug in {@code javac} on JDK versions prior to JDK 9, looking up_annotations directly on a {@link Parameter} will fail for inner class_constructors._<h4>Bug in javac in JDK &lt_ 9</h4>_<p>The parameter annotations array in the compiled byte code excludes an entry_for the implicit <em>enclosing instance</em> parameter for an inner class_constructor._<h4>Workaround</h4>_<p>This method provides a workaround for this off-by-one error by allowing the_caller to access annotations on the preceding {@link Parameter} object (i.e.,_{@code index - 1}). If the supplied {@code index} is zero, this method returns_an empty {@code AnnotatedElement}._<h4>WARNING</h4>_<p>The {@code AnnotatedElement} returned by this method should never be cast and_treated as a {@code Parameter} since the metadata (e.g., {@link Parameter#getName()},_{@link Parameter#getType()}, etc.) will not match those for the declared parameter_at the given index in an inner class constructor._@return the supplied {@code parameter} or the <em>effective</em> {@code Parameter}_if the aforementioned bug is in effect;private static AnnotatedElement getEffectiveAnnotatedParameter(Parameter parameter, int index) {_		Executable executable = parameter.getDeclaringExecutable()__		if (executable instanceof Constructor && ClassUtils.isInnerClass(executable.getDeclaringClass()) &&_				executable.getParameterAnnotations().length == executable.getParameterCount() - 1) {_			_			_			return (index == 0 ? EMPTY_ANNOTATED_ELEMENT : executable.getParameters()[index - 1])__		}_		return parameter__	};due,to,a,bug,in,code,javac,on,jdk,versions,prior,to,jdk,9,looking,up,annotations,directly,on,a,link,parameter,will,fail,for,inner,class,constructors,h4,bug,in,javac,in,jdk,lt,9,h4,p,the,parameter,annotations,array,in,the,compiled,byte,code,excludes,an,entry,for,the,implicit,em,enclosing,instance,em,parameter,for,an,inner,class,constructor,h4,workaround,h4,p,this,method,provides,a,workaround,for,this,off,by,one,error,by,allowing,the,caller,to,access,annotations,on,the,preceding,link,parameter,object,i,e,code,index,1,if,the,supplied,code,index,is,zero,this,method,returns,an,empty,code,annotated,element,h4,warning,h4,p,the,code,annotated,element,returned,by,this,method,should,never,be,cast,and,treated,as,a,code,parameter,since,the,metadata,e,g,link,parameter,get,name,link,parameter,get,type,etc,will,not,match,those,for,the,declared,parameter,at,the,given,index,in,an,inner,class,constructor,return,the,supplied,code,parameter,or,the,em,effective,em,code,parameter,if,the,aforementioned,bug,is,in,effect;private,static,annotated,element,get,effective,annotated,parameter,parameter,parameter,int,index,executable,executable,parameter,get,declaring,executable,if,executable,instanceof,constructor,class,utils,is,inner,class,executable,get,declaring,class,executable,get,parameter,annotations,length,executable,get,parameter,count,1,return,index,0,executable,get,parameters,index,1,return,parameter
AutowireUtils -> public static boolean isAutowirable(Parameter parameter, int parameterIndex);1551276945;Determine if the supplied {@link Parameter} can <em>potentially</em> be_autowired from an {@link AutowireCapableBeanFactory}._<p>Returns {@code true} if the supplied parameter is annotated or_meta-annotated with {@link Autowired @Autowired},_{@link Qualifier @Qualifier}, or {@link Value @Value}._<p>Note that {@link #resolveDependency} may still be able to resolve the_dependency for the supplied parameter even if this method returns {@code false}._@param parameter the parameter whose dependency should be autowired_@param parameterIndex the index of the parameter in the constructor or method_that declares the parameter_@see #resolveDependency_@since 5.2;public static boolean isAutowirable(Parameter parameter, int parameterIndex) {_		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex)__		return (AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class) ||_				AnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class) ||_				AnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class))__	};determine,if,the,supplied,link,parameter,can,em,potentially,em,be,autowired,from,an,link,autowire,capable,bean,factory,p,returns,code,true,if,the,supplied,parameter,is,annotated,or,meta,annotated,with,link,autowired,autowired,link,qualifier,qualifier,or,link,value,value,p,note,that,link,resolve,dependency,may,still,be,able,to,resolve,the,dependency,for,the,supplied,parameter,even,if,this,method,returns,code,false,param,parameter,the,parameter,whose,dependency,should,be,autowired,param,parameter,index,the,index,of,the,parameter,in,the,constructor,or,method,that,declares,the,parameter,see,resolve,dependency,since,5,2;public,static,boolean,is,autowirable,parameter,parameter,int,parameter,index,annotated,element,annotated,parameter,get,effective,annotated,parameter,parameter,parameter,index,return,annotated,element,utils,has,annotation,annotated,parameter,autowired,class,annotated,element,utils,has,annotation,annotated,parameter,qualifier,class,annotated,element,utils,has,annotation,annotated,parameter,value,class
AutowireUtils -> public static boolean isAutowirable(Parameter parameter, int parameterIndex);1551281134;Determine if the supplied {@link Parameter} can <em>potentially</em> be_autowired from an {@link AutowireCapableBeanFactory}._<p>Returns {@code true} if the supplied parameter is annotated or_meta-annotated with {@link Autowired @Autowired},_{@link Qualifier @Qualifier}, or {@link Value @Value}._<p>Note that {@link #resolveDependency} may still be able to resolve the_dependency for the supplied parameter even if this method returns {@code false}._@param parameter the parameter whose dependency should be autowired (must not be_{@code null})_@param parameterIndex the index of the parameter in the constructor or method_that declares the parameter_@see #resolveDependency_@since 5.2;public static boolean isAutowirable(Parameter parameter, int parameterIndex) {_		Assert.notNull(parameter, "Parameter must not be null")__		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex)__		return (AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class) ||_				AnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class) ||_				AnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class))__	};determine,if,the,supplied,link,parameter,can,em,potentially,em,be,autowired,from,an,link,autowire,capable,bean,factory,p,returns,code,true,if,the,supplied,parameter,is,annotated,or,meta,annotated,with,link,autowired,autowired,link,qualifier,qualifier,or,link,value,value,p,note,that,link,resolve,dependency,may,still,be,able,to,resolve,the,dependency,for,the,supplied,parameter,even,if,this,method,returns,code,false,param,parameter,the,parameter,whose,dependency,should,be,autowired,must,not,be,code,null,param,parameter,index,the,index,of,the,parameter,in,the,constructor,or,method,that,declares,the,parameter,see,resolve,dependency,since,5,2;public,static,boolean,is,autowirable,parameter,parameter,int,parameter,index,assert,not,null,parameter,parameter,must,not,be,null,annotated,element,annotated,parameter,get,effective,annotated,parameter,parameter,parameter,index,return,annotated,element,utils,has,annotation,annotated,parameter,autowired,class,annotated,element,utils,has,annotation,annotated,parameter,qualifier,class,annotated,element,utils,has,annotation,annotated,parameter,value,class
AutowireUtils -> public static boolean isAutowirable(Parameter parameter, int parameterIndex);1551282060;Determine if the supplied {@link Parameter} can <em>potentially</em> be_autowired from an {@link AutowireCapableBeanFactory}._<p>Returns {@code true} if the supplied parameter is annotated or_meta-annotated with {@link Autowired @Autowired},_{@link Qualifier @Qualifier}, or {@link Value @Value}._<p>Note that {@link #resolveDependency} may still be able to resolve the_dependency for the supplied parameter even if this method returns {@code false}._@param parameter the parameter whose dependency should be autowired (must not be_{@code null})_@param parameterIndex the index of the parameter in the constructor or method_that declares the parameter_@since 5.2_@see #resolveDependency;public static boolean isAutowirable(Parameter parameter, int parameterIndex) {_		Assert.notNull(parameter, "Parameter must not be null")__		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex)__		return (AnnotatedElementUtils.hasAnnotation(annotatedParameter, Autowired.class) ||_				AnnotatedElementUtils.hasAnnotation(annotatedParameter, Qualifier.class) ||_				AnnotatedElementUtils.hasAnnotation(annotatedParameter, Value.class))__	};determine,if,the,supplied,link,parameter,can,em,potentially,em,be,autowired,from,an,link,autowire,capable,bean,factory,p,returns,code,true,if,the,supplied,parameter,is,annotated,or,meta,annotated,with,link,autowired,autowired,link,qualifier,qualifier,or,link,value,value,p,note,that,link,resolve,dependency,may,still,be,able,to,resolve,the,dependency,for,the,supplied,parameter,even,if,this,method,returns,code,false,param,parameter,the,parameter,whose,dependency,should,be,autowired,must,not,be,code,null,param,parameter,index,the,index,of,the,parameter,in,the,constructor,or,method,that,declares,the,parameter,since,5,2,see,resolve,dependency;public,static,boolean,is,autowirable,parameter,parameter,int,parameter,index,assert,not,null,parameter,parameter,must,not,be,null,annotated,element,annotated,parameter,get,effective,annotated,parameter,parameter,parameter,index,return,annotated,element,utils,has,annotation,annotated,parameter,autowired,class,annotated,element,utils,has,annotation,annotated,parameter,qualifier,class,annotated,element,utils,has,annotation,annotated,parameter,value,class
AutowireUtils -> @Nullable 	public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1496837955;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;@Nullable_	public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;nullable,public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> @Nullable 	public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1498780456;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;@Nullable_	public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;nullable,public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1385412762;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1414498942;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1467846264;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1482012648;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1496837955;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1498780456;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1506097334;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1518770299;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1530174524;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1542613849;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1545401405;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1546963894;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1548002286;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1381787404;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1381843307;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1382826936;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1382905564;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1382912267;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1382963145;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1385412762;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1414498942;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1467846264;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1482012648;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1506097334;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1518770299;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1530174524;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1542613849;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1545401405;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1546963894;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1548002286;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1551276945;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1551281134;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType);1551282060;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;static Object resolveAutowiringValue(Object autowiringValue, Class<?> requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory<?> factory = (ObjectFactory<?>) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class<?>[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class requiredType);1328020251;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class requiredType);1356735495;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class requiredType);1357119239;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static Object resolveAutowiringValue(Object autowiringValue, Class requiredType);1368482696;Resolve the given autowiring value against the given required type,_e.g. an {@link ObjectFactory} value to its actual object result._@param autowiringValue the value to resolve_@param requiredType the type to assign the result to_@return the resolved value;public static Object resolveAutowiringValue(Object autowiringValue, Class requiredType) {_		if (autowiringValue instanceof ObjectFactory && !requiredType.isInstance(autowiringValue)) {_			ObjectFactory factory = (ObjectFactory) autowiringValue__			if (autowiringValue instanceof Serializable && requiredType.isInterface()) {_				autowiringValue = Proxy.newProxyInstance(requiredType.getClassLoader(),_						new Class[] {requiredType}, new ObjectFactoryDelegatingInvocationHandler(factory))__			}_			else {_				return factory.getObject()__			}_		}_		return autowiringValue__	};resolve,the,given,autowiring,value,against,the,given,required,type,e,g,an,link,object,factory,value,to,its,actual,object,result,param,autowiring,value,the,value,to,resolve,param,required,type,the,type,to,assign,the,result,to,return,the,resolved,value;public,static,object,resolve,autowiring,value,object,autowiring,value,class,required,type,if,autowiring,value,instanceof,object,factory,required,type,is,instance,autowiring,value,object,factory,factory,object,factory,autowiring,value,if,autowiring,value,instanceof,serializable,required,type,is,interface,autowiring,value,proxy,new,proxy,instance,required,type,get,class,loader,new,class,required,type,new,object,factory,delegating,invocation,handler,factory,else,return,factory,get,object,return,autowiring,value
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1328020251;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1356735495;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			@Override_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1357119239;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1368482696;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			@Override_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1381787404;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			@Override_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1381843307;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			@Override_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1382826936;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			@Override_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1382905564;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			@Override_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1382912267;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			@Override_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor[] constructors);1382963145;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor>() {_			@Override_			public int compare(Constructor c1, Constructor c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1385412762;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor<?>>() {_			@Override_			public int compare(Constructor<?> c1, Constructor<?> c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1414498942;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor<?>>() {_			@Override_			public int compare(Constructor<?> c1, Constructor<?> c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterTypes().length__				int c2pl = c2.getParameterTypes().length__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,types,length,int,c2pl,c2,get,parameter,types,length,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1467846264;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor<?>>() {_			@Override_			public int compare(Constructor<?> c1, Constructor<?> c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterCount()__				int c2pl = c2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1482012648;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor<?>>() {_			@Override_			public int compare(Constructor<?> c1, Constructor<?> c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterCount()__				int c2pl = c2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1496837955;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor<?>>() {_			@Override_			public int compare(Constructor<?> c1, Constructor<?> c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterCount()__				int c2pl = c2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1498780456;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor<?>>() {_			@Override_			public int compare(Constructor<?> c1, Constructor<?> c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterCount()__				int c2pl = c2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1506097334;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, new Comparator<Constructor<?>>() {_			@Override_			public int compare(Constructor<?> c1, Constructor<?> c2) {_				boolean p1 = Modifier.isPublic(c1.getModifiers())__				boolean p2 = Modifier.isPublic(c2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = c1.getParameterCount()__				int c2pl = c2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,new,comparator,constructor,override,public,int,compare,constructor,c1,constructor,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1518770299;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, (c1, c2) -> {_            boolean p1 = Modifier.isPublic(c1.getModifiers())__            boolean p2 = Modifier.isPublic(c2.getModifiers())__            if (p1 != p2) {_                return (p1 ? -1 : 1)__            }_            int c1pl = c1.getParameterCount()__            int c2pl = c2.getParameterCount()__            return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__        })__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,c1,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1530174524;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, (c1, c2) -> {_			boolean p1 = Modifier.isPublic(c1.getModifiers())__			boolean p2 = Modifier.isPublic(c2.getModifiers())__			if (p1 != p2) {_				return (p1 ? -1 : 1)__			}_			int c1pl = c1.getParameterCount()__			int c2pl = c2.getParameterCount()__			return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,c1,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1542613849;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, (c1, c2) -> {_			boolean p1 = Modifier.isPublic(c1.getModifiers())__			boolean p2 = Modifier.isPublic(c2.getModifiers())__			if (p1 != p2) {_				return (p1 ? -1 : 1)__			}_			int c1pl = c1.getParameterCount()__			int c2pl = c2.getParameterCount()__			return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__		})__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors,c1,c2,boolean,p1,modifier,is,public,c1,get,modifiers,boolean,p2,modifier,is,public,c2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,c1,get,parameter,count,int,c2pl,c2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1545401405;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, EXECUTABLE_COMPARATOR)__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1546963894;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, EXECUTABLE_COMPARATOR)__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors
AutowireUtils -> public static void sortConstructors(Constructor<?>[] constructors);1548002286;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;public static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, EXECUTABLE_COMPARATOR)__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;public,static,void,sort,constructors,constructor,constructors,arrays,sort,constructors
AutowireUtils -> @Nullable 	public static Object resolveDependency( 			Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory) 			throws BeansException;1551276945;Resolve the dependency for the supplied {@link Parameter} from the_supplied {@link AutowireCapableBeanFactory}._<p>Provides comprehensive autowiring support for individual method parameters_on par with Spring's dependency injection facilities for autowired fields and_methods, including support for {@link Autowired @Autowired},_{@link Qualifier @Qualifier}, and {@link Value @Value} with support for property_placeholders and SpEL expressions in {@code @Value} declarations._<p>The dependency is required unless the parameter is annotated or meta-annotated_with {@link Autowired @Autowired} with the {@link Autowired#required required}_flag set to {@code false}._<p>If an explicit <em>qualifier</em> is not declared, the name of the parameter_will be used as the qualifier for resolving ambiguities._@param parameter the parameter whose dependency should be resolved_@param parameterIndex the index of the parameter in the constructor or method_that declares the parameter_@param containingClass the concrete class that contains the parameter_ this may_differ from the class that declares the parameter in that it may be a subclass_thereof, potentially substituting type variables_@param beanFactory the {@code AutowireCapableBeanFactory} from which to resolve_the dependency_@return the resolved object, or {@code null} if none found_@throws BeansException if dependency resolution failed_@see #isAutowirable_@see Autowired#required_@see SynthesizingMethodParameter#forExecutable(Executable, int)_@see AutowireCapableBeanFactory#resolveDependency(DependencyDescriptor, String)_@since 5.2;@Nullable_	public static Object resolveDependency(_			Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory)_			throws BeansException {__		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex)__		Autowired autowired = AnnotatedElementUtils.findMergedAnnotation(annotatedParameter, Autowired.class)__		boolean required = (autowired == null || autowired.required())___		MethodParameter methodParameter = SynthesizingMethodParameter.forExecutable(_				parameter.getDeclaringExecutable(), parameterIndex)__		DependencyDescriptor descriptor = new DependencyDescriptor(methodParameter, required)__		descriptor.setContainingClass(containingClass)__		return beanFactory.resolveDependency(descriptor, null)__	};resolve,the,dependency,for,the,supplied,link,parameter,from,the,supplied,link,autowire,capable,bean,factory,p,provides,comprehensive,autowiring,support,for,individual,method,parameters,on,par,with,spring,s,dependency,injection,facilities,for,autowired,fields,and,methods,including,support,for,link,autowired,autowired,link,qualifier,qualifier,and,link,value,value,with,support,for,property,placeholders,and,sp,el,expressions,in,code,value,declarations,p,the,dependency,is,required,unless,the,parameter,is,annotated,or,meta,annotated,with,link,autowired,autowired,with,the,link,autowired,required,required,flag,set,to,code,false,p,if,an,explicit,em,qualifier,em,is,not,declared,the,name,of,the,parameter,will,be,used,as,the,qualifier,for,resolving,ambiguities,param,parameter,the,parameter,whose,dependency,should,be,resolved,param,parameter,index,the,index,of,the,parameter,in,the,constructor,or,method,that,declares,the,parameter,param,containing,class,the,concrete,class,that,contains,the,parameter,this,may,differ,from,the,class,that,declares,the,parameter,in,that,it,may,be,a,subclass,thereof,potentially,substituting,type,variables,param,bean,factory,the,code,autowire,capable,bean,factory,from,which,to,resolve,the,dependency,return,the,resolved,object,or,code,null,if,none,found,throws,beans,exception,if,dependency,resolution,failed,see,is,autowirable,see,autowired,required,see,synthesizing,method,parameter,for,executable,executable,int,see,autowire,capable,bean,factory,resolve,dependency,dependency,descriptor,string,since,5,2;nullable,public,static,object,resolve,dependency,parameter,parameter,int,parameter,index,class,containing,class,autowire,capable,bean,factory,bean,factory,throws,beans,exception,annotated,element,annotated,parameter,get,effective,annotated,parameter,parameter,parameter,index,autowired,autowired,annotated,element,utils,find,merged,annotation,annotated,parameter,autowired,class,boolean,required,autowired,null,autowired,required,method,parameter,method,parameter,synthesizing,method,parameter,for,executable,parameter,get,declaring,executable,parameter,index,dependency,descriptor,descriptor,new,dependency,descriptor,method,parameter,required,descriptor,set,containing,class,containing,class,return,bean,factory,resolve,dependency,descriptor,null
AutowireUtils -> @Nullable 	public static Object resolveDependency( 			Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory) 			throws BeansException;1551281134;Resolve the dependency for the supplied {@link Parameter} from the_supplied {@link AutowireCapableBeanFactory}._<p>Provides comprehensive autowiring support for individual method parameters_on par with Spring's dependency injection facilities for autowired fields and_methods, including support for {@link Autowired @Autowired},_{@link Qualifier @Qualifier}, and {@link Value @Value} with support for property_placeholders and SpEL expressions in {@code @Value} declarations._<p>The dependency is required unless the parameter is annotated or meta-annotated_with {@link Autowired @Autowired} with the {@link Autowired#required required}_flag set to {@code false}._<p>If an explicit <em>qualifier</em> is not declared, the name of the parameter_will be used as the qualifier for resolving ambiguities._@param parameter the parameter whose dependency should be resolved (must not be_{@code null})_@param parameterIndex the index of the parameter in the constructor or method_that declares the parameter_@param containingClass the concrete class that contains the parameter_ this may_differ from the class that declares the parameter in that it may be a subclass_thereof, potentially substituting type variables_@param beanFactory the {@code AutowireCapableBeanFactory} from which to resolve_the dependency (must not be {@code null})_@return the resolved object, or {@code null} if none found_@throws BeansException if dependency resolution failed_@see #isAutowirable_@see Autowired#required_@see SynthesizingMethodParameter#forExecutable(Executable, int)_@see AutowireCapableBeanFactory#resolveDependency(DependencyDescriptor, String)_@since 5.2;@Nullable_	public static Object resolveDependency(_			Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory)_			throws BeansException {__		Assert.notNull(parameter, "Parameter must not be null")__		Assert.notNull(beanFactory, "AutowireCapableBeanFactory must not be null")___		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex)__		Autowired autowired = AnnotatedElementUtils.findMergedAnnotation(annotatedParameter, Autowired.class)__		boolean required = (autowired == null || autowired.required())___		MethodParameter methodParameter = SynthesizingMethodParameter.forExecutable(_				parameter.getDeclaringExecutable(), parameterIndex)__		DependencyDescriptor descriptor = new DependencyDescriptor(methodParameter, required)__		descriptor.setContainingClass(containingClass)__		return beanFactory.resolveDependency(descriptor, null)__	};resolve,the,dependency,for,the,supplied,link,parameter,from,the,supplied,link,autowire,capable,bean,factory,p,provides,comprehensive,autowiring,support,for,individual,method,parameters,on,par,with,spring,s,dependency,injection,facilities,for,autowired,fields,and,methods,including,support,for,link,autowired,autowired,link,qualifier,qualifier,and,link,value,value,with,support,for,property,placeholders,and,sp,el,expressions,in,code,value,declarations,p,the,dependency,is,required,unless,the,parameter,is,annotated,or,meta,annotated,with,link,autowired,autowired,with,the,link,autowired,required,required,flag,set,to,code,false,p,if,an,explicit,em,qualifier,em,is,not,declared,the,name,of,the,parameter,will,be,used,as,the,qualifier,for,resolving,ambiguities,param,parameter,the,parameter,whose,dependency,should,be,resolved,must,not,be,code,null,param,parameter,index,the,index,of,the,parameter,in,the,constructor,or,method,that,declares,the,parameter,param,containing,class,the,concrete,class,that,contains,the,parameter,this,may,differ,from,the,class,that,declares,the,parameter,in,that,it,may,be,a,subclass,thereof,potentially,substituting,type,variables,param,bean,factory,the,code,autowire,capable,bean,factory,from,which,to,resolve,the,dependency,must,not,be,code,null,return,the,resolved,object,or,code,null,if,none,found,throws,beans,exception,if,dependency,resolution,failed,see,is,autowirable,see,autowired,required,see,synthesizing,method,parameter,for,executable,executable,int,see,autowire,capable,bean,factory,resolve,dependency,dependency,descriptor,string,since,5,2;nullable,public,static,object,resolve,dependency,parameter,parameter,int,parameter,index,class,containing,class,autowire,capable,bean,factory,bean,factory,throws,beans,exception,assert,not,null,parameter,parameter,must,not,be,null,assert,not,null,bean,factory,autowire,capable,bean,factory,must,not,be,null,annotated,element,annotated,parameter,get,effective,annotated,parameter,parameter,parameter,index,autowired,autowired,annotated,element,utils,find,merged,annotation,annotated,parameter,autowired,class,boolean,required,autowired,null,autowired,required,method,parameter,method,parameter,synthesizing,method,parameter,for,executable,parameter,get,declaring,executable,parameter,index,dependency,descriptor,descriptor,new,dependency,descriptor,method,parameter,required,descriptor,set,containing,class,containing,class,return,bean,factory,resolve,dependency,descriptor,null
AutowireUtils -> @Nullable 	public static Object resolveDependency( 			Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory) 			throws BeansException;1551282060;Resolve the dependency for the supplied {@link Parameter} from the_supplied {@link AutowireCapableBeanFactory}._<p>Provides comprehensive autowiring support for individual method parameters_on par with Spring's dependency injection facilities for autowired fields and_methods, including support for {@link Autowired @Autowired},_{@link Qualifier @Qualifier}, and {@link Value @Value} with support for property_placeholders and SpEL expressions in {@code @Value} declarations._<p>The dependency is required unless the parameter is annotated or meta-annotated_with {@link Autowired @Autowired} with the {@link Autowired#required required}_flag set to {@code false}._<p>If an explicit <em>qualifier</em> is not declared, the name of the parameter_will be used as the qualifier for resolving ambiguities._@param parameter the parameter whose dependency should be resolved (must not be_{@code null})_@param parameterIndex the index of the parameter in the constructor or method_that declares the parameter_@param containingClass the concrete class that contains the parameter_ this may_differ from the class that declares the parameter in that it may be a subclass_thereof, potentially substituting type variables_@param beanFactory the {@code AutowireCapableBeanFactory} from which to resolve_the dependency (must not be {@code null})_@return the resolved object, or {@code null} if none found_@throws BeansException if dependency resolution failed_@since 5.2_@see #isAutowirable_@see Autowired#required_@see SynthesizingMethodParameter#forExecutable(Executable, int)_@see AutowireCapableBeanFactory#resolveDependency(DependencyDescriptor, String);@Nullable_	public static Object resolveDependency(_			Parameter parameter, int parameterIndex, Class<?> containingClass, AutowireCapableBeanFactory beanFactory)_			throws BeansException {__		Assert.notNull(parameter, "Parameter must not be null")__		Assert.notNull(beanFactory, "AutowireCapableBeanFactory must not be null")___		AnnotatedElement annotatedParameter = getEffectiveAnnotatedParameter(parameter, parameterIndex)__		Autowired autowired = AnnotatedElementUtils.findMergedAnnotation(annotatedParameter, Autowired.class)__		boolean required = (autowired == null || autowired.required())___		MethodParameter methodParameter = SynthesizingMethodParameter.forExecutable(_				parameter.getDeclaringExecutable(), parameterIndex)__		DependencyDescriptor descriptor = new DependencyDescriptor(methodParameter, required)__		descriptor.setContainingClass(containingClass)__		return beanFactory.resolveDependency(descriptor, null)__	};resolve,the,dependency,for,the,supplied,link,parameter,from,the,supplied,link,autowire,capable,bean,factory,p,provides,comprehensive,autowiring,support,for,individual,method,parameters,on,par,with,spring,s,dependency,injection,facilities,for,autowired,fields,and,methods,including,support,for,link,autowired,autowired,link,qualifier,qualifier,and,link,value,value,with,support,for,property,placeholders,and,sp,el,expressions,in,code,value,declarations,p,the,dependency,is,required,unless,the,parameter,is,annotated,or,meta,annotated,with,link,autowired,autowired,with,the,link,autowired,required,required,flag,set,to,code,false,p,if,an,explicit,em,qualifier,em,is,not,declared,the,name,of,the,parameter,will,be,used,as,the,qualifier,for,resolving,ambiguities,param,parameter,the,parameter,whose,dependency,should,be,resolved,must,not,be,code,null,param,parameter,index,the,index,of,the,parameter,in,the,constructor,or,method,that,declares,the,parameter,param,containing,class,the,concrete,class,that,contains,the,parameter,this,may,differ,from,the,class,that,declares,the,parameter,in,that,it,may,be,a,subclass,thereof,potentially,substituting,type,variables,param,bean,factory,the,code,autowire,capable,bean,factory,from,which,to,resolve,the,dependency,must,not,be,code,null,return,the,resolved,object,or,code,null,if,none,found,throws,beans,exception,if,dependency,resolution,failed,since,5,2,see,is,autowirable,see,autowired,required,see,synthesizing,method,parameter,for,executable,executable,int,see,autowire,capable,bean,factory,resolve,dependency,dependency,descriptor,string;nullable,public,static,object,resolve,dependency,parameter,parameter,int,parameter,index,class,containing,class,autowire,capable,bean,factory,bean,factory,throws,beans,exception,assert,not,null,parameter,parameter,must,not,be,null,assert,not,null,bean,factory,autowire,capable,bean,factory,must,not,be,null,annotated,element,annotated,parameter,get,effective,annotated,parameter,parameter,parameter,index,autowired,autowired,annotated,element,utils,find,merged,annotation,annotated,parameter,autowired,class,boolean,required,autowired,null,autowired,required,method,parameter,method,parameter,synthesizing,method,parameter,for,executable,parameter,get,declaring,executable,parameter,index,dependency,descriptor,descriptor,new,dependency,descriptor,method,parameter,required,descriptor,set,containing,class,containing,class,return,bean,factory,resolve,dependency,descriptor,null
AutowireUtils -> static void sortConstructors(Constructor<?>[] constructors);1551276945;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, EXECUTABLE_COMPARATOR)__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;static,void,sort,constructors,constructor,constructors,arrays,sort,constructors
AutowireUtils -> static void sortConstructors(Constructor<?>[] constructors);1551281134;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, EXECUTABLE_COMPARATOR)__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;static,void,sort,constructors,constructor,constructors,arrays,sort,constructors
AutowireUtils -> static void sortConstructors(Constructor<?>[] constructors);1551282060;Sort the given constructors, preferring public constructors and "greedy" ones with_a maximum number of arguments. The result will contain public constructors first,_with decreasing number of arguments, then non-public constructors, again with_decreasing number of arguments._@param constructors the constructor array to sort;static void sortConstructors(Constructor<?>[] constructors) {_		Arrays.sort(constructors, EXECUTABLE_COMPARATOR)__	};sort,the,given,constructors,preferring,public,constructors,and,greedy,ones,with,a,maximum,number,of,arguments,the,result,will,contain,public,constructors,first,with,decreasing,number,of,arguments,then,non,public,constructors,again,with,decreasing,number,of,arguments,param,constructors,the,constructor,array,to,sort;static,void,sort,constructors,constructor,constructors,arrays,sort,constructors
AutowireUtils -> static void sortFactoryMethods(Method[] factoryMethods);1551276945;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, EXECUTABLE_COMPARATOR)__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods
AutowireUtils -> static void sortFactoryMethods(Method[] factoryMethods);1551281134;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, EXECUTABLE_COMPARATOR)__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods
AutowireUtils -> static void sortFactoryMethods(Method[] factoryMethods);1551282060;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, EXECUTABLE_COMPARATOR)__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1328020251;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class targetClass = setter.getDeclaringClass()__			for (Class ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1356735495;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class targetClass = setter.getDeclaringClass()__			for (Class ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1357119239;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class targetClass = setter.getDeclaringClass()__			for (Class ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1368482696;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class targetClass = setter.getDeclaringClass()__			for (Class ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1381787404;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1381843307;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1382826936;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1382905564;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1382912267;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces);1382963145;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;public static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;public,static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1381787404;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForGenericMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForGenericMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(never {@code null})_@return the resolved target return type, the standard return type, or {@code null};public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specified class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,generic,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,generic,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specified,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1381843307;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(never {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()___		_		if (declaredTypeVariables.length == 0) {_			return method.getReturnType()__		}__		_		_		if (args.length < methodArgumentTypes.length) {_			return null__		}__		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specified class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,if,declared,type,variables,length,0,return,method,get,return,type,if,args,length,method,argument,types,length,return,null,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specified,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1382826936;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(never {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodArgumentTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else if (arg instanceof String) {_								try {_									return classLoader.loadClass((String) arg)__								}_								catch (ClassNotFoundException ex) {_									throw new IllegalStateException(_											"Could not resolve specified class name argument [" + arg + "]", ex)__								}_							}_							else {_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,assert,is,true,args,length,method,argument,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,if,arg,instanceof,string,try,return,class,loader,load,class,string,arg,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specified,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1382905564;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(never {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodArgumentTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodArgumentTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodArgumentTypes.length_ i++) {_				Type currentMethodArgumentType = methodArgumentTypes[i]__				if (currentMethodArgumentType.equals(genericReturnType)) {_					return args[i].getClass()__				}_				if (currentMethodArgumentType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) currentMethodArgumentType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							Object arg = args[i]__							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									className = ((TypedStringValue) arg).getValue()__								}_								if (className != null) {_									try {_										return classLoader.loadClass(className)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException(_												"Could not resolve specified class name argument [" + arg + "]", ex)__									}_								}_								else {_									_									_									return method.getReturnType()__								}_							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,argument,types,method,get,generic,parameter,types,assert,is,true,args,length,method,argument,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,argument,types,length,i,type,current,method,argument,type,method,argument,types,i,if,current,method,argument,type,equals,generic,return,type,return,args,i,get,class,if,current,method,argument,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,current,method,argument,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,object,arg,args,i,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,class,name,typed,string,value,arg,get,value,if,class,name,null,try,return,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specified,class,name,argument,arg,ex,else,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1382912267;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(never {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							return typedValue.resolveTargetType(classLoader)__						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve typed value", ex)__						}_					}_					_					if (arg != null && !(arg instanceof BeanMetadataElement)) {_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return classLoader.loadClass(className)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException(_												"Could not resolve specified class name argument [" + arg + "]", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,return,typed,value,resolve,target,type,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,typed,value,ex,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,loader,load,class,class,name,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,specified,class,name,argument,arg,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1382963145;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(never {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							return typedValue.resolveTargetType(classLoader)__						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					_					if (arg != null && !(arg instanceof BeanMetadataElement)) {_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,return,typed,value,resolve,target,type,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1385412762;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(never {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							return typedValue.resolveTargetType(classLoader)__						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					_					if (arg != null && !(arg instanceof BeanMetadataElement)) {_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,return,typed,value,resolve,target,type,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1414498942;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(never {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							return typedValue.resolveTargetType(classLoader)__						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					_					if (arg != null && !(arg instanceof BeanMetadataElement)) {_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,return,typed,value,resolve,target,type,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1467846264;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature,_if {@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against, if necessary_(never {@code null})_@return the resolved target return type, the standard return type, or {@code null}_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							return typedValue.resolveTargetType(classLoader)__						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					_					if (arg != null && !(arg instanceof BeanMetadataElement)) {_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,the,standard,return,type,or,code,null,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,return,typed,value,resolve,target,type,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1482012648;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							return typedValue.resolveTargetType(classLoader)__						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					_					if (arg != null && !(arg instanceof BeanMetadataElement)) {_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,return,typed,value,resolve,target,type,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader);1496837955;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code creatProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;public static Class<?> resolveReturnTypeForFactoryMethod(Method method, Object[] args, ClassLoader classLoader) {_		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")__		Assert.notNull(classLoader, "ClassLoader must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,creat,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;public,static,class,resolve,return,type,for,factory,method,method,method,object,args,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,assert,not,null,class,loader,class,loader,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1551276945;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1551281134;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd);1551282060;Determine whether the given bean property is excluded from dependency checks._<p>This implementation excludes properties defined by CGLIB._@param pd the PropertyDescriptor of the bean property_@return whether the bean property is excluded;static boolean isExcludedFromDependencyCheck(PropertyDescriptor pd) {_		Method wm = pd.getWriteMethod()__		if (wm == null) {_			return false__		}_		if (!wm.getDeclaringClass().getName().contains("$$")) {_			_			return false__		}_		_		_		Class<?> superclass = wm.getDeclaringClass().getSuperclass()__		return !ClassUtils.hasMethod(superclass, wm.getName(), wm.getParameterTypes())__	};determine,whether,the,given,bean,property,is,excluded,from,dependency,checks,p,this,implementation,excludes,properties,defined,by,cglib,param,pd,the,property,descriptor,of,the,bean,property,return,whether,the,bean,property,is,excluded;static,boolean,is,excluded,from,dependency,check,property,descriptor,pd,method,wm,pd,get,write,method,if,wm,null,return,false,if,wm,get,declaring,class,get,name,contains,return,false,class,superclass,wm,get,declaring,class,get,superclass,return,class,utils,has,method,superclass,wm,get,name,wm,get,parameter,types
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1328020251;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1356735495;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1357119239;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1368482696;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1381787404;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1381843307;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1382826936;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1382905564;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1382912267;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1382963145;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1385412762;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (new Integer(c1pl)).compareTo(c2pl) * -1__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,new,integer,c1pl,compare,to,c2pl,1
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1414498942;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterTypes().length__				int c2pl = fm2.getParameterTypes().length__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,types,length,int,c2pl,fm2,get,parameter,types,length,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1467846264;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterCount()__				int c2pl = fm2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,count,int,c2pl,fm2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1482012648;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterCount()__				int c2pl = fm2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,count,int,c2pl,fm2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1496837955;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterCount()__				int c2pl = fm2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,count,int,c2pl,fm2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1498780456;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterCount()__				int c2pl = fm2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,count,int,c2pl,fm2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1506097334;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, new Comparator<Method>() {_			@Override_			public int compare(Method fm1, Method fm2) {_				boolean p1 = Modifier.isPublic(fm1.getModifiers())__				boolean p2 = Modifier.isPublic(fm2.getModifiers())__				if (p1 != p2) {_					return (p1 ? -1 : 1)__				}_				int c1pl = fm1.getParameterCount()__				int c2pl = fm2.getParameterCount()__				return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__			}_		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,new,comparator,method,override,public,int,compare,method,fm1,method,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,count,int,c2pl,fm2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1518770299;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, (fm1, fm2) -> {_            boolean p1 = Modifier.isPublic(fm1.getModifiers())__            boolean p2 = Modifier.isPublic(fm2.getModifiers())__            if (p1 != p2) {_                return (p1 ? -1 : 1)__            }_            int c1pl = fm1.getParameterCount()__            int c2pl = fm2.getParameterCount()__            return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__        })__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,fm1,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,count,int,c2pl,fm2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1530174524;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, (fm1, fm2) -> {_			boolean p1 = Modifier.isPublic(fm1.getModifiers())__			boolean p2 = Modifier.isPublic(fm2.getModifiers())__			if (p1 != p2) {_				return (p1 ? -1 : 1)__			}_			int c1pl = fm1.getParameterCount()__			int c2pl = fm2.getParameterCount()__			return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,fm1,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,count,int,c2pl,fm2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1542613849;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, (fm1, fm2) -> {_			boolean p1 = Modifier.isPublic(fm1.getModifiers())__			boolean p2 = Modifier.isPublic(fm2.getModifiers())__			if (p1 != p2) {_				return (p1 ? -1 : 1)__			}_			int c1pl = fm1.getParameterCount()__			int c2pl = fm2.getParameterCount()__			return (c1pl < c2pl ? 1 : (c1pl > c2pl ? -1 : 0))__		})__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods,fm1,fm2,boolean,p1,modifier,is,public,fm1,get,modifiers,boolean,p2,modifier,is,public,fm2,get,modifiers,if,p1,p2,return,p1,1,1,int,c1pl,fm1,get,parameter,count,int,c2pl,fm2,get,parameter,count,return,c1pl,c2pl,1,c1pl,c2pl,1,0
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1545401405;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, EXECUTABLE_COMPARATOR)__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1546963894;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, EXECUTABLE_COMPARATOR)__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods
AutowireUtils -> public static void sortFactoryMethods(Method[] factoryMethods);1548002286;Sort the given factory methods, preferring public methods and "greedy" ones_with a maximum of arguments. The result will contain public methods first,_with decreasing number of arguments, then non-public methods, again with_decreasing number of arguments._@param factoryMethods the factory method array to sort;public static void sortFactoryMethods(Method[] factoryMethods) {_		Arrays.sort(factoryMethods, EXECUTABLE_COMPARATOR)__	};sort,the,given,factory,methods,preferring,public,methods,and,greedy,ones,with,a,maximum,of,arguments,the,result,will,contain,public,methods,first,with,decreasing,number,of,arguments,then,non,public,methods,again,with,decreasing,number,of,arguments,param,factory,methods,the,factory,method,array,to,sort;public,static,void,sort,factory,methods,method,factory,methods,arrays,sort,factory,methods
AutowireUtils -> static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1551276945;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1551281134;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces);1551282060;Return whether the setter method of the given bean property is defined_in any of the given interfaces._@param pd the PropertyDescriptor of the bean property_@param interfaces the Set of interfaces (Class objects)_@return whether the setter method is defined by an interface;static boolean isSetterDefinedInInterface(PropertyDescriptor pd, Set<Class<?>> interfaces) {_		Method setter = pd.getWriteMethod()__		if (setter != null) {_			Class<?> targetClass = setter.getDeclaringClass()__			for (Class<?> ifc : interfaces) {_				if (ifc.isAssignableFrom(targetClass) &&_						ClassUtils.hasMethod(ifc, setter.getName(), setter.getParameterTypes())) {_					return true__				}_			}_		}_		return false__	};return,whether,the,setter,method,of,the,given,bean,property,is,defined,in,any,of,the,given,interfaces,param,pd,the,property,descriptor,of,the,bean,property,param,interfaces,the,set,of,interfaces,class,objects,return,whether,the,setter,method,is,defined,by,an,interface;static,boolean,is,setter,defined,in,interface,property,descriptor,pd,set,class,interfaces,method,setter,pd,get,write,method,if,setter,null,class,target,class,setter,get,declaring,class,for,class,ifc,interfaces,if,ifc,is,assignable,from,target,class,class,utils,has,method,ifc,setter,get,name,setter,get,parameter,types,return,true,return,false
AutowireUtils -> static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1551276945;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code createProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,create,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1551281134;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code createProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,create,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
AutowireUtils -> static Class<?> resolveReturnTypeForFactoryMethod( 			Method method, Object[] args, @Nullable ClassLoader classLoader);1551282060;Determine the target type for the generic return type of the given_<em>generic factory method</em>, where formal type variables are declared_on the given method itself._<p>For example, given a factory method with the following signature, if_{@code resolveReturnTypeForFactoryMethod()} is invoked with the reflected_method for {@code createProxy()} and an {@code Object[]} array containing_{@code MyService.class}, {@code resolveReturnTypeForFactoryMethod()} will_infer that the target return type is {@code MyService}._<pre class="code">{@code public static <T> T createProxy(Class<T> clazz)}</pre>_<h4>Possible Return Values</h4>_<ul>_<li>the target return type, if it can be inferred</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if_the given {@code method} does not declare any {@linkplain_Method#getTypeParameters() formal type variables}</li>_<li>the {@linkplain Method#getReturnType() standard return type}, if the_target return type cannot be inferred (e.g., due to type erasure)</li>_<li>{@code null}, if the length of the given arguments array is shorter_than the length of the {@linkplain_Method#getGenericParameterTypes() formal argument list} for the given_method</li>_</ul>_@param method the method to introspect (never {@code null})_@param args the arguments that will be supplied to the method when it is_invoked (never {@code null})_@param classLoader the ClassLoader to resolve class names against,_if necessary (never {@code null})_@return the resolved target return type or the standard method return type_@since 3.2.5;static Class<?> resolveReturnTypeForFactoryMethod(_			Method method, Object[] args, @Nullable ClassLoader classLoader) {__		Assert.notNull(method, "Method must not be null")__		Assert.notNull(args, "Argument array must not be null")___		TypeVariable<Method>[] declaredTypeVariables = method.getTypeParameters()__		Type genericReturnType = method.getGenericReturnType()__		Type[] methodParameterTypes = method.getGenericParameterTypes()__		Assert.isTrue(args.length == methodParameterTypes.length, "Argument array does not match parameter count")___		_		_		boolean locallyDeclaredTypeVariableMatchesReturnType = false__		for (TypeVariable<Method> currentTypeVariable : declaredTypeVariables) {_			if (currentTypeVariable.equals(genericReturnType)) {_				locallyDeclaredTypeVariableMatchesReturnType = true__				break__			}_		}__		if (locallyDeclaredTypeVariableMatchesReturnType) {_			for (int i = 0_ i < methodParameterTypes.length_ i++) {_				Type methodParameterType = methodParameterTypes[i]__				Object arg = args[i]__				if (methodParameterType.equals(genericReturnType)) {_					if (arg instanceof TypedStringValue) {_						TypedStringValue typedValue = ((TypedStringValue) arg)__						if (typedValue.hasTargetType()) {_							return typedValue.getTargetType()__						}_						try {_							Class<?> resolvedType = typedValue.resolveTargetType(classLoader)__							if (resolvedType != null) {_								return resolvedType__							}_						}_						catch (ClassNotFoundException ex) {_							throw new IllegalStateException("Failed to resolve value type [" +_									typedValue.getTargetTypeName() + "] for factory method argument", ex)__						}_					}_					else if (arg != null && !(arg instanceof BeanMetadataElement)) {_						_						return arg.getClass()__					}_					return method.getReturnType()__				}_				else if (methodParameterType instanceof ParameterizedType) {_					ParameterizedType parameterizedType = (ParameterizedType) methodParameterType__					Type[] actualTypeArguments = parameterizedType.getActualTypeArguments()__					for (Type typeArg : actualTypeArguments) {_						if (typeArg.equals(genericReturnType)) {_							if (arg instanceof Class) {_								return (Class<?>) arg__							}_							else {_								String className = null__								if (arg instanceof String) {_									className = (String) arg__								}_								else if (arg instanceof TypedStringValue) {_									TypedStringValue typedValue = ((TypedStringValue) arg)__									String targetTypeName = typedValue.getTargetTypeName()__									if (targetTypeName == null || Class.class.getName().equals(targetTypeName)) {_										className = typedValue.getValue()__									}_								}_								if (className != null) {_									try {_										return ClassUtils.forName(className, classLoader)__									}_									catch (ClassNotFoundException ex) {_										throw new IllegalStateException("Could not resolve class name [" + arg +_												"] for factory method argument", ex)__									}_								}_								_								_								return method.getReturnType()__							}_						}_					}_				}_			}_		}__		_		return method.getReturnType()__	};determine,the,target,type,for,the,generic,return,type,of,the,given,em,generic,factory,method,em,where,formal,type,variables,are,declared,on,the,given,method,itself,p,for,example,given,a,factory,method,with,the,following,signature,if,code,resolve,return,type,for,factory,method,is,invoked,with,the,reflected,method,for,code,create,proxy,and,an,code,object,array,containing,code,my,service,class,code,resolve,return,type,for,factory,method,will,infer,that,the,target,return,type,is,code,my,service,pre,class,code,code,public,static,t,t,create,proxy,class,t,clazz,pre,h4,possible,return,values,h4,ul,li,the,target,return,type,if,it,can,be,inferred,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,given,code,method,does,not,declare,any,linkplain,method,get,type,parameters,formal,type,variables,li,li,the,linkplain,method,get,return,type,standard,return,type,if,the,target,return,type,cannot,be,inferred,e,g,due,to,type,erasure,li,li,code,null,if,the,length,of,the,given,arguments,array,is,shorter,than,the,length,of,the,linkplain,method,get,generic,parameter,types,formal,argument,list,for,the,given,method,li,ul,param,method,the,method,to,introspect,never,code,null,param,args,the,arguments,that,will,be,supplied,to,the,method,when,it,is,invoked,never,code,null,param,class,loader,the,class,loader,to,resolve,class,names,against,if,necessary,never,code,null,return,the,resolved,target,return,type,or,the,standard,method,return,type,since,3,2,5;static,class,resolve,return,type,for,factory,method,method,method,object,args,nullable,class,loader,class,loader,assert,not,null,method,method,must,not,be,null,assert,not,null,args,argument,array,must,not,be,null,type,variable,method,declared,type,variables,method,get,type,parameters,type,generic,return,type,method,get,generic,return,type,type,method,parameter,types,method,get,generic,parameter,types,assert,is,true,args,length,method,parameter,types,length,argument,array,does,not,match,parameter,count,boolean,locally,declared,type,variable,matches,return,type,false,for,type,variable,method,current,type,variable,declared,type,variables,if,current,type,variable,equals,generic,return,type,locally,declared,type,variable,matches,return,type,true,break,if,locally,declared,type,variable,matches,return,type,for,int,i,0,i,method,parameter,types,length,i,type,method,parameter,type,method,parameter,types,i,object,arg,args,i,if,method,parameter,type,equals,generic,return,type,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,if,typed,value,has,target,type,return,typed,value,get,target,type,try,class,resolved,type,typed,value,resolve,target,type,class,loader,if,resolved,type,null,return,resolved,type,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,failed,to,resolve,value,type,typed,value,get,target,type,name,for,factory,method,argument,ex,else,if,arg,null,arg,instanceof,bean,metadata,element,return,arg,get,class,return,method,get,return,type,else,if,method,parameter,type,instanceof,parameterized,type,parameterized,type,parameterized,type,parameterized,type,method,parameter,type,type,actual,type,arguments,parameterized,type,get,actual,type,arguments,for,type,type,arg,actual,type,arguments,if,type,arg,equals,generic,return,type,if,arg,instanceof,class,return,class,arg,else,string,class,name,null,if,arg,instanceof,string,class,name,string,arg,else,if,arg,instanceof,typed,string,value,typed,string,value,typed,value,typed,string,value,arg,string,target,type,name,typed,value,get,target,type,name,if,target,type,name,null,class,class,get,name,equals,target,type,name,class,name,typed,value,get,value,if,class,name,null,try,return,class,utils,for,name,class,name,class,loader,catch,class,not,found,exception,ex,throw,new,illegal,state,exception,could,not,resolve,class,name,arg,for,factory,method,argument,ex,return,method,get,return,type,return,method,get,return,type
