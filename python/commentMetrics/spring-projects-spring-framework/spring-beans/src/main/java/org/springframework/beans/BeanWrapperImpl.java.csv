commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}.  * @param object the actual target object  * @since 4.3  * @see #setWrappedInstance(Object)  */ ;/**  * Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}.  * @param object the actual target object  * @since 4.3  * @see #setWrappedInstance(Object)  */ public void setBeanInstance(Object object) {     this.wrappedObject = object.     this.rootObject = object.     this.typeConverterDelegate = new TypeConverterDelegate(this, this.wrappedObject).     setIntrospectionClass(object.getClass()). }
false;public;3;5;;@Override public void setWrappedInstance(Object object, @Nullable String nestedPath, @Nullable Object rootObject) {     super.setWrappedInstance(object, nestedPath, rootObject).     setIntrospectionClass(getWrappedClass()). }
true;protected;1;5;/**  * Set the class to introspect.  * Needs to be called when the target object changes.  * @param clazz the class to introspect  */ ;/**  * Set the class to introspect.  * Needs to be called when the target object changes.  * @param clazz the class to introspect  */ protected void setIntrospectionClass(Class<?> clazz) {     if (this.cachedIntrospectionResults != null && this.cachedIntrospectionResults.getBeanClass() != clazz) {         this.cachedIntrospectionResults = null.     } }
true;private;0;6;/**  * Obtain a lazily initialized CachedIntrospectionResults instance  * for the wrapped object.  */ ;/**  * Obtain a lazily initialized CachedIntrospectionResults instance  * for the wrapped object.  */ private CachedIntrospectionResults getCachedIntrospectionResults() {     if (this.cachedIntrospectionResults == null) {         this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass()).     }     return this.cachedIntrospectionResults. }
true;public;1;3;/**  * Set the security context used during the invocation of the wrapped instance methods.  * Can be null.  */ ;/**  * Set the security context used during the invocation of the wrapped instance methods.  * Can be null.  */ public void setSecurityContext(@Nullable AccessControlContext acc) {     this.acc = acc. }
true;public;0;4;/**  * Return the security context used during the invocation of the wrapped instance methods.  * Can be null.  */ ;/**  * Return the security context used during the invocation of the wrapped instance methods.  * Can be null.  */ @Nullable public AccessControlContext getSecurityContext() {     return this.acc. }
true;public;2;14;/**  * Convert the given value for the specified property to the latter's type.  * <p>This method is only intended for optimizations in a BeanFactory.  * Use the {@code convertIfNecessary} methods for programmatic conversion.  * @param value the value to convert  * @param propertyName the target property  * (note that nested or indexed properties are not supported here)  * @return the new value, possibly the result of type conversion  * @throws TypeMismatchException if type conversion failed  */ ;/**  * Convert the given value for the specified property to the latter's type.  * <p>This method is only intended for optimizations in a BeanFactory.  * Use the {@code convertIfNecessary} methods for programmatic conversion.  * @param value the value to convert  * @param propertyName the target property  * (note that nested or indexed properties are not supported here)  * @return the new value, possibly the result of type conversion  * @throws TypeMismatchException if type conversion failed  */ @Nullable public Object convertForProperty(@Nullable Object value, String propertyName) throws TypeMismatchException {     CachedIntrospectionResults cachedIntrospectionResults = getCachedIntrospectionResults().     PropertyDescriptor pd = cachedIntrospectionResults.getPropertyDescriptor(propertyName).     if (pd == null) {         throw new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName, "No property '" + propertyName + "' found").     }     TypeDescriptor td = cachedIntrospectionResults.getTypeDescriptor(pd).     if (td == null) {         td = cachedIntrospectionResults.addTypeDescriptor(pd, new TypeDescriptor(property(pd))).     }     return convertForProperty(propertyName, null, value, td). }
false;private;1;4;;private Property property(PropertyDescriptor pd) {     GenericTypeAwarePropertyDescriptor gpd = (GenericTypeAwarePropertyDescriptor) pd.     return new Property(gpd.getBeanClass(), gpd.getReadMethod(), gpd.getWriteMethod(), gpd.getName()). }
false;protected;1;6;;@Override @Nullable protected BeanPropertyHandler getLocalPropertyHandler(String propertyName) {     PropertyDescriptor pd = getCachedIntrospectionResults().getPropertyDescriptor(propertyName).     return (pd != null ? new BeanPropertyHandler(pd) : null). }
false;protected;2;4;;@Override protected BeanWrapperImpl newNestedPropertyAccessor(Object object, String nestedPath) {     return new BeanWrapperImpl(object, nestedPath, this). }
false;protected;1;6;;@Override protected NotWritablePropertyException createNotWritablePropertyException(String propertyName) {     PropertyMatches matches = PropertyMatches.forProperty(propertyName, getRootClass()).     throw new NotWritablePropertyException(getRootClass(), getNestedPath() + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches()). }
false;public;0;4;;@Override public PropertyDescriptor[] getPropertyDescriptors() {     return getCachedIntrospectionResults().getPropertyDescriptors(). }
false;public;1;11;;@Override public PropertyDescriptor getPropertyDescriptor(String propertyName) throws InvalidPropertyException {     BeanWrapperImpl nestedBw = (BeanWrapperImpl) getPropertyAccessorForPropertyPath(propertyName).     String finalPath = getFinalPath(nestedBw, propertyName).     PropertyDescriptor pd = nestedBw.getCachedIntrospectionResults().getPropertyDescriptor(finalPath).     if (pd == null) {         throw new InvalidPropertyException(getRootClass(), getNestedPath() + propertyName, "No property '" + propertyName + "' found").     }     return pd. }
false;public;0;4;;@Override public ResolvableType getResolvableType() {     return ResolvableType.forMethodReturnType(this.pd.getReadMethod()). }
false;public;0;4;;@Override public TypeDescriptor toTypeDescriptor() {     return new TypeDescriptor(property(this.pd)). }
false;public;1;5;;@Override @Nullable public TypeDescriptor nested(int level) {     return TypeDescriptor.nested(property(this.pd), level). }
false;public;0;22;;@Override @Nullable public Object getValue() throws Exception {     final Method readMethod = this.pd.getReadMethod().     if (System.getSecurityManager() != null) {         AccessController.doPrivileged((PrivilegedAction<Object>) () -> {             ReflectionUtils.makeAccessible(readMethod).             return null.         }).         try {             return AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> readMethod.invoke(getWrappedInstance(), (Object[]) null), acc).         } catch (PrivilegedActionException pae) {             throw pae.getException().         }     } else {         ReflectionUtils.makeAccessible(readMethod).         return readMethod.invoke(getWrappedInstance(), (Object[]) null).     } }
false;public;1;23;;@Override public void setValue(@Nullable final Object value) throws Exception {     final Method writeMethod = (this.pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) this.pd).getWriteMethodForActualAccess() : this.pd.getWriteMethod()).     if (System.getSecurityManager() != null) {         AccessController.doPrivileged((PrivilegedAction<Object>) () -> {             ReflectionUtils.makeAccessible(writeMethod).             return null.         }).         try {             AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> writeMethod.invoke(getWrappedInstance(), value), acc).         } catch (PrivilegedActionException ex) {             throw ex.getException().         }     } else {         ReflectionUtils.makeAccessible(writeMethod).         writeMethod.invoke(getWrappedInstance(), value).     } }
