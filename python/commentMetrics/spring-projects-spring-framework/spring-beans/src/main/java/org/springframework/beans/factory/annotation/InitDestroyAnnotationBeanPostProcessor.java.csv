commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the init annotation to check for, indicating initialization  * methods to call after configuration of a bean.  * <p>Any custom annotation can be used, since there are no required  * annotation attributes. There is no default, although a typical choice  * is the JSR-250 {@link javax.annotation.PostConstruct} annotation.  */ ;/**  * Specify the init annotation to check for, indicating initialization  * methods to call after configuration of a bean.  * <p>Any custom annotation can be used, since there are no required  * annotation attributes. There is no default, although a typical choice  * is the JSR-250 {@link javax.annotation.PostConstruct} annotation.  */ public void setInitAnnotationType(Class<? extends Annotation> initAnnotationType) {     this.initAnnotationType = initAnnotationType. }
true;public;1;3;/**  * Specify the destroy annotation to check for, indicating destruction  * methods to call when the context is shutting down.  * <p>Any custom annotation can be used, since there are no required  * annotation attributes. There is no default, although a typical choice  * is the JSR-250 {@link javax.annotation.PreDestroy} annotation.  */ ;/**  * Specify the destroy annotation to check for, indicating destruction  * methods to call when the context is shutting down.  * <p>Any custom annotation can be used, since there are no required  * annotation attributes. There is no default, although a typical choice  * is the JSR-250 {@link javax.annotation.PreDestroy} annotation.  */ public void setDestroyAnnotationType(Class<? extends Annotation> destroyAnnotationType) {     this.destroyAnnotationType = destroyAnnotationType. }
false;public;1;3;;public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
false;public;3;5;;@Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {     LifecycleMetadata metadata = findLifecycleMetadata(beanType).     metadata.checkConfigMembers(beanDefinition). }
false;public;2;14;;@Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {     LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass()).     try {         metadata.invokeInitMethods(bean, beanName).     } catch (InvocationTargetException ex) {         throw new BeanCreationException(beanName, "Invocation of init method failed", ex.getTargetException()).     } catch (Throwable ex) {         throw new BeanCreationException(beanName, "Failed to invoke init method", ex).     }     return bean. }
false;public;2;4;;@Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {     return bean. }
false;public;2;19;;@Override public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {     LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass()).     try {         metadata.invokeDestroyMethods(bean, beanName).     } catch (InvocationTargetException ex) {         String msg = "Destroy method on bean with name '" + beanName + "' threw an exception".         if (logger.isDebugEnabled()) {             logger.warn(msg, ex.getTargetException()).         } else {             logger.warn(msg + ": " + ex.getTargetException()).         }     } catch (Throwable ex) {         logger.warn("Failed to invoke destroy method on bean with name '" + beanName + "'", ex).     } }
false;public;1;4;;@Override public boolean requiresDestruction(Object bean) {     return findLifecycleMetadata(bean.getClass()).hasDestroyMethods(). }
false;private;1;19;;private LifecycleMetadata findLifecycleMetadata(Class<?> clazz) {     if (this.lifecycleMetadataCache == null) {         // Happens after deserialization, during destruction...         return buildLifecycleMetadata(clazz).     }     // Quick check on the concurrent map first, with minimal locking.     LifecycleMetadata metadata = this.lifecycleMetadataCache.get(clazz).     if (metadata == null) {         synchronized (this.lifecycleMetadataCache) {             metadata = this.lifecycleMetadataCache.get(clazz).             if (metadata == null) {                 metadata = buildLifecycleMetadata(clazz).                 this.lifecycleMetadataCache.put(clazz, metadata).             }             return metadata.         }     }     return metadata. }
false;private;1;33;;private LifecycleMetadata buildLifecycleMetadata(final Class<?> clazz) {     List<LifecycleElement> initMethods = new ArrayList<>().     List<LifecycleElement> destroyMethods = new ArrayList<>().     Class<?> targetClass = clazz.     do {         final List<LifecycleElement> currInitMethods = new ArrayList<>().         final List<LifecycleElement> currDestroyMethods = new ArrayList<>().         ReflectionUtils.doWithLocalMethods(targetClass, method -> {             if (this.initAnnotationType != null && method.isAnnotationPresent(this.initAnnotationType)) {                 LifecycleElement element = new LifecycleElement(method).                 currInitMethods.add(element).                 if (logger.isTraceEnabled()) {                     logger.trace("Found init method on class [" + clazz.getName() + "]: " + method).                 }             }             if (this.destroyAnnotationType != null && method.isAnnotationPresent(this.destroyAnnotationType)) {                 currDestroyMethods.add(new LifecycleElement(method)).                 if (logger.isTraceEnabled()) {                     logger.trace("Found destroy method on class [" + clazz.getName() + "]: " + method).                 }             }         }).         initMethods.addAll(0, currInitMethods).         destroyMethods.addAll(currDestroyMethods).         targetClass = targetClass.getSuperclass().     } while (targetClass != null && targetClass != Object.class).     return new LifecycleMetadata(clazz, initMethods, destroyMethods). }
false;private;1;7;;// --------------------------------------------------------------------- // Serialization support // --------------------------------------------------------------------- private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {     // Rely on default serialization. just initialize state after deserialization.     ois.defaultReadObject().     // Initialize transient fields.     this.logger = LogFactory.getLog(getClass()). }
false;public;1;26;;public void checkConfigMembers(RootBeanDefinition beanDefinition) {     Set<LifecycleElement> checkedInitMethods = new LinkedHashSet<>(this.initMethods.size()).     for (LifecycleElement element : this.initMethods) {         String methodIdentifier = element.getIdentifier().         if (!beanDefinition.isExternallyManagedInitMethod(methodIdentifier)) {             beanDefinition.registerExternallyManagedInitMethod(methodIdentifier).             checkedInitMethods.add(element).             if (logger.isTraceEnabled()) {                 logger.trace("Registered init method on class [" + this.targetClass.getName() + "]: " + element).             }         }     }     Set<LifecycleElement> checkedDestroyMethods = new LinkedHashSet<>(this.destroyMethods.size()).     for (LifecycleElement element : this.destroyMethods) {         String methodIdentifier = element.getIdentifier().         if (!beanDefinition.isExternallyManagedDestroyMethod(methodIdentifier)) {             beanDefinition.registerExternallyManagedDestroyMethod(methodIdentifier).             checkedDestroyMethods.add(element).             if (logger.isTraceEnabled()) {                 logger.trace("Registered destroy method on class [" + this.targetClass.getName() + "]: " + element).             }         }     }     this.checkedInitMethods = checkedInitMethods.     this.checkedDestroyMethods = checkedDestroyMethods. }
false;public;2;13;;public void invokeInitMethods(Object target, String beanName) throws Throwable {     Collection<LifecycleElement> checkedInitMethods = this.checkedInitMethods.     Collection<LifecycleElement> initMethodsToIterate = (checkedInitMethods != null ? checkedInitMethods : this.initMethods).     if (!initMethodsToIterate.isEmpty()) {         for (LifecycleElement element : initMethodsToIterate) {             if (logger.isTraceEnabled()) {                 logger.trace("Invoking init method on bean '" + beanName + "': " + element.getMethod()).             }             element.invoke(target).         }     } }
false;public;2;13;;public void invokeDestroyMethods(Object target, String beanName) throws Throwable {     Collection<LifecycleElement> checkedDestroyMethods = this.checkedDestroyMethods.     Collection<LifecycleElement> destroyMethodsToUse = (checkedDestroyMethods != null ? checkedDestroyMethods : this.destroyMethods).     if (!destroyMethodsToUse.isEmpty()) {         for (LifecycleElement element : destroyMethodsToUse) {             if (logger.isTraceEnabled()) {                 logger.trace("Invoking destroy method on bean '" + beanName + "': " + element.getMethod()).             }             element.invoke(target).         }     } }
false;public;0;6;;public boolean hasDestroyMethods() {     Collection<LifecycleElement> checkedDestroyMethods = this.checkedDestroyMethods.     Collection<LifecycleElement> destroyMethodsToUse = (checkedDestroyMethods != null ? checkedDestroyMethods : this.destroyMethods).     return !destroyMethodsToUse.isEmpty(). }
false;public;0;3;;public Method getMethod() {     return this.method. }
false;public;0;3;;public String getIdentifier() {     return this.identifier. }
false;public;1;4;;public void invoke(Object target) throws Throwable {     ReflectionUtils.makeAccessible(this.method).     this.method.invoke(target, (Object[]) null). }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof LifecycleElement)) {         return false.     }     LifecycleElement otherElement = (LifecycleElement) other.     return (this.identifier.equals(otherElement.identifier)). }
false;public;0;4;;@Override public int hashCode() {     return this.identifier.hashCode(). }
