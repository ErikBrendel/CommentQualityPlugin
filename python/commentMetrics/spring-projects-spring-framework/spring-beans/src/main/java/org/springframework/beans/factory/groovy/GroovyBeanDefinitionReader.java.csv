commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setMetaClass(MetaClass metaClass) {     this.metaClass = metaClass. }
false;public;0;3;;public MetaClass getMetaClass() {     return this.metaClass. }
true;public;1;3;/**  * Set the binding, i.e. the Groovy variables available in the scope  * of a {@code GroovyBeanDefinitionReader} closure.  */ ;/**  * Set the binding, i.e. the Groovy variables available in the scope  * of a {@code GroovyBeanDefinitionReader} closure.  */ public void setBinding(Binding binding) {     this.binding = binding. }
true;public;0;3;/**  * Return a specified binding for Groovy variables, if any.  */ ;/**  * Return a specified binding for Groovy variables, if any.  */ public Binding getBinding() {     return this.binding. }
true;public;1;3;/**  * Load bean definitions from the specified Groovy script or XML file.  * <p>Note that {@code ".xml"} files will be parsed as XML content. all other kinds  * of resources will be parsed as Groovy scripts.  * @param resource the resource descriptor for the Groovy script or XML file  * @return the number of bean definitions found  * @throws BeanDefinitionStoreException in case of loading or parsing errors  */ ;// TRADITIONAL BEAN DEFINITION READER METHODS /**  * Load bean definitions from the specified Groovy script or XML file.  * <p>Note that {@code ".xml"} files will be parsed as XML content. all other kinds  * of resources will be parsed as Groovy scripts.  * @param resource the resource descriptor for the Groovy script or XML file  * @return the number of bean definitions found  * @throws BeanDefinitionStoreException in case of loading or parsing errors  */ public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {     return loadBeanDefinitions(new EncodedResource(resource)). }
false;public;1;5;;@Override public Object call(Object[] args) {     invokeBeanDefiningClosure((Closure) args[0]).     return null. }
false;public;2;9;;@Override public void setVariable(String name, Object value) {     if (currentBeanDefinition != null) {         applyPropertyToBeanDefinition(name, value).     } else {         super.setVariable(name, value).     } }
true;public;1;47;/**  * Load bean definitions from the specified Groovy script or XML file.  * <p>Note that {@code ".xml"} files will be parsed as XML content. all other kinds  * of resources will be parsed as Groovy scripts.  * @param encodedResource the resource descriptor for the Groovy script or XML file,  * allowing specification of an encoding to use for parsing the file  * @return the number of bean definitions found  * @throws BeanDefinitionStoreException in case of loading or parsing errors  */ ;/**  * Load bean definitions from the specified Groovy script or XML file.  * <p>Note that {@code ".xml"} files will be parsed as XML content. all other kinds  * of resources will be parsed as Groovy scripts.  * @param encodedResource the resource descriptor for the Groovy script or XML file,  * allowing specification of an encoding to use for parsing the file  * @return the number of bean definitions found  * @throws BeanDefinitionStoreException in case of loading or parsing errors  */ public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {     // Check for XML files and redirect them to the "standard" XmlBeanDefinitionReader     String filename = encodedResource.getResource().getFilename().     if (StringUtils.endsWithIgnoreCase(filename, ".xml")) {         return this.standardXmlBeanDefinitionReader.loadBeanDefinitions(encodedResource).     }     if (logger.isTraceEnabled()) {         logger.trace("Loading Groovy bean definitions from " + encodedResource).     }     Closure beans = new Closure(this) {          @Override         public Object call(Object[] args) {             invokeBeanDefiningClosure((Closure) args[0]).             return null.         }     }.     Binding binding = new Binding() {          @Override         public void setVariable(String name, Object value) {             if (currentBeanDefinition != null) {                 applyPropertyToBeanDefinition(name, value).             } else {                 super.setVariable(name, value).             }         }     }.     binding.setVariable("beans", beans).     int countBefore = getRegistry().getBeanDefinitionCount().     try {         GroovyShell shell = new GroovyShell(getBeanClassLoader(), binding).         shell.evaluate(encodedResource.getReader(), "beans").     } catch (Throwable ex) {         throw new BeanDefinitionParsingException(new Problem("Error evaluating Groovy script: " + ex.getMessage(), new Location(encodedResource.getResource()), null, ex)).     }     int count = getRegistry().getBeanDefinitionCount() - countBefore.     if (logger.isDebugEnabled()) {         logger.debug("Loaded " + count + " bean definitions from " + encodedResource).     }     return count. }
true;public;1;3;/**  * Defines a set of beans for the given block or closure.  * @param closure the block or closure  * @return this {@code GroovyBeanDefinitionReader} instance  */ ;// METHODS FOR CONSUMPTION IN A GROOVY CLOSURE /**  * Defines a set of beans for the given block or closure.  * @param closure the block or closure  * @return this {@code GroovyBeanDefinitionReader} instance  */ public GroovyBeanDefinitionReader beans(Closure closure) {     return invokeBeanDefiningClosure(closure). }
true;public;1;5;/**  * Define an inner bean definition.  * @param type the bean type  * @return the bean definition  */ ;/**  * Define an inner bean definition.  * @param type the bean type  * @return the bean definition  */ public GenericBeanDefinition bean(Class<?> type) {     GenericBeanDefinition beanDefinition = new GenericBeanDefinition().     beanDefinition.setBeanClass(type).     return beanDefinition. }
true;public;2;27;/**  * Define an inner bean definition.  * @param type the bean type  * @param args the constructors arguments and closure configurer  * @return the bean definition  */ ;/**  * Define an inner bean definition.  * @param type the bean type  * @param args the constructors arguments and closure configurer  * @return the bean definition  */ public AbstractBeanDefinition bean(Class<?> type, Object... args) {     GroovyBeanDefinitionWrapper current = this.currentBeanDefinition.     try {         Closure callable = null.         Collection constructorArgs = null.         if (!ObjectUtils.isEmpty(args)) {             int index = args.length.             Object lastArg = args[index - 1].             if (lastArg instanceof Closure) {                 callable = (Closure) lastArg.                 index--.             }             if (index > -1) {                 constructorArgs = resolveConstructorArguments(args, 0, index).             }         }         this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(null, type, constructorArgs).         if (callable != null) {             callable.call(this.currentBeanDefinition).         }         return this.currentBeanDefinition.getBeanDefinition().     } finally {         this.currentBeanDefinition = current.     } }
true;public;1;18;/**  * Define a Spring XML namespace definition to use.  * @param definition the namespace definition  */ ;/**  * Define a Spring XML namespace definition to use.  * @param definition the namespace definition  */ public void xmlns(Map<String, String> definition) {     if (!definition.isEmpty()) {         for (Map.Entry<String, String> entry : definition.entrySet()) {             String namespace = entry.getKey().             String uri = entry.getValue().             if (uri == null) {                 throw new IllegalArgumentException("Namespace definition must supply a non-null URI").             }             NamespaceHandler namespaceHandler = this.groovyDslXmlBeanDefinitionReader.getNamespaceHandlerResolver().resolve(uri).             if (namespaceHandler == null) {                 throw new BeanDefinitionParsingException(new Problem("No namespace handler found for URI: " + uri, new Location(new DescriptiveResource(("Groovy"))))).             }             this.namespaces.put(namespace, uri).         }     } }
true;public;1;3;/**  * Import Spring bean definitions from either XML or Groovy sources into the  * current bean builder instance.  * @param resourcePattern the resource pattern  */ ;/**  * Import Spring bean definitions from either XML or Groovy sources into the  * current bean builder instance.  * @param resourcePattern the resource pattern  */ public void importBeans(String resourcePattern) throws IOException {     loadBeanDefinitions(resourcePattern). }
true;public;2;43;/**  * This method overrides method invocation to create beans for each method name that  * takes a class argument.  */ ;// INTERNAL HANDLING OF GROOVY CLOSURES AND PROPERTIES /**  * This method overrides method invocation to create beans for each method name that  * takes a class argument.  */ public Object invokeMethod(String name, Object arg) {     Object[] args = (Object[]) arg.     if ("beans".equals(name) && args.length == 1 && args[0] instanceof Closure) {         return beans((Closure) args[0]).     } else if ("ref".equals(name)) {         String refName.         if (args[0] == null) {             throw new IllegalArgumentException("Argument to ref() is not a valid bean or was not found").         }         if (args[0] instanceof RuntimeBeanReference) {             refName = ((RuntimeBeanReference) args[0]).getBeanName().         } else {             refName = args[0].toString().         }         boolean parentRef = false.         if (args.length > 1 && args[1] instanceof Boolean) {             parentRef = (Boolean) args[1].         }         return new RuntimeBeanReference(refName, parentRef).     } else if (this.namespaces.containsKey(name) && args.length > 0 && args[0] instanceof Closure) {         GroovyDynamicElementReader reader = createDynamicElementReader(name).         reader.invokeMethod("doCall", args).     } else if (args.length > 0 && args[0] instanceof Closure) {         // abstract bean definition         return invokeBeanDefiningMethod(name, args).     } else if (args.length > 0 && (args[0] instanceof Class || args[0] instanceof RuntimeBeanReference || args[0] instanceof Map)) {         return invokeBeanDefiningMethod(name, args).     } else if (args.length > 1 && args[args.length - 1] instanceof Closure) {         return invokeBeanDefiningMethod(name, args).     }     MetaClass mc = DefaultGroovyMethods.getMetaClass(getRegistry()).     if (!mc.respondsTo(getRegistry(), name, args).isEmpty()) {         return mc.invokeMethod(getRegistry(), name, args).     }     return this. }
false;private;2;8;;private boolean addDeferredProperty(String property, Object newValue) {     if (newValue instanceof List || newValue instanceof Map) {         this.deferredProperties.put(this.currentBeanDefinition.getBeanName() + '.' + property, new DeferredProperty(this.currentBeanDefinition, property, newValue)).         return true.     }     return false. }
false;private;0;12;;private void finalizeDeferredProperties() {     for (DeferredProperty dp : this.deferredProperties.values()) {         if (dp.value instanceof List) {             dp.value = manageListIfNecessary((List) dp.value).         } else if (dp.value instanceof Map) {             dp.value = manageMapIfNecessary((Map) dp.value).         }         dp.apply().     }     this.deferredProperties.clear(). }
true;protected;1;6;/**  * When a method argument is only a closure it is a set of bean definitions.  * @param callable the closure argument  * @return this {@code GroovyBeanDefinitionReader} instance  */ ;/**  * When a method argument is only a closure it is a set of bean definitions.  * @param callable the closure argument  * @return this {@code GroovyBeanDefinitionReader} instance  */ protected GroovyBeanDefinitionReader invokeBeanDefiningClosure(Closure callable) {     callable.setDelegate(this).     callable.call().     finalizeDeferredProperties().     return this. }
true;private;2;78;/**  * This method is called when a bean definition node is called.  * @param beanName the name of the bean to define  * @param args the arguments to the bean. The first argument is the class name, the last  * argument is sometimes a closure. All the arguments in between are constructor arguments.  * @return the bean definition wrapper  */ ;/**  * This method is called when a bean definition node is called.  * @param beanName the name of the bean to define  * @param args the arguments to the bean. The first argument is the class name, the last  * argument is sometimes a closure. All the arguments in between are constructor arguments.  * @return the bean definition wrapper  */ private GroovyBeanDefinitionWrapper invokeBeanDefiningMethod(String beanName, Object[] args) {     boolean hasClosureArgument = (args[args.length - 1] instanceof Closure).     if (args[0] instanceof Class) {         Class<?> beanClass = (Class<?>) args[0].         if (hasClosureArgument) {             if (args.length - 1 != 1) {                 this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName, beanClass, resolveConstructorArguments(args, 1, args.length - 1)).             } else {                 this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName, beanClass).             }         } else {             this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName, beanClass, resolveConstructorArguments(args, 1, args.length)).         }     } else if (args[0] instanceof RuntimeBeanReference) {         this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName).         this.currentBeanDefinition.getBeanDefinition().setFactoryBeanName(((RuntimeBeanReference) args[0]).getBeanName()).     } else if (args[0] instanceof Map) {         // named constructor arguments         if (args.length > 1 && args[1] instanceof Class) {             List constructorArgs = resolveConstructorArguments(args, 2, hasClosureArgument ? args.length - 1 : args.length).             this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName, (Class) args[1], constructorArgs).             Map namedArgs = (Map) args[0].             for (Object o : namedArgs.keySet()) {                 String propName = (String) o.                 setProperty(propName, namedArgs.get(propName)).             }         } else // factory method syntax         {             this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName).             // First arg is the map containing factoryBean : factoryMethod             Map.Entry factoryBeanEntry = (Map.Entry) ((Map) args[0]).entrySet().iterator().next().             // If we have a closure body, that will be the last argument.             // In between are the constructor args             int constructorArgsTest = (hasClosureArgument ? 2 : 1).             // If we have more than this number of args, we have constructor args             if (args.length > constructorArgsTest) {                 // factory-method requires args                 int endOfConstructArgs = (hasClosureArgument ? args.length - 1 : args.length).                 this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName, null, resolveConstructorArguments(args, 1, endOfConstructArgs)).             } else {                 this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName).             }             this.currentBeanDefinition.getBeanDefinition().setFactoryBeanName(factoryBeanEntry.getKey().toString()).             this.currentBeanDefinition.getBeanDefinition().setFactoryMethodName(factoryBeanEntry.getValue().toString()).         }     } else if (args[0] instanceof Closure) {         this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName).         this.currentBeanDefinition.getBeanDefinition().setAbstract(true).     } else {         List constructorArgs = resolveConstructorArguments(args, 0, hasClosureArgument ? args.length - 1 : args.length).         this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(beanName, null, constructorArgs).     }     if (hasClosureArgument) {         Closure callable = (Closure) args[args.length - 1].         callable.setDelegate(this).         callable.setResolveStrategy(Closure.DELEGATE_FIRST).         callable.call(this.currentBeanDefinition).     }     GroovyBeanDefinitionWrapper beanDefinition = this.currentBeanDefinition.     this.currentBeanDefinition = null.     beanDefinition.getBeanDefinition().setAttribute(GroovyBeanDefinitionWrapper.class.getName(), beanDefinition).     getRegistry().registerBeanDefinition(beanName, beanDefinition.getBeanDefinition()).     return beanDefinition. }
false;protected;3;15;;protected List<Object> resolveConstructorArguments(Object[] args, int start, int end) {     Object[] constructorArgs = Arrays.copyOfRange(args, start, end).     for (int i = 0. i < constructorArgs.length. i++) {         if (constructorArgs[i] instanceof GString) {             constructorArgs[i] = constructorArgs[i].toString().         } else if (constructorArgs[i] instanceof List) {             constructorArgs[i] = manageListIfNecessary((List) constructorArgs[i]).         } else if (constructorArgs[i] instanceof Map) {             constructorArgs[i] = manageMapIfNecessary((Map) constructorArgs[i]).         }     }     return Arrays.asList(constructorArgs). }
true;private;1;15;/**  * Checks whether there are any {@link RuntimeBeanReference RuntimeBeanReferences}  * inside the {@link Map} and converts it to a {@link ManagedMap} if necessary.  * @param map the original Map  * @return either the original map or a managed copy of it  */ ;/**  * Checks whether there are any {@link RuntimeBeanReference RuntimeBeanReferences}  * inside the {@link Map} and converts it to a {@link ManagedMap} if necessary.  * @param map the original Map  * @return either the original map or a managed copy of it  */ private Object manageMapIfNecessary(Map<?, ?> map) {     boolean containsRuntimeRefs = false.     for (Object element : map.values()) {         if (element instanceof RuntimeBeanReference) {             containsRuntimeRefs = true.             break.         }     }     if (containsRuntimeRefs) {         Map<Object, Object> managedMap = new ManagedMap<>().         managedMap.putAll(map).         return managedMap.     }     return map. }
true;private;1;15;/**  * Checks whether there are any {@link RuntimeBeanReference RuntimeBeanReferences}  * inside the {@link List} and converts it to a {@link ManagedList} if necessary.  * @param list the original List  * @return either the original list or a managed copy of it  */ ;/**  * Checks whether there are any {@link RuntimeBeanReference RuntimeBeanReferences}  * inside the {@link List} and converts it to a {@link ManagedList} if necessary.  * @param list the original List  * @return either the original list or a managed copy of it  */ private Object manageListIfNecessary(List<?> list) {     boolean containsRuntimeRefs = false.     for (Object element : list) {         if (element instanceof RuntimeBeanReference) {             containsRuntimeRefs = true.             break.         }     }     if (containsRuntimeRefs) {         List<Object> managedList = new ManagedList<>().         managedList.addAll(list).         return managedList.     }     return list. }
true;public;2;5;/**  * This method overrides property setting in the scope of the {@code GroovyBeanDefinitionReader}  * to set properties on the current bean definition.  */ ;/**  * This method overrides property setting in the scope of the {@code GroovyBeanDefinitionReader}  * to set properties on the current bean definition.  */ public void setProperty(String name, Object value) {     if (this.currentBeanDefinition != null) {         applyPropertyToBeanDefinition(name, value).     } }
false;protected;2;29;;protected void applyPropertyToBeanDefinition(String name, Object value) {     if (value instanceof GString) {         value = value.toString().     }     if (addDeferredProperty(name, value)) {         return.     } else if (value instanceof Closure) {         GroovyBeanDefinitionWrapper current = this.currentBeanDefinition.         try {             Closure callable = (Closure) value.             Class<?> parameterType = callable.getParameterTypes()[0].             if (Object.class == parameterType) {                 this.currentBeanDefinition = new GroovyBeanDefinitionWrapper("").                 callable.call(this.currentBeanDefinition).             } else {                 this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(null, parameterType).                 callable.call((Object) null).             }             value = this.currentBeanDefinition.getBeanDefinition().         } finally {             this.currentBeanDefinition = current.         }     }     this.currentBeanDefinition.addProperty(name, value). }
true;public;1;41;/**  * This method overrides property retrieval in the scope of the  * {@code GroovyBeanDefinitionReader}. A property retrieval will either:  * <ul>  * <li>Retrieve a variable from the bean builder's binding if it exists  * <li>Retrieve a RuntimeBeanReference for a specific bean if it exists  * <li>Otherwise just delegate to MetaClass.getProperty which will resolve  * properties from the {@code GroovyBeanDefinitionReader} itself  * </ul>  */ ;/**  * This method overrides property retrieval in the scope of the  * {@code GroovyBeanDefinitionReader}. A property retrieval will either:  * <ul>  * <li>Retrieve a variable from the bean builder's binding if it exists  * <li>Retrieve a RuntimeBeanReference for a specific bean if it exists  * <li>Otherwise just delegate to MetaClass.getProperty which will resolve  * properties from the {@code GroovyBeanDefinitionReader} itself  * </ul>  */ public Object getProperty(String name) {     Binding binding = getBinding().     if (binding != null && binding.hasVariable(name)) {         return binding.getVariable(name).     } else {         if (this.namespaces.containsKey(name)) {             return createDynamicElementReader(name).         }         if (getRegistry().containsBeanDefinition(name)) {             GroovyBeanDefinitionWrapper beanDefinition = (GroovyBeanDefinitionWrapper) getRegistry().getBeanDefinition(name).getAttribute(GroovyBeanDefinitionWrapper.class.getName()).             if (beanDefinition != null) {                 return new GroovyRuntimeBeanReference(name, beanDefinition, false).             } else {                 return new RuntimeBeanReference(name, false).             }         } else // statement in a closure (hence the return value)         if (this.currentBeanDefinition != null) {             MutablePropertyValues pvs = this.currentBeanDefinition.getBeanDefinition().getPropertyValues().             if (pvs.contains(name)) {                 return pvs.get(name).             } else {                 DeferredProperty dp = this.deferredProperties.get(this.currentBeanDefinition.getBeanName() + name).                 if (dp != null) {                     return dp.value.                 } else {                     return getMetaClass().getProperty(this, name).                 }             }         } else {             return getMetaClass().getProperty(this, name).         }     } }
false;protected;0;6;;@Override protected void afterInvocation() {     if (!this.decorating) {         currentBeanDefinition = null.     } }
false;private;1;17;;private GroovyDynamicElementReader createDynamicElementReader(String namespace) {     XmlReaderContext readerContext = this.groovyDslXmlBeanDefinitionReader.createReaderContext(new DescriptiveResource("Groovy")).     BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext).     boolean decorating = (this.currentBeanDefinition != null).     if (!decorating) {         this.currentBeanDefinition = new GroovyBeanDefinitionWrapper(namespace).     }     return new GroovyDynamicElementReader(namespace, this.namespaces, delegate, this.currentBeanDefinition, decorating) {          @Override         protected void afterInvocation() {             if (!this.decorating) {                 currentBeanDefinition = null.             }         }     }. }
false;public;0;3;;public void apply() {     this.beanDefinition.addProperty(this.name, this.value). }
false;public;0;3;;public MetaClass getMetaClass() {     return this.metaClass. }
false;public;1;15;;public Object getProperty(String property) {     if (property.equals("beanName")) {         return getBeanName().     } else if (property.equals("source")) {         return getSource().     } else if (this.beanDefinition != null) {         return new GroovyPropertyValue(property, this.beanDefinition.getBeanDefinition().getPropertyValues().get(property)).     } else {         return this.metaClass.getProperty(this, property).     } }
false;public;2;3;;public Object invokeMethod(String name, Object args) {     return this.metaClass.invokeMethod(this, name, args). }
false;public;1;3;;public void setMetaClass(MetaClass metaClass) {     this.metaClass = metaClass. }
false;public;2;5;;public void setProperty(String property, Object newValue) {     if (!addDeferredProperty(property, newValue)) {         this.beanDefinition.getBeanDefinition().getPropertyValues().add(property, newValue).     } }
false;public;1;4;;public void leftShift(Object value) {     InvokerHelper.invokeMethod(this.propertyValue, "leftShift", value).     updateDeferredProperties(value). }
false;public;1;5;;public boolean add(Object value) {     boolean retVal = (Boolean) InvokerHelper.invokeMethod(this.propertyValue, "add", value).     updateDeferredProperties(value).     return retVal. }
false;public;1;7;;public boolean addAll(Collection values) {     boolean retVal = (Boolean) InvokerHelper.invokeMethod(this.propertyValue, "addAll", values).     for (Object value : values) {         updateDeferredProperties(value).     }     return retVal. }
false;public;2;4;;@Override public Object invokeMethod(String name, Object args) {     return InvokerHelper.invokeMethod(this.propertyValue, name, args). }
false;public;1;4;;@Override public Object getProperty(String name) {     return InvokerHelper.getProperty(this.propertyValue, name). }
false;public;2;4;;@Override public void setProperty(String name, Object value) {     InvokerHelper.setProperty(this.propertyValue, name, value). }
false;private;1;6;;private void updateDeferredProperties(Object value) {     if (value instanceof RuntimeBeanReference) {         deferredProperties.put(beanDefinition.getBeanName(), new DeferredProperty(beanDefinition, this.propertyName, this.propertyValue)).     } }
