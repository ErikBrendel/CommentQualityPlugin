commented;modifiers;parameterAmount;loc;comment;code
true;protected,final;2;30;/**  * Creates a {@link BeanDefinitionBuilder} instance for the  * {@link #getBeanClass bean Class} and passes it to the  * {@link #doParse} strategy method.  * @param element the element that is to be parsed into a single BeanDefinition  * @param parserContext the object encapsulating the current state of the parsing process  * @return the BeanDefinition resulting from the parsing of the supplied {@link Element}  * @throws IllegalStateException if the bean {@link Class} returned from  * {@link #getBeanClass(org.w3c.dom.Element)} is {@code null}  * @see #doParse  */ ;/**  * Creates a {@link BeanDefinitionBuilder} instance for the  * {@link #getBeanClass bean Class} and passes it to the  * {@link #doParse} strategy method.  * @param element the element that is to be parsed into a single BeanDefinition  * @param parserContext the object encapsulating the current state of the parsing process  * @return the BeanDefinition resulting from the parsing of the supplied {@link Element}  * @throws IllegalStateException if the bean {@link Class} returned from  * {@link #getBeanClass(org.w3c.dom.Element)} is {@code null}  * @see #doParse  */ @Override protected final AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {     BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition().     String parentName = getParentName(element).     if (parentName != null) {         builder.getRawBeanDefinition().setParentName(parentName).     }     Class<?> beanClass = getBeanClass(element).     if (beanClass != null) {         builder.getRawBeanDefinition().setBeanClass(beanClass).     } else {         String beanClassName = getBeanClassName(element).         if (beanClassName != null) {             builder.getRawBeanDefinition().setBeanClassName(beanClassName).         }     }     builder.getRawBeanDefinition().setSource(parserContext.extractSource(element)).     BeanDefinition containingBd = parserContext.getContainingBeanDefinition().     if (containingBd != null) {         // Inner bean definition must receive same scope as containing bean.         builder.setScope(containingBd.getScope()).     }     if (parserContext.isDefaultLazyInit()) {         // Default-lazy-init applies to custom bean definitions as well.         builder.setLazyInit(true).     }     doParse(element, parserContext, builder).     return builder.getBeanDefinition(). }
true;protected;1;4;/**  * Determine the name for the parent of the currently parsed bean,  * in case of the current bean being defined as a child bean.  * <p>The default implementation returns {@code null},  * indicating a root bean definition.  * @param element the {@code Element} that is being parsed  * @return the name of the parent bean for the currently parsed bean,  * or {@code null} if none  */ ;/**  * Determine the name for the parent of the currently parsed bean,  * in case of the current bean being defined as a child bean.  * <p>The default implementation returns {@code null},  * indicating a root bean definition.  * @param element the {@code Element} that is being parsed  * @return the name of the parent bean for the currently parsed bean,  * or {@code null} if none  */ @Nullable protected String getParentName(Element element) {     return null. }
true;protected;1;4;/**  * Determine the bean class corresponding to the supplied {@link Element}.  * <p>Note that, for application classes, it is generally preferable to  * override {@link #getBeanClassName} instead, in order to avoid a direct  * dependence on the bean implementation class. The BeanDefinitionParser  * and its NamespaceHandler can be used within an IDE plugin then, even  * if the application classes are not available on the plugin's classpath.  * @param element the {@code Element} that is being parsed  * @return the {@link Class} of the bean that is being defined via parsing  * the supplied {@code Element}, or {@code null} if none  * @see #getBeanClassName  */ ;/**  * Determine the bean class corresponding to the supplied {@link Element}.  * <p>Note that, for application classes, it is generally preferable to  * override {@link #getBeanClassName} instead, in order to avoid a direct  * dependence on the bean implementation class. The BeanDefinitionParser  * and its NamespaceHandler can be used within an IDE plugin then, even  * if the application classes are not available on the plugin's classpath.  * @param element the {@code Element} that is being parsed  * @return the {@link Class} of the bean that is being defined via parsing  * the supplied {@code Element}, or {@code null} if none  * @see #getBeanClassName  */ @Nullable protected Class<?> getBeanClass(Element element) {     return null. }
true;protected;1;4;/**  * Determine the bean class name corresponding to the supplied {@link Element}.  * @param element the {@code Element} that is being parsed  * @return the class name of the bean that is being defined via parsing  * the supplied {@code Element}, or {@code null} if none  * @see #getBeanClass  */ ;/**  * Determine the bean class name corresponding to the supplied {@link Element}.  * @param element the {@code Element} that is being parsed  * @return the class name of the bean that is being defined via parsing  * the supplied {@code Element}, or {@code null} if none  * @see #getBeanClass  */ @Nullable protected String getBeanClassName(Element element) {     return null. }
true;protected;3;3;/**  * Parse the supplied {@link Element} and populate the supplied  * {@link BeanDefinitionBuilder} as required.  * <p>The default implementation delegates to the {@code doParse}  * version without ParserContext argument.  * @param element the XML element being parsed  * @param parserContext the object encapsulating the current state of the parsing process  * @param builder used to define the {@code BeanDefinition}  * @see #doParse(Element, BeanDefinitionBuilder)  */ ;/**  * Parse the supplied {@link Element} and populate the supplied  * {@link BeanDefinitionBuilder} as required.  * <p>The default implementation delegates to the {@code doParse}  * version without ParserContext argument.  * @param element the XML element being parsed  * @param parserContext the object encapsulating the current state of the parsing process  * @param builder used to define the {@code BeanDefinition}  * @see #doParse(Element, BeanDefinitionBuilder)  */ protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {     doParse(element, builder). }
true;protected;2;2;/**  * Parse the supplied {@link Element} and populate the supplied  * {@link BeanDefinitionBuilder} as required.  * <p>The default implementation does nothing.  * @param element the XML element being parsed  * @param builder used to define the {@code BeanDefinition}  */ ;/**  * Parse the supplied {@link Element} and populate the supplied  * {@link BeanDefinitionBuilder} as required.  * <p>The default implementation does nothing.  * @param element the XML element being parsed  * @param builder used to define the {@code BeanDefinition}  */ protected void doParse(Element element, BeanDefinitionBuilder builder) { }
