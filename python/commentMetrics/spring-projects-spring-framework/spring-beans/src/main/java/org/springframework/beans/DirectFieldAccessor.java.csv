commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;13;;@Override @Nullable protected FieldPropertyHandler getLocalPropertyHandler(String propertyName) {     FieldPropertyHandler propertyHandler = this.fieldMap.get(propertyName).     if (propertyHandler == null) {         Field field = ReflectionUtils.findField(getWrappedClass(), propertyName).         if (field != null) {             propertyHandler = new FieldPropertyHandler(field).             this.fieldMap.put(propertyName, propertyHandler).         }     }     return propertyHandler. }
false;protected;2;4;;@Override protected DirectFieldAccessor newNestedPropertyAccessor(Object object, String nestedPath) {     return new DirectFieldAccessor(object, nestedPath, this). }
false;protected;1;7;;@Override protected NotWritablePropertyException createNotWritablePropertyException(String propertyName) {     PropertyMatches matches = PropertyMatches.forField(propertyName, getRootClass()).     throw new NotWritablePropertyException(getRootClass(), getNestedPath() + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches()). }
false;public;0;4;;@Override public TypeDescriptor toTypeDescriptor() {     return new TypeDescriptor(this.field). }
false;public;0;4;;@Override public ResolvableType getResolvableType() {     return ResolvableType.forField(this.field). }
false;public;1;5;;@Override @Nullable public TypeDescriptor nested(int level) {     return TypeDescriptor.nested(this.field, level). }
false;public;0;13;;@Override @Nullable public Object getValue() throws Exception {     try {         ReflectionUtils.makeAccessible(this.field).         return this.field.get(getWrappedInstance()).     } catch (IllegalAccessException ex) {         throw new InvalidPropertyException(getWrappedClass(), this.field.getName(), "Field is not accessible", ex).     } }
false;public;1;11;;@Override public void setValue(@Nullable Object value) throws Exception {     try {         ReflectionUtils.makeAccessible(this.field).         this.field.set(getWrappedInstance(), value).     } catch (IllegalAccessException ex) {         throw new InvalidPropertyException(getWrappedClass(), this.field.getName(), "Field is not accessible", ex).     } }
