commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;@Override public void init() { }
false;public;2;7;;@Override @Nullable public BeanDefinition parse(Element element, ParserContext parserContext) {     parserContext.getReaderContext().error("Class [" + getClass().getName() + "] does not support custom elements.", element).     return null. }
false;public;3;65;;@Override public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) {     if (node instanceof Attr) {         Attr attr = (Attr) node.         String argName = StringUtils.trimWhitespace(parserContext.getDelegate().getLocalName(attr)).         String argValue = StringUtils.trimWhitespace(attr.getValue()).         ConstructorArgumentValues cvs = definition.getBeanDefinition().getConstructorArgumentValues().         boolean ref = false.         // handle -ref arguments         if (argName.endsWith(REF_SUFFIX)) {             ref = true.             argName = argName.substring(0, argName.length() - REF_SUFFIX.length()).         }         ValueHolder valueHolder = new ValueHolder(ref ? new RuntimeBeanReference(argValue) : argValue).         valueHolder.setSource(parserContext.getReaderContext().extractSource(attr)).         // handle "escaped"/"_" arguments         if (argName.startsWith(DELIMITER_PREFIX)) {             String arg = argName.substring(1).trim().             // fast default check             if (!StringUtils.hasText(arg)) {                 cvs.addGenericArgumentValue(valueHolder).             } else // assume an index otherwise             {                 int index = -1.                 try {                     index = Integer.parseInt(arg).                 } catch (NumberFormatException ex) {                     parserContext.getReaderContext().error("Constructor argument '" + argName + "' specifies an invalid integer", attr).                 }                 if (index < 0) {                     parserContext.getReaderContext().error("Constructor argument '" + argName + "' specifies a negative index", attr).                 }                 if (cvs.hasIndexedArgumentValue(index)) {                     parserContext.getReaderContext().error("Constructor argument '" + argName + "' with index " + index + " already defined using <constructor-arg>." + " Only one approach may be used per argument.", attr).                 }                 cvs.addIndexedArgumentValue(index, valueHolder).             }         } else // no escaping -> ctr name         {             String name = Conventions.attributeNameToPropertyName(argName).             if (containsArgWithName(name, cvs)) {                 parserContext.getReaderContext().error("Constructor argument '" + argName + "' already defined using <constructor-arg>." + " Only one approach may be used per argument.", attr).             }             valueHolder.setName(Conventions.attributeNameToPropertyName(argName)).             cvs.addGenericArgumentValue(valueHolder).         }     }     return definition. }
false;private;2;4;;private boolean containsArgWithName(String name, ConstructorArgumentValues cvs) {     return (checkName(name, cvs.getGenericArgumentValues()) || checkName(name, cvs.getIndexedArgumentValues().values())). }
false;private;2;8;;private boolean checkName(String name, Collection<ValueHolder> values) {     for (ValueHolder holder : values) {         if (name.equals(holder.getName())) {             return true.         }     }     return false. }
