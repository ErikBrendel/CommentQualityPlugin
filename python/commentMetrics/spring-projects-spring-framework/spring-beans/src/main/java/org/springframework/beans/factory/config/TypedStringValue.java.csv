commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the String value.  * <p>Only necessary for manipulating a registered value,  * for example in BeanFactoryPostProcessors.  */ ;/**  * Set the String value.  * <p>Only necessary for manipulating a registered value,  * for example in BeanFactoryPostProcessors.  */ public void setValue(@Nullable String value) {     this.value = value. }
true;public;0;4;/**  * Return the String value.  */ ;/**  * Return the String value.  */ @Nullable public String getValue() {     return this.value. }
true;public;1;4;/**  * Set the type to convert to.  * <p>Only necessary for manipulating a registered value,  * for example in BeanFactoryPostProcessors.  */ ;/**  * Set the type to convert to.  * <p>Only necessary for manipulating a registered value,  * for example in BeanFactoryPostProcessors.  */ public void setTargetType(Class<?> targetType) {     Assert.notNull(targetType, "'targetType' must not be null").     this.targetType = targetType. }
true;public;0;7;/**  * Return the type to convert to.  */ ;/**  * Return the type to convert to.  */ public Class<?> getTargetType() {     Object targetTypeValue = this.targetType.     if (!(targetTypeValue instanceof Class)) {         throw new IllegalStateException("Typed String value does not carry a resolved target type").     }     return (Class<?>) targetTypeValue. }
true;public;1;3;/**  * Specify the type to convert to.  */ ;/**  * Specify the type to convert to.  */ public void setTargetTypeName(@Nullable String targetTypeName) {     this.targetType = targetTypeName. }
true;public;0;10;/**  * Return the type to convert to.  */ ;/**  * Return the type to convert to.  */ @Nullable public String getTargetTypeName() {     Object targetTypeValue = this.targetType.     if (targetTypeValue instanceof Class) {         return ((Class<?>) targetTypeValue).getName().     } else {         return (String) targetTypeValue.     } }
true;public;0;3;/**  * Return whether this typed String value carries a target type .  */ ;/**  * Return whether this typed String value carries a target type .  */ public boolean hasTargetType() {     return (this.targetType instanceof Class). }
true;public;1;10;/**  * Determine the type to convert to, resolving it from a specified class name  * if necessary. Will also reload a specified Class from its name when called  * with the target type already resolved.  * @param classLoader the ClassLoader to use for resolving a (potential) class name  * @return the resolved type to convert to  * @throws ClassNotFoundException if the type cannot be resolved  */ ;/**  * Determine the type to convert to, resolving it from a specified class name  * if necessary. Will also reload a specified Class from its name when called  * with the target type already resolved.  * @param classLoader the ClassLoader to use for resolving a (potential) class name  * @return the resolved type to convert to  * @throws ClassNotFoundException if the type cannot be resolved  */ @Nullable public Class<?> resolveTargetType(@Nullable ClassLoader classLoader) throws ClassNotFoundException {     String typeName = getTargetTypeName().     if (typeName == null) {         return null.     }     Class<?> resolvedClass = ClassUtils.forName(typeName, classLoader).     this.targetType = resolvedClass.     return resolvedClass. }
true;public;1;3;/**  * Set the configuration source {@code Object} for this metadata element.  * <p>The exact type of the object will depend on the configuration mechanism used.  */ ;/**  * Set the configuration source {@code Object} for this metadata element.  * <p>The exact type of the object will depend on the configuration mechanism used.  */ public void setSource(@Nullable Object source) {     this.source = source. }
false;public;0;5;;@Override @Nullable public Object getSource() {     return this.source. }
true;public;1;3;/**  * Set the type name as actually specified for this particular value, if any.  */ ;/**  * Set the type name as actually specified for this particular value, if any.  */ public void setSpecifiedTypeName(@Nullable String specifiedTypeName) {     this.specifiedTypeName = specifiedTypeName. }
true;public;0;4;/**  * Return the type name as actually specified for this particular value, if any.  */ ;/**  * Return the type name as actually specified for this particular value, if any.  */ @Nullable public String getSpecifiedTypeName() {     return this.specifiedTypeName. }
true;public;0;3;/**  * Mark this value as dynamic, i.e. as containing an expression  * and hence not being subject to caching.  */ ;/**  * Mark this value as dynamic, i.e. as containing an expression  * and hence not being subject to caching.  */ public void setDynamic() {     this.dynamic = true. }
true;public;0;3;/**  * Return whether this value has been marked as dynamic.  */ ;/**  * Return whether this value has been marked as dynamic.  */ public boolean isDynamic() {     return this.dynamic. }
false;public;1;12;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof TypedStringValue)) {         return false.     }     TypedStringValue otherValue = (TypedStringValue) other.     return (ObjectUtils.nullSafeEquals(this.value, otherValue.value) && ObjectUtils.nullSafeEquals(this.targetType, otherValue.targetType)). }
false;public;0;4;;@Override public int hashCode() {     return ObjectUtils.nullSafeHashCode(this.value) * 29 + ObjectUtils.nullSafeHashCode(this.targetType). }
false;public;0;4;;@Override public String toString() {     return "TypedStringValue: value [" + this.value + "], target type [" + this.targetType + "]". }
