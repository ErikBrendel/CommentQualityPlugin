# id;timestamp;commentText;codeText;commentWords;codeWords
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1386791358;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1386802599;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1387221517;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1404080175;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1417981895;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1419270405;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1432125256;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1454934048;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1460629667;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1461047077;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1467846264;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1468948866;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1469561191;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1495868221;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses);1496259743;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args);1500540246;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter if needed)_@throws BeanInstantiationException if no primary constructor can be found;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) {_			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				throw new BeanInstantiationException(ctor.getDeclaringClass(), "No corresponding Kotlin constructor found")__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(), _					"The number of provided arguments should be less of equals than the number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && (args[i] == null))) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed,throws,bean,instantiation,exception,if,no,primary,constructor,can,be,found;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,throw,new,bean,instantiation,exception,ctor,get,declaring,class,no,corresponding,kotlin,constructor,found,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,the,number,of,provided,arguments,should,be,less,of,equals,than,the,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args);1500549410;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter if needed)_@throws BeanInstantiationException if no primary constructor can be found;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) {_			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				throw new BeanInstantiationException(ctor.getDeclaringClass(), "No corresponding Kotlin constructor found")__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(), _					"The number of provided arguments should be less of equals than the number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && (args[i] == null))) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed,throws,bean,instantiation,exception,if,no,primary,constructor,can,be,found;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,throw,new,bean,instantiation,exception,ctor,get,declaring,class,no,corresponding,kotlin,constructor,found,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,the,number,of,provided,arguments,should,be,less,of,equals,than,the,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> public static void copyProperties(Object source, Object target, String[] ignoreProperties) 			throws BeansException;1328020251;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String[] ignoreProperties)_			throws BeansException {__		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String[] ignoreProperties) 			throws BeansException;1355352386;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String[] ignoreProperties)_			throws BeansException {__		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String[] ignoreProperties) 			throws BeansException;1356735495;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String[] ignoreProperties)_			throws BeansException {__		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String[] ignoreProperties) 			throws BeansException;1385412762;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String[] ignoreProperties)_			throws BeansException {__		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1328020251;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1355352386;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1356735495;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1385412762;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1386791358;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1386802599;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1387221517;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1404080175;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1417981895;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1419270405;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1432125256;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1454934048;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1460629667;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1461047077;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1467846264;Instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1468948866;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1469561191;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1495868221;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1496259743;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1496837955;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1498780456;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1500540246;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (kotlinPresent && isKotlinClass(clazz) ?_					KotlinDelegate.findPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			if (ctor == null) {_				throw new BeanInstantiationException(clazz, "No default constructor found")__			}_			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,present,is,kotlin,class,clazz,kotlin,delegate,find,primary,constructor,clazz,clazz,get,declared,constructor,if,ctor,null,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1500549410;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (kotlinPresent && isKotlinClass(clazz) ?_					KotlinDelegate.findPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			if (ctor == null) {_				throw new BeanInstantiationException(clazz, "No default constructor found")__			}_			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,present,is,kotlin,class,clazz,kotlin,delegate,find,primary,constructor,clazz,clazz,get,declared,constructor,if,ctor,null,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1502716442;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (kotlinPresent && isKotlinClass(clazz) ?_					KotlinDelegate.findPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			if (ctor == null) {_				throw new BeanInstantiationException(clazz, "No default constructor found")__			}_			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,present,is,kotlin,class,clazz,kotlin,delegate,find,primary,constructor,clazz,clazz,get,declared,constructor,if,ctor,null,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1503272000;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (isKotlinClass(clazz) ?_					KotlinDelegate.findPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			if (ctor == null) {_				throw new BeanInstantiationException(clazz, "No default constructor found")__			}_			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,is,kotlin,class,clazz,kotlin,delegate,find,primary,constructor,clazz,clazz,get,declared,constructor,if,ctor,null,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1503411745;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (useKotlinSupport(clazz) ?_					KotlinDelegate.findPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			if (ctor == null) {_				throw new BeanInstantiationException(clazz, "No default constructor found")__			}_			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,use,kotlin,support,clazz,kotlin,delegate,find,primary,constructor,clazz,clazz,get,declared,constructor,if,ctor,null,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1506080437;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (useKotlinSupport(clazz) ?_					KotlinDelegate.findPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			if (ctor == null) {_				throw new BeanInstantiationException(clazz, "No default constructor found")__			}_			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,use,kotlin,support,clazz,kotlin,delegate,find,primary,constructor,clazz,clazz,get,declared,constructor,if,ctor,null,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1506287440;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (useKotlinSupport(clazz) ?_					KotlinDelegate.findPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			if (ctor == null) {_				throw new BeanInstantiationException(clazz, "No default constructor found")__			}_			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,use,kotlin,support,clazz,kotlin,delegate,find,primary,constructor,clazz,clazz,get,declared,constructor,if,ctor,null,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1506551472;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (KotlinDetector.isKotlinType(clazz) ?_					KotlinDelegate.findPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			if (ctor == null) {_				throw new BeanInstantiationException(clazz, "No default constructor found")__			}_			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,detector,is,kotlin,type,clazz,kotlin,delegate,find,primary,constructor,clazz,clazz,get,declared,constructor,if,ctor,null,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1515363609;Instantiate a class using its no-arg constructor._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (KotlinDetector.isKotlinType(clazz) ?_					KotlinDelegate.findPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			if (ctor == null) {_				throw new BeanInstantiationException(clazz, "No default constructor found")__			}_			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,no,arg,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,detector,is,kotlin,type,clazz,kotlin,delegate,find,primary,constructor,clazz,clazz,get,declared,constructor,if,ctor,null,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1516210145;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found - or an exception thrown from_the constructor invocation attempt, including a runtime-generated_{@link NoClassDefFoundError} in case of an unresolvable dependency._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (KotlinDetector.isKotlinType(clazz) ?_					KotlinDelegate.getPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,or,an,exception,thrown,from,the,constructor,invocation,attempt,including,a,runtime,generated,link,no,class,def,found,error,in,case,of,an,unresolvable,dependency,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,detector,is,kotlin,type,clazz,kotlin,delegate,get,primary,constructor,clazz,clazz,get,declared,constructor,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1516217097;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found, a {@link NoClassDefFoundError}_or other {@link LinkageError} in case of an unresolvable class definition_(e.g. due to a missing dependency at runtime), or an exception thrown_from the constructor invocation itself._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (KotlinDetector.isKotlinType(clazz) ?_					KotlinDelegate.getPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_		catch (LinkageError err) {_			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,a,link,no,class,def,found,error,or,other,link,linkage,error,in,case,of,an,unresolvable,class,definition,e,g,due,to,a,missing,dependency,at,runtime,or,an,exception,thrown,from,the,constructor,invocation,itself,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,detector,is,kotlin,type,clazz,kotlin,delegate,get,primary,constructor,clazz,clazz,get,declared,constructor,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex,catch,linkage,error,err,throw,new,bean,instantiation,exception,clazz,unresolvable,class,definition,err
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1519588127;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found, a {@link NoClassDefFoundError}_or other {@link LinkageError} in case of an unresolvable class definition_(e.g. due to a missing dependency at runtime), or an exception thrown_from the constructor invocation itself._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (KotlinDetector.isKotlinType(clazz) ?_					KotlinDelegate.getPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_		catch (LinkageError err) {_			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,a,link,no,class,def,found,error,or,other,link,linkage,error,in,case,of,an,unresolvable,class,definition,e,g,due,to,a,missing,dependency,at,runtime,or,an,exception,thrown,from,the,constructor,invocation,itself,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,detector,is,kotlin,type,clazz,kotlin,delegate,get,primary,constructor,clazz,clazz,get,declared,constructor,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex,catch,linkage,error,err,throw,new,bean,instantiation,exception,clazz,unresolvable,class,definition,err
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1522360217;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found, a {@link NoClassDefFoundError}_or other {@link LinkageError} in case of an unresolvable class definition_(e.g. due to a missing dependency at runtime), or an exception thrown_from the constructor invocation itself._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (KotlinDetector.isKotlinType(clazz) ?_					KotlinDelegate.getPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_		catch (LinkageError err) {_			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,a,link,no,class,def,found,error,or,other,link,linkage,error,in,case,of,an,unresolvable,class,definition,e,g,due,to,a,missing,dependency,at,runtime,or,an,exception,thrown,from,the,constructor,invocation,itself,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,detector,is,kotlin,type,clazz,kotlin,delegate,get,primary,constructor,clazz,clazz,get,declared,constructor,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex,catch,linkage,error,err,throw,new,bean,instantiation,exception,clazz,unresolvable,class,definition,err
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1530174524;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found, a {@link NoClassDefFoundError}_or other {@link LinkageError} in case of an unresolvable class definition_(e.g. due to a missing dependency at runtime), or an exception thrown_from the constructor invocation itself._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (KotlinDetector.isKotlinType(clazz) ?_					KotlinDelegate.getPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_		catch (LinkageError err) {_			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,a,link,no,class,def,found,error,or,other,link,linkage,error,in,case,of,an,unresolvable,class,definition,e,g,due,to,a,missing,dependency,at,runtime,or,an,exception,thrown,from,the,constructor,invocation,itself,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,detector,is,kotlin,type,clazz,kotlin,delegate,get,primary,constructor,clazz,clazz,get,declared,constructor,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex,catch,linkage,error,err,throw,new,bean,instantiation,exception,clazz,unresolvable,class,definition,err
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1532091916;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found, a {@link NoClassDefFoundError}_or other {@link LinkageError} in case of an unresolvable class definition_(e.g. due to a missing dependency at runtime), or an exception thrown_from the constructor invocation itself._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			Constructor<T> ctor = (KotlinDetector.isKotlinType(clazz) ?_					KotlinDelegate.getPrimaryConstructor(clazz) : clazz.getDeclaredConstructor())__			return instantiateClass(ctor)__		}_		catch (NoSuchMethodException ex) {_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_		catch (LinkageError err) {_			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,a,link,no,class,def,found,error,or,other,link,linkage,error,in,case,of,an,unresolvable,class,definition,e,g,due,to,a,missing,dependency,at,runtime,or,an,exception,thrown,from,the,constructor,invocation,itself,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,constructor,t,ctor,kotlin,detector,is,kotlin,type,clazz,kotlin,delegate,get,primary,constructor,clazz,clazz,get,declared,constructor,return,instantiate,class,ctor,catch,no,such,method,exception,ex,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex,catch,linkage,error,err,throw,new,bean,instantiation,exception,clazz,unresolvable,class,definition,err
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1532332488;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found, a {@link NoClassDefFoundError}_or other {@link LinkageError} in case of an unresolvable class definition_(e.g. due to a missing dependency at runtime), or an exception thrown_from the constructor invocation itself._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(clazz)) {_				Constructor<T> ctor = findPrimaryConstructor(clazz)__				if (ctor != null) {_					return instantiateClass(ctor)__				}_			}_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_		catch (LinkageError err) {_			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,a,link,no,class,def,found,error,or,other,link,linkage,error,in,case,of,an,unresolvable,class,definition,e,g,due,to,a,missing,dependency,at,runtime,or,an,exception,thrown,from,the,constructor,invocation,itself,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,if,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,clazz,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,return,instantiate,class,ctor,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex,catch,linkage,error,err,throw,new,bean,instantiation,exception,clazz,unresolvable,class,definition,err
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1532706365;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found, a {@link NoClassDefFoundError}_or other {@link LinkageError} in case of an unresolvable class definition_(e.g. due to a missing dependency at runtime), or an exception thrown_from the constructor invocation itself._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(clazz)) {_				Constructor<T> ctor = findPrimaryConstructor(clazz)__				if (ctor != null) {_					return instantiateClass(ctor)__				}_			}_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_		catch (LinkageError err) {_			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,a,link,no,class,def,found,error,or,other,link,linkage,error,in,case,of,an,unresolvable,class,definition,e,g,due,to,a,missing,dependency,at,runtime,or,an,exception,thrown,from,the,constructor,invocation,itself,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,if,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,clazz,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,return,instantiate,class,ctor,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex,catch,linkage,error,err,throw,new,bean,instantiation,exception,clazz,unresolvable,class,definition,err
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1537388389;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found, a {@link NoClassDefFoundError}_or other {@link LinkageError} in case of an unresolvable class definition_(e.g. due to a missing dependency at runtime), or an exception thrown_from the constructor invocation itself._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			Constructor<T> ctor = findPrimaryConstructor(clazz)__			if (ctor != null) {_				return instantiateClass(ctor)__			}_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_		catch (LinkageError err) {_			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,a,link,no,class,def,found,error,or,other,link,linkage,error,in,case,of,an,unresolvable,class,definition,e,g,due,to,a,missing,dependency,at,runtime,or,an,exception,thrown,from,the,constructor,invocation,itself,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,return,instantiate,class,ctor,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex,catch,linkage,error,err,throw,new,bean,instantiation,exception,clazz,unresolvable,class,definition,err
BeanUtils -> public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException;1537391140;Instantiate a class using its 'primary' constructor (for Kotlin classes,_potentially having default arguments declared) or its default constructor_(for regular Java classes, expecting a standard no-arg setup)._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz the class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated._The cause may notably indicate a {@link NoSuchMethodException} if no_primary/default constructor was found, a {@link NoClassDefFoundError}_or other {@link LinkageError} in case of an unresolvable class definition_(e.g. due to a missing dependency at runtime), or an exception thrown_from the constructor invocation itself._@see Constructor#newInstance;public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return instantiateClass(clazz.getDeclaredConstructor())__		}_		catch (NoSuchMethodException ex) {_			Constructor<T> ctor = findPrimaryConstructor(clazz)__			if (ctor != null) {_				return instantiateClass(ctor)__			}_			throw new BeanInstantiationException(clazz, "No default constructor found", ex)__		}_		catch (LinkageError err) {_			throw new BeanInstantiationException(clazz, "Unresolvable class definition", err)__		}_	};instantiate,a,class,using,its,primary,constructor,for,kotlin,classes,potentially,having,default,arguments,declared,or,its,default,constructor,for,regular,java,classes,expecting,a,standard,no,arg,setup,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,the,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,the,cause,may,notably,indicate,a,link,no,such,method,exception,if,no,primary,default,constructor,was,found,a,link,no,class,def,found,error,or,other,link,linkage,error,in,case,of,an,unresolvable,class,definition,e,g,due,to,a,missing,dependency,at,runtime,or,an,exception,thrown,from,the,constructor,invocation,itself,see,constructor,new,instance;public,static,t,t,instantiate,class,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,instantiate,class,clazz,get,declared,constructor,catch,no,such,method,exception,ex,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,return,instantiate,class,ctor,throw,new,bean,instantiation,exception,clazz,no,default,constructor,found,ex,catch,linkage,error,err,throw,new,bean,instantiation,exception,clazz,unresolvable,class,definition,err
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1328020251;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T)instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1355352386;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T)instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1356735495;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T)instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1385412762;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T)instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1386791358;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T)instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1386802599;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1387221517;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1404080175;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1417981895;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1419270405;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1432125256;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1454934048;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1460629667;Instantiate a class using its no-arg constructor and return the new instance_as the the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1461047077;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1467846264;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where_the type of the class to instantiate (clazz) is not available, but the type_desired (assignableTo) is known._<p>As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1468948866;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1469561191;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1495868221;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1496259743;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1496837955;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1498780456;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1500540246;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1500549410;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1502716442;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1503272000;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1503411745;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1506080437;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1506287440;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1506551472;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1515363609;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1516210145;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1516217097;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1519588127;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1522360217;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1530174524;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1532091916;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1532332488;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1532706365;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1537388389;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> @SuppressWarnings("unchecked") 	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException;1537391140;Instantiate a class using its no-arg constructor and return the new instance_as the specified assignable type._<p>Useful in cases where the type of the class to instantiate (clazz) is not_available, but the type desired (assignableTo) is known._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param clazz class to instantiate_@param assignableTo type that clazz must be assignableTo_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;@SuppressWarnings("unchecked")_	public static <T> T instantiateClass(Class<?> clazz, Class<T> assignableTo) throws BeanInstantiationException {_		Assert.isAssignable(assignableTo, clazz)__		return (T) instantiateClass(clazz)__	};instantiate,a,class,using,its,no,arg,constructor,and,return,the,new,instance,as,the,specified,assignable,type,p,useful,in,cases,where,the,type,of,the,class,to,instantiate,clazz,is,not,available,but,the,type,desired,assignable,to,is,known,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,clazz,class,to,instantiate,param,assignable,to,type,that,clazz,must,be,assignable,to,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;suppress,warnings,unchecked,public,static,t,t,instantiate,class,class,clazz,class,t,assignable,to,throws,bean,instantiation,exception,assert,is,assignable,assignable,to,clazz,return,t,instantiate,class,clazz
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String[] ignoreProperties) 			throws BeansException;1328020251;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String[] ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null) ? Arrays.asList(ignoreProperties) : null___		for (PropertyDescriptor targetPd : targetPds) {_			if (targetPd.getWriteMethod() != null &&_					(ignoreProperties == null || (!ignoreList.contains(targetPd.getName())))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null && sourcePd.getReadMethod() != null) {_					try {_						Method readMethod = sourcePd.getReadMethod()__						if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_							readMethod.setAccessible(true)__						}_						Object value = readMethod.invoke(source)__						Method writeMethod = targetPd.getWriteMethod()__						if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_							writeMethod.setAccessible(true)__						}_						writeMethod.invoke(target, value)__					}_					catch (Throwable ex) {_						throw new FatalBeanException("Could not copy properties from source to target", ex)__					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,if,target,pd,get,write,method,null,ignore,properties,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,source,pd,get,read,method,null,try,method,read,method,source,pd,get,read,method,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,method,write,method,target,pd,get,write,method,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,properties,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String[] ignoreProperties) 			throws BeansException;1355352386;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String[] ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null) ? Arrays.asList(ignoreProperties) : null___		for (PropertyDescriptor targetPd : targetPds) {_			if (targetPd.getWriteMethod() != null &&_					(ignoreProperties == null || (!ignoreList.contains(targetPd.getName())))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null && sourcePd.getReadMethod() != null) {_					try {_						Method readMethod = sourcePd.getReadMethod()__						if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_							readMethod.setAccessible(true)__						}_						Object value = readMethod.invoke(source)__						Method writeMethod = targetPd.getWriteMethod()__						if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_							writeMethod.setAccessible(true)__						}_						writeMethod.invoke(target, value)__					}_					catch (Throwable ex) {_						throw new FatalBeanException("Could not copy properties from source to target", ex)__					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,if,target,pd,get,write,method,null,ignore,properties,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,source,pd,get,read,method,null,try,method,read,method,source,pd,get,read,method,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,method,write,method,target,pd,get,write,method,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,properties,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String[] ignoreProperties) 			throws BeansException;1356735495;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String[] ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null) ? Arrays.asList(ignoreProperties) : null___		for (PropertyDescriptor targetPd : targetPds) {_			if (targetPd.getWriteMethod() != null &&_					(ignoreProperties == null || (!ignoreList.contains(targetPd.getName())))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null && sourcePd.getReadMethod() != null) {_					try {_						Method readMethod = sourcePd.getReadMethod()__						if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_							readMethod.setAccessible(true)__						}_						Object value = readMethod.invoke(source)__						Method writeMethod = targetPd.getWriteMethod()__						if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_							writeMethod.setAccessible(true)__						}_						writeMethod.invoke(target, value)__					}_					catch (Throwable ex) {_						throw new FatalBeanException("Could not copy properties from source to target", ex)__					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,if,target,pd,get,write,method,null,ignore,properties,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,source,pd,get,read,method,null,try,method,read,method,source,pd,get,read,method,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,method,write,method,target,pd,get,write,method,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,properties,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String[] ignoreProperties) 			throws BeansException;1385412762;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String[] ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null) ? Arrays.asList(ignoreProperties) : null___		for (PropertyDescriptor targetPd : targetPds) {_			if (targetPd.getWriteMethod() != null &&_					(ignoreProperties == null || (!ignoreList.contains(targetPd.getName())))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null && sourcePd.getReadMethod() != null) {_					try {_						Method readMethod = sourcePd.getReadMethod()__						if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_							readMethod.setAccessible(true)__						}_						Object value = readMethod.invoke(source)__						Method writeMethod = targetPd.getWriteMethod()__						if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_							writeMethod.setAccessible(true)__						}_						writeMethod.invoke(target, value)__					}_					catch (Throwable ex) {_						throw new FatalBeanException("Could not copy properties from source to target", ex)__					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,if,target,pd,get,write,method,null,ignore,properties,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,source,pd,get,read,method,null,try,method,read,method,source,pd,get,read,method,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,method,write,method,target,pd,get,write,method,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,properties,from,source,to,target,ex
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1386802599;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1387221517;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1404080175;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1417981895;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1419270405;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1432125256;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1454934048;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1460629667;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1461047077;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1467846264;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1468948866;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1469561191;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1495868221;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1496259743;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1496837955;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1498780456;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1500540246;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1500549410;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1502716442;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1503272000;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1503411745;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1506080437;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1506287440;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1506551472;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1515363609;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1516210145;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1516217097;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1519588127;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1522360217;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1530174524;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1532091916;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1532332488;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1532706365;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1537388389;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException;1537391140;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable) throws BeansException {_		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1328020251;Retrieve the JavaBeans <code>PropertyDescriptor</code>s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of <code>PropertyDescriptors</code> for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,code,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,code,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1355352386;Retrieve the JavaBeans <code>PropertyDescriptor</code>s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of <code>PropertyDescriptors</code> for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,code,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,code,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1356735495;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1385412762;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1386791358;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1386802599;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1387221517;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1404080175;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1417981895;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1419270405;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1432125256;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1454934048;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1460629667;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1461047077;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1467846264;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1468948866;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1469561191;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1495868221;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1496259743;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1496837955;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1498780456;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1500540246;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1500549410;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1502716442;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1503272000;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1503411745;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1506080437;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1506287440;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1506551472;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1515363609;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1516210145;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1516217097;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1519588127;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1522360217;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1530174524;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given_class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1532091916;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given_class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1532332488;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given_class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1532706365;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given_class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1537388389;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given_class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException;1537391140;Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class._@param clazz the Class to retrieve the PropertyDescriptors for_@return an array of {@code PropertyDescriptors} for the given class_@throws BeansException if PropertyDescriptor look fails;public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {_		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptors()__	};retrieve,the,java,beans,code,property,descriptor,s,of,a,given,class,param,clazz,the,class,to,retrieve,the,property,descriptors,for,return,an,array,of,code,property,descriptors,for,the,given,class,throws,beans,exception,if,property,descriptor,look,fails;public,static,property,descriptor,get,property,descriptors,class,clazz,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptors
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1495868221;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1496259743;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1496837955;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1498780456;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1500540246;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1500549410;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1502716442;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1503272000;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1503411745;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1506080437;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1506287440;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1506551472;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1515363609;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1516210145;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1516217097;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1519588127;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1522360217;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1530174524;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1532091916;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1532332488;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1532706365;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1537388389;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> @Nullable 	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1537391140;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;@Nullable_	public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;nullable,public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1328020251;Find a JavaBeans <code>PropertyDescriptor</code> for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@return the corresponding PropertyDescriptor, or <code>null</code> if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(method.getDeclaringClass())__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,code,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,return,the,corresponding,property,descriptor,or,code,null,code,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,method,get,declaring,class,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1355352386;Find a JavaBeans <code>PropertyDescriptor</code> for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@return the corresponding PropertyDescriptor, or <code>null</code> if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(method.getDeclaringClass())__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,code,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,return,the,corresponding,property,descriptor,or,code,null,code,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,method,get,declaring,class,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1356735495;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(method.getDeclaringClass())__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,method,get,declaring,class,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1385412762;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(method.getDeclaringClass())__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,method,get,declaring,class,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1386791358;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(method.getDeclaringClass())__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,method,get,declaring,class,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1386802599;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(method.getDeclaringClass())__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,method,get,declaring,class,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1387221517;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(method.getDeclaringClass())__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,method,get,declaring,class,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1404080175;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(method.getDeclaringClass())__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,method,get,declaring,class,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1417981895;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1419270405;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1432125256;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1454934048;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1460629667;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1461047077;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1467846264;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1468948866;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1469561191;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1496837955;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1498780456;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1500540246;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1500549410;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1502716442;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1503272000;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1503411745;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1506080437;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1506287440;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1506551472;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1515363609;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1516210145;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1516217097;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1519588127;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1522360217;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1530174524;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1532091916;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1532332488;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1532706365;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1537388389;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, @Nullable Class<?> editable, 			@Nullable String... ignoreProperties) throws BeansException;1537391140;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, @Nullable Class<?> editable,_			@Nullable String... ignoreProperties) throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,nullable,class,editable,nullable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1500540246;Return the primary constructor of the provided class (single or default constructor_for Java classes and primary constructor for Kotlin classes) if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">http://kotlinlang.org/docs/reference/classes.html#constructors</a>_@since 5.0;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		Constructor<T> ctor = null__		if (kotlinPresent && isKotlinClass(clazz)) {_			ctor = KotlinDelegate.findPrimaryConstructor(clazz)__		}_		else {_			Constructor<T>[] ctors = (Constructor<T>[])clazz.getConstructors()__			if (ctors.length == 1) {_				ctor = ctors[0]__			}_			else {_				try {_					ctor = clazz.getDeclaredConstructor()__				}_				catch (NoSuchMethodException e) {_				}_			}_		}_		return ctor__	};return,the,primary,constructor,of,the,provided,class,single,or,default,constructor,for,java,classes,and,primary,constructor,for,kotlin,classes,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a,since,5,0;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,constructor,t,ctor,null,if,kotlin,present,is,kotlin,class,clazz,ctor,kotlin,delegate,find,primary,constructor,clazz,else,constructor,t,ctors,constructor,t,clazz,get,constructors,if,ctors,length,1,ctor,ctors,0,else,try,ctor,clazz,get,declared,constructor,catch,no,such,method,exception,e,return,ctor
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1500549410;Return the primary constructor of the provided class (single or default constructor_for Java classes and primary constructor for Kotlin classes), if any._@param clazz the {@link Class} of the Kotlin class_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		Constructor<T> ctor = null__		if (kotlinPresent && isKotlinClass(clazz)) {_			return KotlinDelegate.findPrimaryConstructor(clazz)__		}_		else {_			Constructor<T>[] ctors = (Constructor<T>[]) clazz.getConstructors()__			if (ctors.length == 1) {_				return ctors[0]__			}_			else {_				try {_					return clazz.getDeclaredConstructor()__				}_				catch (NoSuchMethodException ex) {_					return null__				}_			}_		}_	};return,the,primary,constructor,of,the,provided,class,single,or,default,constructor,for,java,classes,and,primary,constructor,for,kotlin,classes,if,any,param,clazz,the,link,class,of,the,kotlin,class,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,constructor,t,ctor,null,if,kotlin,present,is,kotlin,class,clazz,return,kotlin,delegate,find,primary,constructor,clazz,else,constructor,t,ctors,constructor,t,clazz,get,constructors,if,ctors,length,1,return,ctors,0,else,try,return,clazz,get,declared,constructor,catch,no,such,method,exception,ex,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1502716442;Return the primary constructor of the provided class (single or default constructor_for Java classes and primary constructor for Kotlin classes), if any._@param clazz the {@link Class} of the Kotlin class_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		Constructor<T> ctor = null__		if (kotlinPresent && isKotlinClass(clazz)) {_			return KotlinDelegate.findPrimaryConstructor(clazz)__		}_		else {_			Constructor<T>[] ctors = (Constructor<T>[]) clazz.getConstructors()__			if (ctors.length == 1) {_				return ctors[0]__			}_			else {_				try {_					return clazz.getDeclaredConstructor()__				}_				catch (NoSuchMethodException ex) {_					return null__				}_			}_		}_	};return,the,primary,constructor,of,the,provided,class,single,or,default,constructor,for,java,classes,and,primary,constructor,for,kotlin,classes,if,any,param,clazz,the,link,class,of,the,kotlin,class,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,constructor,t,ctor,null,if,kotlin,present,is,kotlin,class,clazz,return,kotlin,delegate,find,primary,constructor,clazz,else,constructor,t,ctors,constructor,t,clazz,get,constructors,if,ctors,length,1,return,ctors,0,else,try,return,clazz,get,declared,constructor,catch,no,such,method,exception,ex,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1503272000;Return the primary constructor of the provided class (single or default constructor_for Java classes and primary constructor for Kotlin classes), if any._@param clazz the {@link Class} of the Kotlin class_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (isKotlinClass(clazz)) {_			return KotlinDelegate.findPrimaryConstructor(clazz)__		}_		else {_			Constructor<T>[] ctors = (Constructor<T>[]) clazz.getConstructors()__			if (ctors.length == 1) {_				return ctors[0]__			}_			else {_				try {_					return clazz.getDeclaredConstructor()__				}_				catch (NoSuchMethodException ex) {_					return null__				}_			}_		}_	};return,the,primary,constructor,of,the,provided,class,single,or,default,constructor,for,java,classes,and,primary,constructor,for,kotlin,classes,if,any,param,clazz,the,link,class,of,the,kotlin,class,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,is,kotlin,class,clazz,return,kotlin,delegate,find,primary,constructor,clazz,else,constructor,t,ctors,constructor,t,clazz,get,constructors,if,ctors,length,1,return,ctors,0,else,try,return,clazz,get,declared,constructor,catch,no,such,method,exception,ex,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1503411745;Return the primary constructor of the provided class (single or default constructor_for Java classes and primary constructor for Kotlin classes), if any._@param clazz the {@link Class} of the Kotlin class_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (useKotlinSupport(clazz)) {_			return KotlinDelegate.findPrimaryConstructor(clazz)__		}_		else {_			Constructor<T>[] ctors = (Constructor<T>[]) clazz.getConstructors()__			if (ctors.length == 1) {_				return ctors[0]__			}_			else {_				try {_					return clazz.getDeclaredConstructor()__				}_				catch (NoSuchMethodException ex) {_					return null__				}_			}_		}_	};return,the,primary,constructor,of,the,provided,class,single,or,default,constructor,for,java,classes,and,primary,constructor,for,kotlin,classes,if,any,param,clazz,the,link,class,of,the,kotlin,class,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,use,kotlin,support,clazz,return,kotlin,delegate,find,primary,constructor,clazz,else,constructor,t,ctors,constructor,t,clazz,get,constructors,if,ctors,length,1,return,ctors,0,else,try,return,clazz,get,declared,constructor,catch,no,such,method,exception,ex,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1506080437;Return the primary constructor of the provided class. For Java classes, it returns_the single or the default constructor if any. For Kotlin classes, it returns the Java_constructor corresponding to the Kotlin primary constructor (as defined in_Kotlin specification), the single or the default constructor if any.__@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (useKotlinSupport(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		Constructor<T>[] ctors = (Constructor<T>[]) clazz.getConstructors()__		if (ctors.length == 1) {_			return ctors[0]__		}_		else {_			try {_				return clazz.getDeclaredConstructor()__			}_			catch (NoSuchMethodException ex) {_				return null__			}_		}_	};return,the,primary,constructor,of,the,provided,class,for,java,classes,it,returns,the,single,or,the,default,constructor,if,any,for,kotlin,classes,it,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,kotlin,specification,the,single,or,the,default,constructor,if,any,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,use,kotlin,support,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,constructor,t,ctors,constructor,t,clazz,get,constructors,if,ctors,length,1,return,ctors,0,else,try,return,clazz,get,declared,constructor,catch,no,such,method,exception,ex,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1506287440;Return the primary constructor of the provided class. For Java classes, it returns_the single or the default constructor if any. For Kotlin classes, it returns the Java_constructor corresponding to the Kotlin primary constructor (as defined in_Kotlin specification), the single or the default constructor if any.__@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (useKotlinSupport(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		Constructor<T>[] ctors = (Constructor<T>[]) clazz.getConstructors()__		if (ctors.length == 1) {_			return ctors[0]__		}_		else {_			try {_				return clazz.getDeclaredConstructor()__			}_			catch (NoSuchMethodException ex) {_				return null__			}_		}_	};return,the,primary,constructor,of,the,provided,class,for,java,classes,it,returns,the,single,or,the,default,constructor,if,any,for,kotlin,classes,it,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,kotlin,specification,the,single,or,the,default,constructor,if,any,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,use,kotlin,support,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,constructor,t,ctors,constructor,t,clazz,get,constructors,if,ctors,length,1,return,ctors,0,else,try,return,clazz,get,declared,constructor,catch,no,such,method,exception,ex,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1506551472;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1515363609;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1516210145;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1516217097;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1519588127;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1522360217;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1530174524;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1532091916;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1532332488;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1532706365;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1537388389;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1537391140;Return the primary constructor of the provided class. For Kotlin classes, this_returns the Java constructor corresponding to the Kotlin primary constructor_(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlin_classes, this simply returns {@code null}._@param clazz the class to check_@since 5.0_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>;@SuppressWarnings("unchecked")_	@Nullable_	public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(clazz)) {_			Constructor<T> kotlinPrimaryConstructor = KotlinDelegate.findPrimaryConstructor(clazz)__			if (kotlinPrimaryConstructor != null) {_				return kotlinPrimaryConstructor__			}_		}_		return null__	};return,the,primary,constructor,of,the,provided,class,for,kotlin,classes,this,returns,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,as,defined,in,the,kotlin,specification,otherwise,in,particular,for,non,kotlin,classes,this,simply,returns,code,null,param,clazz,the,class,to,check,since,5,0,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,kotlin,docs,a;suppress,warnings,unchecked,nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,assert,not,null,clazz,class,must,not,be,null,if,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,clazz,constructor,t,kotlin,primary,constructor,kotlin,delegate,find,primary,constructor,clazz,if,kotlin,primary,constructor,null,return,kotlin,primary,constructor,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1386791358;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1386802599;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1387221517;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1404080175;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1417981895;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1419270405;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1432125256;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1454934048;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1460629667;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1461047077;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1467846264;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1468948866;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1469561191;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1500540246;Return the Java constructor corresponding to the Kotlin primary constructor if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__			if (primaryConstructor == null) {_				return null__			}_			Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor)__			Assert.notNull(constructor, "Can't get the Java constructor corresponding to the Kotlin primary constructor of " + clazz.getName())__			return constructor__		};return,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,kfunction,t,primary,constructor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,constructor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,constructor,assert,not,null,constructor,can,t,get,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,of,clazz,get,name,return,constructor
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1500549410;Return the Java constructor corresponding to the Kotlin primary constructor if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__			if (primaryConstructor == null) {_				return null__			}_			Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor)__			Assert.notNull(constructor, "Can't get the Java constructor corresponding to the Kotlin primary constructor of " + clazz.getName())__			return constructor__		};return,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,kfunction,t,primary,constructor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,constructor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,constructor,assert,not,null,constructor,can,t,get,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,of,clazz,get,name,return,constructor
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1502716442;Return the Java constructor corresponding to the Kotlin primary constructor if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__			if (primaryConstructor == null) {_				return null__			}_			Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor)__			Assert.notNull(constructor, "Can't get the Java constructor corresponding to the Kotlin primary constructor of " + clazz.getName())__			return constructor__		};return,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,kfunction,t,primary,constructor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,constructor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,constructor,assert,not,null,constructor,can,t,get,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,of,clazz,get,name,return,constructor
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1503272000;Return the Java constructor corresponding to the Kotlin primary constructor if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__			if (primaryConstructor == null) {_				return null__			}_			Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor)__			Assert.notNull(constructor,_					() -> "Failed to find Java constructor corresponding to Kotlin primary constructor: " + clazz.getName())__			return constructor__		};return,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,kfunction,t,primary,constructor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,constructor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,constructor,assert,not,null,constructor,failed,to,find,java,constructor,corresponding,to,kotlin,primary,constructor,clazz,get,name,return,constructor
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1503411745;Return the Java constructor corresponding to the Kotlin primary constructor if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__			if (primaryConstructor == null) {_				return null__			}_			Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor)__			Assert.notNull(constructor,_					() -> "Failed to find Java constructor corresponding to Kotlin primary constructor: " + clazz.getName())__			return constructor__		};return,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,kfunction,t,primary,constructor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,constructor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,constructor,assert,not,null,constructor,failed,to,find,java,constructor,corresponding,to,kotlin,primary,constructor,clazz,get,name,return,constructor
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1506080437;Return the Java constructor corresponding to the Kotlin primary constructor if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__			if (primaryConstructor == null) {_				return null__			}_			Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor)__			Assert.notNull(constructor,_					() -> "Failed to find Java constructor corresponding to Kotlin primary constructor: " + clazz.getName())__			return constructor__		};return,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,kfunction,t,primary,constructor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,constructor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,constructor,assert,not,null,constructor,failed,to,find,java,constructor,corresponding,to,kotlin,primary,constructor,clazz,get,name,return,constructor
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1506287440;Return the Java constructor corresponding to the Kotlin primary constructor if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryConstructor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryConstructor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryConstructor)__				Assert.notNull(constructor,_						() -> "Failed to find Java constructor corresponding to Kotlin primary constructor: " + clazz.getName())__				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};return,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,constructor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,constructor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,constructor,assert,not,null,constructor,failed,to,find,java,constructor,corresponding,to,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1506551472;Return the Java constructor corresponding to the Kotlin primary constructor if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				Assert.notNull(constructor,_						() -> "Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};return,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,assert,not,null,constructor,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1515363609;Return the Java constructor corresponding to the Kotlin primary constructor if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				Assert.notNull(constructor,_						() -> "Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};return,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,assert,not,null,constructor,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1516210145;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1516217097;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1519588127;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1522360217;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1530174524;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1532091916;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1532332488;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1532706365;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1537388389;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> KotlinDelegate -> @Nullable 		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz);1537391140;Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any._@param clazz the {@link Class} of the Kotlin class_@see <a href="http://kotlinlang.org/docs/reference/classes.html#constructors">_http://kotlinlang.org/docs/reference/classes.html#constructors</a>;@Nullable_		public static <T> Constructor<T> findPrimaryConstructor(Class<T> clazz) {_			try {_				KFunction<T> primaryCtor = KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))__				if (primaryCtor == null) {_					return null__				}_				Constructor<T> constructor = ReflectJvmMapping.getJavaConstructor(primaryCtor)__				if (constructor == null) {_					throw new IllegalStateException(_							"Failed to find Java constructor for Kotlin primary constructor: " + clazz.getName())__				}_				return constructor__			}_			catch (UnsupportedOperationException ex) {_				return null__			}_		};retrieve,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,if,any,param,clazz,the,link,class,of,the,kotlin,class,see,a,href,http,kotlinlang,org,docs,reference,classes,html,constructors,http,kotlinlang,org,docs,reference,classes,html,constructors,a;nullable,public,static,t,constructor,t,find,primary,constructor,class,t,clazz,try,kfunction,t,primary,ctor,kclasses,get,primary,constructor,jvm,class,mapping,kt,get,kotlin,class,clazz,if,primary,ctor,null,return,null,constructor,t,constructor,reflect,jvm,mapping,get,java,constructor,primary,ctor,if,constructor,null,throw,new,illegal,state,exception,failed,to,find,java,constructor,for,kotlin,primary,constructor,clazz,get,name,return,constructor,catch,unsupported,operation,exception,ex,return,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1328020251;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1355352386;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1356735495;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1385412762;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1386791358;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1386802599;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1387221517;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1404080175;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1417981895;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1419270405;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1432125256;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1454934048;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1460629667;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1461047077;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1467846264;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1468948866;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1469561191;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1495868221;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1496259743;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1496837955;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1498780456;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1500540246;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1500549410;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1502716442;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1503272000;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1503411745;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1506080437;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1506287440;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1506551472;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1515363609;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1516210145;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1516217097;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1519588127;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1522360217;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1530174524;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1532091916;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1532332488;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1532706365;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1537388389;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> public static void copyProperties(Object source, Object target) throws BeansException;1537391140;Copy the property values of the given source bean into the target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target) throws BeansException {_		copyProperties(source, target, null, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,throws,beans,exception,copy,properties,source,target,null,string,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(Class<?> targetType);1495868221;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(Class<?> targetType);1496259743;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1503272000;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"The number of provided arguments should be less of equals than the number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && (args[i] == null))) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,the,number,of,provided,arguments,should,be,less,of,equals,than,the,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1503411745;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"The number of provided arguments should be less of equals than the number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && (args[i] == null))) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,the,number,of,provided,arguments,should,be,less,of,equals,than,the,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1506080437;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"The number of provided arguments should be less of equals than the number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && (args[i] == null))) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,the,number,of,provided,arguments,should,be,less,of,equals,than,the,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1506287440;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"The number of provided arguments should be less of equals than the number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && (args[i] == null))) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,the,number,of,provided,arguments,should,be,less,of,equals,than,the,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1506551472;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1515363609;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1516210145;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1516217097;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1519588127;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1522360217;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1530174524;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1532091916;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1532332488;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1532706365;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1537388389;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> KotlinDelegate -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) 				throws IllegalAccessException, InvocationTargetException, InstantiationException;1537391140;Instantiate a Kotlin class using the provided constructor._@param ctor the constructor of the Kotlin class to instantiate_@param args the constructor arguments to apply_(use {@code null} for unspecified parameter if needed);public static <T> T instantiateClass(Constructor<T> ctor, Object... args)_				throws IllegalAccessException, InvocationTargetException, InstantiationException {__			KFunction<T> kotlinConstructor = ReflectJvmMapping.getKotlinFunction(ctor)__			if (kotlinConstructor == null) {_				return ctor.newInstance(args)__			}_			List<KParameter> parameters = kotlinConstructor.getParameters()__			Map<KParameter, Object> argParameters = new HashMap<>(parameters.size())__			Assert.isTrue(args.length <= parameters.size(),_					"Number of provided arguments should be less of equals than number of constructor parameters")__			for (int i = 0 _ i < args.length _ i++) {_				if (!(parameters.get(i).isOptional() && args[i] == null)) {_					argParameters.put(parameters.get(i), args[i])__				}_			}_			return kotlinConstructor.callBy(argParameters)__		};instantiate,a,kotlin,class,using,the,provided,constructor,param,ctor,the,constructor,of,the,kotlin,class,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,unspecified,parameter,if,needed;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,illegal,access,exception,invocation,target,exception,instantiation,exception,kfunction,t,kotlin,constructor,reflect,jvm,mapping,get,kotlin,function,ctor,if,kotlin,constructor,null,return,ctor,new,instance,args,list,kparameter,parameters,kotlin,constructor,get,parameters,map,kparameter,object,arg,parameters,new,hash,map,parameters,size,assert,is,true,args,length,parameters,size,number,of,provided,arguments,should,be,less,of,equals,than,number,of,constructor,parameters,for,int,i,0,i,args,length,i,if,parameters,get,i,is,optional,args,i,null,arg,parameters,put,parameters,get,i,args,i,return,kotlin,constructor,call,by,arg,parameters
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>[] beanClasses);1328020251;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or <code>Object.class</code> as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>[] beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,code,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>[] beanClasses);1355352386;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or <code>Object.class</code> as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>[] beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,code,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>[] beanClasses);1356735495;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>[] beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, Class<?>[] beanClasses);1385412762;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, Class<?>[] beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1386791358;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null) ? Arrays.asList(ignoreProperties) : null___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreProperties == null || (!ignoreList.contains(targetPd.getName())))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							writeMethod.getParameterTypes()[0].isAssignableFrom(readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,properties,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,write,method,get,parameter,types,0,is,assignable,from,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1386802599;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null) ? Arrays.asList(ignoreProperties) : null___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreProperties == null || (!ignoreList.contains(targetPd.getName())))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							writeMethod.getParameterTypes()[0].isAssignableFrom(readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,properties,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,write,method,get,parameter,types,0,is,assignable,from,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1387221517;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null) ? Arrays.asList(ignoreProperties) : null___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreProperties == null || (!ignoreList.contains(targetPd.getName())))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,properties,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1404080175;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null) ? Arrays.asList(ignoreProperties) : null___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreProperties == null || (!ignoreList.contains(targetPd.getName())))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,properties,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1417981895;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || (!ignoreList.contains(targetPd.getName())))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1419270405;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1432125256;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1454934048;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1460629667;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1461047077;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1467846264;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1468948866;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1469561191;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties) 			throws BeansException;1495868221;Copy the property values of the given source bean into the given target bean._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;private static void copyProperties(Object source, Object target, Class<?> editable, String... ignoreProperties)_			throws BeansException {__		Assert.notNull(source, "Source must not be null")__		Assert.notNull(target, "Target must not be null")___		Class<?> actualEditable = target.getClass()__		if (editable != null) {_			if (!editable.isInstance(target)) {_				throw new IllegalArgumentException("Target class [" + target.getClass().getName() +_						"] not assignable to Editable class [" + editable.getName() + "]")__			}_			actualEditable = editable__		}_		PropertyDescriptor[] targetPds = getPropertyDescriptors(actualEditable)__		List<String> ignoreList = (ignoreProperties != null ? Arrays.asList(ignoreProperties) : null)___		for (PropertyDescriptor targetPd : targetPds) {_			Method writeMethod = targetPd.getWriteMethod()__			if (writeMethod != null && (ignoreList == null || !ignoreList.contains(targetPd.getName()))) {_				PropertyDescriptor sourcePd = getPropertyDescriptor(source.getClass(), targetPd.getName())__				if (sourcePd != null) {_					Method readMethod = sourcePd.getReadMethod()__					if (readMethod != null &&_							ClassUtils.isAssignable(writeMethod.getParameterTypes()[0], readMethod.getReturnType())) {_						try {_							if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {_								readMethod.setAccessible(true)__							}_							Object value = readMethod.invoke(source)__							if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {_								writeMethod.setAccessible(true)__							}_							writeMethod.invoke(target, value)__						}_						catch (Throwable ex) {_							throw new FatalBeanException(_									"Could not copy property '" + targetPd.getName() + "' from source to target", ex)__						}_					}_				}_			}_		}_	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;private,static,void,copy,properties,object,source,object,target,class,editable,string,ignore,properties,throws,beans,exception,assert,not,null,source,source,must,not,be,null,assert,not,null,target,target,must,not,be,null,class,actual,editable,target,get,class,if,editable,null,if,editable,is,instance,target,throw,new,illegal,argument,exception,target,class,target,get,class,get,name,not,assignable,to,editable,class,editable,get,name,actual,editable,editable,property,descriptor,target,pds,get,property,descriptors,actual,editable,list,string,ignore,list,ignore,properties,null,arrays,as,list,ignore,properties,null,for,property,descriptor,target,pd,target,pds,method,write,method,target,pd,get,write,method,if,write,method,null,ignore,list,null,ignore,list,contains,target,pd,get,name,property,descriptor,source,pd,get,property,descriptor,source,get,class,target,pd,get,name,if,source,pd,null,method,read,method,source,pd,get,read,method,if,read,method,null,class,utils,is,assignable,write,method,get,parameter,types,0,read,method,get,return,type,try,if,modifier,is,public,read,method,get,declaring,class,get,modifiers,read,method,set,accessible,true,object,value,read,method,invoke,source,if,modifier,is,public,write,method,get,declaring,class,get,modifiers,write,method,set,accessible,true,write,method,invoke,target,value,catch,throwable,ex,throw,new,fatal,bean,exception,could,not,copy,property,target,pd,get,name,from,source,to,target,ex
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1328020251;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1355352386;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1356735495;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1385412762;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1386791358;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1386802599;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1387221517;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1404080175;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1417981895;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1419270405;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1432125256;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1454934048;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1460629667;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1461047077;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1467846264;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1468948866;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1469561191;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1495868221;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1496259743;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1496837955;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1498780456;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1500540246;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1500549410;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1502716442;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1503272000;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1503411745;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1506080437;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1506287440;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1506551472;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1515363609;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1516210145;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1516217097;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1519588127;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1522360217;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1530174524;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1532091916;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1532332488;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1532706365;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1537388389;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static boolean isSimpleProperty(Class<?> clazz);1537391140;Check if the given type represents a "simple" property:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale, a Class, or a corresponding array._<p>Used to determine properties to check for a "simple" dependency-check._@param clazz the type to check_@return whether the given type represents a "simple" property_@see org.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLE_@see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies;public static boolean isSimpleProperty(Class<?> clazz) {_		Assert.notNull(clazz, "Class must not be null")__		return isSimpleValueType(clazz) || (clazz.isArray() && isSimpleValueType(clazz.getComponentType()))__	};check,if,the,given,type,represents,a,simple,property,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,a,class,or,a,corresponding,array,p,used,to,determine,properties,to,check,for,a,simple,dependency,check,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,property,see,org,springframework,beans,factory,support,root,bean,definition,see,org,springframework,beans,factory,support,abstract,autowire,capable,bean,factory,check,dependencies;public,static,boolean,is,simple,property,class,clazz,assert,not,null,clazz,class,must,not,be,null,return,is,simple,value,type,clazz,clazz,is,array,is,simple,value,type,clazz,get,component,type
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1417981895;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 4.0.9;public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,4,0,9;public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1419270405;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1432125256;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1454934048;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1460629667;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1461047077;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1467846264;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1468948866;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1469561191;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1495868221;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1496259743;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1496837955;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1498780456;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1500540246;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1500549410;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1502716442;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1503272000;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1503411745;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1506080437;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1506287440;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1506551472;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1515363609;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1516210145;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1516217097;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1519588127;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1522360217;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1530174524;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1532091916;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1532332488;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1532706365;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1537388389;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1537391140;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;@Nullable_	public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @SuppressWarnings("unchecked") 	private static boolean useKotlinSupport(Class<?> clazz);1503411745;Return true if Kotlin is present and if the specified class is a Kotlin one.;@SuppressWarnings("unchecked")_	private static boolean useKotlinSupport(Class<?> clazz) {_		return (kotlinMetadata != null &&_				clazz.getDeclaredAnnotation((Class<? extends Annotation>) kotlinMetadata) != null)__	};return,true,if,kotlin,is,present,and,if,the,specified,class,is,a,kotlin,one;suppress,warnings,unchecked,private,static,boolean,use,kotlin,support,class,clazz,return,kotlin,metadata,null,clazz,get,declared,annotation,class,extends,annotation,kotlin,metadata,null
BeanUtils -> @SuppressWarnings("unchecked") 	private static boolean useKotlinSupport(Class<?> clazz);1506080437;Return true if Kotlin is present and if the specified class is a Kotlin one.;@SuppressWarnings("unchecked")_	private static boolean useKotlinSupport(Class<?> clazz) {_		return (kotlinMetadata != null &&_				clazz.getDeclaredAnnotation((Class<? extends Annotation>) kotlinMetadata) != null)__	};return,true,if,kotlin,is,present,and,if,the,specified,class,is,a,kotlin,one;suppress,warnings,unchecked,private,static,boolean,use,kotlin,support,class,clazz,return,kotlin,metadata,null,clazz,get,declared,annotation,class,extends,annotation,kotlin,metadata,null
BeanUtils -> @SuppressWarnings("unchecked") 	private static boolean useKotlinSupport(Class<?> clazz);1506287440;Return true if Kotlin is present and if the specified class is a Kotlin one.;@SuppressWarnings("unchecked")_	private static boolean useKotlinSupport(Class<?> clazz) {_		return (kotlinMetadata != null &&_				clazz.getDeclaredAnnotation((Class<? extends Annotation>) kotlinMetadata) != null)__	};return,true,if,kotlin,is,present,and,if,the,specified,class,is,a,kotlin,one;suppress,warnings,unchecked,private,static,boolean,use,kotlin,support,class,clazz,return,kotlin,metadata,null,clazz,get,declared,annotation,class,extends,annotation,kotlin,metadata,null
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1328020251;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks <code>Class.getMethod</code> first, falling back to_<code>findDeclaredMethod</code>. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or <code>null</code> if not found_@see java.lang.Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,code,first,falling,back,to,code,find,declared,method,code,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,see,java,lang,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1355352386;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks <code>Class.getMethod</code> first, falling back to_<code>findDeclaredMethod</code>. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or <code>null</code> if not found_@see java.lang.Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,code,first,falling,back,to,code,find,declared,method,code,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,see,java,lang,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1356735495;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1385412762;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1386791358;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1386802599;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1387221517;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1404080175;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1417981895;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1419270405;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1432125256;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1454934048;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1460629667;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1461047077;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1467846264;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1468948866;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1469561191;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> KotlinDelegate -> public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException;1516210145;Determine the Java constructor corresponding to the Kotlin primary constructor._@param clazz the {@link Class} of the Kotlin class_@throws NoSuchMethodException if no such constructor found_@since 5.0.3_@see #findPrimaryConstructor_@see Class#getDeclaredConstructor;public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException {_			Constructor<T> ctor = findPrimaryConstructor(clazz)__			if (ctor == null) {_				throw new NoSuchMethodException()__			}_			return ctor__		};determine,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,param,clazz,the,link,class,of,the,kotlin,class,throws,no,such,method,exception,if,no,such,constructor,found,since,5,0,3,see,find,primary,constructor,see,class,get,declared,constructor;public,static,t,constructor,t,get,primary,constructor,class,t,clazz,throws,no,such,method,exception,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,throw,new,no,such,method,exception,return,ctor
BeanUtils -> KotlinDelegate -> public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException;1516217097;Determine the Java constructor corresponding to the Kotlin primary constructor._@param clazz the {@link Class} of the Kotlin class_@throws NoSuchMethodException if no such constructor found_@since 5.0.3_@see #findPrimaryConstructor_@see Class#getDeclaredConstructor;public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException {_			Constructor<T> ctor = findPrimaryConstructor(clazz)__			if (ctor == null) {_				throw new NoSuchMethodException()__			}_			return ctor__		};determine,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,param,clazz,the,link,class,of,the,kotlin,class,throws,no,such,method,exception,if,no,such,constructor,found,since,5,0,3,see,find,primary,constructor,see,class,get,declared,constructor;public,static,t,constructor,t,get,primary,constructor,class,t,clazz,throws,no,such,method,exception,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,throw,new,no,such,method,exception,return,ctor
BeanUtils -> KotlinDelegate -> public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException;1519588127;Determine the Java constructor corresponding to the Kotlin primary constructor._@param clazz the {@link Class} of the Kotlin class_@throws NoSuchMethodException if no such constructor found_@since 5.0.3_@see #findPrimaryConstructor_@see Class#getDeclaredConstructor;public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException {_			Constructor<T> ctor = findPrimaryConstructor(clazz)__			if (ctor == null) {_				throw new NoSuchMethodException()__			}_			return ctor__		};determine,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,param,clazz,the,link,class,of,the,kotlin,class,throws,no,such,method,exception,if,no,such,constructor,found,since,5,0,3,see,find,primary,constructor,see,class,get,declared,constructor;public,static,t,constructor,t,get,primary,constructor,class,t,clazz,throws,no,such,method,exception,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,throw,new,no,such,method,exception,return,ctor
BeanUtils -> KotlinDelegate -> public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException;1522360217;Determine the Java constructor corresponding to the Kotlin primary constructor._@param clazz the {@link Class} of the Kotlin class_@throws NoSuchMethodException if no such constructor found_@since 5.0.3_@see #findPrimaryConstructor_@see Class#getDeclaredConstructor;public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException {_			Constructor<T> ctor = findPrimaryConstructor(clazz)__			if (ctor == null) {_				throw new NoSuchMethodException()__			}_			return ctor__		};determine,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,param,clazz,the,link,class,of,the,kotlin,class,throws,no,such,method,exception,if,no,such,constructor,found,since,5,0,3,see,find,primary,constructor,see,class,get,declared,constructor;public,static,t,constructor,t,get,primary,constructor,class,t,clazz,throws,no,such,method,exception,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,throw,new,no,such,method,exception,return,ctor
BeanUtils -> KotlinDelegate -> public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException;1530174524;Determine the Java constructor corresponding to the Kotlin primary constructor._@param clazz the {@link Class} of the Kotlin class_@throws NoSuchMethodException if no such constructor found_@since 5.0.3_@see #findPrimaryConstructor_@see Class#getDeclaredConstructor;public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException {_			Constructor<T> ctor = findPrimaryConstructor(clazz)__			if (ctor == null) {_				throw new NoSuchMethodException()__			}_			return ctor__		};determine,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,param,clazz,the,link,class,of,the,kotlin,class,throws,no,such,method,exception,if,no,such,constructor,found,since,5,0,3,see,find,primary,constructor,see,class,get,declared,constructor;public,static,t,constructor,t,get,primary,constructor,class,t,clazz,throws,no,such,method,exception,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,throw,new,no,such,method,exception,return,ctor
BeanUtils -> KotlinDelegate -> public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException;1532091916;Determine the Java constructor corresponding to the Kotlin primary constructor._@param clazz the {@link Class} of the Kotlin class_@throws NoSuchMethodException if no such constructor found_@since 5.0.3_@see #findPrimaryConstructor_@see Class#getDeclaredConstructor;public static <T> Constructor<T> getPrimaryConstructor(Class<T> clazz) throws NoSuchMethodException {_			Constructor<T> ctor = findPrimaryConstructor(clazz)__			if (ctor == null) {_				throw new NoSuchMethodException()__			}_			return ctor__		};determine,the,java,constructor,corresponding,to,the,kotlin,primary,constructor,param,clazz,the,link,class,of,the,kotlin,class,throws,no,such,method,exception,if,no,such,constructor,found,since,5,0,3,see,find,primary,constructor,see,class,get,declared,constructor;public,static,t,constructor,t,get,primary,constructor,class,t,clazz,throws,no,such,method,exception,constructor,t,ctor,find,primary,constructor,clazz,if,ctor,null,throw,new,no,such,method,exception,return,ctor
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1496837955;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1498780456;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1500540246;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1500549410;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1502716442;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1503272000;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1503411745;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1506080437;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1506287440;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1506551472;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1515363609;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1516210145;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1516217097;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1519588127;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1522360217;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1530174524;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1532091916;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1532332488;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1532706365;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1537388389;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses);1537391140;Determine the bean property type for the given property from the_given classes/interfaces, if possible._@param propertyName the name of the bean property_@param beanClasses the classes to check against_@return the property type, or {@code Object.class} as fallback;public static Class<?> findPropertyType(String propertyName, @Nullable Class<?>... beanClasses) {_		if (beanClasses != null) {_			for (Class<?> beanClass : beanClasses) {_				PropertyDescriptor pd = getPropertyDescriptor(beanClass, propertyName)__				if (pd != null) {_					return pd.getPropertyType()__				}_			}_		}_		return Object.class__	};determine,the,bean,property,type,for,the,given,property,from,the,given,classes,interfaces,if,possible,param,property,name,the,name,of,the,bean,property,param,bean,classes,the,classes,to,check,against,return,the,property,type,or,code,object,class,as,fallback;public,static,class,find,property,type,string,property,name,nullable,class,bean,classes,if,bean,classes,null,for,class,bean,class,bean,classes,property,descriptor,pd,get,property,descriptor,bean,class,property,name,if,pd,null,return,pd,get,property,type,return,object,class
BeanUtils -> private static boolean isKotlinClass(Class<?> clazz);1500540246;Return true if the specified class is a Kotlin one.;private static boolean isKotlinClass(Class<?> clazz) {_		for (Annotation annotation : clazz.getDeclaredAnnotations()) {_			if (annotation.annotationType().getName().equals("kotlin.Metadata")) {_				return true__			}_		}_		return false__	};return,true,if,the,specified,class,is,a,kotlin,one;private,static,boolean,is,kotlin,class,class,clazz,for,annotation,annotation,clazz,get,declared,annotations,if,annotation,annotation,type,get,name,equals,kotlin,metadata,return,true,return,false
BeanUtils -> private static boolean isKotlinClass(Class<?> clazz);1500549410;Return true if the specified class is a Kotlin one.;private static boolean isKotlinClass(Class<?> clazz) {_		for (Annotation annotation : clazz.getDeclaredAnnotations()) {_			if (annotation.annotationType().getName().equals("kotlin.Metadata")) {_				return true__			}_		}_		return false__	};return,true,if,the,specified,class,is,a,kotlin,one;private,static,boolean,is,kotlin,class,class,clazz,for,annotation,annotation,clazz,get,declared,annotations,if,annotation,annotation,type,get,name,equals,kotlin,metadata,return,true,return,false
BeanUtils -> private static boolean isKotlinClass(Class<?> clazz);1502716442;Return true if the specified class is a Kotlin one.;private static boolean isKotlinClass(Class<?> clazz) {_		for (Annotation annotation : clazz.getDeclaredAnnotations()) {_			if (annotation.annotationType().getName().equals("kotlin.Metadata")) {_				return true__			}_		}_		return false__	};return,true,if,the,specified,class,is,a,kotlin,one;private,static,boolean,is,kotlin,class,class,clazz,for,annotation,annotation,clazz,get,declared,annotations,if,annotation,annotation,type,get,name,equals,kotlin,metadata,return,true,return,false
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1328020251;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(_					((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1355352386;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(_					((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1356735495;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(_					((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1385412762;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(_					((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1386791358;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(_					((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1386802599;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1387221517;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1404080175;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1417981895;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1419270405;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1432125256;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1454934048;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1460629667;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1461047077;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1467846264;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1468948866;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1469561191;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1495868221;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1496259743;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1496837955;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			return new MethodParameter(pd.getWriteMethod(), 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,return,new,method,parameter,pd,get,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1498780456;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1500540246;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1500549410;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1502716442;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1503272000;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1503411745;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1506080437;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1506287440;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1506551472;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1515363609;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1516210145;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1516217097;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1519588127;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1522360217;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1530174524;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1532091916;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1532332488;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1532706365;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1537388389;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd);1537391140;Obtain a new MethodParameter object for the write method of the_specified property._@param pd the PropertyDescriptor for the property_@return a corresponding MethodParameter object;public static MethodParameter getWriteMethodParameter(PropertyDescriptor pd) {_		if (pd instanceof GenericTypeAwarePropertyDescriptor) {_			return new MethodParameter(((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodParameter())__		}_		else {_			Method writeMethod = pd.getWriteMethod()__			Assert.state(writeMethod != null, "No write method available")__			return new MethodParameter(writeMethod, 0)__		}_	};obtain,a,new,method,parameter,object,for,the,write,method,of,the,specified,property,param,pd,the,property,descriptor,for,the,property,return,a,corresponding,method,parameter,object;public,static,method,parameter,get,write,method,parameter,property,descriptor,pd,if,pd,instanceof,generic,type,aware,property,descriptor,return,new,method,parameter,generic,type,aware,property,descriptor,pd,get,write,method,parameter,else,method,write,method,pd,get,write,method,assert,state,write,method,null,no,write,method,available,return,new,method,parameter,write,method,0
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1328020251;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1355352386;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1356735495;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1385412762;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1386791358;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1386802599;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1387221517;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1404080175;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1417981895;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1419270405;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				clazz.equals(URI.class) || clazz.equals(URL.class) ||_				clazz.equals(Locale.class) || clazz.equals(Class.class)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,clazz,equals,uri,class,clazz,equals,url,class,clazz,equals,locale,class,clazz,equals,class,class
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1432125256;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1454934048;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1460629667;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1461047077;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1467846264;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1468948866;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1469561191;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1495868221;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1496259743;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1496837955;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1498780456;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1500540246;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1500549410;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1502716442;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1503272000;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1503411745;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1506080437;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1506287440;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1506551472;Check if the given type represents a "simple" value type:_a primitive, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,clazz,is,enum,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1515363609;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1516210145;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1516217097;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1519588127;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1522360217;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1530174524;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1532091916;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1532332488;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1532706365;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1537388389;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static boolean isSimpleValueType(Class<?> clazz);1537391140;Check if the given type represents a "simple" value type:_a primitive, an enum, a String or other CharSequence, a Number, a Date,_a URI, a URL, a Locale or a Class._@param clazz the type to check_@return whether the given type represents a "simple" value type;public static boolean isSimpleValueType(Class<?> clazz) {_		return (ClassUtils.isPrimitiveOrWrapper(clazz) ||_				Enum.class.isAssignableFrom(clazz) ||_				CharSequence.class.isAssignableFrom(clazz) ||_				Number.class.isAssignableFrom(clazz) ||_				Date.class.isAssignableFrom(clazz) ||_				URI.class == clazz || URL.class == clazz ||_				Locale.class == clazz || Class.class == clazz)__	};check,if,the,given,type,represents,a,simple,value,type,a,primitive,an,enum,a,string,or,other,char,sequence,a,number,a,date,a,uri,a,url,a,locale,or,a,class,param,clazz,the,type,to,check,return,whether,the,given,type,represents,a,simple,value,type;public,static,boolean,is,simple,value,type,class,clazz,return,class,utils,is,primitive,or,wrapper,clazz,enum,class,is,assignable,from,clazz,char,sequence,class,is,assignable,from,clazz,number,class,is,assignable,from,clazz,date,class,is,assignable,from,clazz,uri,class,clazz,url,class,clazz,locale,class,clazz,class,class,clazz
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1328020251;Retrieve the JavaBeans <code>PropertyDescriptors</code> for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or <code>null</code> if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,code,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,code,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1355352386;Retrieve the JavaBeans <code>PropertyDescriptors</code> for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or <code>null</code> if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,code,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,code,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1356735495;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1385412762;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1386791358;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1386802599;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1387221517;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1404080175;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1417981895;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1419270405;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1432125256;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1454934048;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1460629667;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1461047077;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1467846264;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1468948866;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1469561191;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1496837955;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1498780456;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1500540246;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1500549410;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1502716442;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1503272000;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1503411745;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1506080437;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1506287440;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1506551472;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1515363609;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1516210145;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1516217097;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1519588127;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1522360217;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1530174524;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1532091916;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isInfoEnabled()) {_					logger.info("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,info,enabled,logger,info,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1532332488;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isInfoEnabled()) {_					logger.info("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,info,enabled,logger,info,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1532706365;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isInfoEnabled()) {_					logger.info("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isTraceEnabled()) {_				logger.trace("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,info,enabled,logger,info,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,trace,enabled,logger,trace,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1537388389;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isInfoEnabled()) {_					logger.info("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isTraceEnabled()) {_				logger.trace("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,info,enabled,logger,info,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,trace,enabled,logger,trace,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType);1537391140;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;@Nullable_	public static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isInfoEnabled()) {_					logger.info("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isTraceEnabled()) {_				logger.trace("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;nullable,public,static,property,editor,find,editor,by,convention,nullable,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,info,enabled,logger,info,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,trace,enabled,logger,trace,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1328020251;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1355352386;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1356735495;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1385412762;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1386791358;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1386802599;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1387221517;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1404080175;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1417981895;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1419270405;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1432125256;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1454934048;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor.getDeclaringClass(),_					"Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,get,declaring,class,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1460629667;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1461047077;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1467846264;Convenience method to instantiate a class using the given constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._<p>Note that this method tries to set the constructor accessible_if given a non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1468948866;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1469561191;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1495868221;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1496259743;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1496837955;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1498780456;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor._@param ctor the constructor to instantiate_@param args the constructor arguments to apply_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return ctor.newInstance(args)__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1500540246;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter_if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (kotlinPresent && isKotlinClass(ctor.getDeclaringClass()) ? KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,present,is,kotlin,class,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1500549410;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter_if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (kotlinPresent && isKotlinClass(ctor.getDeclaringClass()) ? KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,present,is,kotlin,class,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1502716442;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use null for unspecified parameter_if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (kotlinPresent && isKotlinClass(ctor.getDeclaringClass()) ? KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,null,for,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,present,is,kotlin,class,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1503272000;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (isKotlinClass(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,is,kotlin,class,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1503411745;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (useKotlinSupport(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,use,kotlin,support,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1506080437;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (useKotlinSupport(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,use,kotlin,support,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1506287440;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (useKotlinSupport(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,use,kotlin,support,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1506551472;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1515363609;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1516210145;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1516217097;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1519588127;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1522360217;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1530174524;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1532091916;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1532332488;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1532706365;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1537388389;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException;1537391140;Convenience method to instantiate a class using the given constructor._<p>Note that this method tries to set the constructor accessible if given a_non-accessible (that is, non-public) constructor, and supports Kotlin classes_with optional parameters and default values._@param ctor the constructor to instantiate_@param args the constructor arguments to apply (use {@code null} for an unspecified_parameter if needed for Kotlin classes with optional parameters and default values)_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@see Constructor#newInstance;public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {_		Assert.notNull(ctor, "Constructor must not be null")__		try {_			ReflectionUtils.makeAccessible(ctor)__			return (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?_					KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args))__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(ctor, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(ctor, "Is the constructor accessible?", ex)__		}_		catch (IllegalArgumentException ex) {_			throw new BeanInstantiationException(ctor, "Illegal arguments for constructor", ex)__		}_		catch (InvocationTargetException ex) {_			throw new BeanInstantiationException(ctor, "Constructor threw exception", ex.getTargetException())__		}_	};convenience,method,to,instantiate,a,class,using,the,given,constructor,p,note,that,this,method,tries,to,set,the,constructor,accessible,if,given,a,non,accessible,that,is,non,public,constructor,and,supports,kotlin,classes,with,optional,parameters,and,default,values,param,ctor,the,constructor,to,instantiate,param,args,the,constructor,arguments,to,apply,use,code,null,for,an,unspecified,parameter,if,needed,for,kotlin,classes,with,optional,parameters,and,default,values,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,see,constructor,new,instance;public,static,t,t,instantiate,class,constructor,t,ctor,object,args,throws,bean,instantiation,exception,assert,not,null,ctor,constructor,must,not,be,null,try,reflection,utils,make,accessible,ctor,return,kotlin,detector,is,kotlin,reflect,present,kotlin,detector,is,kotlin,type,ctor,get,declaring,class,kotlin,delegate,instantiate,class,ctor,args,ctor,new,instance,args,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,ctor,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,ctor,is,the,constructor,accessible,ex,catch,illegal,argument,exception,ex,throw,new,bean,instantiation,exception,ctor,illegal,arguments,for,constructor,ex,catch,invocation,target,exception,ex,throw,new,bean,instantiation,exception,ctor,constructor,threw,exception,ex,get,target,exception
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1328020251;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1355352386;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1356735495;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1385412762;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1386791358;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1386802599;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1387221517;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1404080175;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1417981895;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1419270405;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1432125256;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1454934048;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1460629667;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1461047077;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1467846264;Convenience method to instantiate a class using its no-arg constructor._As this method doesn't try to load classes by name, it should avoid_class-loading issues._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated;public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,as,this,method,doesn,t,try,to,load,classes,by,name,it,should,avoid,class,loading,issues,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated;public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1328020251;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or <code>null</code> if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.containsKey(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.put(targetType, Boolean.TRUE)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.put(targetType, Boolean.TRUE)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,code,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,key,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,put,target,type,boolean,true,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,put,target,type,boolean,true,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1355352386;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or <code>null</code> if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.containsKey(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.put(targetType, Boolean.TRUE)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.put(targetType, Boolean.TRUE)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,code,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,key,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,put,target,type,boolean,true,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,put,target,type,boolean,true,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1356735495;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.containsKey(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.put(targetType, Boolean.TRUE)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.put(targetType, Boolean.TRUE)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,key,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,put,target,type,boolean,true,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,put,target,type,boolean,true,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1385412762;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.containsKey(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.put(targetType, Boolean.TRUE)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.put(targetType, Boolean.TRUE)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,key,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,put,target,type,boolean,true,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,put,target,type,boolean,true,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1386791358;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.containsKey(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.put(targetType, Boolean.TRUE)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.put(targetType, Boolean.TRUE)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,key,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,put,target,type,boolean,true,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,put,target,type,boolean,true,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1386802599;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.containsKey(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.put(targetType, Boolean.TRUE)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.put(targetType, Boolean.TRUE)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,key,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,put,target,type,boolean,true,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,put,target,type,boolean,true,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1387221517;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.containsKey(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.put(targetType, Boolean.TRUE)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.put(targetType, Boolean.TRUE)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,key,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,put,target,type,boolean,true,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,put,target,type,boolean,true,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1404080175;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1417981895;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1419270405;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1432125256;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1454934048;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1460629667;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1461047077;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1467846264;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1468948866;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> public static PropertyEditor findEditorByConvention(Class<?> targetType);1469561191;Find a JavaBeans PropertyEditor following the 'Editor' suffix convention_(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor")._<p>Compatible to the standard JavaBeans convention as implemented by_{@link java.beans.PropertyEditorManager} but isolated from the latter's_registered default editors for primitive types._@param targetType the type to find an editor for_@return the corresponding editor, or {@code null} if none found;public static PropertyEditor findEditorByConvention(Class<?> targetType) {_		if (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {_			return null__		}_		ClassLoader cl = targetType.getClassLoader()__		if (cl == null) {_			try {_				cl = ClassLoader.getSystemClassLoader()__				if (cl == null) {_					return null__				}_			}_			catch (Throwable ex) {_				_				if (logger.isDebugEnabled()) {_					logger.debug("Could not access system ClassLoader: " + ex)__				}_				return null__			}_		}_		String editorName = targetType.getName() + "Editor"__		try {_			Class<?> editorClass = cl.loadClass(editorName)__			if (!PropertyEditor.class.isAssignableFrom(editorClass)) {_				if (logger.isWarnEnabled()) {_					logger.warn("Editor class [" + editorName +_							"] does not implement [java.beans.PropertyEditor] interface")__				}_				unknownEditorTypes.add(targetType)__				return null__			}_			return (PropertyEditor) instantiateClass(editorClass)__		}_		catch (ClassNotFoundException ex) {_			if (logger.isDebugEnabled()) {_				logger.debug("No property editor [" + editorName + "] found for type " +_						targetType.getName() + " according to 'Editor' suffix convention")__			}_			unknownEditorTypes.add(targetType)__			return null__		}_	};find,a,java,beans,property,editor,following,the,editor,suffix,convention,e,g,mypackage,my,domain,class,mypackage,my,domain,class,editor,p,compatible,to,the,standard,java,beans,convention,as,implemented,by,link,java,beans,property,editor,manager,but,isolated,from,the,latter,s,registered,default,editors,for,primitive,types,param,target,type,the,type,to,find,an,editor,for,return,the,corresponding,editor,or,code,null,if,none,found;public,static,property,editor,find,editor,by,convention,class,target,type,if,target,type,null,target,type,is,array,unknown,editor,types,contains,target,type,return,null,class,loader,cl,target,type,get,class,loader,if,cl,null,try,cl,class,loader,get,system,class,loader,if,cl,null,return,null,catch,throwable,ex,if,logger,is,debug,enabled,logger,debug,could,not,access,system,class,loader,ex,return,null,string,editor,name,target,type,get,name,editor,try,class,editor,class,cl,load,class,editor,name,if,property,editor,class,is,assignable,from,editor,class,if,logger,is,warn,enabled,logger,warn,editor,class,editor,name,does,not,implement,java,beans,property,editor,interface,unknown,editor,types,add,target,type,return,null,return,property,editor,instantiate,class,editor,class,catch,class,not,found,exception,ex,if,logger,is,debug,enabled,logger,debug,no,property,editor,editor,name,found,for,type,target,type,get,name,according,to,editor,suffix,convention,unknown,editor,types,add,target,type,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1495868221;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1496259743;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1496837955;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1498780456;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1500540246;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1500549410;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1502716442;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1503272000;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1503411745;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1506080437;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1506287440;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1506551472;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1515363609;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1516210145;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1516217097;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1519588127;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1522360217;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1530174524;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1532091916;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1532332488;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1532706365;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1537388389;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException;1537391140;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for,_introspecting its declaring class_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {_		return findPropertyForMethod(method, method.getDeclaringClass())__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,introspecting,its,declaring,class,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,find,property,for,method,method,method,throws,beans,exception,return,find,property,for,method,method,method,get,declaring,class
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) 			throws BeansException;1328020251;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable)_			throws BeansException {__		copyProperties(source, target, editable, null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) 			throws BeansException;1355352386;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable)_			throws BeansException {__		copyProperties(source, target, editable, null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) 			throws BeansException;1356735495;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable)_			throws BeansException {__		copyProperties(source, target, editable, null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) 			throws BeansException;1385412762;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable)_			throws BeansException {__		copyProperties(source, target, editable, null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,null
BeanUtils -> public static void copyProperties(Object source, Object target, Class<?> editable) 			throws BeansException;1386791358;Copy the property values of the given source bean into the given target bean,_only setting properties defined in the given "editable" class (or interface)._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param editable the class (or interface) to restrict property setting to_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, Class<?> editable)_			throws BeansException {__		copyProperties(source, target, editable, (String[]) null)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,only,setting,properties,defined,in,the,given,editable,class,or,interface,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,editable,the,class,or,interface,to,restrict,property,setting,to,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,class,editable,throws,beans,exception,copy,properties,source,target,editable,string,null
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1328020251;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or <code>null</code> if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1355352386;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or <code>null</code> if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1356735495;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1385412762;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1386791358;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1386802599;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1387221517;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1404080175;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1417981895;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1419270405;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1432125256;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else {_					if (targetMethod.getParameterTypes().length == numParams) {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters, but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,target,method,get,parameter,types,length,num,params,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1454934048;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterTypes().length == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,types,length,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1460629667;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterTypes().length == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,types,length,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1461047077;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterTypes().length__				if (targetMethod == null || numParams < targetMethod.getParameterTypes().length) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterTypes().length == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,types,length,if,target,method,null,num,params,target,method,get,parameter,types,length,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,types,length,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1467846264;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1468948866;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Method[] methods, String methodName) 			throws IllegalArgumentException;1469561191;Find a method with the given method name and minimal parameters (best case: none)_in the given list of methods._@param methods the methods to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters;public static Method findMethodWithMinimalParameters(Method[] methods, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = null__		int numMethodsFoundWithCurrentMinimumArgs = 0__		for (Method method : methods) {_			if (method.getName().equals(methodName)) {_				int numParams = method.getParameterCount()__				if (targetMethod == null || numParams < targetMethod.getParameterCount()) {_					targetMethod = method__					numMethodsFoundWithCurrentMinimumArgs = 1__				}_				else if (!method.isBridge() && targetMethod.getParameterCount() == numParams) {_					if (targetMethod.isBridge()) {_						_						targetMethod = method__					}_					else {_						_						numMethodsFoundWithCurrentMinimumArgs++__					}_				}_			}_		}_		if (numMethodsFoundWithCurrentMinimumArgs > 1) {_			throw new IllegalArgumentException("Cannot resolve method '" + methodName +_					"' to a unique method. Attempted to resolve to overloaded method with " +_					"the least number of parameters but there were " +_					numMethodsFoundWithCurrentMinimumArgs + " candidates.")__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,in,the,given,list,of,methods,param,methods,the,methods,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,method,methods,string,method,name,throws,illegal,argument,exception,method,target,method,null,int,num,methods,found,with,current,minimum,args,0,for,method,method,methods,if,method,get,name,equals,method,name,int,num,params,method,get,parameter,count,if,target,method,null,num,params,target,method,get,parameter,count,target,method,method,num,methods,found,with,current,minimum,args,1,else,if,method,is,bridge,target,method,get,parameter,count,num,params,if,target,method,is,bridge,target,method,method,else,num,methods,found,with,current,minimum,args,if,num,methods,found,with,current,minimum,args,1,throw,new,illegal,argument,exception,cannot,resolve,method,method,name,to,a,unique,method,attempted,to,resolve,to,overloaded,method,with,the,least,number,of,parameters,but,there,were,num,methods,found,with,current,minimum,args,candidates,return,target,method
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1495868221;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1496259743;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1496837955;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1498780456;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1500540246;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1500549410;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1502716442;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1503272000;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1503411745;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1506080437;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1506287440;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1506551472;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1515363609;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1516210145;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1516217097;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1519588127;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1522360217;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1530174524;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1532091916;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1532332488;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1532706365;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1537388389;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> @Nullable 	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes);1537391140;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethod} first, falling back to_{@code findDeclaredMethod}. This allows to find public methods_without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getMethod_@see #findDeclaredMethod;@Nullable_	public static Method findMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {_		try {_			return clazz.getMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			return findDeclaredMethod(clazz, methodName, paramTypes)__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,method,first,falling,back,to,code,find,declared,method,this,allows,to,find,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,method,see,find,declared,method;nullable,public,static,method,find,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,method,method,name,param,types,catch,no,such,method,exception,ex,return,find,declared,method,clazz,method,name,param,types
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1328020251;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks <code>Class.getDeclaredMethods</code>, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or <code>null</code> if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see java.lang.Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,code,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,java,lang,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1355352386;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks <code>Class.getDeclaredMethods</code>, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or <code>null</code> if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see java.lang.Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,code,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,java,lang,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1356735495;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1385412762;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1386791358;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1386802599;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1387221517;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1404080175;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1417981895;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1419270405;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1432125256;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1454934048;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1460629667;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1461047077;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1467846264;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1468948866;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1469561191;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1386802599;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1387221517;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1404080175;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1417981895;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1419270405;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1432125256;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1454934048;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1460629667;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1461047077;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1467846264;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1468948866;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1469561191;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1495868221;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1496259743;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1496837955;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1498780456;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1500540246;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1500549410;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1502716442;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1503272000;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1503411745;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1506080437;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1506287440;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1506551472;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1515363609;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1516210145;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1516217097;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1519588127;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1522360217;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1530174524;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1532091916;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1532332488;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1532706365;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1537388389;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException;1537391140;Copy the property values of the given source bean into the given target bean,_ignoring the given "ignoreProperties"._<p>Note: The source and target classes do not have to match or even be derived_from each other, as long as the properties match. Any bean properties that the_source bean exposes but the target bean does not will silently be ignored._<p>This is just a convenience method. For more complex transfer needs,_consider using a full BeanWrapper._@param source the source bean_@param target the target bean_@param ignoreProperties array of property names to ignore_@throws BeansException if the copying failed_@see BeanWrapper;public static void copyProperties(Object source, Object target, String... ignoreProperties) throws BeansException {_		copyProperties(source, target, null, ignoreProperties)__	};copy,the,property,values,of,the,given,source,bean,into,the,given,target,bean,ignoring,the,given,ignore,properties,p,note,the,source,and,target,classes,do,not,have,to,match,or,even,be,derived,from,each,other,as,long,as,the,properties,match,any,bean,properties,that,the,source,bean,exposes,but,the,target,bean,does,not,will,silently,be,ignored,p,this,is,just,a,convenience,method,for,more,complex,transfer,needs,consider,using,a,full,bean,wrapper,param,source,the,source,bean,param,target,the,target,bean,param,ignore,properties,array,of,property,names,to,ignore,throws,beans,exception,if,the,copying,failed,see,bean,wrapper;public,static,void,copy,properties,object,source,object,target,string,ignore,properties,throws,beans,exception,copy,properties,source,target,null,ignore,properties
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1495868221;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1496259743;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1496837955;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1498780456;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1500540246;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1500549410;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1502716442;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1503272000;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1503411745;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1506080437;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1506287440;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1506551472;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1515363609;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1516210145;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1516217097;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1519588127;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1522360217;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1530174524;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1532091916;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1532332488;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1532706365;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1537388389;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName) 			throws BeansException;1537391140;Retrieve the JavaBeans {@code PropertyDescriptors} for the given property._@param clazz the Class to retrieve the PropertyDescriptor for_@param propertyName the name of the property_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails;@Nullable_	public static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)_			throws BeansException {__		CachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz)__		return cr.getPropertyDescriptor(propertyName)__	};retrieve,the,java,beans,code,property,descriptors,for,the,given,property,param,clazz,the,class,to,retrieve,the,property,descriptor,for,param,property,name,the,name,of,the,property,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails;nullable,public,static,property,descriptor,get,property,descriptor,class,clazz,string,property,name,throws,beans,exception,cached,introspection,results,cr,cached,introspection,results,for,class,clazz,return,cr,get,property,descriptor,property,name
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1495868221;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1496259743;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1496837955;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1498780456;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1500540246;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1500549410;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1502716442;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1503272000;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1503411745;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1506080437;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1506287440;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1506551472;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1515363609;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1516210145;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1516217097;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1519588127;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1522360217;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1530174524;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1532091916;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1532332488;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1532706365;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1537388389;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> @Nullable 	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException;1537391140;Find a JavaBeans {@code PropertyDescriptor} for the given method,_with the method either being the read method or the write method for_that bean property._@param method the method to find a corresponding PropertyDescriptor for_@param clazz the (most specific) class to introspect for descriptors_@return the corresponding PropertyDescriptor, or {@code null} if none_@throws BeansException if PropertyDescriptor lookup fails_@since 3.2.13;@Nullable_	public static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {_		Assert.notNull(method, "Method must not be null")__		PropertyDescriptor[] pds = getPropertyDescriptors(clazz)__		for (PropertyDescriptor pd : pds) {_			if (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {_				return pd__			}_		}_		return null__	};find,a,java,beans,code,property,descriptor,for,the,given,method,with,the,method,either,being,the,read,method,or,the,write,method,for,that,bean,property,param,method,the,method,to,find,a,corresponding,property,descriptor,for,param,clazz,the,most,specific,class,to,introspect,for,descriptors,return,the,corresponding,property,descriptor,or,code,null,if,none,throws,beans,exception,if,property,descriptor,lookup,fails,since,3,2,13;nullable,public,static,property,descriptor,find,property,for,method,method,method,class,clazz,throws,beans,exception,assert,not,null,method,method,must,not,be,null,property,descriptor,pds,get,property,descriptors,clazz,for,property,descriptor,pd,pds,if,method,equals,pd,get,read,method,method,equals,pd,get,write,method,return,pd,return,null
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1328020251;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks <code>Class.getMethods</code> first, falling back to_<code>findDeclaredMethodWithMinimalParameters</code>. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or <code>null</code> if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see java.lang.Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,code,first,falling,back,to,code,find,declared,method,with,minimal,parameters,code,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,java,lang,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1355352386;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks <code>Class.getMethods</code> first, falling back to_<code>findDeclaredMethodWithMinimalParameters</code>. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or <code>null</code> if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see java.lang.Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,code,first,falling,back,to,code,find,declared,method,with,minimal,parameters,code,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,java,lang,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1356735495;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1385412762;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1386791358;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1386802599;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1387221517;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1404080175;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1417981895;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1419270405;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1432125256;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1454934048;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1460629667;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1461047077;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1467846264;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1468948866;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1469561191;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1495868221;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1496259743;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1496837955;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1498780456;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1500540246;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1500549410;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1502716442;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1503272000;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1503411745;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1506080437;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1506287440;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1506551472;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1515363609;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1516210145;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1516217097;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1519588127;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1522360217;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1530174524;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1532091916;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1532332488;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1532706365;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1537388389;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1537391140;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Prefers public methods,_but will return a protected, package access, or private method too._<p>Checks {@code Class.getMethods} first, falling back to_{@code findDeclaredMethodWithMinimalParameters}. This allows for finding public_methods without issues even in environments with restricted Java security settings._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getMethods_@see #findDeclaredMethodWithMinimalParameters;@Nullable_	public static Method findMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getMethods(), methodName)__		if (targetMethod == null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz, methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,prefers,public,methods,but,will,return,a,protected,package,access,or,private,method,too,p,checks,code,class,get,methods,first,falling,back,to,code,find,declared,method,with,minimal,parameters,this,allows,for,finding,public,methods,without,issues,even,in,environments,with,restricted,java,security,settings,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,methods,see,find,declared,method,with,minimal,parameters;nullable,public,static,method,find,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,methods,method,name,if,target,method,null,target,method,find,declared,method,with,minimal,parameters,clazz,method,name,return,target,method
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1468948866;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1469561191;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1495868221;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1496259743;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1496837955;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1498780456;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1500540246;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1500549410;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1502716442;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1503272000;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1503411745;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1506080437;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1506287440;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1506551472;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1515363609;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1516210145;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1516217097;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1519588127;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1522360217;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1530174524;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1532091916;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1532332488;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1532706365;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1537388389;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Deprecated 	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException;1537391140;Convenience method to instantiate a class using its no-arg constructor._@param clazz class to instantiate_@return the new instance_@throws BeanInstantiationException if the bean cannot be instantiated_@deprecated as of Spring 5.0, following the deprecation of_{@link Class#newInstance()} in JDK 9_@see Class#newInstance();@Deprecated_	public static <T> T instantiate(Class<T> clazz) throws BeanInstantiationException {_		Assert.notNull(clazz, "Class must not be null")__		if (clazz.isInterface()) {_			throw new BeanInstantiationException(clazz, "Specified class is an interface")__		}_		try {_			return clazz.newInstance()__		}_		catch (InstantiationException ex) {_			throw new BeanInstantiationException(clazz, "Is it an abstract class?", ex)__		}_		catch (IllegalAccessException ex) {_			throw new BeanInstantiationException(clazz, "Is the constructor accessible?", ex)__		}_	};convenience,method,to,instantiate,a,class,using,its,no,arg,constructor,param,clazz,class,to,instantiate,return,the,new,instance,throws,bean,instantiation,exception,if,the,bean,cannot,be,instantiated,deprecated,as,of,spring,5,0,following,the,deprecation,of,link,class,new,instance,in,jdk,9,see,class,new,instance;deprecated,public,static,t,t,instantiate,class,t,clazz,throws,bean,instantiation,exception,assert,not,null,clazz,class,must,not,be,null,if,clazz,is,interface,throw,new,bean,instantiation,exception,clazz,specified,class,is,an,interface,try,return,clazz,new,instance,catch,instantiation,exception,ex,throw,new,bean,instantiation,exception,clazz,is,it,an,abstract,class,ex,catch,illegal,access,exception,ex,throw,new,bean,instantiation,exception,clazz,is,the,constructor,accessible,ex
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1495868221;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1496259743;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1496837955;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1498780456;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1500540246;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1500549410;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1502716442;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1503272000;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1503411745;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1506080437;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1506287440;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1506551472;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1515363609;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1516210145;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1516217097;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1519588127;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1522360217;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1530174524;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1532091916;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1532332488;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1532706365;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1537388389;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName) 			throws IllegalArgumentException;1537391140;Find a method with the given method name and minimal parameters (best case: none),_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@return the Method object, or {@code null} if not found_@throws IllegalArgumentException if methods of the given name were found but_could not be resolved to a unique method with minimal parameters_@see Class#getDeclaredMethods;@Nullable_	public static Method findDeclaredMethodWithMinimalParameters(Class<?> clazz, String methodName)_			throws IllegalArgumentException {__		Method targetMethod = findMethodWithMinimalParameters(clazz.getDeclaredMethods(), methodName)__		if (targetMethod == null && clazz.getSuperclass() != null) {_			targetMethod = findDeclaredMethodWithMinimalParameters(clazz.getSuperclass(), methodName)__		}_		return targetMethod__	};find,a,method,with,the,given,method,name,and,minimal,parameters,best,case,none,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,methods,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,throws,illegal,argument,exception,if,methods,of,the,given,name,were,found,but,could,not,be,resolved,to,a,unique,method,with,minimal,parameters,see,class,get,declared,methods;nullable,public,static,method,find,declared,method,with,minimal,parameters,class,clazz,string,method,name,throws,illegal,argument,exception,method,target,method,find,method,with,minimal,parameters,clazz,get,declared,methods,method,name,if,target,method,null,clazz,get,superclass,null,target,method,find,declared,method,with,minimal,parameters,clazz,get,superclass,method,name,return,target,method
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1495868221;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1496259743;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1496837955;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1498780456;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1500540246;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1500549410;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1502716442;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1503272000;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1503411745;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1506080437;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1506287440;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1506551472;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1515363609;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1516210145;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1516217097;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1519588127;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf('(')__		int lastParen = signature.indexOf(')')__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1522360217;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int startParen = signature.indexOf('(')__		int endParen = signature.indexOf(')')__		if (startParen > -1 && endParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (startParen == -1 && endParen > -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (startParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, startParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,start,paren,signature,index,of,int,end,paren,signature,index,of,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,start,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,start,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,start,paren,1,end,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1530174524;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int startParen = signature.indexOf('(')__		int endParen = signature.indexOf(')')__		if (startParen > -1 && endParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (startParen == -1 && endParen > -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (startParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, startParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,start,paren,signature,index,of,int,end,paren,signature,index,of,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,start,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,start,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,start,paren,1,end,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1532091916;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int startParen = signature.indexOf('(')__		int endParen = signature.indexOf(')')__		if (startParen > -1 && endParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (startParen == -1 && endParen > -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (startParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, startParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,start,paren,signature,index,of,int,end,paren,signature,index,of,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,start,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,start,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,start,paren,1,end,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1532332488;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int startParen = signature.indexOf('(')__		int endParen = signature.indexOf(')')__		if (startParen > -1 && endParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (startParen == -1 && endParen > -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (startParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, startParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,start,paren,signature,index,of,int,end,paren,signature,index,of,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,start,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,start,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,start,paren,1,end,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1532706365;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int startParen = signature.indexOf('(')__		int endParen = signature.indexOf(')')__		if (startParen > -1 && endParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (startParen == -1 && endParen > -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (startParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, startParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,start,paren,signature,index,of,int,end,paren,signature,index,of,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,start,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,start,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,start,paren,1,end,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1537388389;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int startParen = signature.indexOf('(')__		int endParen = signature.indexOf(')')__		if (startParen > -1 && endParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (startParen == -1 && endParen > -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (startParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, startParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,start,paren,signature,index,of,int,end,paren,signature,index,of,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,start,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,start,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,start,paren,1,end,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> @Nullable 	public static Method resolveSignature(String signature, Class<?> clazz);1537391140;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;@Nullable_	public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int startParen = signature.indexOf('(')__		int endParen = signature.indexOf(')')__		if (startParen > -1 && endParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (startParen == -1 && endParen > -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (startParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, startParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;nullable,public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,start,paren,signature,index,of,int,end,paren,signature,index,of,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,start,paren,1,end,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,start,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,start,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,start,paren,1,end,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>[] paramTypes);1328020251;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks <code>Class.getDeclaredMethod</code>, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or <code>null</code> if not found_@see java.lang.Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>[] paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,code,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,see,java,lang,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>[] paramTypes);1355352386;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks <code>Class.getDeclaredMethod</code>, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or <code>null</code> if not found_@see java.lang.Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>[] paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,code,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,code,if,not,found,see,java,lang,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>[] paramTypes);1356735495;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>[] paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>[] paramTypes);1385412762;Find a method with the given method name and the given parameter types,_declared on the given class or one of its superclasses. Will return a public,_protected, package access, or private method._<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses._@param clazz the class to check_@param methodName the name of the method to find_@param paramTypes the parameter types of the method to find_@return the Method object, or {@code null} if not found_@see Class#getDeclaredMethod;public static Method findDeclaredMethod(Class<?> clazz, String methodName, Class<?>[] paramTypes) {_		try {_			return clazz.getDeclaredMethod(methodName, paramTypes)__		}_		catch (NoSuchMethodException ex) {_			if (clazz.getSuperclass() != null) {_				return findDeclaredMethod(clazz.getSuperclass(), methodName, paramTypes)__			}_			return null__		}_	};find,a,method,with,the,given,method,name,and,the,given,parameter,types,declared,on,the,given,class,or,one,of,its,superclasses,will,return,a,public,protected,package,access,or,private,method,p,checks,code,class,get,declared,method,cascading,upwards,to,all,superclasses,param,clazz,the,class,to,check,param,method,name,the,name,of,the,method,to,find,param,param,types,the,parameter,types,of,the,method,to,find,return,the,method,object,or,code,null,if,not,found,see,class,get,declared,method;public,static,method,find,declared,method,class,clazz,string,method,name,class,param,types,try,return,clazz,get,declared,method,method,name,param,types,catch,no,such,method,exception,ex,if,clazz,get,superclass,null,return,find,declared,method,clazz,get,superclass,method,name,param,types,return,null
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1328020251;Parse a method signature in the form <code>methodName[([arg_list])]</code>,_where <code>arg_list</code> is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied <code>Class</code>._<p>When not supplying an argument list (<code>methodName</code>) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that <code>methodName</code> and <code>methodName()</code> are <strong>not</strong>_resolved in the same way. The signature <code>methodName</code> means the method called_<code>methodName</code> with the least number of arguments, whereas <code>methodName()</code>_means the method called <code>methodName</code> with exactly 0 arguments._<p>If no method can be found, then <code>null</code> is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")___		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")___		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,code,where,code,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,code,p,when,not,supplying,an,argument,list,code,method,name,code,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,code,and,code,method,name,code,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,code,means,the,method,called,code,method,name,code,with,the,least,number,of,arguments,whereas,code,method,name,code,means,the,method,called,code,method,name,code,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,code,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1355352386;Parse a method signature in the form <code>methodName[([arg_list])]</code>,_where <code>arg_list</code> is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied <code>Class</code>._<p>When not supplying an argument list (<code>methodName</code>) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that <code>methodName</code> and <code>methodName()</code> are <strong>not</strong>_resolved in the same way. The signature <code>methodName</code> means the method called_<code>methodName</code> with the least number of arguments, whereas <code>methodName()</code>_means the method called <code>methodName</code> with exactly 0 arguments._<p>If no method can be found, then <code>null</code> is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")___		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")___		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,code,where,code,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,code,p,when,not,supplying,an,argument,list,code,method,name,code,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,code,and,code,method,name,code,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,code,means,the,method,called,code,method,name,code,with,the,least,number,of,arguments,whereas,code,method,name,code,means,the,method,called,code,method,name,code,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,code,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1356735495;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")___		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")___		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1385412762;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")___		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")___		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1386791358;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")___		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")___		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1386802599;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1387221517;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1404080175;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1417981895;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1419270405;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1432125256;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1454934048;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1460629667;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1461047077;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1467846264;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1468948866;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
BeanUtils -> public static Method resolveSignature(String signature, Class<?> clazz);1469561191;Parse a method signature in the form {@code methodName[([arg_list])]},_where {@code arg_list} is an optional, comma-separated list of fully-qualified_type names, and attempts to resolve that signature against the supplied {@code Class}._<p>When not supplying an argument list ({@code methodName}) the method whose name_matches and has the least number of parameters will be returned. When supplying an_argument type list, only the method whose name and argument types match will be returned._<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>_resolved in the same way. The signature {@code methodName} means the method called_{@code methodName} with the least number of arguments, whereas {@code methodName()}_means the method called {@code methodName} with exactly 0 arguments._<p>If no method can be found, then {@code null} is returned._@param signature the method signature as String representation_@param clazz the class to resolve the method signature against_@return the resolved Method_@see #findMethod_@see #findMethodWithMinimalParameters;public static Method resolveSignature(String signature, Class<?> clazz) {_		Assert.hasText(signature, "'signature' must not be empty")__		Assert.notNull(clazz, "Class must not be null")__		int firstParen = signature.indexOf("(")__		int lastParen = signature.indexOf(")")__		if (firstParen > -1 && lastParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected closing ')' for args list")__		}_		else if (lastParen > -1 && firstParen == -1) {_			throw new IllegalArgumentException("Invalid method signature '" + signature +_					"': expected opening '(' for args list")__		}_		else if (firstParen == -1 && lastParen == -1) {_			return findMethodWithMinimalParameters(clazz, signature)__		}_		else {_			String methodName = signature.substring(0, firstParen)__			String[] parameterTypeNames =_					StringUtils.commaDelimitedListToStringArray(signature.substring(firstParen + 1, lastParen))__			Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length]__			for (int i = 0_ i < parameterTypeNames.length_ i++) {_				String parameterTypeName = parameterTypeNames[i].trim()__				try {_					parameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader())__				}_				catch (Throwable ex) {_					throw new IllegalArgumentException("Invalid method signature: unable to resolve type [" +_							parameterTypeName + "] for argument " + i + ". Root cause: " + ex)__				}_			}_			return findMethod(clazz, methodName, parameterTypes)__		}_	};parse,a,method,signature,in,the,form,code,method,name,where,code,is,an,optional,comma,separated,list,of,fully,qualified,type,names,and,attempts,to,resolve,that,signature,against,the,supplied,code,class,p,when,not,supplying,an,argument,list,code,method,name,the,method,whose,name,matches,and,has,the,least,number,of,parameters,will,be,returned,when,supplying,an,argument,type,list,only,the,method,whose,name,and,argument,types,match,will,be,returned,p,note,then,that,code,method,name,and,code,method,name,are,strong,not,strong,resolved,in,the,same,way,the,signature,code,method,name,means,the,method,called,code,method,name,with,the,least,number,of,arguments,whereas,code,method,name,means,the,method,called,code,method,name,with,exactly,0,arguments,p,if,no,method,can,be,found,then,code,null,is,returned,param,signature,the,method,signature,as,string,representation,param,clazz,the,class,to,resolve,the,method,signature,against,return,the,resolved,method,see,find,method,see,find,method,with,minimal,parameters;public,static,method,resolve,signature,string,signature,class,clazz,assert,has,text,signature,signature,must,not,be,empty,assert,not,null,clazz,class,must,not,be,null,int,first,paren,signature,index,of,int,last,paren,signature,index,of,if,first,paren,1,last,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,closing,for,args,list,else,if,last,paren,1,first,paren,1,throw,new,illegal,argument,exception,invalid,method,signature,signature,expected,opening,for,args,list,else,if,first,paren,1,last,paren,1,return,find,method,with,minimal,parameters,clazz,signature,else,string,method,name,signature,substring,0,first,paren,string,parameter,type,names,string,utils,comma,delimited,list,to,string,array,signature,substring,first,paren,1,last,paren,class,parameter,types,new,class,parameter,type,names,length,for,int,i,0,i,parameter,type,names,length,i,string,parameter,type,name,parameter,type,names,i,trim,try,parameter,types,i,class,utils,for,name,parameter,type,name,clazz,get,class,loader,catch,throwable,ex,throw,new,illegal,argument,exception,invalid,method,signature,unable,to,resolve,type,parameter,type,name,for,argument,i,root,cause,ex,return,find,method,clazz,method,name,parameter,types
