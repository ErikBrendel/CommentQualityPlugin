# id;timestamp;commentText;codeText;commentWords;codeWords
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier);1338031377;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws IllegalStateException if no matching bean of type {@code T} found_@since 3.2;public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {_		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new IllegalStateException("No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,illegal,state,exception,if,no,matching,bean,of,type,code,t,found,since,3,2;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,illegal,state,exception,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier);1340831268;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws IllegalStateException if no matching bean of type {@code T} found;public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {_		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new IllegalStateException("No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,illegal,state,exception,if,no,matching,bean,of,type,code,t,found;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,illegal,state,exception,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier);1343493442;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws IllegalStateException if no matching bean of type {@code T} found;public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {_		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new IllegalStateException("No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,illegal,state,exception,if,no,matching,bean,of,type,code,t,found;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,illegal,state,exception,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier);1347283603;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param beanFactory the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {_		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bean,factory,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier);1404224980;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param beanFactory the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {_		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bean,factory,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier);1404239431;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param beanFactory the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {_		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bean,factory,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier);1413905053;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param beanFactory the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {_		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bean,factory,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier);1448910783;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param beanFactory the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {_		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bean,factory,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier);1451341688;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param beanFactory the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) {_		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bean,factory,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1338031377;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier_@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws IllegalStateException if no matching bean of type {@code T} found;private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		Map<String, T> candidateBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(bf, beanType)__		T matchingBean = null__		for (String beanName : candidateBeans.keySet()) {_			if (isQualifierMatch(qualifier, beanName, bf)) {_				if (matchingBean != null) {_					throw new IllegalStateException("No unique " + beanType.getSimpleName() +_							" bean found for qualifier '" + qualifier + "'")__				}_				matchingBean = candidateBeans.get(beanName)__			}_		}_		if (matchingBean != null) {_			return matchingBean__		}_		else {_			throw new IllegalStateException("No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier " +_					"match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,illegal,state,exception,if,no,matching,bean,of,type,code,t,found;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,map,string,t,candidate,beans,bean,factory,utils,beans,of,type,including,ancestors,bf,bean,type,t,matching,bean,null,for,string,bean,name,candidate,beans,key,set,if,is,qualifier,match,qualifier,bean,name,bf,if,matching,bean,null,throw,new,illegal,state,exception,no,unique,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,matching,bean,candidate,beans,get,bean,name,if,matching,bean,null,return,matching,bean,else,throw,new,illegal,state,exception,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1340831268;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier_@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws IllegalStateException if no matching bean of type {@code T} found;private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		Map<String, T> candidateBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(bf, beanType)__		T matchingBean = null__		for (String beanName : candidateBeans.keySet()) {_			if (isQualifierMatch(qualifier, beanName, bf)) {_				if (matchingBean != null) {_					throw new IllegalStateException("No unique " + beanType.getSimpleName() +_							" bean found for qualifier '" + qualifier + "'")__				}_				matchingBean = candidateBeans.get(beanName)__			}_		}_		if (matchingBean != null) {_			return matchingBean__		}_		else {_			throw new IllegalStateException("No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier " +_					"match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,illegal,state,exception,if,no,matching,bean,of,type,code,t,found;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,map,string,t,candidate,beans,bean,factory,utils,beans,of,type,including,ancestors,bf,bean,type,t,matching,bean,null,for,string,bean,name,candidate,beans,key,set,if,is,qualifier,match,qualifier,bean,name,bf,if,matching,bean,null,throw,new,illegal,state,exception,no,unique,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,matching,bean,candidate,beans,get,bean,name,if,matching,bean,null,return,matching,bean,else,throw,new,illegal,state,exception,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1343493442;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier_@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws IllegalStateException if no matching bean of type {@code T} found;private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		Map<String, T> candidateBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(bf, beanType)__		T matchingBean = null__		for (String beanName : candidateBeans.keySet()) {_			if (isQualifierMatch(qualifier, beanName, bf)) {_				if (matchingBean != null) {_					throw new IllegalStateException("No unique " + beanType.getSimpleName() +_							" bean found for qualifier '" + qualifier + "'")__				}_				matchingBean = candidateBeans.get(beanName)__			}_		}_		if (matchingBean != null) {_			return matchingBean__		}_		else {_			throw new IllegalStateException("No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier " +_					"nor bean name matches!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,illegal,state,exception,if,no,matching,bean,of,type,code,t,found;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,map,string,t,candidate,beans,bean,factory,utils,beans,of,type,including,ancestors,bf,bean,type,t,matching,bean,null,for,string,bean,name,candidate,beans,key,set,if,is,qualifier,match,qualifier,bean,name,bf,if,matching,bean,null,throw,new,illegal,state,exception,no,unique,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,matching,bean,candidate,beans,get,bean,name,if,matching,bean,null,return,matching,bean,else,throw,new,illegal,state,exception,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,nor,bean,name,matches
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1347283603;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier_(e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given qualifier)._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		Map<String, T> candidateBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(bf, beanType)__		T matchingBean = null__		for (String beanName : candidateBeans.keySet()) {_			if (isQualifierMatch(qualifier, beanName, bf)) {_				if (matchingBean != null) {_					throw new NoSuchBeanDefinitionException(qualifier, "No unique " + beanType.getSimpleName() +_							" bean found for qualifier '" + qualifier + "'")__				}_				matchingBean = candidateBeans.get(beanName)__			}_		}_		if (matchingBean != null) {_			return matchingBean__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier " + "match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,map,string,t,candidate,beans,bean,factory,utils,beans,of,type,including,ancestors,bf,bean,type,t,matching,bean,null,for,string,bean,name,candidate,beans,key,set,if,is,qualifier,match,qualifier,bean,name,bf,if,matching,bean,null,throw,new,no,such,bean,definition,exception,qualifier,no,unique,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,matching,bean,candidate,beans,get,bean,name,if,matching,bean,null,return,matching,bean,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1404224980;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier_(e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given qualifier)._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		Map<String, T> candidateBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(bf, beanType)__		T matchingBean = null__		for (String beanName : candidateBeans.keySet()) {_			if (isQualifierMatch(qualifier, beanName, bf)) {_				if (matchingBean != null) {_					throw new NoSuchBeanDefinitionException(qualifier, "No unique " + beanType.getSimpleName() +_							" bean found for qualifier '" + qualifier + "'")__				}_				matchingBean = candidateBeans.get(beanName)__			}_		}_		if (matchingBean != null) {_			return matchingBean__		}_		else if (bf.containsBean(qualifier)) {_			_			return bf.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier " + "match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,map,string,t,candidate,beans,bean,factory,utils,beans,of,type,including,ancestors,bf,bean,type,t,matching,bean,null,for,string,bean,name,candidate,beans,key,set,if,is,qualifier,match,qualifier,bean,name,bf,if,matching,bean,null,throw,new,no,such,bean,definition,exception,qualifier,no,unique,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,matching,bean,candidate,beans,get,bean,name,if,matching,bean,null,return,matching,bean,else,if,bf,contains,bean,qualifier,return,bf,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1404239431;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier_(e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given qualifier)._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		Map<String, T> candidateBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(bf, beanType)__		T matchingBean = null__		for (String beanName : candidateBeans.keySet()) {_			if (isQualifierMatch(qualifier, beanName, bf)) {_				if (matchingBean != null) {_					throw new NoSuchBeanDefinitionException(qualifier, "No unique " + beanType.getSimpleName() +_							" bean found for qualifier '" + qualifier + "'")__				}_				matchingBean = candidateBeans.get(beanName)__			}_		}_		if (matchingBean != null) {_			return matchingBean__		}_		else if (bf.containsBean(qualifier)) {_			_			return bf.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,map,string,t,candidate,beans,bean,factory,utils,beans,of,type,including,ancestors,bf,bean,type,t,matching,bean,null,for,string,bean,name,candidate,beans,key,set,if,is,qualifier,match,qualifier,bean,name,bf,if,matching,bean,null,throw,new,no,such,bean,definition,exception,qualifier,no,unique,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,matching,bean,candidate,beans,get,bean,name,if,matching,bean,null,return,matching,bean,else,if,bf,contains,bean,qualifier,return,bf,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1413905053;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier_(e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given qualifier)._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		Map<String, T> candidateBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(bf, beanType)__		T matchingBean = null__		for (Map.Entry<String, T> entry : candidateBeans.entrySet()) {_			String beanName = entry.getKey()__			if (isQualifierMatch(qualifier, beanName, bf)) {_				if (matchingBean != null) {_					throw new NoSuchBeanDefinitionException(qualifier, "No unique " + beanType.getSimpleName() +_							" bean found for qualifier '" + qualifier + "'")__				}_				matchingBean = entry.getValue()__			}_		}_		if (matchingBean != null) {_			return matchingBean__		}_		else if (bf.containsBean(qualifier)) {_			_			return bf.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,map,string,t,candidate,beans,bean,factory,utils,beans,of,type,including,ancestors,bf,bean,type,t,matching,bean,null,for,map,entry,string,t,entry,candidate,beans,entry,set,string,bean,name,entry,get,key,if,is,qualifier,match,qualifier,bean,name,bf,if,matching,bean,null,throw,new,no,such,bean,definition,exception,qualifier,no,unique,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,matching,bean,entry,get,value,if,matching,bean,null,return,matching,bean,else,if,bf,contains,bean,qualifier,return,bf,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1448910783;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier_(e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given qualifier)._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		String[] candidateBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(bf, beanType)__		String matchingBean = null__		for (String beanName : candidateBeans) {_			if (isQualifierMatch(qualifier, beanName, bf)) {_				if (matchingBean != null) {_					throw new NoSuchBeanDefinitionException(qualifier, "No unique " + beanType.getSimpleName() +_							" bean found for qualifier '" + qualifier + "'")__				}_				matchingBean = beanName__			}_		}_		if (matchingBean != null) {_			return bf.getBean(matchingBean, beanType)__		}_		else if (bf.containsBean(qualifier)) {_			_			return bf.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,string,candidate,beans,bean,factory,utils,bean,names,for,type,including,ancestors,bf,bean,type,string,matching,bean,null,for,string,bean,name,candidate,beans,if,is,qualifier,match,qualifier,bean,name,bf,if,matching,bean,null,throw,new,no,such,bean,definition,exception,qualifier,no,unique,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,matching,bean,bean,name,if,matching,bean,null,return,bf,get,bean,matching,bean,bean,type,else,if,bf,contains,bean,qualifier,return,bf,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1451341688;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier_(e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given qualifier)._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found;private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		String[] candidateBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(bf, beanType)__		String matchingBean = null__		for (String beanName : candidateBeans) {_			if (isQualifierMatch(qualifier, beanName, bf)) {_				if (matchingBean != null) {_					throw new NoSuchBeanDefinitionException(qualifier, "No unique " + beanType.getSimpleName() +_							" bean found for qualifier '" + qualifier + "'")__				}_				matchingBean = beanName__			}_		}_		if (matchingBean != null) {_			return bf.getBean(matchingBean, beanType)__		}_		else if (bf.containsBean(qualifier)) {_			_			return bf.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,string,candidate,beans,bean,factory,utils,bean,names,for,type,including,ancestors,bf,bean,type,string,matching,bean,null,for,string,bean,name,candidate,beans,if,is,qualifier,match,qualifier,bean,name,bf,if,matching,bean,null,throw,new,no,such,bean,definition,exception,qualifier,no,unique,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,matching,bean,bean,name,if,matching,bean,null,return,bf,get,bean,matching,bean,bean,type,else,if,bf,contains,bean,qualifier,return,bf,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1471387421;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier_(e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given qualifier)._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null});private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		String[] candidateBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(bf, beanType)__		String matchingBean = null__		for (String beanName : candidateBeans) {_			if (isQualifierMatch(qualifier::equals, beanName, bf)) {_				if (matchingBean != null) {_					throw new NoUniqueBeanDefinitionException(beanType, matchingBean, beanName)__				}_				matchingBean = beanName__			}_		}_		if (matchingBean != null) {_			return bf.getBean(matchingBean, beanType)__		}_		else if (bf.containsBean(qualifier)) {_			_			return bf.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,string,candidate,beans,bean,factory,utils,bean,names,for,type,including,ancestors,bf,bean,type,string,matching,bean,null,for,string,bean,name,candidate,beans,if,is,qualifier,match,qualifier,equals,bean,name,bf,if,matching,bean,null,throw,new,no,unique,bean,definition,exception,bean,type,matching,bean,bean,name,matching,bean,bean,name,if,matching,bean,null,return,bf,get,bean,matching,bean,bean,type,else,if,bf,contains,bean,qualifier,return,bf,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier);1496837955;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier_(e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given qualifier)._@param bf the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null});private static <T> T qualifiedBeanOfType(ConfigurableListableBeanFactory bf, Class<T> beanType, String qualifier) {_		String[] candidateBeans = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(bf, beanType)__		String matchingBean = null__		for (String beanName : candidateBeans) {_			if (isQualifierMatch(qualifier::equals, beanName, bf)) {_				if (matchingBean != null) {_					throw new NoUniqueBeanDefinitionException(beanType, matchingBean, beanName)__				}_				matchingBean = beanName__			}_		}_		if (matchingBean != null) {_			return bf.getBean(matchingBean, beanType)__		}_		else if (bf.containsBean(qualifier)) {_			_			return bf.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for qualifier '" + qualifier + "' - neither qualifier match nor bean name match!")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,code,qualifier,or,code,qualifier,matching,the,given,qualifier,param,bf,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null;private,static,t,t,qualified,bean,of,type,configurable,listable,bean,factory,bf,class,t,bean,type,string,qualifier,string,candidate,beans,bean,factory,utils,bean,names,for,type,including,ancestors,bf,bean,type,string,matching,bean,null,for,string,bean,name,candidate,beans,if,is,qualifier,match,qualifier,equals,bean,name,bf,if,matching,bean,null,throw,new,no,unique,bean,definition,exception,bean,type,matching,bean,bean,name,matching,bean,bean,name,if,matching,bean,null,return,bf,get,bean,matching,bean,bean,type,else,if,bf,contains,bean,qualifier,return,bf,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,qualifier,qualifier,neither,qualifier,match,nor,bean,name,match
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) 			throws BeansException;1471387421;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param beanFactory the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoUniqueBeanDefinitionException if multiple matching beans of type {@code T} found_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found_@throws BeansException if the bean could not be created_@see BeanFactory#getBean(Class);public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier)_			throws BeansException {__		Assert.notNull(beanFactory, "BeanFactory must not be null")___		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bean,factory,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,unique,bean,definition,exception,if,multiple,matching,beans,of,type,code,t,found,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found,throws,beans,exception,if,the,bean,could,not,be,created,see,bean,factory,get,bean,class;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,throws,beans,exception,assert,not,null,bean,factory,bean,factory,must,not,be,null,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) 			throws BeansException;1496837955;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param beanFactory the BeanFactory to get the target bean from_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoUniqueBeanDefinitionException if multiple matching beans of type {@code T} found_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found_@throws BeansException if the bean could not be created_@see BeanFactory#getBean(Class);public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier)_			throws BeansException {__		Assert.notNull(beanFactory, "BeanFactory must not be null")___		if (beanFactory instanceof ConfigurableListableBeanFactory) {_			_			return qualifiedBeanOfType((ConfigurableListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bean,factory,the,bean,factory,to,get,the,target,bean,from,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,unique,bean,definition,exception,if,multiple,matching,beans,of,type,code,t,found,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found,throws,beans,exception,if,the,bean,could,not,be,created,see,bean,factory,get,bean,class;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,throws,beans,exception,assert,not,null,bean,factory,bean,factory,must,not,be,null,if,bean,factory,instanceof,configurable,listable,bean,factory,return,qualified,bean,of,type,configurable,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier) 			throws BeansException;1539119667;Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a_qualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the given_qualifier, or having a bean name matching the given qualifier._@param beanFactory the factory to get the target bean from (also searching ancestors)_@param beanType the type of bean to retrieve_@param qualifier the qualifier for selecting between multiple bean matches_@return the matching bean of type {@code T} (never {@code null})_@throws NoUniqueBeanDefinitionException if multiple matching beans of type {@code T} found_@throws NoSuchBeanDefinitionException if no matching bean of type {@code T} found_@throws BeansException if the bean could not be created_@see BeanFactoryUtils#beanOfTypeIncludingAncestors(ListableBeanFactory, Class);public static <T> T qualifiedBeanOfType(BeanFactory beanFactory, Class<T> beanType, String qualifier)_			throws BeansException {__		Assert.notNull(beanFactory, "BeanFactory must not be null")___		if (beanFactory instanceof ListableBeanFactory) {_			_			return qualifiedBeanOfType((ListableBeanFactory) beanFactory, beanType, qualifier)__		}_		else if (beanFactory.containsBean(qualifier)) {_			_			return beanFactory.getBean(qualifier, beanType)__		}_		else {_			throw new NoSuchBeanDefinitionException(qualifier, "No matching " + beanType.getSimpleName() +_					" bean found for bean name '" + qualifier +_					"'! (Note: Qualifier matching not supported because given " +_					"BeanFactory does not implement ConfigurableListableBeanFactory.)")__		}_	};obtain,a,bean,of,type,code,t,from,the,given,code,bean,factory,declaring,a,qualifier,e,g,via,code,qualifier,or,code,qualifier,matching,the,given,qualifier,or,having,a,bean,name,matching,the,given,qualifier,param,bean,factory,the,factory,to,get,the,target,bean,from,also,searching,ancestors,param,bean,type,the,type,of,bean,to,retrieve,param,qualifier,the,qualifier,for,selecting,between,multiple,bean,matches,return,the,matching,bean,of,type,code,t,never,code,null,throws,no,unique,bean,definition,exception,if,multiple,matching,beans,of,type,code,t,found,throws,no,such,bean,definition,exception,if,no,matching,bean,of,type,code,t,found,throws,beans,exception,if,the,bean,could,not,be,created,see,bean,factory,utils,bean,of,type,including,ancestors,listable,bean,factory,class;public,static,t,t,qualified,bean,of,type,bean,factory,bean,factory,class,t,bean,type,string,qualifier,throws,beans,exception,assert,not,null,bean,factory,bean,factory,must,not,be,null,if,bean,factory,instanceof,listable,bean,factory,return,qualified,bean,of,type,listable,bean,factory,bean,factory,bean,type,qualifier,else,if,bean,factory,contains,bean,qualifier,return,bean,factory,get,bean,qualifier,bean,type,else,throw,new,no,such,bean,definition,exception,qualifier,no,matching,bean,type,get,simple,name,bean,found,for,bean,name,qualifier,note,qualifier,matching,not,supported,because,given,bean,factory,does,not,implement,configurable,listable,bean,factory
BeanFactoryAnnotationUtils -> private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf);1338031377;Check whether the named bean declares a qualifier of the given name._@param qualifier the qualifier to match_@param beanName the name of the candidate bean_@param bf the {@code BeanFactory} from which to retrieve the named bean_@return {@code true} if either the bean definition (in the XML case)_or the bean's factory method (in the {@code @Bean} case) defines a matching_qualifier value (through {@code <qualifier>} or {@code @Qualifier});private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {_		if (bf.containsBean(beanName)) {_			try {_				BeanDefinition bd = bf.getMergedBeanDefinition(beanName)__				if (bd instanceof AbstractBeanDefinition) {_					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd__					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName())__					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||_							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {_						return true__					}_				}_				if (bd instanceof RootBeanDefinition) {_					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod()__					if (factoryMethod != null) {_						Qualifier targetAnnotation = factoryMethod.getAnnotation(Qualifier.class)__						if (targetAnnotation != null && qualifier.equals(targetAnnotation.value())) {_							return true__						}_					}_				}_			}_			catch (NoSuchBeanDefinitionException ex) {_				_			}_		}_		return false__	};check,whether,the,named,bean,declares,a,qualifier,of,the,given,name,param,qualifier,the,qualifier,to,match,param,bean,name,the,name,of,the,candidate,bean,param,bf,the,code,bean,factory,from,which,to,retrieve,the,named,bean,return,code,true,if,either,the,bean,definition,in,the,xml,case,or,the,bean,s,factory,method,in,the,code,bean,case,defines,a,matching,qualifier,value,through,code,qualifier,or,code,qualifier;private,static,boolean,is,qualifier,match,string,qualifier,string,bean,name,configurable,listable,bean,factory,bf,if,bf,contains,bean,bean,name,try,bean,definition,bd,bf,get,merged,bean,definition,bean,name,if,bd,instanceof,abstract,bean,definition,abstract,bean,definition,abd,abstract,bean,definition,bd,autowire,candidate,qualifier,candidate,abd,get,qualifier,qualifier,class,get,name,if,candidate,null,qualifier,equals,candidate,get,attribute,autowire,candidate,qualifier,qualifier,equals,bean,name,object,utils,contains,element,bf,get,aliases,bean,name,qualifier,return,true,if,bd,instanceof,root,bean,definition,method,factory,method,root,bean,definition,bd,get,resolved,factory,method,if,factory,method,null,qualifier,target,annotation,factory,method,get,annotation,qualifier,class,if,target,annotation,null,qualifier,equals,target,annotation,value,return,true,catch,no,such,bean,definition,exception,ex,return,false
BeanFactoryAnnotationUtils -> private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf);1340831268;Check whether the named bean declares a qualifier of the given name._@param qualifier the qualifier to match_@param beanName the name of the candidate bean_@param bf the {@code BeanFactory} from which to retrieve the named bean_@return {@code true} if either the bean definition (in the XML case)_or the bean's factory method (in the {@code @Bean} case) defines a matching_qualifier value (through {@code <qualifier>} or {@code @Qualifier});private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {_		if (bf.containsBean(beanName)) {_			try {_				BeanDefinition bd = bf.getMergedBeanDefinition(beanName)__				if (bd instanceof AbstractBeanDefinition) {_					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd__					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName())__					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||_							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {_						return true__					}_				}_				if (bd instanceof RootBeanDefinition) {_					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod()__					if (factoryMethod != null) {_						Qualifier targetAnnotation = factoryMethod.getAnnotation(Qualifier.class)__						if (targetAnnotation != null && qualifier.equals(targetAnnotation.value())) {_							return true__						}_					}_				}_			}_			catch (NoSuchBeanDefinitionException ex) {_				_			}_		}_		return false__	};check,whether,the,named,bean,declares,a,qualifier,of,the,given,name,param,qualifier,the,qualifier,to,match,param,bean,name,the,name,of,the,candidate,bean,param,bf,the,code,bean,factory,from,which,to,retrieve,the,named,bean,return,code,true,if,either,the,bean,definition,in,the,xml,case,or,the,bean,s,factory,method,in,the,code,bean,case,defines,a,matching,qualifier,value,through,code,qualifier,or,code,qualifier;private,static,boolean,is,qualifier,match,string,qualifier,string,bean,name,configurable,listable,bean,factory,bf,if,bf,contains,bean,bean,name,try,bean,definition,bd,bf,get,merged,bean,definition,bean,name,if,bd,instanceof,abstract,bean,definition,abstract,bean,definition,abd,abstract,bean,definition,bd,autowire,candidate,qualifier,candidate,abd,get,qualifier,qualifier,class,get,name,if,candidate,null,qualifier,equals,candidate,get,attribute,autowire,candidate,qualifier,qualifier,equals,bean,name,object,utils,contains,element,bf,get,aliases,bean,name,qualifier,return,true,if,bd,instanceof,root,bean,definition,method,factory,method,root,bean,definition,bd,get,resolved,factory,method,if,factory,method,null,qualifier,target,annotation,factory,method,get,annotation,qualifier,class,if,target,annotation,null,qualifier,equals,target,annotation,value,return,true,catch,no,such,bean,definition,exception,ex,return,false
BeanFactoryAnnotationUtils -> private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf);1343493442;Check whether the named bean declares a qualifier of the given name._@param qualifier the qualifier to match_@param beanName the name of the candidate bean_@param bf the {@code BeanFactory} from which to retrieve the named bean_@return {@code true} if either the bean definition (in the XML case)_or the bean's factory method (in the {@code @Bean} case) defines a matching_qualifier value (through {@code <qualifier>} or {@code @Qualifier});private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {_		if (bf.containsBean(beanName)) {_			try {_				BeanDefinition bd = bf.getMergedBeanDefinition(beanName)__				if (bd instanceof AbstractBeanDefinition) {_					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd__					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName())__					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||_							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {_						return true__					}_				}_				if (bd instanceof RootBeanDefinition) {_					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod()__					if (factoryMethod != null) {_						Qualifier targetAnnotation = factoryMethod.getAnnotation(Qualifier.class)__						if (targetAnnotation != null && qualifier.equals(targetAnnotation.value())) {_							return true__						}_					}_				}_			}_			catch (NoSuchBeanDefinitionException ex) {_				_			}_		}_		return false__	};check,whether,the,named,bean,declares,a,qualifier,of,the,given,name,param,qualifier,the,qualifier,to,match,param,bean,name,the,name,of,the,candidate,bean,param,bf,the,code,bean,factory,from,which,to,retrieve,the,named,bean,return,code,true,if,either,the,bean,definition,in,the,xml,case,or,the,bean,s,factory,method,in,the,code,bean,case,defines,a,matching,qualifier,value,through,code,qualifier,or,code,qualifier;private,static,boolean,is,qualifier,match,string,qualifier,string,bean,name,configurable,listable,bean,factory,bf,if,bf,contains,bean,bean,name,try,bean,definition,bd,bf,get,merged,bean,definition,bean,name,if,bd,instanceof,abstract,bean,definition,abstract,bean,definition,abd,abstract,bean,definition,bd,autowire,candidate,qualifier,candidate,abd,get,qualifier,qualifier,class,get,name,if,candidate,null,qualifier,equals,candidate,get,attribute,autowire,candidate,qualifier,qualifier,equals,bean,name,object,utils,contains,element,bf,get,aliases,bean,name,qualifier,return,true,if,bd,instanceof,root,bean,definition,method,factory,method,root,bean,definition,bd,get,resolved,factory,method,if,factory,method,null,qualifier,target,annotation,factory,method,get,annotation,qualifier,class,if,target,annotation,null,qualifier,equals,target,annotation,value,return,true,catch,no,such,bean,definition,exception,ex,return,false
BeanFactoryAnnotationUtils -> private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf);1347283603;Check whether the named bean declares a qualifier of the given name._@param qualifier the qualifier to match_@param beanName the name of the candidate bean_@param bf the {@code BeanFactory} from which to retrieve the named bean_@return {@code true} if either the bean definition (in the XML case)_or the bean's factory method (in the {@code @Bean} case) defines a matching_qualifier value (through {@code <qualifier>} or {@code @Qualifier});private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {_		if (bf.containsBean(beanName)) {_			try {_				BeanDefinition bd = bf.getMergedBeanDefinition(beanName)__				if (bd instanceof AbstractBeanDefinition) {_					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd__					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName())__					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||_							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {_						return true__					}_				}_				if (bd instanceof RootBeanDefinition) {_					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod()__					if (factoryMethod != null) {_						Qualifier targetAnnotation = factoryMethod.getAnnotation(Qualifier.class)__						if (targetAnnotation != null && qualifier.equals(targetAnnotation.value())) {_							return true__						}_					}_				}_			}_			catch (NoSuchBeanDefinitionException ex) {_				_			}_		}_		return false__	};check,whether,the,named,bean,declares,a,qualifier,of,the,given,name,param,qualifier,the,qualifier,to,match,param,bean,name,the,name,of,the,candidate,bean,param,bf,the,code,bean,factory,from,which,to,retrieve,the,named,bean,return,code,true,if,either,the,bean,definition,in,the,xml,case,or,the,bean,s,factory,method,in,the,code,bean,case,defines,a,matching,qualifier,value,through,code,qualifier,or,code,qualifier;private,static,boolean,is,qualifier,match,string,qualifier,string,bean,name,configurable,listable,bean,factory,bf,if,bf,contains,bean,bean,name,try,bean,definition,bd,bf,get,merged,bean,definition,bean,name,if,bd,instanceof,abstract,bean,definition,abstract,bean,definition,abd,abstract,bean,definition,bd,autowire,candidate,qualifier,candidate,abd,get,qualifier,qualifier,class,get,name,if,candidate,null,qualifier,equals,candidate,get,attribute,autowire,candidate,qualifier,qualifier,equals,bean,name,object,utils,contains,element,bf,get,aliases,bean,name,qualifier,return,true,if,bd,instanceof,root,bean,definition,method,factory,method,root,bean,definition,bd,get,resolved,factory,method,if,factory,method,null,qualifier,target,annotation,factory,method,get,annotation,qualifier,class,if,target,annotation,null,qualifier,equals,target,annotation,value,return,true,catch,no,such,bean,definition,exception,ex,return,false
BeanFactoryAnnotationUtils -> private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf);1404224980;Check whether the named bean declares a qualifier of the given name._@param qualifier the qualifier to match_@param beanName the name of the candidate bean_@param bf the {@code BeanFactory} from which to retrieve the named bean_@return {@code true} if either the bean definition (in the XML case)_or the bean's factory method (in the {@code @Bean} case) defines a matching_qualifier value (through {@code <qualifier>} or {@code @Qualifier});private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {_		if (bf.containsBean(beanName)) {_			try {_				BeanDefinition bd = bf.getMergedBeanDefinition(beanName)__				if (bd instanceof AbstractBeanDefinition) {_					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd__					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName())__					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||_							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {_						return true__					}_				}_				if (bd instanceof RootBeanDefinition) {_					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod()__					if (factoryMethod != null) {_						Qualifier targetAnnotation = factoryMethod.getAnnotation(Qualifier.class)__						if (targetAnnotation != null && qualifier.equals(targetAnnotation.value())) {_							return true__						}_					}_				}_			}_			catch (NoSuchBeanDefinitionException ex) {_				_			}_		}_		return false__	};check,whether,the,named,bean,declares,a,qualifier,of,the,given,name,param,qualifier,the,qualifier,to,match,param,bean,name,the,name,of,the,candidate,bean,param,bf,the,code,bean,factory,from,which,to,retrieve,the,named,bean,return,code,true,if,either,the,bean,definition,in,the,xml,case,or,the,bean,s,factory,method,in,the,code,bean,case,defines,a,matching,qualifier,value,through,code,qualifier,or,code,qualifier;private,static,boolean,is,qualifier,match,string,qualifier,string,bean,name,configurable,listable,bean,factory,bf,if,bf,contains,bean,bean,name,try,bean,definition,bd,bf,get,merged,bean,definition,bean,name,if,bd,instanceof,abstract,bean,definition,abstract,bean,definition,abd,abstract,bean,definition,bd,autowire,candidate,qualifier,candidate,abd,get,qualifier,qualifier,class,get,name,if,candidate,null,qualifier,equals,candidate,get,attribute,autowire,candidate,qualifier,qualifier,equals,bean,name,object,utils,contains,element,bf,get,aliases,bean,name,qualifier,return,true,if,bd,instanceof,root,bean,definition,method,factory,method,root,bean,definition,bd,get,resolved,factory,method,if,factory,method,null,qualifier,target,annotation,factory,method,get,annotation,qualifier,class,if,target,annotation,null,qualifier,equals,target,annotation,value,return,true,catch,no,such,bean,definition,exception,ex,return,false
BeanFactoryAnnotationUtils -> private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf);1404239431;Check whether the named bean declares a qualifier of the given name._@param qualifier the qualifier to match_@param beanName the name of the candidate bean_@param bf the {@code BeanFactory} from which to retrieve the named bean_@return {@code true} if either the bean definition (in the XML case)_or the bean's factory method (in the {@code @Bean} case) defines a matching_qualifier value (through {@code <qualifier>} or {@code @Qualifier});private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {_		if (bf.containsBean(beanName)) {_			try {_				BeanDefinition bd = bf.getMergedBeanDefinition(beanName)__				if (bd instanceof AbstractBeanDefinition) {_					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd__					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName())__					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||_							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {_						return true__					}_				}_				if (bd instanceof RootBeanDefinition) {_					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod()__					if (factoryMethod != null) {_						Qualifier targetAnnotation = factoryMethod.getAnnotation(Qualifier.class)__						if (targetAnnotation != null && qualifier.equals(targetAnnotation.value())) {_							return true__						}_					}_				}_			}_			catch (NoSuchBeanDefinitionException ex) {_				_			}_		}_		return false__	};check,whether,the,named,bean,declares,a,qualifier,of,the,given,name,param,qualifier,the,qualifier,to,match,param,bean,name,the,name,of,the,candidate,bean,param,bf,the,code,bean,factory,from,which,to,retrieve,the,named,bean,return,code,true,if,either,the,bean,definition,in,the,xml,case,or,the,bean,s,factory,method,in,the,code,bean,case,defines,a,matching,qualifier,value,through,code,qualifier,or,code,qualifier;private,static,boolean,is,qualifier,match,string,qualifier,string,bean,name,configurable,listable,bean,factory,bf,if,bf,contains,bean,bean,name,try,bean,definition,bd,bf,get,merged,bean,definition,bean,name,if,bd,instanceof,abstract,bean,definition,abstract,bean,definition,abd,abstract,bean,definition,bd,autowire,candidate,qualifier,candidate,abd,get,qualifier,qualifier,class,get,name,if,candidate,null,qualifier,equals,candidate,get,attribute,autowire,candidate,qualifier,qualifier,equals,bean,name,object,utils,contains,element,bf,get,aliases,bean,name,qualifier,return,true,if,bd,instanceof,root,bean,definition,method,factory,method,root,bean,definition,bd,get,resolved,factory,method,if,factory,method,null,qualifier,target,annotation,factory,method,get,annotation,qualifier,class,if,target,annotation,null,qualifier,equals,target,annotation,value,return,true,catch,no,such,bean,definition,exception,ex,return,false
BeanFactoryAnnotationUtils -> private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf);1413905053;Check whether the named bean declares a qualifier of the given name._@param qualifier the qualifier to match_@param beanName the name of the candidate bean_@param bf the {@code BeanFactory} from which to retrieve the named bean_@return {@code true} if either the bean definition (in the XML case)_or the bean's factory method (in the {@code @Bean} case) defines a matching_qualifier value (through {@code <qualifier>} or {@code @Qualifier});private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {_		if (bf.containsBean(beanName)) {_			try {_				BeanDefinition bd = bf.getMergedBeanDefinition(beanName)__				if (bd instanceof AbstractBeanDefinition) {_					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd__					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName())__					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||_							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {_						return true__					}_				}_				if (bd instanceof RootBeanDefinition) {_					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod()__					if (factoryMethod != null) {_						Qualifier targetAnnotation = factoryMethod.getAnnotation(Qualifier.class)__						if (targetAnnotation != null && qualifier.equals(targetAnnotation.value())) {_							return true__						}_					}_				}_			}_			catch (NoSuchBeanDefinitionException ex) {_				_			}_		}_		return false__	};check,whether,the,named,bean,declares,a,qualifier,of,the,given,name,param,qualifier,the,qualifier,to,match,param,bean,name,the,name,of,the,candidate,bean,param,bf,the,code,bean,factory,from,which,to,retrieve,the,named,bean,return,code,true,if,either,the,bean,definition,in,the,xml,case,or,the,bean,s,factory,method,in,the,code,bean,case,defines,a,matching,qualifier,value,through,code,qualifier,or,code,qualifier;private,static,boolean,is,qualifier,match,string,qualifier,string,bean,name,configurable,listable,bean,factory,bf,if,bf,contains,bean,bean,name,try,bean,definition,bd,bf,get,merged,bean,definition,bean,name,if,bd,instanceof,abstract,bean,definition,abstract,bean,definition,abd,abstract,bean,definition,bd,autowire,candidate,qualifier,candidate,abd,get,qualifier,qualifier,class,get,name,if,candidate,null,qualifier,equals,candidate,get,attribute,autowire,candidate,qualifier,qualifier,equals,bean,name,object,utils,contains,element,bf,get,aliases,bean,name,qualifier,return,true,if,bd,instanceof,root,bean,definition,method,factory,method,root,bean,definition,bd,get,resolved,factory,method,if,factory,method,null,qualifier,target,annotation,factory,method,get,annotation,qualifier,class,if,target,annotation,null,qualifier,equals,target,annotation,value,return,true,catch,no,such,bean,definition,exception,ex,return,false
BeanFactoryAnnotationUtils -> private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf);1448910783;Check whether the named bean declares a qualifier of the given name._@param qualifier the qualifier to match_@param beanName the name of the candidate bean_@param bf the {@code BeanFactory} from which to retrieve the named bean_@return {@code true} if either the bean definition (in the XML case)_or the bean's factory method (in the {@code @Bean} case) defines a matching_qualifier value (through {@code <qualifier>} or {@code @Qualifier});private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {_		if (bf.containsBean(beanName)) {_			try {_				BeanDefinition bd = bf.getMergedBeanDefinition(beanName)__				if (bd instanceof AbstractBeanDefinition) {_					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd__					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName())__					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||_							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {_						return true__					}_				}_				if (bd instanceof RootBeanDefinition) {_					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod()__					if (factoryMethod != null) {_						Qualifier targetAnnotation = factoryMethod.getAnnotation(Qualifier.class)__						if (targetAnnotation != null && qualifier.equals(targetAnnotation.value())) {_							return true__						}_					}_				}_			}_			catch (NoSuchBeanDefinitionException ex) {_				_			}_		}_		return false__	};check,whether,the,named,bean,declares,a,qualifier,of,the,given,name,param,qualifier,the,qualifier,to,match,param,bean,name,the,name,of,the,candidate,bean,param,bf,the,code,bean,factory,from,which,to,retrieve,the,named,bean,return,code,true,if,either,the,bean,definition,in,the,xml,case,or,the,bean,s,factory,method,in,the,code,bean,case,defines,a,matching,qualifier,value,through,code,qualifier,or,code,qualifier;private,static,boolean,is,qualifier,match,string,qualifier,string,bean,name,configurable,listable,bean,factory,bf,if,bf,contains,bean,bean,name,try,bean,definition,bd,bf,get,merged,bean,definition,bean,name,if,bd,instanceof,abstract,bean,definition,abstract,bean,definition,abd,abstract,bean,definition,bd,autowire,candidate,qualifier,candidate,abd,get,qualifier,qualifier,class,get,name,if,candidate,null,qualifier,equals,candidate,get,attribute,autowire,candidate,qualifier,qualifier,equals,bean,name,object,utils,contains,element,bf,get,aliases,bean,name,qualifier,return,true,if,bd,instanceof,root,bean,definition,method,factory,method,root,bean,definition,bd,get,resolved,factory,method,if,factory,method,null,qualifier,target,annotation,factory,method,get,annotation,qualifier,class,if,target,annotation,null,qualifier,equals,target,annotation,value,return,true,catch,no,such,bean,definition,exception,ex,return,false
BeanFactoryAnnotationUtils -> private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf);1451341688;Check whether the named bean declares a qualifier of the given name._@param qualifier the qualifier to match_@param beanName the name of the candidate bean_@param bf the {@code BeanFactory} from which to retrieve the named bean_@return {@code true} if either the bean definition (in the XML case)_or the bean's factory method (in the {@code @Bean} case) defines a matching_qualifier value (through {@code <qualifier>} or {@code @Qualifier});private static boolean isQualifierMatch(String qualifier, String beanName, ConfigurableListableBeanFactory bf) {_		if (bf.containsBean(beanName)) {_			try {_				BeanDefinition bd = bf.getMergedBeanDefinition(beanName)__				_				if (bd instanceof AbstractBeanDefinition) {_					AbstractBeanDefinition abd = (AbstractBeanDefinition) bd__					AutowireCandidateQualifier candidate = abd.getQualifier(Qualifier.class.getName())__					if ((candidate != null && qualifier.equals(candidate.getAttribute(AutowireCandidateQualifier.VALUE_KEY))) ||_							qualifier.equals(beanName) || ObjectUtils.containsElement(bf.getAliases(beanName), qualifier)) {_						return true__					}_				}_				_				if (bd instanceof RootBeanDefinition) {_					Method factoryMethod = ((RootBeanDefinition) bd).getResolvedFactoryMethod()__					if (factoryMethod != null) {_						Qualifier targetAnnotation = AnnotationUtils.getAnnotation(factoryMethod, Qualifier.class)__						if (targetAnnotation != null) {_							return qualifier.equals(targetAnnotation.value())__						}_					}_				}_				_				Class<?> beanType = bf.getType(beanName)__				if (beanType != null) {_					Qualifier targetAnnotation = AnnotationUtils.getAnnotation(beanType, Qualifier.class)__					if (targetAnnotation != null) {_						return qualifier.equals(targetAnnotation.value())__					}_				}_			}_			catch (NoSuchBeanDefinitionException ex) {_				_			}_		}_		return false__	};check,whether,the,named,bean,declares,a,qualifier,of,the,given,name,param,qualifier,the,qualifier,to,match,param,bean,name,the,name,of,the,candidate,bean,param,bf,the,code,bean,factory,from,which,to,retrieve,the,named,bean,return,code,true,if,either,the,bean,definition,in,the,xml,case,or,the,bean,s,factory,method,in,the,code,bean,case,defines,a,matching,qualifier,value,through,code,qualifier,or,code,qualifier;private,static,boolean,is,qualifier,match,string,qualifier,string,bean,name,configurable,listable,bean,factory,bf,if,bf,contains,bean,bean,name,try,bean,definition,bd,bf,get,merged,bean,definition,bean,name,if,bd,instanceof,abstract,bean,definition,abstract,bean,definition,abd,abstract,bean,definition,bd,autowire,candidate,qualifier,candidate,abd,get,qualifier,qualifier,class,get,name,if,candidate,null,qualifier,equals,candidate,get,attribute,autowire,candidate,qualifier,qualifier,equals,bean,name,object,utils,contains,element,bf,get,aliases,bean,name,qualifier,return,true,if,bd,instanceof,root,bean,definition,method,factory,method,root,bean,definition,bd,get,resolved,factory,method,if,factory,method,null,qualifier,target,annotation,annotation,utils,get,annotation,factory,method,qualifier,class,if,target,annotation,null,return,qualifier,equals,target,annotation,value,class,bean,type,bf,get,type,bean,name,if,bean,type,null,qualifier,target,annotation,annotation,utils,get,annotation,bean,type,qualifier,class,if,target,annotation,null,return,qualifier,equals,target,annotation,value,catch,no,such,bean,definition,exception,ex,return,false
