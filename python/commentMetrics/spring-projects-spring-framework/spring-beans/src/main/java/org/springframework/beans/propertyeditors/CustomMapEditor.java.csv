commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Convert the given text value to a Map with a single element.  */ ;/**  * Convert the given text value to a Map with a single element.  */ @Override public void setAsText(String text) throws IllegalArgumentException {     setValue(text). }
true;public;1;20;/**  * Convert the given value to a Map of the target type.  */ ;/**  * Convert the given value to a Map of the target type.  */ @Override public void setValue(@Nullable Object value) {     if (value == null && this.nullAsEmptyMap) {         super.setValue(createMap(this.mapType, 0)).     } else if (value == null || (this.mapType.isInstance(value) && !alwaysCreateNewMap())) {         // Use the source value as-is, as it matches the target type.         super.setValue(value).     } else if (value instanceof Map) {         // Convert Map elements.         Map<?, ?> source = (Map<?, ?>) value.         Map<Object, Object> target = createMap(this.mapType, source.size()).         source.forEach((key, val) -> target.put(convertKey(key), convertValue(val))).         super.setValue(target).     } else {         throw new IllegalArgumentException("Value cannot be converted to Map: " + value).     } }
true;protected;2;18;/**  * Create a Map of the given type, with the given  * initial capacity (if supported by the Map type).  * @param mapType a sub-interface of Map  * @param initialCapacity the initial capacity  * @return the new Map instance  */ ;/**  * Create a Map of the given type, with the given  * initial capacity (if supported by the Map type).  * @param mapType a sub-interface of Map  * @param initialCapacity the initial capacity  * @return the new Map instance  */ @SuppressWarnings({ "rawtypes", "unchecked" }) protected Map<Object, Object> createMap(Class<? extends Map> mapType, int initialCapacity) {     if (!mapType.isInterface()) {         try {             return ReflectionUtils.accessibleConstructor(mapType).newInstance().         } catch (Throwable ex) {             throw new IllegalArgumentException("Could not instantiate map class: " + mapType.getName(), ex).         }     } else if (SortedMap.class == mapType) {         return new TreeMap<>().     } else {         return new LinkedHashMap<>(initialCapacity).     } }
true;protected;0;3;/**  * Return whether to always create a new Map,  * even if the type of the passed-in Map already matches.  * <p>Default is "false". can be overridden to enforce creation of a  * new Map, for example to convert elements in any case.  * @see #convertKey  * @see #convertValue  */ ;/**  * Return whether to always create a new Map,  * even if the type of the passed-in Map already matches.  * <p>Default is "false". can be overridden to enforce creation of a  * new Map, for example to convert elements in any case.  * @see #convertKey  * @see #convertValue  */ protected boolean alwaysCreateNewMap() {     return false. }
true;protected;1;3;/**  * Hook to convert each encountered Map key.  * The default implementation simply returns the passed-in key as-is.  * <p>Can be overridden to perform conversion of certain keys,  * for example from String to Integer.  * <p>Only called if actually creating a new Map!  * This is by default not the case if the type of the passed-in Map  * already matches. Override {@link #alwaysCreateNewMap()} to  * enforce creating a new Map in every case.  * @param key the source key  * @return the key to be used in the target Map  * @see #alwaysCreateNewMap  */ ;/**  * Hook to convert each encountered Map key.  * The default implementation simply returns the passed-in key as-is.  * <p>Can be overridden to perform conversion of certain keys,  * for example from String to Integer.  * <p>Only called if actually creating a new Map!  * This is by default not the case if the type of the passed-in Map  * already matches. Override {@link #alwaysCreateNewMap()} to  * enforce creating a new Map in every case.  * @param key the source key  * @return the key to be used in the target Map  * @see #alwaysCreateNewMap  */ protected Object convertKey(Object key) {     return key. }
true;protected;1;3;/**  * Hook to convert each encountered Map value.  * The default implementation simply returns the passed-in value as-is.  * <p>Can be overridden to perform conversion of certain values,  * for example from String to Integer.  * <p>Only called if actually creating a new Map!  * This is by default not the case if the type of the passed-in Map  * already matches. Override {@link #alwaysCreateNewMap()} to  * enforce creating a new Map in every case.  * @param value the source value  * @return the value to be used in the target Map  * @see #alwaysCreateNewMap  */ ;/**  * Hook to convert each encountered Map value.  * The default implementation simply returns the passed-in value as-is.  * <p>Can be overridden to perform conversion of certain values,  * for example from String to Integer.  * <p>Only called if actually creating a new Map!  * This is by default not the case if the type of the passed-in Map  * already matches. Override {@link #alwaysCreateNewMap()} to  * enforce creating a new Map in every case.  * @param value the source value  * @return the value to be used in the target Map  * @see #alwaysCreateNewMap  */ protected Object convertValue(Object value) {     return value. }
true;public;0;5;/**  * This implementation returns {@code null} to indicate that  * there is no appropriate text representation.  */ ;/**  * This implementation returns {@code null} to indicate that  * there is no appropriate text representation.  */ @Override @Nullable public String getAsText() {     return null. }
