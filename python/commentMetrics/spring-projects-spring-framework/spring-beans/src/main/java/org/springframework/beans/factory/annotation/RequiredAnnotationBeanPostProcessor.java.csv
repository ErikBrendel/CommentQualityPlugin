commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the 'required' annotation type, to be used on bean property  * setter methods.  * <p>The default required annotation type is the Spring-provided  * {@link Required} annotation.  * <p>This setter property exists so that developers can provide their own  * (non-Spring-specific) annotation type to indicate that a property value  * is required.  */ ;/**  * Set the 'required' annotation type, to be used on bean property  * setter methods.  * <p>The default required annotation type is the Spring-provided  * {@link Required} annotation.  * <p>This setter property exists so that developers can provide their own  * (non-Spring-specific) annotation type to indicate that a property value  * is required.  */ public void setRequiredAnnotationType(Class<? extends Annotation> requiredAnnotationType) {     Assert.notNull(requiredAnnotationType, "'requiredAnnotationType' must not be null").     this.requiredAnnotationType = requiredAnnotationType. }
true;protected;0;3;/**  * Return the 'required' annotation type.  */ ;/**  * Return the 'required' annotation type.  */ protected Class<? extends Annotation> getRequiredAnnotationType() {     return this.requiredAnnotationType. }
false;public;1;6;;@Override public void setBeanFactory(BeanFactory beanFactory) {     if (beanFactory instanceof ConfigurableListableBeanFactory) {         this.beanFactory = (ConfigurableListableBeanFactory) beanFactory.     } }
false;public;1;3;;public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
false;public;3;3;;@Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) { }
false;public;4;20;;@Override public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) {     if (!this.validatedBeanNames.contains(beanName)) {         if (!shouldSkip(this.beanFactory, beanName)) {             List<String> invalidProperties = new ArrayList<>().             for (PropertyDescriptor pd : pds) {                 if (isRequiredProperty(pd) && !pvs.contains(pd.getName())) {                     invalidProperties.add(pd.getName()).                 }             }             if (!invalidProperties.isEmpty()) {                 throw new BeanInitializationException(buildExceptionMessage(invalidProperties, beanName)).             }         }         this.validatedBeanNames.add(beanName).     }     return pvs. }
true;protected;2;11;/**  * Check whether the given bean definition is not subject to the annotation-based  * required property check as performed by this post-processor.  * <p>The default implementations check for the presence of the  * {@link #SKIP_REQUIRED_CHECK_ATTRIBUTE} attribute in the bean definition, if any.  * It also suggests skipping in case of a bean definition with a "factory-bean"  * reference set, assuming that instance-based factories pre-populate the bean.  * @param beanFactory the BeanFactory to check against  * @param beanName the name of the bean to check against  * @return {@code true} to skip the bean. {@code false} to process it  */ ;/**  * Check whether the given bean definition is not subject to the annotation-based  * required property check as performed by this post-processor.  * <p>The default implementations check for the presence of the  * {@link #SKIP_REQUIRED_CHECK_ATTRIBUTE} attribute in the bean definition, if any.  * It also suggests skipping in case of a bean definition with a "factory-bean"  * reference set, assuming that instance-based factories pre-populate the bean.  * @param beanFactory the BeanFactory to check against  * @param beanName the name of the bean to check against  * @return {@code true} to skip the bean. {@code false} to process it  */ protected boolean shouldSkip(@Nullable ConfigurableListableBeanFactory beanFactory, String beanName) {     if (beanFactory == null || !beanFactory.containsBeanDefinition(beanName)) {         return false.     }     BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName).     if (beanDefinition.getFactoryBeanName() != null) {         return true.     }     Object value = beanDefinition.getAttribute(SKIP_REQUIRED_CHECK_ATTRIBUTE).     return (value != null && (Boolean.TRUE.equals(value) || Boolean.valueOf(value.toString()))). }
true;protected;1;4;/**  * Is the supplied property required to have a value (that is, to be dependency-injected)?  * <p>This implementation looks for the existence of a  * {@link #setRequiredAnnotationType "required" annotation}  * on the supplied {@link PropertyDescriptor property}.  * @param propertyDescriptor the target PropertyDescriptor (never {@code null})  * @return {@code true} if the supplied property has been marked as being required.  * {@code false} if not, or if the supplied property does not have a setter method  */ ;/**  * Is the supplied property required to have a value (that is, to be dependency-injected)?  * <p>This implementation looks for the existence of a  * {@link #setRequiredAnnotationType "required" annotation}  * on the supplied {@link PropertyDescriptor property}.  * @param propertyDescriptor the target PropertyDescriptor (never {@code null})  * @return {@code true} if the supplied property has been marked as being required.  * {@code false} if not, or if the supplied property does not have a setter method  */ protected boolean isRequiredProperty(PropertyDescriptor propertyDescriptor) {     Method setter = propertyDescriptor.getWriteMethod().     return (setter != null && AnnotationUtils.getAnnotation(setter, getRequiredAnnotationType()) != null). }
true;private;2;20;/**  * Build an exception message for the given list of invalid properties.  * @param invalidProperties the list of names of invalid properties  * @param beanName the name of the bean  * @return the exception message  */ ;/**  * Build an exception message for the given list of invalid properties.  * @param invalidProperties the list of names of invalid properties  * @param beanName the name of the bean  * @return the exception message  */ private String buildExceptionMessage(List<String> invalidProperties, String beanName) {     int size = invalidProperties.size().     StringBuilder sb = new StringBuilder().     sb.append(size == 1 ? "Property" : "Properties").     for (int i = 0. i < size. i++) {         String propertyName = invalidProperties.get(i).         if (i > 0) {             if (i == (size - 1)) {                 sb.append(" and").             } else {                 sb.append(",").             }         }         sb.append(" '").append(propertyName).append("'").     }     sb.append(size == 1 ? " is" : " are").     sb.append(" required for bean '").append(beanName).append("'").     return sb.toString(). }
