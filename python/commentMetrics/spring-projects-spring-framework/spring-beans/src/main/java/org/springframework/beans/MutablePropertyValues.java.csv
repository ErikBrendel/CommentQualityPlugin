commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the underlying List of PropertyValue objects in its raw form.  * The returned List can be modified directly, although this is not recommended.  * <p>This is an accessor for optimized access to all PropertyValue objects.  * It is not intended for typical programmatic use.  */ ;/**  * Return the underlying List of PropertyValue objects in its raw form.  * The returned List can be modified directly, although this is not recommended.  * <p>This is an accessor for optimized access to all PropertyValue objects.  * It is not intended for typical programmatic use.  */ public List<PropertyValue> getPropertyValueList() {     return this.propertyValueList. }
true;public;0;3;/**  * Return the number of PropertyValue entries in the list.  */ ;/**  * Return the number of PropertyValue entries in the list.  */ public int size() {     return this.propertyValueList.size(). }
true;public;1;9;/**  * Copy all given PropertyValues into this object. Guarantees PropertyValue  * references are independent, although it can't deep copy objects currently  * referenced by individual PropertyValue objects.  * @param other the PropertyValues to copy  * @return this in order to allow for adding multiple property values in a chain  */ ;/**  * Copy all given PropertyValues into this object. Guarantees PropertyValue  * references are independent, although it can't deep copy objects currently  * referenced by individual PropertyValue objects.  * @param other the PropertyValues to copy  * @return this in order to allow for adding multiple property values in a chain  */ public MutablePropertyValues addPropertyValues(@Nullable PropertyValues other) {     if (other != null) {         PropertyValue[] pvs = other.getPropertyValues().         for (PropertyValue pv : pvs) {             addPropertyValue(new PropertyValue(pv)).         }     }     return this. }
true;public;1;7;/**  * Add all property values from the given Map.  * @param other a Map with property values keyed by property name,  * which must be a String  * @return this in order to allow for adding multiple property values in a chain  */ ;/**  * Add all property values from the given Map.  * @param other a Map with property values keyed by property name,  * which must be a String  * @return this in order to allow for adding multiple property values in a chain  */ public MutablePropertyValues addPropertyValues(@Nullable Map<?, ?> other) {     if (other != null) {         other.forEach((attrName, attrValue) -> addPropertyValue(new PropertyValue(attrName.toString(), attrValue))).     }     return this. }
true;public;1;12;/**  * Add a PropertyValue object, replacing any existing one for the  * corresponding property or getting merged with it (if applicable).  * @param pv the PropertyValue object to add  * @return this in order to allow for adding multiple property values in a chain  */ ;/**  * Add a PropertyValue object, replacing any existing one for the  * corresponding property or getting merged with it (if applicable).  * @param pv the PropertyValue object to add  * @return this in order to allow for adding multiple property values in a chain  */ public MutablePropertyValues addPropertyValue(PropertyValue pv) {     for (int i = 0. i < this.propertyValueList.size(). i++) {         PropertyValue currentPv = this.propertyValueList.get(i).         if (currentPv.getName().equals(pv.getName())) {             pv = mergeIfRequired(pv, currentPv).             setPropertyValueAt(pv, i).             return this.         }     }     this.propertyValueList.add(pv).     return this. }
true;public;2;3;/**  * Overloaded version of {@code addPropertyValue} that takes  * a property name and a property value.  * <p>Note: As of Spring 3.0, we recommend using the more concise  * and chaining-capable variant {@link #add}.  * @param propertyName name of the property  * @param propertyValue value of the property  * @see #addPropertyValue(PropertyValue)  */ ;/**  * Overloaded version of {@code addPropertyValue} that takes  * a property name and a property value.  * <p>Note: As of Spring 3.0, we recommend using the more concise  * and chaining-capable variant {@link #add}.  * @param propertyName name of the property  * @param propertyValue value of the property  * @see #addPropertyValue(PropertyValue)  */ public void addPropertyValue(String propertyName, Object propertyValue) {     addPropertyValue(new PropertyValue(propertyName, propertyValue)). }
true;public;2;4;/**  * Add a PropertyValue object, replacing any existing one for the  * corresponding property or getting merged with it (if applicable).  * @param propertyName name of the property  * @param propertyValue value of the property  * @return this in order to allow for adding multiple property values in a chain  */ ;/**  * Add a PropertyValue object, replacing any existing one for the  * corresponding property or getting merged with it (if applicable).  * @param propertyName name of the property  * @param propertyValue value of the property  * @return this in order to allow for adding multiple property values in a chain  */ public MutablePropertyValues add(String propertyName, @Nullable Object propertyValue) {     addPropertyValue(new PropertyValue(propertyName, propertyValue)).     return this. }
true;public;2;3;/**  * Modify a PropertyValue object held in this object.  * Indexed from 0.  */ ;/**  * Modify a PropertyValue object held in this object.  * Indexed from 0.  */ public void setPropertyValueAt(PropertyValue pv, int i) {     this.propertyValueList.set(i, pv). }
true;private;2;11;/**  * Merges the value of the supplied 'new' {@link PropertyValue} with that of  * the current {@link PropertyValue} if merging is supported and enabled.  * @see Mergeable  */ ;/**  * Merges the value of the supplied 'new' {@link PropertyValue} with that of  * the current {@link PropertyValue} if merging is supported and enabled.  * @see Mergeable  */ private PropertyValue mergeIfRequired(PropertyValue newPv, PropertyValue currentPv) {     Object value = newPv.getValue().     if (value instanceof Mergeable) {         Mergeable mergeable = (Mergeable) value.         if (mergeable.isMergeEnabled()) {             Object merged = mergeable.merge(currentPv.getValue()).             return new PropertyValue(newPv.getName(), merged).         }     }     return newPv. }
true;public;1;3;/**  * Remove the given PropertyValue, if contained.  * @param pv the PropertyValue to remove  */ ;/**  * Remove the given PropertyValue, if contained.  * @param pv the PropertyValue to remove  */ public void removePropertyValue(PropertyValue pv) {     this.propertyValueList.remove(pv). }
true;public;1;3;/**  * Overloaded version of {@code removePropertyValue} that takes a property name.  * @param propertyName name of the property  * @see #removePropertyValue(PropertyValue)  */ ;/**  * Overloaded version of {@code removePropertyValue} that takes a property name.  * @param propertyName name of the property  * @see #removePropertyValue(PropertyValue)  */ public void removePropertyValue(String propertyName) {     this.propertyValueList.remove(getPropertyValue(propertyName)). }
false;public;0;4;;@Override public Iterator<PropertyValue> iterator() {     return Collections.unmodifiableList(this.propertyValueList).iterator(). }
false;public;0;4;;@Override public Spliterator<PropertyValue> spliterator() {     return Spliterators.spliterator(this.propertyValueList, 0). }
false;public;0;4;;@Override public Stream<PropertyValue> stream() {     return this.propertyValueList.stream(). }
false;public;0;4;;@Override public PropertyValue[] getPropertyValues() {     return this.propertyValueList.toArray(new PropertyValue[0]). }
false;public;1;10;;@Override @Nullable public PropertyValue getPropertyValue(String propertyName) {     for (PropertyValue pv : this.propertyValueList) {         if (pv.getName().equals(propertyName)) {             return pv.         }     }     return null. }
true;public;1;5;/**  * Get the raw property value, if any.  * @param propertyName the name to search for  * @return the raw property value, or {@code null} if none found  * @since 4.0  * @see #getPropertyValue(String)  * @see PropertyValue#getValue()  */ ;/**  * Get the raw property value, if any.  * @param propertyName the name to search for  * @return the raw property value, or {@code null} if none found  * @since 4.0  * @see #getPropertyValue(String)  * @see PropertyValue#getValue()  */ @Nullable public Object get(String propertyName) {     PropertyValue pv = getPropertyValue(propertyName).     return (pv != null ? pv.getValue() : null). }
false;public;1;17;;@Override public PropertyValues changesSince(PropertyValues old) {     MutablePropertyValues changes = new MutablePropertyValues().     if (old == this) {         return changes.     }     // for each property value in the new set     for (PropertyValue newPv : this.propertyValueList) {         // if there wasn't an old one, add it         PropertyValue pvOld = old.getPropertyValue(newPv.getName()).         if (pvOld == null || !pvOld.equals(newPv)) {             changes.addPropertyValue(newPv).         }     }     return changes. }
false;public;1;5;;@Override public boolean contains(String propertyName) {     return (getPropertyValue(propertyName) != null || (this.processedProperties != null && this.processedProperties.contains(propertyName))). }
false;public;0;4;;@Override public boolean isEmpty() {     return this.propertyValueList.isEmpty(). }
true;public;1;6;/**  * Register the specified property as "processed" in the sense  * of some processor calling the corresponding setter method  * outside of the PropertyValue(s) mechanism.  * <p>This will lead to {@code true} being returned from  * a {@link #contains} call for the specified property.  * @param propertyName the name of the property.  */ ;/**  * Register the specified property as "processed" in the sense  * of some processor calling the corresponding setter method  * outside of the PropertyValue(s) mechanism.  * <p>This will lead to {@code true} being returned from  * a {@link #contains} call for the specified property.  * @param propertyName the name of the property.  */ public void registerProcessedProperty(String propertyName) {     if (this.processedProperties == null) {         this.processedProperties = new HashSet<>(4).     }     this.processedProperties.add(propertyName). }
true;public;1;5;/**  * Clear the "processed" registration of the given property, if any.  * @since 3.2.13  */ ;/**  * Clear the "processed" registration of the given property, if any.  * @since 3.2.13  */ public void clearProcessedProperty(String propertyName) {     if (this.processedProperties != null) {         this.processedProperties.remove(propertyName).     } }
true;public;0;3;/**  * Mark this holder as containing converted values only  * (i.e. no runtime resolution needed anymore).  */ ;/**  * Mark this holder as containing converted values only  * (i.e. no runtime resolution needed anymore).  */ public void setConverted() {     this.converted = true. }
true;public;0;3;/**  * Return whether this holder contains converted values only ({@code true}),  * or whether the values still need to be converted ({@code false}).  */ ;/**  * Return whether this holder contains converted values only ({@code true}),  * or whether the values still need to be converted ({@code false}).  */ public boolean isConverted() {     return this.converted. }
false;public;1;5;;@Override public boolean equals(Object other) {     return (this == other || (other instanceof MutablePropertyValues && this.propertyValueList.equals(((MutablePropertyValues) other).propertyValueList))). }
false;public;0;4;;@Override public int hashCode() {     return this.propertyValueList.hashCode(). }
false;public;0;9;;@Override public String toString() {     PropertyValue[] pvs = getPropertyValues().     StringBuilder sb = new StringBuilder("PropertyValues: length=").append(pvs.length).     if (pvs.length > 0) {         sb.append(". ").append(StringUtils.arrayToDelimitedString(pvs, ". ")).     }     return sb.toString(). }
