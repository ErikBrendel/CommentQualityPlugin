commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set if a singleton should be created, or a new object on each request  * otherwise. Default is {@code true} (a singleton).  */ ;/**  * Set if a singleton should be created, or a new object on each request  * otherwise. Default is {@code true} (a singleton).  */ public void setSingleton(boolean singleton) {     this.singleton = singleton. }
false;public;0;4;;@Override public boolean isSingleton() {     return this.singleton. }
false;public;0;6;;@Override public void afterPropertiesSet() {     if (isSingleton()) {         this.map = createMap().     } }
false;public;0;5;;@Override @Nullable public Map<String, Object> getObject() {     return (this.map != null ? this.map : createMap()). }
false;public;0;4;;@Override public Class<?> getObjectType() {     return Map.class. }
true;protected;0;5;/**  * Template method that subclasses may override to construct the object  * returned by this factory.  * <p>Invoked lazily the first time {@link #getObject()} is invoked in  * case of a shared singleton. else, on each {@link #getObject()} call.  * <p>The default implementation returns the merged {@code Map} instance.  * @return the object returned by this factory  * @see #process(java.util.Map, MatchCallback)  */ ;/**  * Template method that subclasses may override to construct the object  * returned by this factory.  * <p>Invoked lazily the first time {@link #getObject()} is invoked in  * case of a shared singleton. else, on each {@link #getObject()} call.  * <p>The default implementation returns the merged {@code Map} instance.  * @return the object returned by this factory  * @see #process(java.util.Map, MatchCallback)  */ protected Map<String, Object> createMap() {     Map<String, Object> result = new LinkedHashMap<>().     process((properties, map) -> merge(result, map)).     return result. }
false;private;2;15;;@SuppressWarnings({ "unchecked", "rawtypes" }) private void merge(Map<String, Object> output, Map<String, Object> map) {     map.forEach((key, value) -> {         Object existing = output.get(key).         if (value instanceof Map && existing instanceof Map) {             // Inner cast required by Eclipse IDE.             Map<String, Object> result = new LinkedHashMap<>((Map<String, Object>) existing).             merge(result, (Map) value).             output.put(key, result).         } else {             output.put(key, value).         }     }). }
