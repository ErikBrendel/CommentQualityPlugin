commented;modifiers;parameterAmount;loc;comment;code
true;public;1;34;/**  * Locate the {@link NamespaceHandler} for the supplied namespace URI  * from the configured mappings.  * @param namespaceUri the relevant namespace URI  * @return the located {@link NamespaceHandler}, or {@code null} if none found  */ ;/**  * Locate the {@link NamespaceHandler} for the supplied namespace URI  * from the configured mappings.  * @param namespaceUri the relevant namespace URI  * @return the located {@link NamespaceHandler}, or {@code null} if none found  */ @Override @Nullable public NamespaceHandler resolve(String namespaceUri) {     Map<String, Object> handlerMappings = getHandlerMappings().     Object handlerOrClassName = handlerMappings.get(namespaceUri).     if (handlerOrClassName == null) {         return null.     } else if (handlerOrClassName instanceof NamespaceHandler) {         return (NamespaceHandler) handlerOrClassName.     } else {         String className = (String) handlerOrClassName.         try {             Class<?> handlerClass = ClassUtils.forName(className, this.classLoader).             if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {                 throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri + "] does not implement the [" + NamespaceHandler.class.getName() + "] interface").             }             NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass).             namespaceHandler.init().             handlerMappings.put(namespaceUri, namespaceHandler).             return namespaceHandler.         } catch (ClassNotFoundException ex) {             throw new FatalBeanException("Could not find NamespaceHandler class [" + className + "] for namespace [" + namespaceUri + "]", ex).         } catch (LinkageError err) {             throw new FatalBeanException("Unresolvable class definition for NamespaceHandler class [" + className + "] for namespace [" + namespaceUri + "]", err).         }     } }
true;private;0;28;/**  * Load the specified NamespaceHandler mappings lazily.  */ ;/**  * Load the specified NamespaceHandler mappings lazily.  */ private Map<String, Object> getHandlerMappings() {     Map<String, Object> handlerMappings = this.handlerMappings.     if (handlerMappings == null) {         synchronized (this) {             handlerMappings = this.handlerMappings.             if (handlerMappings == null) {                 if (logger.isTraceEnabled()) {                     logger.trace("Loading NamespaceHandler mappings from [" + this.handlerMappingsLocation + "]").                 }                 try {                     Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader).                     if (logger.isTraceEnabled()) {                         logger.trace("Loaded NamespaceHandler mappings: " + mappings).                     }                     handlerMappings = new ConcurrentHashMap<>(mappings.size()).                     CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings).                     this.handlerMappings = handlerMappings.                 } catch (IOException ex) {                     throw new IllegalStateException("Unable to load NamespaceHandler mappings from location [" + this.handlerMappingsLocation + "]", ex).                 }             }         }     }     return handlerMappings. }
false;public;0;4;;@Override public String toString() {     return "NamespaceHandlerResolver using mappings " + getHandlerMappings(). }
