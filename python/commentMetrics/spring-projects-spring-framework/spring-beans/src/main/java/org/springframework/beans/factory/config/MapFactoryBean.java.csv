commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the source Map, typically populated via XML "map" elements.  */ ;/**  * Set the source Map, typically populated via XML "map" elements.  */ public void setSourceMap(Map<?, ?> sourceMap) {     this.sourceMap = sourceMap. }
true;public;1;10;/**  * Set the class to use for the target Map. Can be populated with a fully  * qualified class name when defined in a Spring application context.  * <p>Default is a linked HashMap, keeping the registration order.  * @see java.util.LinkedHashMap  */ ;/**  * Set the class to use for the target Map. Can be populated with a fully  * qualified class name when defined in a Spring application context.  * <p>Default is a linked HashMap, keeping the registration order.  * @see java.util.LinkedHashMap  */ @SuppressWarnings("rawtypes") public void setTargetMapClass(@Nullable Class<? extends Map> targetMapClass) {     if (targetMapClass == null) {         throw new IllegalArgumentException("'targetMapClass' must not be null").     }     if (!Map.class.isAssignableFrom(targetMapClass)) {         throw new IllegalArgumentException("'targetMapClass' must implement [java.util.Map]").     }     this.targetMapClass = targetMapClass. }
false;public;0;5;;@Override @SuppressWarnings("rawtypes") public Class<Map> getObjectType() {     return Map.class. }
false;protected;0;33;;@Override @SuppressWarnings("unchecked") protected Map<Object, Object> createInstance() {     if (this.sourceMap == null) {         throw new IllegalArgumentException("'sourceMap' is required").     }     Map<Object, Object> result = null.     if (this.targetMapClass != null) {         result = BeanUtils.instantiateClass(this.targetMapClass).     } else {         result = new LinkedHashMap<>(this.sourceMap.size()).     }     Class<?> keyType = null.     Class<?> valueType = null.     if (this.targetMapClass != null) {         ResolvableType mapType = ResolvableType.forClass(this.targetMapClass).asMap().         keyType = mapType.resolveGeneric(0).         valueType = mapType.resolveGeneric(1).     }     if (keyType != null || valueType != null) {         TypeConverter converter = getBeanTypeConverter().         for (Map.Entry<?, ?> entry : this.sourceMap.entrySet()) {             Object convertedKey = converter.convertIfNecessary(entry.getKey(), keyType).             Object convertedValue = converter.convertIfNecessary(entry.getValue(), valueType).             result.put(convertedKey, convertedValue).         }     } else {         result.putAll(this.sourceMap).     }     return result. }
