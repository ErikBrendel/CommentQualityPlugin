commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Add a new {@link Entry} to the {@link LinkedList}.  */ ;/**  * Add a new {@link Entry} to the {@link LinkedList}.  */ public void push(Entry entry) {     this.state.push(entry). }
true;public;0;3;/**  * Remove an {@link Entry} from the {@link LinkedList}.  */ ;/**  * Remove an {@link Entry} from the {@link LinkedList}.  */ public void pop() {     this.state.pop(). }
true;public;0;4;/**  * Return the {@link Entry} currently at the top of the {@link LinkedList} or  * {@code null} if the {@link LinkedList} is empty.  */ ;/**  * Return the {@link Entry} currently at the top of the {@link LinkedList} or  * {@code null} if the {@link LinkedList} is empty.  */ @Nullable public Entry peek() {     return this.state.peek(). }
true;public;0;3;/**  * Create a new instance of {@link ParseState} which is an independent snapshot  * of this instance.  */ ;/**  * Create a new instance of {@link ParseState} which is an independent snapshot  * of this instance.  */ public ParseState snapshot() {     return new ParseState(this). }
true;public;0;15;/**  * Returns a tree-style representation of the current {@code ParseState}.  */ ;/**  * Returns a tree-style representation of the current {@code ParseState}.  */ @Override public String toString() {     StringBuilder sb = new StringBuilder().     for (int x = 0. x < this.state.size(). x++) {         if (x > 0) {             sb.append('\n').             for (int y = 0. y < x. y++) {                 sb.append(TAB).             }             sb.append("-> ").         }         sb.append(this.state.get(x)).     }     return sb.toString(). }
