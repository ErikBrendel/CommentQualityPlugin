commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Set the source list for this holder.  */ ;/**  * Set the source list for this holder.  */ public void setSource(List<E> source) {     Assert.notNull(source, "Source List must not be null").     this.source = source.     this.refreshDate = new Date().     this.sortUsed = null. }
true;public;0;3;/**  * Return the source list for this holder.  */ ;/**  * Return the source list for this holder.  */ public List<E> getSource() {     return this.source. }
true;public;0;4;/**  * Return the last time the list has been fetched from the source provider.  */ ;/**  * Return the last time the list has been fetched from the source provider.  */ @Nullable public Date getRefreshDate() {     return this.refreshDate. }
true;public;1;3;/**  * Set the sort definition for this holder.  * Typically an instance of MutableSortDefinition.  * @see org.springframework.beans.support.MutableSortDefinition  */ ;/**  * Set the sort definition for this holder.  * Typically an instance of MutableSortDefinition.  * @see org.springframework.beans.support.MutableSortDefinition  */ public void setSort(@Nullable SortDefinition sort) {     this.sort = sort. }
true;public;0;4;/**  * Return the sort definition for this holder.  */ ;/**  * Return the sort definition for this holder.  */ @Nullable public SortDefinition getSort() {     return this.sort. }
true;public;1;8;/**  * Set the current page size.  * Resets the current page number if changed.  * <p>Default value is 10.  */ ;/**  * Set the current page size.  * Resets the current page number if changed.  * <p>Default value is 10.  */ public void setPageSize(int pageSize) {     if (pageSize != this.pageSize) {         this.pageSize = pageSize.         if (!this.newPageSet) {             this.page = 0.         }     } }
true;public;0;3;/**  * Return the current page size.  */ ;/**  * Return the current page size.  */ public int getPageSize() {     return this.pageSize. }
true;public;1;4;/**  * Set the current page number.  * Page numbering starts with 0.  */ ;/**  * Set the current page number.  * Page numbering starts with 0.  */ public void setPage(int page) {     this.page = page.     this.newPageSet = true. }
true;public;0;7;/**  * Return the current page number.  * Page numbering starts with 0.  */ ;/**  * Return the current page number.  * Page numbering starts with 0.  */ public int getPage() {     this.newPageSet = false.     if (this.page >= getPageCount()) {         this.page = getPageCount() - 1.     }     return this.page. }
true;public;1;3;/**  * Set the maximum number of page links to a few pages around the current one.  */ ;/**  * Set the maximum number of page links to a few pages around the current one.  */ public void setMaxLinkedPages(int maxLinkedPages) {     this.maxLinkedPages = maxLinkedPages. }
true;public;0;3;/**  * Return the maximum number of page links to a few pages around the current one.  */ ;/**  * Return the maximum number of page links to a few pages around the current one.  */ public int getMaxLinkedPages() {     return this.maxLinkedPages. }
true;public;0;4;/**  * Return the number of pages for the current source list.  */ ;/**  * Return the number of pages for the current source list.  */ public int getPageCount() {     float nrOfPages = (float) getNrOfElements() / getPageSize().     return (int) ((nrOfPages > (int) nrOfPages || nrOfPages == 0.0) ? nrOfPages + 1 : nrOfPages). }
true;public;0;3;/**  * Return if the current page is the first one.  */ ;/**  * Return if the current page is the first one.  */ public boolean isFirstPage() {     return getPage() == 0. }
true;public;0;3;/**  * Return if the current page is the last one.  */ ;/**  * Return if the current page is the last one.  */ public boolean isLastPage() {     return getPage() == getPageCount() - 1. }
true;public;0;5;/**  * Switch to previous page.  * Will stay on first page if already on first page.  */ ;/**  * Switch to previous page.  * Will stay on first page if already on first page.  */ public void previousPage() {     if (!isFirstPage()) {         this.page--.     } }
true;public;0;5;/**  * Switch to next page.  * Will stay on last page if already on last page.  */ ;/**  * Switch to next page.  * Will stay on last page if already on last page.  */ public void nextPage() {     if (!isLastPage()) {         this.page++.     } }
true;public;0;3;/**  * Return the total number of elements in the source list.  */ ;/**  * Return the total number of elements in the source list.  */ public int getNrOfElements() {     return getSource().size(). }
true;public;0;3;/**  * Return the element index of the first element on the current page.  * Element numbering starts with 0.  */ ;/**  * Return the element index of the first element on the current page.  * Element numbering starts with 0.  */ public int getFirstElementOnPage() {     return (getPageSize() * getPage()). }
true;public;0;5;/**  * Return the element index of the last element on the current page.  * Element numbering starts with 0.  */ ;/**  * Return the element index of the last element on the current page.  * Element numbering starts with 0.  */ public int getLastElementOnPage() {     int endIndex = getPageSize() * (getPage() + 1).     int size = getNrOfElements().     return (endIndex > size ? size : endIndex) - 1. }
true;public;0;3;/**  * Return a sub-list representing the current page.  */ ;/**  * Return a sub-list representing the current page.  */ public List<E> getPageList() {     return getSource().subList(getFirstElementOnPage(), getLastElementOnPage() + 1). }
true;public;0;3;/**  * Return the first page to which create a link around the current page.  */ ;/**  * Return the first page to which create a link around the current page.  */ public int getFirstLinkedPage() {     return Math.max(0, getPage() - (getMaxLinkedPages() / 2)). }
true;public;0;3;/**  * Return the last page to which create a link around the current page.  */ ;/**  * Return the last page to which create a link around the current page.  */ public int getLastLinkedPage() {     return Math.min(getFirstLinkedPage() + getMaxLinkedPages() - 1, getPageCount() - 1). }
true;public;0;8;/**  * Resort the list if necessary, i.e. if the current {@code sort} instance  * isn't equal to the backed-up {@code sortUsed} instance.  * <p>Calls {@code doSort} to trigger actual sorting.  * @see #doSort  */ ;/**  * Resort the list if necessary, i.e. if the current {@code sort} instance  * isn't equal to the backed-up {@code sortUsed} instance.  * <p>Calls {@code doSort} to trigger actual sorting.  * @see #doSort  */ public void resort() {     SortDefinition sort = getSort().     if (sort != null && !sort.equals(this.sortUsed)) {         this.sortUsed = copySortDefinition(sort).         doSort(getSource(), sort).         setPage(0).     } }
true;protected;1;3;/**  * Create a deep copy of the given sort definition,  * for use as state holder to compare a modified sort definition against.  * <p>Default implementation creates a MutableSortDefinition instance.  * Can be overridden in subclasses, in particular in case of custom  * extensions to the SortDefinition interface. Is allowed to return  * null, which means that no sort state will be held, triggering  * actual sorting for each {@code resort} call.  * @param sort the current SortDefinition object  * @return a deep copy of the SortDefinition object  * @see MutableSortDefinition#MutableSortDefinition(SortDefinition)  */ ;/**  * Create a deep copy of the given sort definition,  * for use as state holder to compare a modified sort definition against.  * <p>Default implementation creates a MutableSortDefinition instance.  * Can be overridden in subclasses, in particular in case of custom  * extensions to the SortDefinition interface. Is allowed to return  * null, which means that no sort state will be held, triggering  * actual sorting for each {@code resort} call.  * @param sort the current SortDefinition object  * @return a deep copy of the SortDefinition object  * @see MutableSortDefinition#MutableSortDefinition(SortDefinition)  */ protected SortDefinition copySortDefinition(SortDefinition sort) {     return new MutableSortDefinition(sort). }
true;protected;2;3;/**  * Actually perform sorting of the given source list, according to  * the given sort definition.  * <p>The default implementation uses Spring's PropertyComparator.  * Can be overridden in subclasses.  * @see PropertyComparator#sort(java.util.List, SortDefinition)  */ ;/**  * Actually perform sorting of the given source list, according to  * the given sort definition.  * <p>The default implementation uses Spring's PropertyComparator.  * Can be overridden in subclasses.  * @see PropertyComparator#sort(java.util.List, SortDefinition)  */ protected void doSort(List<E> source, SortDefinition sort) {     PropertyComparator.sort(source, sort). }
