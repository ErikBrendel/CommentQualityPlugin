# id;timestamp;commentText;codeText;commentWords;codeWords
BeanFactoryUtils -> public static boolean isGeneratedBeanName(String name);1328020251;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(String name);1337516454;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(String name);1338031377;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(String name);1356735495;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(String name);1362408075;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(String name);1383167211;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(String name);1426716313;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(String name);1467730834;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(String name);1493370460;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1328020251;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of <code>beanOfType</code> automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,code,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1337516454;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of <code>beanOfType</code> automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,code,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1338031377;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of <code>beanOfType</code> automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,code,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1356735495;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1362408075;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1383167211;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1426716313;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1467730834;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1493370460;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1496837955;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1497271072;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1504419574;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1519514826;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1533823565;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1533943217;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created_@see ListableBeanFactory#getBeansOfType(Class);public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created,see,listable,bean,factory,get,beans,of,type,class;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException;1539119689;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfType} automatically includes_prototypes and FactoryBeans._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created_@see ListableBeanFactory#getBeansOfType(Class);public static <T> T beanOfType(ListableBeanFactory lbf, Class<T> type) throws BeansException {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created,see,listable,bean,factory,get,beans,of,type,class;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1328020251;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1337516454;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1338031377;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1356735495;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1362408075;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1383167211;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1426716313;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1467730834;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1493370460;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				_				parentResult.entrySet().forEach(entry -> {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,parent,result,entry,set,for,each,entry,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1496837955;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				_				parentResult.entrySet().forEach(entry -> {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,parent,result,entry,set,for,each,entry,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1497271072;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1504419574;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1519514826;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1533823565;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1533943217;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created_@see ListableBeanFactory#getBeansOfType(Class, boolean, boolean);public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created,see,listable,bean,factory,get,beans,of,type,class,boolean,boolean;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1539119689;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created_@see ListableBeanFactory#getBeansOfType(Class, boolean, boolean);public static <T> Map<String, T> beansOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				parentResult.forEach((beanName, beanInstance) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanInstance)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created,see,listable,bean,factory,get,beans,of,type,class,boolean,boolean;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,parent,result,for,each,bean,name,bean,instance,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,instance,return,result
BeanFactoryUtils -> public static boolean isFactoryDereference(@Nullable String name);1496837955;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(@Nullable String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,nullable,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(@Nullable String name);1497271072;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(@Nullable String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,nullable,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(@Nullable String name);1504419574;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(@Nullable String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,nullable,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(@Nullable String name);1519514826;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(@Nullable String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,nullable,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(@Nullable String name);1533823565;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(@Nullable String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,nullable,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(@Nullable String name);1533943217;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(@Nullable String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,nullable,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(@Nullable String name);1539119689;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(@Nullable String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,nullable,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1328020251;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1337516454;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1338031377;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1356735495;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1362408075;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1383167211;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1426716313;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1467730834;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1493370460;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1496837955;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1497271072;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1504419574;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1519514826;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1533823565;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1533943217;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories_@see #beanNamesIncludingAncestors;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories,see,bean,names,including,ancestors;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static int countBeansIncludingAncestors(ListableBeanFactory lbf);1539119689;Count all beans in any hierarchy in which this factory participates._Includes counts of ancestor bean factories._<p>Beans that are "overridden" (specified in a descendant factory_with the same name) are only counted once._@param lbf the bean factory_@return count of beans including those defined in ancestor factories_@see #beanNamesIncludingAncestors;public static int countBeansIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesIncludingAncestors(lbf).length__	};count,all,beans,in,any,hierarchy,in,which,this,factory,participates,includes,counts,of,ancestor,bean,factories,p,beans,that,are,overridden,specified,in,a,descendant,factory,with,the,same,name,are,only,counted,once,param,lbf,the,bean,factory,return,count,of,beans,including,those,defined,in,ancestor,factories,see,bean,names,including,ancestors;public,static,int,count,beans,including,ancestors,listable,bean,factory,lbf,return,bean,names,including,ancestors,lbf,length
BeanFactoryUtils -> public static boolean isGeneratedBeanName(@Nullable String name);1496837955;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(@Nullable String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,nullable,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(@Nullable String name);1497271072;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(@Nullable String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,nullable,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(@Nullable String name);1504419574;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(@Nullable String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,nullable,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(@Nullable String name);1519514826;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(@Nullable String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,nullable,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(@Nullable String name);1533823565;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(@Nullable String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,nullable,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(@Nullable String name);1533943217;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(@Nullable String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,nullable,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static boolean isGeneratedBeanName(@Nullable String name);1539119689;Return whether the given name is a bean name which has been generated_by the default naming strategy (containing a "#..." part)._@param name the name of the bean_@return whether the given name is a generated bean name_@see #GENERATED_BEAN_NAME_SEPARATOR_@see org.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanName_@see org.springframework.beans.factory.support.DefaultBeanNameGenerator;public static boolean isGeneratedBeanName(@Nullable String name) {_		return (name != null && name.contains(GENERATED_BEAN_NAME_SEPARATOR))__	};return,whether,the,given,name,is,a,bean,name,which,has,been,generated,by,the,default,naming,strategy,containing,a,part,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,generated,bean,name,see,see,org,springframework,beans,factory,support,bean,definition,reader,utils,generate,bean,name,see,org,springframework,beans,factory,support,default,bean,name,generator;public,static,boolean,is,generated,bean,name,nullable,string,name,return,name,null,name,contains
BeanFactoryUtils -> public static String originalBeanName(String name);1328020251;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1337516454;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1338031377;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1356735495;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1362408075;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1383167211;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1426716313;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1467730834;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1493370460;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1496837955;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1497271072;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1504419574;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1519514826;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1533823565;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1533943217;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static String originalBeanName(String name);1539119689;Extract the "raw" bean name from the given (potentially generated) bean name,_excluding any "#..." suffixes which might have been added for uniqueness._@param name the potentially generated bean name_@return the raw bean name_@see #GENERATED_BEAN_NAME_SEPARATOR;public static String originalBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		int separatorIndex = name.indexOf(GENERATED_BEAN_NAME_SEPARATOR)__		return (separatorIndex != -1 ? name.substring(0, separatorIndex) : name)__	};extract,the,raw,bean,name,from,the,given,potentially,generated,bean,name,excluding,any,suffixes,which,might,have,been,added,for,uniqueness,param,name,the,potentially,generated,bean,name,return,the,raw,bean,name,see;public,static,string,original,bean,name,string,name,assert,not,null,name,name,must,not,be,null,int,separator,index,name,index,of,return,separator,index,1,name,substring,0,separator,index,name
BeanFactoryUtils -> public static boolean isFactoryDereference(String name);1328020251;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(String name);1337516454;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(String name);1338031377;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(String name);1356735495;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(String name);1362408075;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(String name);1383167211;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(String name);1426716313;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(String name);1467730834;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static boolean isFactoryDereference(String name);1493370460;Return whether the given name is a factory dereference_(beginning with the factory dereference prefix)._@param name the name of the bean_@return whether the given name is a factory dereference_@see BeanFactory#FACTORY_BEAN_PREFIX;public static boolean isFactoryDereference(String name) {_		return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__	};return,whether,the,given,name,is,a,factory,dereference,beginning,with,the,factory,dereference,prefix,param,name,the,name,of,the,bean,return,whether,the,given,name,is,a,factory,dereference,see,bean,factory;public,static,boolean,is,factory,dereference,string,name,return,name,null,name,starts,with,bean,factory
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1383167211;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1426716313;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1467730834;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1493370460;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1496837955;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1497271072;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1504419574;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1519514826;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1533823565;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1533943217;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none_@see ListableBeanFactory#getBeanNamesForType(Class, boolean, boolean);public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,listable,bean,factory,get,bean,names,for,type,class,boolean,boolean;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);1539119689;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none_@see ListableBeanFactory#getBeanNamesForType(Class, boolean, boolean);public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,listable,bean,factory,get,bean,names,for,type,class,boolean,boolean;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1328020251;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1337516454;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1338031377;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1356735495;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1362408075;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1383167211;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1426716313;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<String, T>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,string,t,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1467730834;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				for (Map.Entry<String, T> entry : parentResult.entrySet()) {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				}_			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,for,map,entry,string,t,entry,parent,result,entry,set,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1493370460;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				parentResult.entrySet().forEach(entry -> {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,parent,result,entry,set,for,each,entry,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1496837955;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				parentResult.entrySet().forEach(entry -> {_					String beanName = entry.getKey()__					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, entry.getValue())__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,parent,result,entry,set,for,each,entry,string,bean,name,entry,get,key,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,entry,get,value,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1497271072;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1504419574;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1519514826;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1533823565;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created;public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1533943217;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created_@see ListableBeanFactory#getBeansOfType(Class);public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				parentResult.forEach((beanName, beanType) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanType)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created,see,listable,bean,factory,get,beans,of,type,class;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,parent,result,for,each,bean,name,bean,type,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,type,return,result
BeanFactoryUtils -> public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1539119689;Return all beans of the given type or subtypes, also picking up beans defined in_ancestor bean factories if the current bean factory is a HierarchicalBeanFactory._The returned Map will only contain beans of this type._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the Map of matching bean instances, or an empty Map if none_@throws BeansException if a bean could not be created_@see ListableBeanFactory#getBeansOfType(Class);public static <T> Map<String, T> beansOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> result = new LinkedHashMap<>(4)__		result.putAll(lbf.getBeansOfType(type))__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				Map<String, T> parentResult = beansOfTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				parentResult.forEach((beanName, beanInstance) -> {_					if (!result.containsKey(beanName) && !hbf.containsLocalBean(beanName)) {_						result.put(beanName, beanInstance)__					}_				})__			}_		}_		return result__	};return,all,beans,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,the,returned,map,will,only,contain,beans,of,this,type,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,map,of,matching,bean,instances,or,an,empty,map,if,none,throws,beans,exception,if,a,bean,could,not,be,created,see,listable,bean,factory,get,beans,of,type,class;public,static,t,map,string,t,beans,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,result,new,linked,hash,map,4,result,put,all,lbf,get,beans,of,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,map,string,t,parent,result,beans,of,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,parent,result,for,each,bean,name,bean,instance,if,result,contains,key,bean,name,hbf,contains,local,bean,bean,name,result,put,bean,name,bean,instance,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit);1328020251;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit);1337516454;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit);1338031377;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit);1356735495;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors( 			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit);1362408075;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(_			ListableBeanFactory lbf, Class type, boolean includeNonSingletons, boolean allowEagerInit) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,boolean,include,non,singletons,boolean,allow,eager,init,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,include,non,singletons,allow,eager,init,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,include,non,singletons,allow,eager,init,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type);1328020251;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of <code>beanNamesForTypeIncludingAncestors</code> automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,code,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type);1337516454;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of <code>beanNamesForTypeIncludingAncestors</code> automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,code,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type);1338031377;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of <code>beanNamesForTypeIncludingAncestors</code> automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,code,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type);1356735495;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type);1362408075;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1328020251;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of <code>beanOfTypeIncludingAncestors</code> automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,code,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1337516454;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of <code>beanOfTypeIncludingAncestors</code> automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,code,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1338031377;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of <code>beanOfTypeIncludingAncestors</code> automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,code,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1356735495;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1362408075;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1383167211;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1426716313;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1467730834;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1493370460;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1496837955;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1497271072;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1504419574;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1519514826;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1533823565;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1533943217;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created_@see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class);public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created,see,beans,of,type,including,ancestors,listable,bean,factory,class;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type) 			throws BeansException;1539119689;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanOfTypeIncludingAncestors} automatically includes_prototypes and FactoryBeans._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created_@see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class);public static <T> T beanOfTypeIncludingAncestors(ListableBeanFactory lbf, Class<T> type)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,of,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created,see,beans,of,type,including,ancestors,listable,bean,factory,class;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static String transformedBeanName(String name);1328020251;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1337516454;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1338031377;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1356735495;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1362408075;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1383167211;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1426716313;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1467730834;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1493370460;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1496837955;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1497271072;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1504419574;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1519514826;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		String beanName = name__		while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__		}_		return beanName__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,string,bean,name,name,while,bean,name,starts,with,bean,factory,bean,name,bean,name,substring,bean,factory,length,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1533823565;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			return name__		}_		return transformedBeanNameCache.computeIfAbsent(name, beanName -> {_			do {_				beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__			}_			while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__			return beanName__		})__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,if,name,starts,with,bean,factory,return,name,return,transformed,bean,name,cache,compute,if,absent,name,bean,name,do,bean,name,bean,name,substring,bean,factory,length,while,bean,name,starts,with,bean,factory,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1533943217;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			return name__		}_		return transformedBeanNameCache.computeIfAbsent(name, beanName -> {_			do {_				beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__			}_			while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__			return beanName__		})__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,if,name,starts,with,bean,factory,return,name,return,transformed,bean,name,cache,compute,if,absent,name,bean,name,do,bean,name,bean,name,substring,bean,factory,length,while,bean,name,starts,with,bean,factory,return,bean,name
BeanFactoryUtils -> public static String transformedBeanName(String name);1539119689;Return the actual bean name, stripping out the factory dereference_prefix (if any, also stripping repeated factory prefixes if found)._@param name the name of the bean_@return the transformed name_@see BeanFactory#FACTORY_BEAN_PREFIX;public static String transformedBeanName(String name) {_		Assert.notNull(name, "'name' must not be null")__		if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) {_			return name__		}_		return transformedBeanNameCache.computeIfAbsent(name, beanName -> {_			do {_				beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length())__			}_			while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX))__			return beanName__		})__	};return,the,actual,bean,name,stripping,out,the,factory,dereference,prefix,if,any,also,stripping,repeated,factory,prefixes,if,found,param,name,the,name,of,the,bean,return,the,transformed,name,see,bean,factory;public,static,string,transformed,bean,name,string,name,assert,not,null,name,name,must,not,be,null,if,name,starts,with,bean,factory,return,name,return,transformed,bean,name,cache,compute,if,absent,name,bean,name,do,bean,name,bean,name,substring,bean,factory,length,while,bean,name,starts,with,bean,factory,return,bean,name
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1426716313;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1467730834;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1493370460;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1496837955;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1497271072;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1504419574;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1519514826;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1533823565;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1533943217;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2_@see ListableBeanFactory#getBeanNamesForType(ResolvableType);public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2,see,listable,bean,factory,get,bean,names,for,type,resolvable,type;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type);1539119689;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code ResolvableType})_@return the array of matching bean names, or an empty array if none_@since 4.2_@see ListableBeanFactory#getBeanNamesForType(ResolvableType);public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, ResolvableType type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,resolvable,type,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,4,2,see,listable,bean,factory,get,bean,names,for,type,resolvable,type;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,resolvable,type,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1328020251;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1337516454;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1338031377;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1356735495;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1362408075;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1383167211;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1426716313;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1467730834;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1493370460;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1496837955;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1497271072;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1504419574;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1519514826;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1533823565;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1533943217;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created_@see ListableBeanFactory#getBeansOfType(Class, boolean, boolean);public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created,see,listable,bean,factory,get,beans,of,type,class,boolean,boolean;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfType( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1539119689;Return a single bean of the given type or subtypes, not looking in ancestor_factories. Useful convenience method when we expect a single bean and_don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit"_flag is set, which means that FactoryBeans will get initialized. If the_object created by the FactoryBean doesn't match, the raw FactoryBean itself_will be matched against the type. If "allowEagerInit" is not set,_only raw FactoryBeans will be checked (which doesn't require initialization_of each FactoryBean)._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created_@see ListableBeanFactory#getBeansOfType(Class, boolean, boolean);public static <T> T beanOfType(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		Map<String, T> beansOfType = lbf.getBeansOfType(type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,not,looking,in,ancestor,factories,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created,see,listable,bean,factory,get,beans,of,type,class,boolean,boolean;public,static,t,t,bean,of,type,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,assert,not,null,lbf,listable,bean,factory,must,not,be,null,map,string,t,beans,of,type,lbf,get,beans,of,type,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1362408075;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int nrFound = matchingBeans.size()__		if (nrFound == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (nrFound > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,nr,found,matching,beans,size,if,nr,found,1,return,matching,beans,values,iterator,next,else,if,nr,found,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1383167211;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int nrFound = matchingBeans.size()__		if (nrFound == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (nrFound > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,nr,found,matching,beans,size,if,nr,found,1,return,matching,beans,values,iterator,next,else,if,nr,found,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1426716313;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int nrFound = matchingBeans.size()__		if (nrFound == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (nrFound > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,nr,found,matching,beans,size,if,nr,found,1,return,matching,beans,values,iterator,next,else,if,nr,found,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1467730834;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int nrFound = matchingBeans.size()__		if (nrFound == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (nrFound > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,nr,found,matching,beans,size,if,nr,found,1,return,matching,beans,values,iterator,next,else,if,nr,found,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1493370460;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int nrFound = matchingBeans.size()__		if (nrFound == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (nrFound > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,nr,found,matching,beans,size,if,nr,found,1,return,matching,beans,values,iterator,next,else,if,nr,found,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1496837955;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int nrFound = matchingBeans.size()__		if (nrFound == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (nrFound > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,nr,found,matching,beans,size,if,nr,found,1,return,matching,beans,values,iterator,next,else,if,nr,found,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1497271072;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int nrFound = matchingBeans.size()__		if (nrFound == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (nrFound > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,nr,found,matching,beans,size,if,nr,found,1,return,matching,beans,values,iterator,next,else,if,nr,found,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1504419574;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int nrFound = matchingBeans.size()__		if (nrFound == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (nrFound > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,nr,found,matching,beans,size,if,nr,found,1,return,matching,beans,values,iterator,next,else,if,nr,found,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1519514826;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int count = matchingBeans.size()__		if (count == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (count > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,count,matching,beans,size,if,count,1,return,matching,beans,values,iterator,next,else,if,count,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1533823565;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int count = matchingBeans.size()__		if (count == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (count > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,count,matching,beans,size,if,count,1,return,matching,beans,values,iterator,next,else,if,count,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1533943217;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int count = matchingBeans.size()__		if (count == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (count > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,count,matching,beans,size,if,count,1,return,matching,beans,values,iterator,next,else,if,count,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans);1539119689;Extract a unique bean for the given type from the given Map of matching beans._@param type type of bean to match_@param matchingBeans all matching beans found_@return the unique bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found;private static <T> T uniqueBean(Class<T> type, Map<String, T> matchingBeans) {_		int count = matchingBeans.size()__		if (count == 1) {_			return matchingBeans.values().iterator().next()__		}_		else if (count > 1) {_			throw new NoUniqueBeanDefinitionException(type, matchingBeans.keySet())__		}_		else {_			throw new NoSuchBeanDefinitionException(type)__		}_	};extract,a,unique,bean,for,the,given,type,from,the,given,map,of,matching,beans,param,type,type,of,bean,to,match,param,matching,beans,all,matching,beans,found,return,the,unique,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found;private,static,t,t,unique,bean,class,t,type,map,string,t,matching,beans,int,count,matching,beans,size,if,count,1,return,matching,beans,values,iterator,next,else,if,count,1,throw,new,no,unique,bean,definition,exception,type,matching,beans,key,set,else,throw,new,no,such,bean,definition,exception,type
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1328020251;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1337516454;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1338031377;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1356735495;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1362408075;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1383167211;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1426716313;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1467730834;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1493370460;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1496837955;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1497271072;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1504419574;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1519514826;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1533823565;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1533943217;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf);1539119689;Return all bean names in the factory, including ancestor factories._@param lbf the bean factory_@return the array of matching bean names, or an empty array if none_@see #beanNamesForTypeIncludingAncestors;public static String[] beanNamesIncludingAncestors(ListableBeanFactory lbf) {_		return beanNamesForTypeIncludingAncestors(lbf, Object.class)__	};return,all,bean,names,in,the,factory,including,ancestor,factories,param,lbf,the,bean,factory,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,bean,names,for,type,including,ancestors;public,static,string,bean,names,including,ancestors,listable,bean,factory,lbf,return,bean,names,for,type,including,ancestors,lbf,object,class
BeanFactoryUtils -> public static String[] beanNamesForAnnotationIncludingAncestors( 			ListableBeanFactory lbf, Class<? extends Annotation> annotationType);1504419574;Get all bean names whose {@code Class} has the supplied {@link Annotation}_type, including those defined in ancestor factories, without creating any bean_instances yet. Will return unique names in case of overridden bean definitions._@param lbf the bean factory_@param annotationType the type of annotation to look for_@return the array of matching bean names, or an empty array if none_@since 5.0;public static String[] beanNamesForAnnotationIncludingAncestors(_			ListableBeanFactory lbf, Class<? extends Annotation> annotationType) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForAnnotation(annotationType)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForAnnotationIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), annotationType)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,whose,code,class,has,the,supplied,link,annotation,type,including,those,defined,in,ancestor,factories,without,creating,any,bean,instances,yet,will,return,unique,names,in,case,of,overridden,bean,definitions,param,lbf,the,bean,factory,param,annotation,type,the,type,of,annotation,to,look,for,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,5,0;public,static,string,bean,names,for,annotation,including,ancestors,listable,bean,factory,lbf,class,extends,annotation,annotation,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,annotation,annotation,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,annotation,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,annotation,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForAnnotationIncludingAncestors( 			ListableBeanFactory lbf, Class<? extends Annotation> annotationType);1519514826;Get all bean names whose {@code Class} has the supplied {@link Annotation}_type, including those defined in ancestor factories, without creating any bean_instances yet. Will return unique names in case of overridden bean definitions._@param lbf the bean factory_@param annotationType the type of annotation to look for_@return the array of matching bean names, or an empty array if none_@since 5.0;public static String[] beanNamesForAnnotationIncludingAncestors(_			ListableBeanFactory lbf, Class<? extends Annotation> annotationType) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForAnnotation(annotationType)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForAnnotationIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), annotationType)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,whose,code,class,has,the,supplied,link,annotation,type,including,those,defined,in,ancestor,factories,without,creating,any,bean,instances,yet,will,return,unique,names,in,case,of,overridden,bean,definitions,param,lbf,the,bean,factory,param,annotation,type,the,type,of,annotation,to,look,for,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,5,0;public,static,string,bean,names,for,annotation,including,ancestors,listable,bean,factory,lbf,class,extends,annotation,annotation,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,annotation,annotation,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,annotation,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,annotation,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForAnnotationIncludingAncestors( 			ListableBeanFactory lbf, Class<? extends Annotation> annotationType);1533823565;Get all bean names whose {@code Class} has the supplied {@link Annotation}_type, including those defined in ancestor factories, without creating any bean_instances yet. Will return unique names in case of overridden bean definitions._@param lbf the bean factory_@param annotationType the type of annotation to look for_@return the array of matching bean names, or an empty array if none_@since 5.0;public static String[] beanNamesForAnnotationIncludingAncestors(_			ListableBeanFactory lbf, Class<? extends Annotation> annotationType) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForAnnotation(annotationType)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForAnnotationIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), annotationType)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,whose,code,class,has,the,supplied,link,annotation,type,including,those,defined,in,ancestor,factories,without,creating,any,bean,instances,yet,will,return,unique,names,in,case,of,overridden,bean,definitions,param,lbf,the,bean,factory,param,annotation,type,the,type,of,annotation,to,look,for,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,5,0;public,static,string,bean,names,for,annotation,including,ancestors,listable,bean,factory,lbf,class,extends,annotation,annotation,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,annotation,annotation,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,annotation,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,annotation,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForAnnotationIncludingAncestors( 			ListableBeanFactory lbf, Class<? extends Annotation> annotationType);1533943217;Get all bean names whose {@code Class} has the supplied {@link Annotation}_type, including those defined in ancestor factories, without creating any bean_instances yet. Will return unique names in case of overridden bean definitions._@param lbf the bean factory_@param annotationType the type of annotation to look for_@return the array of matching bean names, or an empty array if none_@since 5.0_@see ListableBeanFactory#getBeanNamesForAnnotation(Class);public static String[] beanNamesForAnnotationIncludingAncestors(_			ListableBeanFactory lbf, Class<? extends Annotation> annotationType) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForAnnotation(annotationType)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForAnnotationIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), annotationType)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,whose,code,class,has,the,supplied,link,annotation,type,including,those,defined,in,ancestor,factories,without,creating,any,bean,instances,yet,will,return,unique,names,in,case,of,overridden,bean,definitions,param,lbf,the,bean,factory,param,annotation,type,the,type,of,annotation,to,look,for,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,5,0,see,listable,bean,factory,get,bean,names,for,annotation,class;public,static,string,bean,names,for,annotation,including,ancestors,listable,bean,factory,lbf,class,extends,annotation,annotation,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,annotation,annotation,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,annotation,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,annotation,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForAnnotationIncludingAncestors( 			ListableBeanFactory lbf, Class<? extends Annotation> annotationType);1539119689;Get all bean names whose {@code Class} has the supplied {@link Annotation}_type, including those defined in ancestor factories, without creating any bean_instances yet. Will return unique names in case of overridden bean definitions._@param lbf the bean factory_@param annotationType the type of annotation to look for_@return the array of matching bean names, or an empty array if none_@since 5.0_@see ListableBeanFactory#getBeanNamesForAnnotation(Class);public static String[] beanNamesForAnnotationIncludingAncestors(_			ListableBeanFactory lbf, Class<? extends Annotation> annotationType) {__		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForAnnotation(annotationType)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForAnnotationIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), annotationType)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,whose,code,class,has,the,supplied,link,annotation,type,including,those,defined,in,ancestor,factories,without,creating,any,bean,instances,yet,will,return,unique,names,in,case,of,overridden,bean,definitions,param,lbf,the,bean,factory,param,annotation,type,the,type,of,annotation,to,look,for,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,since,5,0,see,listable,bean,factory,get,bean,names,for,annotation,class;public,static,string,bean,names,for,annotation,including,ancestors,listable,bean,factory,lbf,class,extends,annotation,annotation,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,annotation,annotation,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,annotation,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,annotation,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1383167211;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1426716313;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<String>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,string,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1467730834;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1493370460;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1496837955;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1497271072;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1504419574;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				List<String> resultList = new ArrayList<>()__				resultList.addAll(Arrays.asList(result))__				for (String beanName : parentResult) {_					if (!resultList.contains(beanName) && !hbf.containsLocalBean(beanName)) {_						resultList.add(beanName)__					}_				}_				result = StringUtils.toStringArray(resultList)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,list,string,result,list,new,array,list,result,list,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,result,list,contains,bean,name,hbf,contains,local,bean,bean,name,result,list,add,bean,name,result,string,utils,to,string,array,result,list,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1519514826;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1533823565;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none;public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1533943217;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none_@see ListableBeanFactory#getBeanNamesForType(Class);public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,listable,bean,factory,get,bean,names,for,type,class;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type);1539119689;Get all bean names for the given type, including those defined in ancestor_factories. Will return unique names in case of overridden bean definitions._<p>Does consider objects created by FactoryBeans, which means that FactoryBeans_will get initialized. If the object created by the FactoryBean doesn't match,_the raw FactoryBean itself will be matched against the type._<p>This version of {@code beanNamesForTypeIncludingAncestors} automatically_includes prototypes and FactoryBeans._@param lbf the bean factory_@param type the type that beans must match (as a {@code Class})_@return the array of matching bean names, or an empty array if none_@see ListableBeanFactory#getBeanNamesForType(Class);public static String[] beanNamesForTypeIncludingAncestors(ListableBeanFactory lbf, Class<?> type) {_		Assert.notNull(lbf, "ListableBeanFactory must not be null")__		String[] result = lbf.getBeanNamesForType(type)__		if (lbf instanceof HierarchicalBeanFactory) {_			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf__			if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {_				String[] parentResult = beanNamesForTypeIncludingAncestors(_						(ListableBeanFactory) hbf.getParentBeanFactory(), type)__				result = mergeNamesWithParent(result, parentResult, hbf)__			}_		}_		return result__	};get,all,bean,names,for,the,given,type,including,those,defined,in,ancestor,factories,will,return,unique,names,in,case,of,overridden,bean,definitions,p,does,consider,objects,created,by,factory,beans,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,p,this,version,of,code,bean,names,for,type,including,ancestors,automatically,includes,prototypes,and,factory,beans,param,lbf,the,bean,factory,param,type,the,type,that,beans,must,match,as,a,code,class,return,the,array,of,matching,bean,names,or,an,empty,array,if,none,see,listable,bean,factory,get,bean,names,for,type,class;public,static,string,bean,names,for,type,including,ancestors,listable,bean,factory,lbf,class,type,assert,not,null,lbf,listable,bean,factory,must,not,be,null,string,result,lbf,get,bean,names,for,type,type,if,lbf,instanceof,hierarchical,bean,factory,hierarchical,bean,factory,hbf,hierarchical,bean,factory,lbf,if,hbf,get,parent,bean,factory,instanceof,listable,bean,factory,string,parent,result,bean,names,for,type,including,ancestors,listable,bean,factory,hbf,get,parent,bean,factory,type,result,merge,names,with,parent,result,parent,result,hbf,return,result
BeanFactoryUtils -> private static String[] mergeNamesWithParent(String[] result, String[] parentResult, HierarchicalBeanFactory hbf);1519514826;Merge the given bean names result with the given parent result._@param result the local bean name result_@param parentResult the parent bean name result (possibly empty)_@param hbf the local bean factory_@return the merged result (possibly the local result as-is)_@since 4.3.15;private static String[] mergeNamesWithParent(String[] result, String[] parentResult, HierarchicalBeanFactory hbf) {_		if (parentResult.length == 0) {_			return result__		}_		List<String> merged = new ArrayList<>(result.length + parentResult.length)__		merged.addAll(Arrays.asList(result))__		for (String beanName : parentResult) {_			if (!merged.contains(beanName) && !hbf.containsLocalBean(beanName)) {_				merged.add(beanName)__			}_		}_		return StringUtils.toStringArray(merged)__	};merge,the,given,bean,names,result,with,the,given,parent,result,param,result,the,local,bean,name,result,param,parent,result,the,parent,bean,name,result,possibly,empty,param,hbf,the,local,bean,factory,return,the,merged,result,possibly,the,local,result,as,is,since,4,3,15;private,static,string,merge,names,with,parent,string,result,string,parent,result,hierarchical,bean,factory,hbf,if,parent,result,length,0,return,result,list,string,merged,new,array,list,result,length,parent,result,length,merged,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,merged,contains,bean,name,hbf,contains,local,bean,bean,name,merged,add,bean,name,return,string,utils,to,string,array,merged
BeanFactoryUtils -> private static String[] mergeNamesWithParent(String[] result, String[] parentResult, HierarchicalBeanFactory hbf);1533823565;Merge the given bean names result with the given parent result._@param result the local bean name result_@param parentResult the parent bean name result (possibly empty)_@param hbf the local bean factory_@return the merged result (possibly the local result as-is)_@since 4.3.15;private static String[] mergeNamesWithParent(String[] result, String[] parentResult, HierarchicalBeanFactory hbf) {_		if (parentResult.length == 0) {_			return result__		}_		List<String> merged = new ArrayList<>(result.length + parentResult.length)__		merged.addAll(Arrays.asList(result))__		for (String beanName : parentResult) {_			if (!merged.contains(beanName) && !hbf.containsLocalBean(beanName)) {_				merged.add(beanName)__			}_		}_		return StringUtils.toStringArray(merged)__	};merge,the,given,bean,names,result,with,the,given,parent,result,param,result,the,local,bean,name,result,param,parent,result,the,parent,bean,name,result,possibly,empty,param,hbf,the,local,bean,factory,return,the,merged,result,possibly,the,local,result,as,is,since,4,3,15;private,static,string,merge,names,with,parent,string,result,string,parent,result,hierarchical,bean,factory,hbf,if,parent,result,length,0,return,result,list,string,merged,new,array,list,result,length,parent,result,length,merged,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,merged,contains,bean,name,hbf,contains,local,bean,bean,name,merged,add,bean,name,return,string,utils,to,string,array,merged
BeanFactoryUtils -> private static String[] mergeNamesWithParent(String[] result, String[] parentResult, HierarchicalBeanFactory hbf);1533943217;Merge the given bean names result with the given parent result._@param result the local bean name result_@param parentResult the parent bean name result (possibly empty)_@param hbf the local bean factory_@return the merged result (possibly the local result as-is)_@since 4.3.15;private static String[] mergeNamesWithParent(String[] result, String[] parentResult, HierarchicalBeanFactory hbf) {_		if (parentResult.length == 0) {_			return result__		}_		List<String> merged = new ArrayList<>(result.length + parentResult.length)__		merged.addAll(Arrays.asList(result))__		for (String beanName : parentResult) {_			if (!merged.contains(beanName) && !hbf.containsLocalBean(beanName)) {_				merged.add(beanName)__			}_		}_		return StringUtils.toStringArray(merged)__	};merge,the,given,bean,names,result,with,the,given,parent,result,param,result,the,local,bean,name,result,param,parent,result,the,parent,bean,name,result,possibly,empty,param,hbf,the,local,bean,factory,return,the,merged,result,possibly,the,local,result,as,is,since,4,3,15;private,static,string,merge,names,with,parent,string,result,string,parent,result,hierarchical,bean,factory,hbf,if,parent,result,length,0,return,result,list,string,merged,new,array,list,result,length,parent,result,length,merged,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,merged,contains,bean,name,hbf,contains,local,bean,bean,name,merged,add,bean,name,return,string,utils,to,string,array,merged
BeanFactoryUtils -> private static String[] mergeNamesWithParent(String[] result, String[] parentResult, HierarchicalBeanFactory hbf);1539119689;Merge the given bean names result with the given parent result._@param result the local bean name result_@param parentResult the parent bean name result (possibly empty)_@param hbf the local bean factory_@return the merged result (possibly the local result as-is)_@since 4.3.15;private static String[] mergeNamesWithParent(String[] result, String[] parentResult, HierarchicalBeanFactory hbf) {_		if (parentResult.length == 0) {_			return result__		}_		List<String> merged = new ArrayList<>(result.length + parentResult.length)__		merged.addAll(Arrays.asList(result))__		for (String beanName : parentResult) {_			if (!merged.contains(beanName) && !hbf.containsLocalBean(beanName)) {_				merged.add(beanName)__			}_		}_		return StringUtils.toStringArray(merged)__	};merge,the,given,bean,names,result,with,the,given,parent,result,param,result,the,local,bean,name,result,param,parent,result,the,parent,bean,name,result,possibly,empty,param,hbf,the,local,bean,factory,return,the,merged,result,possibly,the,local,result,as,is,since,4,3,15;private,static,string,merge,names,with,parent,string,result,string,parent,result,hierarchical,bean,factory,hbf,if,parent,result,length,0,return,result,list,string,merged,new,array,list,result,length,parent,result,length,merged,add,all,arrays,as,list,result,for,string,bean,name,parent,result,if,merged,contains,bean,name,hbf,contains,local,bean,bean,name,merged,add,bean,name,return,string,utils,to,string,array,merged
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1328020251;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1337516454;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1338031377;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1356735495;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws org.springframework.beans.factory.NoSuchBeanDefinitionException_if 0 or more than 1 beans of the given type were found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		if (beansOfType.size() == 1) {_			return beansOfType.values().iterator().next()__		}_		else {_			throw new NoSuchBeanDefinitionException(type, "expected single bean but found " + beansOfType.size())__		}_	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,org,springframework,beans,factory,no,such,bean,definition,exception,if,0,or,more,than,1,beans,of,the,given,type,were,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,if,beans,of,type,size,1,return,beans,of,type,values,iterator,next,else,throw,new,no,such,bean,definition,exception,type,expected,single,bean,but,found,beans,of,type,size
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1362408075;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1383167211;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1426716313;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1467730834;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1493370460;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1496837955;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1497271072;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1504419574;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1519514826;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1533823565;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created;public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1533943217;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created_@see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean);public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created,see,beans,of,type,including,ancestors,listable,bean,factory,class,boolean,boolean;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
BeanFactoryUtils -> public static <T> T beanOfTypeIncludingAncestors( 			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) 			throws BeansException;1539119689;Return a single bean of the given type or subtypes, also picking up beans_defined in ancestor bean factories if the current bean factory is a_HierarchicalBeanFactory. Useful convenience method when we expect a_single bean and don't care about the bean name._<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,_which means that FactoryBeans will get initialized. If the object created by the_FactoryBean doesn't match, the raw FactoryBean itself will be matched against the_type. If "allowEagerInit" is not set, only raw FactoryBeans will be checked_(which doesn't require initialization of each FactoryBean)._<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,_i.e. such beans will be returned from the lowest factory that they are being found in,_hiding corresponding beans in ancestor factories.</b> This feature allows for_'replacing' beans by explicitly choosing the same bean name in a child factory__the bean in the ancestor factory won't be visible then, not even for by-type lookups._@param lbf the bean factory_@param type type of bean to match_@param includeNonSingletons whether to include prototype or scoped beans too_or just singletons (also applies to FactoryBeans)_@param allowEagerInit whether to initialize <i>lazy-init singletons</i> and_<i>objects created by FactoryBeans</i> (or by factory methods with a_"factory-bean" reference) for the type check. Note that FactoryBeans need to be_eagerly initialized to determine their type: So be aware that passing in "true"_for this flag will initialize FactoryBeans and "factory-bean" references._@return the matching bean instance_@throws NoSuchBeanDefinitionException if no bean of the given type was found_@throws NoUniqueBeanDefinitionException if more than one bean of the given type was found_@throws BeansException if the bean could not be created_@see #beansOfTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean);public static <T> T beanOfTypeIncludingAncestors(_			ListableBeanFactory lbf, Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)_			throws BeansException {__		Map<String, T> beansOfType = beansOfTypeIncludingAncestors(lbf, type, includeNonSingletons, allowEagerInit)__		return uniqueBean(type, beansOfType)__	};return,a,single,bean,of,the,given,type,or,subtypes,also,picking,up,beans,defined,in,ancestor,bean,factories,if,the,current,bean,factory,is,a,hierarchical,bean,factory,useful,convenience,method,when,we,expect,a,single,bean,and,don,t,care,about,the,bean,name,p,does,consider,objects,created,by,factory,beans,if,the,allow,eager,init,flag,is,set,which,means,that,factory,beans,will,get,initialized,if,the,object,created,by,the,factory,bean,doesn,t,match,the,raw,factory,bean,itself,will,be,matched,against,the,type,if,allow,eager,init,is,not,set,only,raw,factory,beans,will,be,checked,which,doesn,t,require,initialization,of,each,factory,bean,p,b,note,beans,of,the,same,name,will,take,precedence,at,the,lowest,factory,level,i,e,such,beans,will,be,returned,from,the,lowest,factory,that,they,are,being,found,in,hiding,corresponding,beans,in,ancestor,factories,b,this,feature,allows,for,replacing,beans,by,explicitly,choosing,the,same,bean,name,in,a,child,factory,the,bean,in,the,ancestor,factory,won,t,be,visible,then,not,even,for,by,type,lookups,param,lbf,the,bean,factory,param,type,type,of,bean,to,match,param,include,non,singletons,whether,to,include,prototype,or,scoped,beans,too,or,just,singletons,also,applies,to,factory,beans,param,allow,eager,init,whether,to,initialize,i,lazy,init,singletons,i,and,i,objects,created,by,factory,beans,i,or,by,factory,methods,with,a,factory,bean,reference,for,the,type,check,note,that,factory,beans,need,to,be,eagerly,initialized,to,determine,their,type,so,be,aware,that,passing,in,true,for,this,flag,will,initialize,factory,beans,and,factory,bean,references,return,the,matching,bean,instance,throws,no,such,bean,definition,exception,if,no,bean,of,the,given,type,was,found,throws,no,unique,bean,definition,exception,if,more,than,one,bean,of,the,given,type,was,found,throws,beans,exception,if,the,bean,could,not,be,created,see,beans,of,type,including,ancestors,listable,bean,factory,class,boolean,boolean;public,static,t,t,bean,of,type,including,ancestors,listable,bean,factory,lbf,class,t,type,boolean,include,non,singletons,boolean,allow,eager,init,throws,beans,exception,map,string,t,beans,of,type,beans,of,type,including,ancestors,lbf,type,include,non,singletons,allow,eager,init,return,unique,bean,type,beans,of,type
