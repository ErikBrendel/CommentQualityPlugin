commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return the SortDefinition that this comparator uses.  */ ;/**  * Return the SortDefinition that this comparator uses.  */ public final SortDefinition getSortDefinition() {     return this.sortDefinition. }
false;public;2;30;;@Override @SuppressWarnings("unchecked") public int compare(T o1, T o2) {     Object v1 = getPropertyValue(o1).     Object v2 = getPropertyValue(o2).     if (this.sortDefinition.isIgnoreCase() && (v1 instanceof String) && (v2 instanceof String)) {         v1 = ((String) v1).toLowerCase().         v2 = ((String) v2).toLowerCase().     }     int result.     // Put an object with null property at the end of the sort result.     try {         if (v1 != null) {             result = (v2 != null ? ((Comparable<Object>) v1).compareTo(v2) : -1).         } else {             result = (v2 != null ? 1 : 0).         }     } catch (RuntimeException ex) {         if (logger.isDebugEnabled()) {             logger.debug("Could not sort objects [" + o1 + "] and [" + o2 + "]", ex).         }         return 0.     }     return (this.sortDefinition.isAscending() ? result : -result). }
true;private;1;14;/**  * Get the SortDefinition's property value for the given object.  * @param obj the object to get the property value for  * @return the property value  */ ;/**  * Get the SortDefinition's property value for the given object.  * @param obj the object to get the property value for  * @return the property value  */ @Nullable private Object getPropertyValue(Object obj) {     // first place, let the exception through.     try {         this.beanWrapper.setWrappedInstance(obj).         return this.beanWrapper.getPropertyValue(this.sortDefinition.getProperty()).     } catch (BeansException ex) {         logger.debug("PropertyComparator could not access property - treating as null for sorting", ex).         return null.     } }
true;public,static;2;5;/**  * Sort the given List according to the given sort definition.  * <p>Note: Contained objects have to provide the given property  * in the form of a bean property, i.e. a getXXX method.  * @param source the input List  * @param sortDefinition the parameters to sort by  * @throws java.lang.IllegalArgumentException in case of a missing propertyName  */ ;/**  * Sort the given List according to the given sort definition.  * <p>Note: Contained objects have to provide the given property  * in the form of a bean property, i.e. a getXXX method.  * @param source the input List  * @param sortDefinition the parameters to sort by  * @throws java.lang.IllegalArgumentException in case of a missing propertyName  */ public static void sort(List<?> source, SortDefinition sortDefinition) throws BeansException {     if (StringUtils.hasText(sortDefinition.getProperty())) {         source.sort(new PropertyComparator<>(sortDefinition)).     } }
true;public,static;2;5;/**  * Sort the given source according to the given sort definition.  * <p>Note: Contained objects have to provide the given property  * in the form of a bean property, i.e. a getXXX method.  * @param source input source  * @param sortDefinition the parameters to sort by  * @throws java.lang.IllegalArgumentException in case of a missing propertyName  */ ;/**  * Sort the given source according to the given sort definition.  * <p>Note: Contained objects have to provide the given property  * in the form of a bean property, i.e. a getXXX method.  * @param source input source  * @param sortDefinition the parameters to sort by  * @throws java.lang.IllegalArgumentException in case of a missing propertyName  */ public static void sort(Object[] source, SortDefinition sortDefinition) throws BeansException {     if (StringUtils.hasText(sortDefinition.getProperty())) {         Arrays.sort(source, new PropertyComparator<>(sortDefinition)).     } }
