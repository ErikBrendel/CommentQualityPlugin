commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getParentName() {     return null. }
false;public;1;6;;@Override public void setParentName(@Nullable String parentName) {     if (parentName != null) {         throw new IllegalArgumentException("Root bean cannot be changed into a child bean with parent reference").     } }
true;public;1;3;/**  * Register a target definition that is being decorated by this bean definition.  */ ;/**  * Register a target definition that is being decorated by this bean definition.  */ public void setDecoratedDefinition(@Nullable BeanDefinitionHolder decoratedDefinition) {     this.decoratedDefinition = decoratedDefinition. }
true;public;0;4;/**  * Return the target definition that is being decorated by this bean definition, if any.  */ ;/**  * Return the target definition that is being decorated by this bean definition, if any.  */ @Nullable public BeanDefinitionHolder getDecoratedDefinition() {     return this.decoratedDefinition. }
true;public;1;3;/**  * Specify the {@link AnnotatedElement} defining qualifiers,  * to be used instead of the target class or factory method.  * @since 4.3.3  * @see #setTargetType(ResolvableType)  * @see #getResolvedFactoryMethod()  */ ;/**  * Specify the {@link AnnotatedElement} defining qualifiers,  * to be used instead of the target class or factory method.  * @since 4.3.3  * @see #setTargetType(ResolvableType)  * @see #getResolvedFactoryMethod()  */ public void setQualifiedElement(@Nullable AnnotatedElement qualifiedElement) {     this.qualifiedElement = qualifiedElement. }
true;public;0;4;/**  * Return the {@link AnnotatedElement} defining qualifiers, if any.  * Otherwise, the factory method and target class will be checked.  * @since 4.3.3  */ ;/**  * Return the {@link AnnotatedElement} defining qualifiers, if any.  * Otherwise, the factory method and target class will be checked.  * @since 4.3.3  */ @Nullable public AnnotatedElement getQualifiedElement() {     return this.qualifiedElement. }
true;public;1;3;/**  * Specify a generics-containing target type of this bean definition, if known in advance.  * @since 4.3.3  */ ;/**  * Specify a generics-containing target type of this bean definition, if known in advance.  * @since 4.3.3  */ public void setTargetType(ResolvableType targetType) {     this.targetType = targetType. }
true;public;1;3;/**  * Specify the target type of this bean definition, if known in advance.  * @since 3.2.2  */ ;/**  * Specify the target type of this bean definition, if known in advance.  * @since 3.2.2  */ public void setTargetType(@Nullable Class<?> targetType) {     this.targetType = (targetType != null ? ResolvableType.forClass(targetType) : null). }
true;public;0;8;/**  * Return the target type of this bean definition, if known  * (either specified in advance or resolved on first instantiation).  * @since 3.2.2  */ ;/**  * Return the target type of this bean definition, if known  * (either specified in advance or resolved on first instantiation).  * @since 3.2.2  */ @Nullable public Class<?> getTargetType() {     if (this.resolvedTargetType != null) {         return this.resolvedTargetType.     }     ResolvableType targetType = this.targetType.     return (targetType != null ? targetType.resolve() : null). }
true;public;0;4;/**  * Return a {@link ResolvableType} for this bean definition,  * either from runtime-cached type information or from configuration-time  * {@link #setTargetType(ResolvableType)} or {@link #setBeanClass(Class)}.  * @since 5.1  * @see #getTargetType()  * @see #getBeanClass()  */ ;/**  * Return a {@link ResolvableType} for this bean definition,  * either from runtime-cached type information or from configuration-time  * {@link #setTargetType(ResolvableType)} or {@link #setBeanClass(Class)}.  * @since 5.1  * @see #getTargetType()  * @see #getBeanClass()  */ public ResolvableType getResolvableType() {     ResolvableType targetType = this.targetType.     return (targetType != null ? targetType : ResolvableType.forClass(getBeanClass())). }
true;public;0;4;/**  * Determine preferred constructors to use for default construction, if any.  * Constructor arguments will be autowired if necessary.  * @return one or more preferred constructors, or {@code null} if none  * (in which case the regular no-arg default constructor will be called)  * @since 5.1  */ ;/**  * Determine preferred constructors to use for default construction, if any.  * Constructor arguments will be autowired if necessary.  * @return one or more preferred constructors, or {@code null} if none  * (in which case the regular no-arg default constructor will be called)  * @since 5.1  */ @Nullable public Constructor<?>[] getPreferredConstructors() {     return null. }
true;public;1;5;/**  * Specify a factory method name that refers to a non-overloaded method.  */ ;/**  * Specify a factory method name that refers to a non-overloaded method.  */ public void setUniqueFactoryMethodName(String name) {     Assert.hasText(name, "Factory method name must not be empty").     setFactoryMethodName(name).     this.isFactoryMethodUnique = true. }
true;public;1;3;/**  * Check whether the given candidate qualifies as a factory method.  */ ;/**  * Check whether the given candidate qualifies as a factory method.  */ public boolean isFactoryMethod(Method candidate) {     return candidate.getName().equals(getFactoryMethodName()). }
true;public;0;4;/**  * Return the resolved factory method as a Java Method object, if available.  * @return the factory method, or {@code null} if not found or not resolved yet  */ ;/**  * Return the resolved factory method as a Java Method object, if available.  * @return the factory method, or {@code null} if not found or not resolved yet  */ @Nullable public Method getResolvedFactoryMethod() {     return this.factoryMethodToIntrospect. }
false;public;1;8;;public void registerExternallyManagedConfigMember(Member configMember) {     synchronized (this.postProcessingLock) {         if (this.externallyManagedConfigMembers == null) {             this.externallyManagedConfigMembers = new HashSet<>(1).         }         this.externallyManagedConfigMembers.add(configMember).     } }
false;public;1;6;;public boolean isExternallyManagedConfigMember(Member configMember) {     synchronized (this.postProcessingLock) {         return (this.externallyManagedConfigMembers != null && this.externallyManagedConfigMembers.contains(configMember)).     } }
false;public;1;8;;public void registerExternallyManagedInitMethod(String initMethod) {     synchronized (this.postProcessingLock) {         if (this.externallyManagedInitMethods == null) {             this.externallyManagedInitMethods = new HashSet<>(1).         }         this.externallyManagedInitMethods.add(initMethod).     } }
false;public;1;6;;public boolean isExternallyManagedInitMethod(String initMethod) {     synchronized (this.postProcessingLock) {         return (this.externallyManagedInitMethods != null && this.externallyManagedInitMethods.contains(initMethod)).     } }
false;public;1;8;;public void registerExternallyManagedDestroyMethod(String destroyMethod) {     synchronized (this.postProcessingLock) {         if (this.externallyManagedDestroyMethods == null) {             this.externallyManagedDestroyMethods = new HashSet<>(1).         }         this.externallyManagedDestroyMethods.add(destroyMethod).     } }
false;public;1;6;;public boolean isExternallyManagedDestroyMethod(String destroyMethod) {     synchronized (this.postProcessingLock) {         return (this.externallyManagedDestroyMethods != null && this.externallyManagedDestroyMethods.contains(destroyMethod)).     } }
false;public;0;4;;@Override public RootBeanDefinition cloneBeanDefinition() {     return new RootBeanDefinition(this). }
false;public;1;4;;@Override public boolean equals(Object other) {     return (this == other || (other instanceof RootBeanDefinition && super.equals(other))). }
false;public;0;4;;@Override public String toString() {     return "Root bean: " + super.toString(). }
