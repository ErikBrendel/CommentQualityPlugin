commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;5;/**  * Accept the given ClassLoader as cache-safe, even if its classes would  * not qualify as cache-safe in this CachedIntrospectionResults class.  * <p>This configuration method is only relevant in scenarios where the Spring  * classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)  * whose lifecycle is not coupled to the application. In such a scenario,  * CachedIntrospectionResults would by default not cache any of the application's  * classes, since they would create a leak in the common ClassLoader.  * <p>Any {@code acceptClassLoader} call at application startup should  * be paired with a {@link #clearClassLoader} call at application shutdown.  * @param classLoader the ClassLoader to accept  */ ;/**  * Accept the given ClassLoader as cache-safe, even if its classes would  * not qualify as cache-safe in this CachedIntrospectionResults class.  * <p>This configuration method is only relevant in scenarios where the Spring  * classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)  * whose lifecycle is not coupled to the application. In such a scenario,  * CachedIntrospectionResults would by default not cache any of the application's  * classes, since they would create a leak in the common ClassLoader.  * <p>Any {@code acceptClassLoader} call at application startup should  * be paired with a {@link #clearClassLoader} call at application shutdown.  * @param classLoader the ClassLoader to accept  */ public static void acceptClassLoader(@Nullable ClassLoader classLoader) {     if (classLoader != null) {         acceptedClassLoaders.add(classLoader).     } }
true;public,static;1;8;/**  * Clear the introspection cache for the given ClassLoader, removing the  * introspection results for all classes underneath that ClassLoader, and  * removing the ClassLoader (and its children) from the acceptance list.  * @param classLoader the ClassLoader to clear the cache for  */ ;/**  * Clear the introspection cache for the given ClassLoader, removing the  * introspection results for all classes underneath that ClassLoader, and  * removing the ClassLoader (and its children) from the acceptance list.  * @param classLoader the ClassLoader to clear the cache for  */ public static void clearClassLoader(@Nullable ClassLoader classLoader) {     acceptedClassLoaders.removeIf(registeredLoader -> isUnderneathClassLoader(registeredLoader, classLoader)).     strongClassCache.keySet().removeIf(beanClass -> isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)).     softClassCache.keySet().removeIf(beanClass -> isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)). }
true;static;1;28;/**  * Create CachedIntrospectionResults for the given bean class.  * @param beanClass the bean class to analyze  * @return the corresponding CachedIntrospectionResults  * @throws BeansException in case of introspection failure  */ ;/**  * Create CachedIntrospectionResults for the given bean class.  * @param beanClass the bean class to analyze  * @return the corresponding CachedIntrospectionResults  * @throws BeansException in case of introspection failure  */ @SuppressWarnings("unchecked") static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {     CachedIntrospectionResults results = strongClassCache.get(beanClass).     if (results != null) {         return results.     }     results = softClassCache.get(beanClass).     if (results != null) {         return results.     }     results = new CachedIntrospectionResults(beanClass).     ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse.     if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) || isClassLoaderAccepted(beanClass.getClassLoader())) {         classCacheToUse = strongClassCache.     } else {         if (logger.isDebugEnabled()) {             logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe").         }         classCacheToUse = softClassCache.     }     CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results).     return (existing != null ? existing : results). }
true;private,static;1;8;/**  * Check whether this CachedIntrospectionResults class is configured  * to accept the given ClassLoader.  * @param classLoader the ClassLoader to check  * @return whether the given ClassLoader is accepted  * @see #acceptClassLoader  */ ;/**  * Check whether this CachedIntrospectionResults class is configured  * to accept the given ClassLoader.  * @param classLoader the ClassLoader to check  * @return whether the given ClassLoader is accepted  * @see #acceptClassLoader  */ private static boolean isClassLoaderAccepted(ClassLoader classLoader) {     for (ClassLoader acceptedLoader : acceptedClassLoaders) {         if (isUnderneathClassLoader(classLoader, acceptedLoader)) {             return true.         }     }     return false. }
true;private,static;2;16;/**  * Check whether the given ClassLoader is underneath the given parent,  * that is, whether the parent is within the candidate's hierarchy.  * @param candidate the candidate ClassLoader to check  * @param parent the parent ClassLoader to check for  */ ;/**  * Check whether the given ClassLoader is underneath the given parent,  * that is, whether the parent is within the candidate's hierarchy.  * @param candidate the candidate ClassLoader to check  * @param parent the parent ClassLoader to check for  */ private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent) {     if (candidate == parent) {         return true.     }     if (candidate == null) {         return false.     }     ClassLoader classLoaderToCheck = candidate.     while (classLoaderToCheck != null) {         classLoaderToCheck = classLoaderToCheck.getParent().         if (classLoaderToCheck == parent) {             return true.         }     }     return false. }
true;private,static;1;11;/**  * Retrieve a {@link BeanInfo} descriptor for the given target class.  * @param beanClass the target class to introspect  * @return the resulting {@code BeanInfo} descriptor (never {@code null})  * @throws IntrospectionException from the underlying {@link Introspector}  */ ;/**  * Retrieve a {@link BeanInfo} descriptor for the given target class.  * @param beanClass the target class to introspect  * @return the resulting {@code BeanInfo} descriptor (never {@code null})  * @throws IntrospectionException from the underlying {@link Introspector}  */ private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {     for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {         BeanInfo beanInfo = beanInfoFactory.getBeanInfo(beanClass).         if (beanInfo != null) {             return beanInfo.         }     }     return (shouldIntrospectorIgnoreBeaninfoClasses ? Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) : Introspector.getBeanInfo(beanClass)). }
false;private;2;17;;private void introspectInterfaces(Class<?> beanClass, Class<?> currClass) throws IntrospectionException {     for (Class<?> ifc : currClass.getInterfaces()) {         if (!ClassUtils.isJavaLanguageInterface(ifc)) {             for (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {                 PropertyDescriptor existingPd = this.propertyDescriptorCache.get(pd.getName()).                 if (existingPd == null || (existingPd.getReadMethod() == null && pd.getReadMethod() != null)) {                     // GenericTypeAwarePropertyDescriptor leniently resolves a set* write method                     // against a declared read method, so we prefer read method descriptors here.                     pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd).                     this.propertyDescriptorCache.put(pd.getName(), pd).                 }             }             introspectInterfaces(ifc, ifc).         }     } }
false;;0;3;;BeanInfo getBeanInfo() {     return this.beanInfo. }
false;;0;3;;Class<?> getBeanClass() {     return this.beanInfo.getBeanDescriptor().getBeanClass(). }
false;;1;13;;@Nullable PropertyDescriptor getPropertyDescriptor(String name) {     PropertyDescriptor pd = this.propertyDescriptorCache.get(name).     if (pd == null && StringUtils.hasLength(name)) {         // Same lenient fallback checking as in Property...         pd = this.propertyDescriptorCache.get(StringUtils.uncapitalize(name)).         if (pd == null) {             pd = this.propertyDescriptorCache.get(StringUtils.capitalize(name)).         }     }     return (pd == null || pd instanceof GenericTypeAwarePropertyDescriptor ? pd : buildGenericTypeAwarePropertyDescriptor(getBeanClass(), pd)). }
false;;0;10;;PropertyDescriptor[] getPropertyDescriptors() {     PropertyDescriptor[] pds = new PropertyDescriptor[this.propertyDescriptorCache.size()].     int i = 0.     for (PropertyDescriptor pd : this.propertyDescriptorCache.values()) {         pds[i] = (pd instanceof GenericTypeAwarePropertyDescriptor ? pd : buildGenericTypeAwarePropertyDescriptor(getBeanClass(), pd)).         i++.     }     return pds. }
false;private;2;9;;private PropertyDescriptor buildGenericTypeAwarePropertyDescriptor(Class<?> beanClass, PropertyDescriptor pd) {     try {         return new GenericTypeAwarePropertyDescriptor(beanClass, pd.getName(), pd.getReadMethod(), pd.getWriteMethod(), pd.getPropertyEditorClass()).     } catch (IntrospectionException ex) {         throw new FatalBeanException("Failed to re-introspect class [" + beanClass.getName() + "]", ex).     } }
false;;2;4;;TypeDescriptor addTypeDescriptor(PropertyDescriptor pd, TypeDescriptor td) {     TypeDescriptor existing = this.typeDescriptorCache.putIfAbsent(pd, td).     return (existing != null ? existing : td). }
false;;1;4;;@Nullable TypeDescriptor getTypeDescriptor(PropertyDescriptor pd) {     return this.typeDescriptorCache.get(pd). }
