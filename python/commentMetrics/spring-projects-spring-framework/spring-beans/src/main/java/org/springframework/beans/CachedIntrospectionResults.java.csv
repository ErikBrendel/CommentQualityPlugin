# id;timestamp;commentText;codeText;commentWords;codeWords
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1328020251;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader,_and deregistering the ClassLoader (and any of its children) from the_acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		if (classLoader == null) {_			return__		}_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,deregistering,the,class,loader,and,any,of,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,if,class,loader,null,return,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1345800660;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader,_and deregistering the ClassLoader (and any of its children) from the_acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		if (classLoader == null) {_			return__		}_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,deregistering,the,class,loader,and,any,of,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,if,class,loader,null,return,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1347201928;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader,_and deregistering the ClassLoader (and any of its children) from the_acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		if (classLoader == null) {_			return__		}_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,deregistering,the,class,loader,and,any,of,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,if,class,loader,null,return,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1347280133;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader,_and deregistering the ClassLoader (and any of its children) from the_acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		if (classLoader == null) {_			return__		}_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,deregistering,the,class,loader,and,any,of,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,if,class,loader,null,return,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1347311781;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader,_and deregistering the ClassLoader (and any of its children) from the_acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		if (classLoader == null) {_			return__		}_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,deregistering,the,class,loader,and,any,of,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,if,class,loader,null,return,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1353872607;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader,_and deregistering the ClassLoader (and any of its children) from the_acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		if (classLoader == null) {_			return__		}_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,deregistering,the,class,loader,and,any,of,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,if,class,loader,null,return,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1355352386;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader,_and deregistering the ClassLoader (and any of its children) from the_acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		if (classLoader == null) {_			return__		}_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,deregistering,the,class,loader,and,any,of,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,if,class,loader,null,return,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1356735495;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader,_and deregistering the ClassLoader (and any of its children) from the_acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		if (classLoader == null) {_			return__		}_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,deregistering,the,class,loader,and,any,of,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,if,class,loader,null,return,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1362408075;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader,_and deregistering the ClassLoader (and any of its children) from the_acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,deregistering,the,class,loader,and,any,of,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1382793514;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1385412762;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class<?>> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1386050100;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class<?>> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1386759526;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class<?>> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1388763574;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class<?>> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1389804304;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class<?>> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1390576922;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class<?>> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1390584131;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class<?>> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1390606047;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class<?>> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1391528714;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		synchronized (classCache) {_			for (Iterator<Class<?>> it = classCache.keySet().iterator()_ it.hasNext()_) {_				Class<?> beanClass = it.next()__				if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_					it.remove()__				}_			}_		}_		synchronized (acceptedClassLoaders) {_			for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_				ClassLoader registeredLoader = it.next()__				if (isUnderneathClassLoader(registeredLoader, classLoader)) {_					it.remove()__				}_			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,synchronized,class,cache,for,iterator,class,it,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,synchronized,accepted,class,loaders,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1404080175;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1408481454;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1408483722;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1410544072;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1432125256;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1461764340;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1467730834;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(ClassLoader classLoader);1469561191;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1382793514;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class<?> classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1385412762;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class<?> classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1386050100;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class<?> classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new HashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1386759526;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class<?> classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new HashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1388763574;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class<?> classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new HashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1389804304;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class<?> classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new HashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1390576922;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			_			if (!shouldIntrospectorIgnoreBeaninfoClasses) {_				_				_				_				_				Class<?> classToFlush = beanClass__				do {_					Introspector.flushFromCaches(classToFlush)__					classToFlush = classToFlush.getSuperclass()__				}_				while (classToFlush != null)__			}__			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new ConcurrentHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,should,introspector,ignore,beaninfo,classes,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,concurrent,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1390584131;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new ConcurrentHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,concurrent,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1390606047;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new ConcurrentHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,concurrent,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1391528714;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new ConcurrentHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,concurrent,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1404080175;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new ConcurrentHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,concurrent,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1408481454;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.putIfAbsent(pd.getName(), pd)__			}__			this.typeDescriptorCache = new ConcurrentHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,if,absent,pd,get,name,pd,this,type,descriptor,cache,new,concurrent,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1408483722;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new ConcurrentHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,concurrent,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1410544072;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,concurrent,reference,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1432125256;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,this,type,descriptor,cache,new,concurrent,reference,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1461764340;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					BeanInfo ifcInfo = Introspector.getBeanInfo(ifc, Introspector.IGNORE_ALL_BEANINFO)__					PropertyDescriptor[] ifcPds = ifcInfo.getPropertyDescriptors()__					for (PropertyDescriptor pd : ifcPds) {_						if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_							pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__							this.propertyDescriptorCache.put(pd.getName(), pd)__						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<PropertyDescriptor, TypeDescriptor>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,bean,info,ifc,info,introspector,get,bean,info,ifc,introspector,property,descriptor,ifc,pds,ifc,info,get,property,descriptors,for,property,descriptor,pd,ifc,pds,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,property,descriptor,type,descriptor,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1467730834;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					BeanInfo ifcInfo = Introspector.getBeanInfo(ifc, Introspector.IGNORE_ALL_BEANINFO)__					PropertyDescriptor[] ifcPds = ifcInfo.getPropertyDescriptors()__					for (PropertyDescriptor pd : ifcPds) {_						if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_							pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__							this.propertyDescriptorCache.put(pd.getName(), pd)__						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,bean,info,ifc,info,introspector,get,bean,info,ifc,introspector,property,descriptor,ifc,pds,ifc,info,get,property,descriptors,for,property,descriptor,pd,ifc,pds,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1469561191;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					BeanInfo ifcInfo = Introspector.getBeanInfo(ifc, Introspector.IGNORE_ALL_BEANINFO)__					PropertyDescriptor[] ifcPds = ifcInfo.getPropertyDescriptors()__					for (PropertyDescriptor pd : ifcPds) {_						if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_							pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__							this.propertyDescriptorCache.put(pd.getName(), pd)__						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,bean,info,ifc,info,introspector,get,bean,info,ifc,introspector,property,descriptor,ifc,pds,ifc,info,get,property,descriptors,for,property,descriptor,pd,ifc,pds,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1496837955;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					BeanInfo ifcInfo = Introspector.getBeanInfo(ifc, Introspector.IGNORE_ALL_BEANINFO)__					PropertyDescriptor[] ifcPds = ifcInfo.getPropertyDescriptors()__					for (PropertyDescriptor pd : ifcPds) {_						if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_							pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__							this.propertyDescriptorCache.put(pd.getName(), pd)__						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,bean,info,ifc,info,introspector,get,bean,info,ifc,introspector,property,descriptor,ifc,pds,ifc,info,get,property,descriptors,for,property,descriptor,pd,ifc,pds,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1513100167;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = (shouldIntrospectorIgnoreBeaninfoClasses ?_						Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_						Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					BeanInfo ifcInfo = Introspector.getBeanInfo(ifc, Introspector.IGNORE_ALL_BEANINFO)__					PropertyDescriptor[] ifcPds = ifcInfo.getPropertyDescriptors()__					for (PropertyDescriptor pd : ifcPds) {_						if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_							pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__							this.propertyDescriptorCache.put(pd.getName(), pd)__						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class,this,bean,info,bean,info,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,bean,info,ifc,info,introspector,get,bean,info,ifc,introspector,property,descriptor,ifc,pds,ifc,info,get,property,descriptors,for,property,descriptor,pd,ifc,pds,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1515431102;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}_			this.beanInfo = getBeanInfo(beanClass, shouldIntrospectorIgnoreBeaninfoClasses)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null && clazz != Object.class) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					if (!ClassUtils.isJavaLanguageInterface(ifc)) {_						BeanInfo ifcInfo = getBeanInfo(ifc, true)__						PropertyDescriptor[] ifcPds = ifcInfo.getPropertyDescriptors()__						for (PropertyDescriptor pd : ifcPds) {_							if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_								pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__								this.propertyDescriptorCache.put(pd.getName(), pd)__							}_						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,this,bean,info,get,bean,info,bean,class,should,introspector,ignore,beaninfo,classes,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,clazz,object,class,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,if,class,utils,is,java,language,interface,ifc,bean,info,ifc,info,get,bean,info,ifc,true,property,descriptor,ifc,pds,ifc,info,get,property,descriptors,for,property,descriptor,pd,ifc,pds,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1520508549;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}_			this.beanInfo = getBeanInfo(beanClass)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null && clazz != Object.class) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					if (!ClassUtils.isJavaLanguageInterface(ifc)) {_						for (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {_							if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_								pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__								this.propertyDescriptorCache.put(pd.getName(), pd)__							}_						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,this,bean,info,get,bean,info,bean,class,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,clazz,object,class,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,if,class,utils,is,java,language,interface,ifc,for,property,descriptor,pd,get,bean,info,ifc,get,property,descriptors,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1521714971;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}_			this.beanInfo = getBeanInfo(beanClass)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null && clazz != Object.class) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					if (!ClassUtils.isJavaLanguageInterface(ifc)) {_						for (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {_							if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_								pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__								this.propertyDescriptorCache.put(pd.getName(), pd)__							}_						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,this,bean,info,get,bean,info,bean,class,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,clazz,object,class,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,if,class,utils,is,java,language,interface,ifc,for,property,descriptor,pd,get,bean,info,ifc,get,property,descriptors,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1530174524;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}_			this.beanInfo = getBeanInfo(beanClass)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null && clazz != Object.class) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					if (!ClassUtils.isJavaLanguageInterface(ifc)) {_						for (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {_							if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_								pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__								this.propertyDescriptorCache.put(pd.getName(), pd)__							}_						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,this,bean,info,get,bean,info,bean,class,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,clazz,object,class,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,if,class,utils,is,java,language,interface,ifc,for,property,descriptor,pd,get,bean,info,ifc,get,property,descriptors,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1530174524;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}_			this.beanInfo = getBeanInfo(beanClass)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> clazz = beanClass__			while (clazz != null && clazz != Object.class) {_				Class<?>[] ifcs = clazz.getInterfaces()__				for (Class<?> ifc : ifcs) {_					if (!ClassUtils.isJavaLanguageInterface(ifc)) {_						for (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {_							if (!this.propertyDescriptorCache.containsKey(pd.getName())) {_								pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__								this.propertyDescriptorCache.put(pd.getName(), pd)__							}_						}_					}_				}_				clazz = clazz.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,this,bean,info,get,bean,info,bean,class,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,clazz,bean,class,while,clazz,null,clazz,object,class,class,ifcs,clazz,get,interfaces,for,class,ifc,ifcs,if,class,utils,is,java,language,interface,ifc,for,property,descriptor,pd,get,bean,info,ifc,get,property,descriptors,if,this,property,descriptor,cache,contains,key,pd,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,clazz,clazz,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class<?> beanClass) throws BeansException;1530188116;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class<?> beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}_			this.beanInfo = getBeanInfo(beanClass)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class == beanClass &&_						("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}__			_			_			Class<?> currClass = beanClass__			while (currClass != null && currClass != Object.class) {_				introspectInterfaces(beanClass, currClass)__				currClass = currClass.getSuperclass()__			}__			this.typeDescriptorCache = new ConcurrentReferenceHashMap<>()__		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,this,bean,info,get,bean,info,bean,class,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,bean,class,class,loader,equals,pd,get,name,protection,domain,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,class,curr,class,bean,class,while,curr,class,null,curr,class,object,class,introspect,interfaces,bean,class,curr,class,curr,class,curr,class,get,superclass,this,type,descriptor,cache,new,concurrent,reference,hash,map,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> public static void acceptClassLoader(@Nullable ClassLoader classLoader);1496837955;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(@Nullable ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,nullable,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(@Nullable ClassLoader classLoader);1513100167;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(@Nullable ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,nullable,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(@Nullable ClassLoader classLoader);1515431102;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(@Nullable ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,nullable,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(@Nullable ClassLoader classLoader);1520508549;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(@Nullable ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,nullable,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(@Nullable ClassLoader classLoader);1521714971;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(@Nullable ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,nullable,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(@Nullable ClassLoader classLoader);1530174524;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(@Nullable ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,nullable,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(@Nullable ClassLoader classLoader);1530174524;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(@Nullable ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,nullable,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(@Nullable ClassLoader classLoader);1530188116;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(@Nullable ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,nullable,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException;1520508549;Retrieve a {@link BeanInfo} descriptor for the given target class._@param beanClass the target class to introspect_@return the resulting {@code BeanInfo} descriptor (never {@code null})_@throws IntrospectionException from the underlying {@link Introspector};private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {_		for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_			BeanInfo beanInfo = beanInfoFactory.getBeanInfo(beanClass)__			if (beanInfo != null) {_				return beanInfo__			}_		}_		return (shouldIntrospectorIgnoreBeaninfoClasses ?_				Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_				Introspector.getBeanInfo(beanClass))__	};retrieve,a,link,bean,info,descriptor,for,the,given,target,class,param,bean,class,the,target,class,to,introspect,return,the,resulting,code,bean,info,descriptor,never,code,null,throws,introspection,exception,from,the,underlying,link,introspector;private,static,bean,info,get,bean,info,class,bean,class,throws,introspection,exception,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,return,bean,info,return,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class
CachedIntrospectionResults -> private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException;1521714971;Retrieve a {@link BeanInfo} descriptor for the given target class._@param beanClass the target class to introspect_@return the resulting {@code BeanInfo} descriptor (never {@code null})_@throws IntrospectionException from the underlying {@link Introspector};private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {_		for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_			BeanInfo beanInfo = beanInfoFactory.getBeanInfo(beanClass)__			if (beanInfo != null) {_				return beanInfo__			}_		}_		return (shouldIntrospectorIgnoreBeaninfoClasses ?_				Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_				Introspector.getBeanInfo(beanClass))__	};retrieve,a,link,bean,info,descriptor,for,the,given,target,class,param,bean,class,the,target,class,to,introspect,return,the,resulting,code,bean,info,descriptor,never,code,null,throws,introspection,exception,from,the,underlying,link,introspector;private,static,bean,info,get,bean,info,class,bean,class,throws,introspection,exception,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,return,bean,info,return,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class
CachedIntrospectionResults -> private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException;1530174524;Retrieve a {@link BeanInfo} descriptor for the given target class._@param beanClass the target class to introspect_@return the resulting {@code BeanInfo} descriptor (never {@code null})_@throws IntrospectionException from the underlying {@link Introspector};private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {_		for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_			BeanInfo beanInfo = beanInfoFactory.getBeanInfo(beanClass)__			if (beanInfo != null) {_				return beanInfo__			}_		}_		return (shouldIntrospectorIgnoreBeaninfoClasses ?_				Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_				Introspector.getBeanInfo(beanClass))__	};retrieve,a,link,bean,info,descriptor,for,the,given,target,class,param,bean,class,the,target,class,to,introspect,return,the,resulting,code,bean,info,descriptor,never,code,null,throws,introspection,exception,from,the,underlying,link,introspector;private,static,bean,info,get,bean,info,class,bean,class,throws,introspection,exception,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,return,bean,info,return,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class
CachedIntrospectionResults -> private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException;1530174524;Retrieve a {@link BeanInfo} descriptor for the given target class._@param beanClass the target class to introspect_@return the resulting {@code BeanInfo} descriptor (never {@code null})_@throws IntrospectionException from the underlying {@link Introspector};private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {_		for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_			BeanInfo beanInfo = beanInfoFactory.getBeanInfo(beanClass)__			if (beanInfo != null) {_				return beanInfo__			}_		}_		return (shouldIntrospectorIgnoreBeaninfoClasses ?_				Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_				Introspector.getBeanInfo(beanClass))__	};retrieve,a,link,bean,info,descriptor,for,the,given,target,class,param,bean,class,the,target,class,to,introspect,return,the,resulting,code,bean,info,descriptor,never,code,null,throws,introspection,exception,from,the,underlying,link,introspector;private,static,bean,info,get,bean,info,class,bean,class,throws,introspection,exception,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,return,bean,info,return,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class
CachedIntrospectionResults -> private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException;1530188116;Retrieve a {@link BeanInfo} descriptor for the given target class._@param beanClass the target class to introspect_@return the resulting {@code BeanInfo} descriptor (never {@code null})_@throws IntrospectionException from the underlying {@link Introspector};private static BeanInfo getBeanInfo(Class<?> beanClass) throws IntrospectionException {_		for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_			BeanInfo beanInfo = beanInfoFactory.getBeanInfo(beanClass)__			if (beanInfo != null) {_				return beanInfo__			}_		}_		return (shouldIntrospectorIgnoreBeaninfoClasses ?_				Introspector.getBeanInfo(beanClass, Introspector.IGNORE_ALL_BEANINFO) :_				Introspector.getBeanInfo(beanClass))__	};retrieve,a,link,bean,info,descriptor,for,the,given,target,class,param,bean,class,the,target,class,to,introspect,return,the,resulting,code,bean,info,descriptor,never,code,null,throws,introspection,exception,from,the,underlying,link,introspector;private,static,bean,info,get,bean,info,class,bean,class,throws,introspection,exception,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,return,bean,info,return,should,introspector,ignore,beaninfo,classes,introspector,get,bean,info,bean,class,introspector,introspector,get,bean,info,bean,class
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1328020251;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray =_				acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1345800660;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray =_				acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1347201928;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray =_				acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1347280133;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray =_				acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1347311781;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray =_				acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1353872607;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray =_				acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1355352386;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1356735495;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1362408075;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1382793514;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1385412762;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1386050100;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1386759526;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1388763574;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1389804304;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1390576922;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1390584131;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader registeredLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, registeredLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,registered,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,registered,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1390606047;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader acceptedLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,accepted,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1391528714;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		_		_		ClassLoader[] acceptedLoaderArray__		synchronized (acceptedClassLoaders) {_			acceptedLoaderArray = acceptedClassLoaders.toArray(new ClassLoader[acceptedClassLoaders.size()])__		}_		for (ClassLoader acceptedLoader : acceptedLoaderArray) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,class,loader,accepted,loader,array,synchronized,accepted,class,loaders,accepted,loader,array,accepted,class,loaders,to,array,new,class,loader,accepted,class,loaders,size,for,class,loader,accepted,loader,accepted,loader,array,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1404080175;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1408481454;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1408483722;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1410544072;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1432125256;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1461764340;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1467730834;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1469561191;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1496837955;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1513100167;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1515431102;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1520508549;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1521714971;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1530174524;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1530174524;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private static boolean isClassLoaderAccepted(ClassLoader classLoader);1530188116;Check whether this CachedIntrospectionResults class is configured_to accept the given ClassLoader._@param classLoader the ClassLoader to check_@return whether the given ClassLoader is accepted_@see #acceptClassLoader;private static boolean isClassLoaderAccepted(ClassLoader classLoader) {_		for (ClassLoader acceptedLoader : acceptedClassLoaders) {_			if (isUnderneathClassLoader(classLoader, acceptedLoader)) {_				return true__			}_		}_		return false__	};check,whether,this,cached,introspection,results,class,is,configured,to,accept,the,given,class,loader,param,class,loader,the,class,loader,to,check,return,whether,the,given,class,loader,is,accepted,see,accept,class,loader;private,static,boolean,is,class,loader,accepted,class,loader,class,loader,for,class,loader,accepted,loader,accepted,class,loaders,if,is,underneath,class,loader,class,loader,accepted,loader,return,true,return,false
CachedIntrospectionResults -> private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException;1328020251;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}_			this.beanInfo = new ExtendedBeanInfo(Introspector.getBeanInfo(beanClass))___			_			_			_			_			Class classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				if (cacheFullMetadata) {_					pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				}_				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,boolean,cache,full,metadata,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,this,bean,info,new,extended,bean,info,introspector,get,bean,info,bean,class,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,if,cache,full,metadata,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException;1345800660;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			List<BeanInfoFactory> beanInfoFactories = getBeanInfoFactories(beanClass.getClassLoader())__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				if (beanInfoFactory.supports(beanClass)) {_					beanInfo = beanInfoFactory.getBeanInfo(beanClass)__					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = new ExtendedBeanInfo(Introspector.getBeanInfo(beanClass))__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				if (cacheFullMetadata) {_					pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				}_				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,boolean,cache,full,metadata,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,list,bean,info,factory,bean,info,factories,get,bean,info,factories,bean,class,get,class,loader,for,bean,info,factory,bean,info,factory,bean,info,factories,if,bean,info,factory,supports,bean,class,bean,info,bean,info,factory,get,bean,info,bean,class,break,if,bean,info,null,bean,info,new,extended,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,if,cache,full,metadata,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException;1347201928;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			List<BeanInfoFactory> beanInfoFactories = getBeanInfoFactories(beanClass.getClassLoader())__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				if (beanInfoFactory.supports(beanClass)) {_					beanInfo = beanInfoFactory.getBeanInfo(beanClass)__					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				if (cacheFullMetadata) {_					pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				}_				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,boolean,cache,full,metadata,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,list,bean,info,factory,bean,info,factories,get,bean,info,factories,bean,class,get,class,loader,for,bean,info,factory,bean,info,factory,bean,info,factories,if,bean,info,factory,supports,bean,class,bean,info,bean,info,factory,get,bean,info,bean,class,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,if,cache,full,metadata,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException;1347280133;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			List<BeanInfoFactory> beanInfoFactories = getBeanInfoFactories(beanClass.getClassLoader())__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				if (cacheFullMetadata) {_					pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				}_				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,boolean,cache,full,metadata,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,list,bean,info,factory,bean,info,factories,get,bean,info,factories,bean,class,get,class,loader,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,if,cache,full,metadata,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException;1347311781;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class beanClass, boolean cacheFullMetadata) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				if (cacheFullMetadata) {_					pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				}_				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,boolean,cache,full,metadata,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,if,cache,full,metadata,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1385412762;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference<CachedIntrospectionResults> ref = (Reference<CachedIntrospectionResults>) value__			results = ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,cached,introspection,results,ref,reference,cached,introspection,results,value,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1386050100;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference<CachedIntrospectionResults> ref = (Reference<CachedIntrospectionResults>) value__			results = ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,cached,introspection,results,ref,reference,cached,introspection,results,value,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1386759526;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference<CachedIntrospectionResults> ref = (Reference<CachedIntrospectionResults>) value__			results = ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,cached,introspection,results,ref,reference,cached,introspection,results,value,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1388763574;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference<CachedIntrospectionResults> ref = (Reference<CachedIntrospectionResults>) value__			results = ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,cached,introspection,results,ref,reference,cached,introspection,results,value,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1389804304;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference<CachedIntrospectionResults> ref = (Reference<CachedIntrospectionResults>) value__			results = ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,cached,introspection,results,ref,reference,cached,introspection,results,value,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1390576922;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference<CachedIntrospectionResults> ref = (Reference<CachedIntrospectionResults>) value__			results = ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,cached,introspection,results,ref,reference,cached,introspection,results,value,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1390584131;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference<CachedIntrospectionResults> ref = (Reference<CachedIntrospectionResults>) value__			results = ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,cached,introspection,results,ref,reference,cached,introspection,results,value,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1390606047;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference<CachedIntrospectionResults> ref = (Reference<CachedIntrospectionResults>) value__			results = ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,cached,introspection,results,ref,reference,cached,introspection,results,value,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1391528714;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference<CachedIntrospectionResults> ref = (Reference<CachedIntrospectionResults>) value__			results = ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,cached,introspection,results,ref,reference,cached,introspection,results,value,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1404080175;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			strongClassCache.put(beanClass, results)__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			softClassCache.put(beanClass, results)__		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,strong,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,soft,class,cache,put,bean,class,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1408481454;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			strongClassCache.putIfAbsent(beanClass, results)__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			softClassCache.putIfAbsent(beanClass, results)__		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,strong,class,cache,put,if,absent,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,soft,class,cache,put,if,absent,bean,class,results,return,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1408483722;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1410544072;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1432125256;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1461764340;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1467730834;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1469561191;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1496837955;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1513100167;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1515431102;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1520508549;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1521714971;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1530174524;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1530174524;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> @SuppressWarnings("unchecked") 	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException;1530188116;Create CachedIntrospectionResults for the given bean class._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;@SuppressWarnings("unchecked")_	static CachedIntrospectionResults forClass(Class<?> beanClass) throws BeansException {_		CachedIntrospectionResults results = strongClassCache.get(beanClass)__		if (results != null) {_			return results__		}_		results = softClassCache.get(beanClass)__		if (results != null) {_			return results__		}__		results = new CachedIntrospectionResults(beanClass)__		ConcurrentMap<Class<?>, CachedIntrospectionResults> classCacheToUse___		if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_				isClassLoaderAccepted(beanClass.getClassLoader())) {_			classCacheToUse = strongClassCache__		}_		else {_			if (logger.isDebugEnabled()) {_				logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__			}_			classCacheToUse = softClassCache__		}__		CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results)__		return (existing != null ? existing : results)__	};create,cached,introspection,results,for,the,given,bean,class,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;suppress,warnings,unchecked,static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,strong,class,cache,get,bean,class,if,results,null,return,results,results,soft,class,cache,get,bean,class,if,results,null,return,results,results,new,cached,introspection,results,bean,class,concurrent,map,class,cached,introspection,results,class,cache,to,use,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,class,cache,to,use,strong,class,cache,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,class,cache,to,use,soft,class,cache,cached,introspection,results,existing,class,cache,to,use,put,if,absent,bean,class,results,return,existing,null,existing,results
CachedIntrospectionResults -> static CachedIntrospectionResults forClass(Class beanClass) throws BeansException;1328020251;Create CachedIntrospectionResults for the given bean class._<P>We don't want to use synchronization here. Object references are atomic,_so we can live with doing the occasional unnecessary lookup at startup only._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;static CachedIntrospectionResults forClass(Class beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value = classCache.get(beanClass)__		if (value instanceof Reference) {_			Reference ref = (Reference) value__			results = (CachedIntrospectionResults) ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			_			_			boolean fullyCacheable =_					ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())__			if (fullyCacheable || !ClassUtils.isPresent(beanClass.getName() + "BeanInfo", beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass, fullyCacheable)__				classCache.put(beanClass, results)__			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass, true)__				classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,p,we,don,t,want,to,use,synchronization,here,object,references,are,atomic,so,we,can,live,with,doing,the,occasional,unnecessary,lookup,at,startup,only,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,ref,reference,value,results,cached,introspection,results,ref,get,else,results,cached,introspection,results,value,if,results,null,boolean,fully,cacheable,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,if,fully,cacheable,class,utils,is,present,bean,class,get,name,bean,info,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,fully,cacheable,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,true,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> static CachedIntrospectionResults forClass(Class beanClass) throws BeansException;1345800660;Create CachedIntrospectionResults for the given bean class._<P>We don't want to use synchronization here. Object references are atomic,_so we can live with doing the occasional unnecessary lookup at startup only._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;static CachedIntrospectionResults forClass(Class beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value = classCache.get(beanClass)__		if (value instanceof Reference) {_			Reference ref = (Reference) value__			results = (CachedIntrospectionResults) ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			_			_			boolean fullyCacheable =_					ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())__			if (fullyCacheable || !ClassUtils.isPresent(beanClass.getName() + "BeanInfo", beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass, fullyCacheable)__				classCache.put(beanClass, results)__			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass, true)__				classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,p,we,don,t,want,to,use,synchronization,here,object,references,are,atomic,so,we,can,live,with,doing,the,occasional,unnecessary,lookup,at,startup,only,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,ref,reference,value,results,cached,introspection,results,ref,get,else,results,cached,introspection,results,value,if,results,null,boolean,fully,cacheable,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,if,fully,cacheable,class,utils,is,present,bean,class,get,name,bean,info,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,fully,cacheable,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,true,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> static CachedIntrospectionResults forClass(Class beanClass) throws BeansException;1347201928;Create CachedIntrospectionResults for the given bean class._<P>We don't want to use synchronization here. Object references are atomic,_so we can live with doing the occasional unnecessary lookup at startup only._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;static CachedIntrospectionResults forClass(Class beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value = classCache.get(beanClass)__		if (value instanceof Reference) {_			Reference ref = (Reference) value__			results = (CachedIntrospectionResults) ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			_			_			boolean fullyCacheable =_					ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())__			if (fullyCacheable || !ClassUtils.isPresent(beanClass.getName() + "BeanInfo", beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass, fullyCacheable)__				classCache.put(beanClass, results)__			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass, true)__				classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,p,we,don,t,want,to,use,synchronization,here,object,references,are,atomic,so,we,can,live,with,doing,the,occasional,unnecessary,lookup,at,startup,only,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,ref,reference,value,results,cached,introspection,results,ref,get,else,results,cached,introspection,results,value,if,results,null,boolean,fully,cacheable,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,if,fully,cacheable,class,utils,is,present,bean,class,get,name,bean,info,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,fully,cacheable,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,true,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> static CachedIntrospectionResults forClass(Class beanClass) throws BeansException;1347280133;Create CachedIntrospectionResults for the given bean class._<P>We don't want to use synchronization here. Object references are atomic,_so we can live with doing the occasional unnecessary lookup at startup only._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;static CachedIntrospectionResults forClass(Class beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value = classCache.get(beanClass)__		if (value instanceof Reference) {_			Reference ref = (Reference) value__			results = (CachedIntrospectionResults) ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			_			_			boolean fullyCacheable =_					ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())__			if (fullyCacheable || !ClassUtils.isPresent(beanClass.getName() + "BeanInfo", beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass, fullyCacheable)__				classCache.put(beanClass, results)__			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass, true)__				classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,p,we,don,t,want,to,use,synchronization,here,object,references,are,atomic,so,we,can,live,with,doing,the,occasional,unnecessary,lookup,at,startup,only,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,ref,reference,value,results,cached,introspection,results,ref,get,else,results,cached,introspection,results,value,if,results,null,boolean,fully,cacheable,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,if,fully,cacheable,class,utils,is,present,bean,class,get,name,bean,info,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,fully,cacheable,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,true,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> static CachedIntrospectionResults forClass(Class beanClass) throws BeansException;1347311781;Create CachedIntrospectionResults for the given bean class._<P>We don't want to use synchronization here. Object references are atomic,_so we can live with doing the occasional unnecessary lookup at startup only._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;static CachedIntrospectionResults forClass(Class beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value = classCache.get(beanClass)__		if (value instanceof Reference) {_			Reference ref = (Reference) value__			results = (CachedIntrospectionResults) ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			_			_			boolean fullyCacheable =_					ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())__			if (fullyCacheable || !ClassUtils.isPresent(beanClass.getName() + "BeanInfo", beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass, fullyCacheable)__				classCache.put(beanClass, results)__			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass, true)__				classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,p,we,don,t,want,to,use,synchronization,here,object,references,are,atomic,so,we,can,live,with,doing,the,occasional,unnecessary,lookup,at,startup,only,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,ref,reference,value,results,cached,introspection,results,ref,get,else,results,cached,introspection,results,value,if,results,null,boolean,fully,cacheable,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,if,fully,cacheable,class,utils,is,present,bean,class,get,name,bean,info,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,fully,cacheable,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,true,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> static CachedIntrospectionResults forClass(Class beanClass) throws BeansException;1353872607;Create CachedIntrospectionResults for the given bean class._<P>We don't want to use synchronization here. Object references are atomic,_so we can live with doing the occasional unnecessary lookup at startup only._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;static CachedIntrospectionResults forClass(Class beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value = classCache.get(beanClass)__		if (value instanceof Reference) {_			Reference ref = (Reference) value__			results = (CachedIntrospectionResults) ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				classCache.put(beanClass, results)__			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,p,we,don,t,want,to,use,synchronization,here,object,references,are,atomic,so,we,can,live,with,doing,the,occasional,unnecessary,lookup,at,startup,only,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,ref,reference,value,results,cached,introspection,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> static CachedIntrospectionResults forClass(Class beanClass) throws BeansException;1355352386;Create CachedIntrospectionResults for the given bean class._<P>We don't want to use synchronization here. Object references are atomic,_so we can live with doing the occasional unnecessary lookup at startup only._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;static CachedIntrospectionResults forClass(Class beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference ref = (Reference) value__			results = (CachedIntrospectionResults) ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,p,we,don,t,want,to,use,synchronization,here,object,references,are,atomic,so,we,can,live,with,doing,the,occasional,unnecessary,lookup,at,startup,only,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,ref,reference,value,results,cached,introspection,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> static CachedIntrospectionResults forClass(Class beanClass) throws BeansException;1356735495;Create CachedIntrospectionResults for the given bean class._<P>We don't want to use synchronization here. Object references are atomic,_so we can live with doing the occasional unnecessary lookup at startup only._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;static CachedIntrospectionResults forClass(Class beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference ref = (Reference) value__			results = (CachedIntrospectionResults) ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,p,we,don,t,want,to,use,synchronization,here,object,references,are,atomic,so,we,can,live,with,doing,the,occasional,unnecessary,lookup,at,startup,only,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,ref,reference,value,results,cached,introspection,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> static CachedIntrospectionResults forClass(Class beanClass) throws BeansException;1362408075;Create CachedIntrospectionResults for the given bean class._<P>We don't want to use synchronization here. Object references are atomic,_so we can live with doing the occasional unnecessary lookup at startup only._@param beanClass the bean class to analyze_@return the corresponding CachedIntrospectionResults_@throws BeansException in case of introspection failure;static CachedIntrospectionResults forClass(Class beanClass) throws BeansException {_		CachedIntrospectionResults results__		Object value__		synchronized (classCache) {_			value = classCache.get(beanClass)__		}_		if (value instanceof Reference) {_			Reference ref = (Reference) value__			results = (CachedIntrospectionResults) ref.get()__		}_		else {_			results = (CachedIntrospectionResults) value__		}_		if (results == null) {_			if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) ||_					isClassLoaderAccepted(beanClass.getClassLoader())) {_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, results)__				}_			}_			else {_				if (logger.isDebugEnabled()) {_					logger.debug("Not strongly caching class [" + beanClass.getName() + "] because it is not cache-safe")__				}_				results = new CachedIntrospectionResults(beanClass)__				synchronized (classCache) {_					classCache.put(beanClass, new WeakReference<CachedIntrospectionResults>(results))__				}_			}_		}_		return results__	};create,cached,introspection,results,for,the,given,bean,class,p,we,don,t,want,to,use,synchronization,here,object,references,are,atomic,so,we,can,live,with,doing,the,occasional,unnecessary,lookup,at,startup,only,param,bean,class,the,bean,class,to,analyze,return,the,corresponding,cached,introspection,results,throws,beans,exception,in,case,of,introspection,failure;static,cached,introspection,results,for,class,class,bean,class,throws,beans,exception,cached,introspection,results,results,object,value,synchronized,class,cache,value,class,cache,get,bean,class,if,value,instanceof,reference,reference,ref,reference,value,results,cached,introspection,results,ref,get,else,results,cached,introspection,results,value,if,results,null,if,class,utils,is,cache,safe,bean,class,cached,introspection,results,class,get,class,loader,is,class,loader,accepted,bean,class,get,class,loader,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,results,else,if,logger,is,debug,enabled,logger,debug,not,strongly,caching,class,bean,class,get,name,because,it,is,not,cache,safe,results,new,cached,introspection,results,bean,class,synchronized,class,cache,class,cache,put,bean,class,new,weak,reference,cached,introspection,results,results,return,results
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1328020251;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any <code>acceptClassLoader</code> call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,code,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1345800660;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any <code>acceptClassLoader</code> call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,code,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1347201928;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any <code>acceptClassLoader</code> call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,code,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1347280133;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any <code>acceptClassLoader</code> call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,code,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1347311781;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any <code>acceptClassLoader</code> call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,code,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1353872607;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any <code>acceptClassLoader</code> call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,code,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1355352386;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any <code>acceptClassLoader</code> call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,code,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1356735495;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1362408075;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1382793514;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1385412762;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1386050100;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1386759526;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1388763574;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1389804304;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1390576922;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1390584131;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1390606047;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1391528714;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			synchronized (acceptedClassLoaders) {_				acceptedClassLoaders.add(classLoader)__			}_		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,synchronized,accepted,class,loaders,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1404080175;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1408481454;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1408483722;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1410544072;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1432125256;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1461764340;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1467730834;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> public static void acceptClassLoader(ClassLoader classLoader);1469561191;Accept the given ClassLoader as cache-safe, even if its classes would_not qualify as cache-safe in this CachedIntrospectionResults class._<p>This configuration method is only relevant in scenarios where the Spring_classes reside in a 'common' ClassLoader (e.g. the system ClassLoader)_whose lifecycle is not coupled to the application. In such a scenario,_CachedIntrospectionResults would by default not cache any of the application's_classes, since they would create a leak in the common ClassLoader._<p>Any {@code acceptClassLoader} call at application startup should_be paired with a {@link #clearClassLoader} call at application shutdown._@param classLoader the ClassLoader to accept;public static void acceptClassLoader(ClassLoader classLoader) {_		if (classLoader != null) {_			acceptedClassLoaders.add(classLoader)__		}_	};accept,the,given,class,loader,as,cache,safe,even,if,its,classes,would,not,qualify,as,cache,safe,in,this,cached,introspection,results,class,p,this,configuration,method,is,only,relevant,in,scenarios,where,the,spring,classes,reside,in,a,common,class,loader,e,g,the,system,class,loader,whose,lifecycle,is,not,coupled,to,the,application,in,such,a,scenario,cached,introspection,results,would,by,default,not,cache,any,of,the,application,s,classes,since,they,would,create,a,leak,in,the,common,class,loader,p,any,code,accept,class,loader,call,at,application,startup,should,be,paired,with,a,link,clear,class,loader,call,at,application,shutdown,param,class,loader,the,class,loader,to,accept;public,static,void,accept,class,loader,class,loader,class,loader,if,class,loader,null,accepted,class,loaders,add,class,loader
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent);1496837955;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,nullable,class,loader,candidate,nullable,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent);1513100167;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,nullable,class,loader,candidate,nullable,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent);1515431102;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,nullable,class,loader,candidate,nullable,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent);1520508549;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,nullable,class,loader,candidate,nullable,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent);1521714971;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,nullable,class,loader,candidate,nullable,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent);1530174524;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,nullable,class,loader,candidate,nullable,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent);1530174524;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,nullable,class,loader,candidate,nullable,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent);1530188116;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(@Nullable ClassLoader candidate, @Nullable ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,nullable,class,loader,candidate,nullable,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> public static void clearClassLoader(@Nullable ClassLoader classLoader);1496837955;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(@Nullable ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,nullable,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(@Nullable ClassLoader classLoader);1513100167;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(@Nullable ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,nullable,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(@Nullable ClassLoader classLoader);1515431102;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(@Nullable ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,nullable,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(@Nullable ClassLoader classLoader);1520508549;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(@Nullable ClassLoader classLoader) {_		for (Iterator<ClassLoader> it = acceptedClassLoaders.iterator()_ it.hasNext()_) {_			ClassLoader registeredLoader = it.next()__			if (isUnderneathClassLoader(registeredLoader, classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = strongClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_		for (Iterator<Class<?>> it = softClassCache.keySet().iterator()_ it.hasNext()_) {_			Class<?> beanClass = it.next()__			if (isUnderneathClassLoader(beanClass.getClassLoader(), classLoader)) {_				it.remove()__			}_		}_	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,nullable,class,loader,class,loader,for,iterator,class,loader,it,accepted,class,loaders,iterator,it,has,next,class,loader,registered,loader,it,next,if,is,underneath,class,loader,registered,loader,class,loader,it,remove,for,iterator,class,it,strong,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove,for,iterator,class,it,soft,class,cache,key,set,iterator,it,has,next,class,bean,class,it,next,if,is,underneath,class,loader,bean,class,get,class,loader,class,loader,it,remove
CachedIntrospectionResults -> public static void clearClassLoader(@Nullable ClassLoader classLoader);1521714971;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(@Nullable ClassLoader classLoader) {_		acceptedClassLoaders.removeIf(registeredLoader ->_				isUnderneathClassLoader(registeredLoader, classLoader))__		strongClassCache.keySet().removeIf(beanClass ->_				isUnderneathClassLoader(beanClass.getClassLoader(), classLoader))__		softClassCache.keySet().removeIf(beanClass ->_				isUnderneathClassLoader(beanClass.getClassLoader(), classLoader))__	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,nullable,class,loader,class,loader,accepted,class,loaders,remove,if,registered,loader,is,underneath,class,loader,registered,loader,class,loader,strong,class,cache,key,set,remove,if,bean,class,is,underneath,class,loader,bean,class,get,class,loader,class,loader,soft,class,cache,key,set,remove,if,bean,class,is,underneath,class,loader,bean,class,get,class,loader,class,loader
CachedIntrospectionResults -> public static void clearClassLoader(@Nullable ClassLoader classLoader);1530174524;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(@Nullable ClassLoader classLoader) {_		acceptedClassLoaders.removeIf(registeredLoader ->_				isUnderneathClassLoader(registeredLoader, classLoader))__		strongClassCache.keySet().removeIf(beanClass ->_				isUnderneathClassLoader(beanClass.getClassLoader(), classLoader))__		softClassCache.keySet().removeIf(beanClass ->_				isUnderneathClassLoader(beanClass.getClassLoader(), classLoader))__	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,nullable,class,loader,class,loader,accepted,class,loaders,remove,if,registered,loader,is,underneath,class,loader,registered,loader,class,loader,strong,class,cache,key,set,remove,if,bean,class,is,underneath,class,loader,bean,class,get,class,loader,class,loader,soft,class,cache,key,set,remove,if,bean,class,is,underneath,class,loader,bean,class,get,class,loader,class,loader
CachedIntrospectionResults -> public static void clearClassLoader(@Nullable ClassLoader classLoader);1530174524;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(@Nullable ClassLoader classLoader) {_		acceptedClassLoaders.removeIf(registeredLoader ->_				isUnderneathClassLoader(registeredLoader, classLoader))__		strongClassCache.keySet().removeIf(beanClass ->_				isUnderneathClassLoader(beanClass.getClassLoader(), classLoader))__		softClassCache.keySet().removeIf(beanClass ->_				isUnderneathClassLoader(beanClass.getClassLoader(), classLoader))__	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,nullable,class,loader,class,loader,accepted,class,loaders,remove,if,registered,loader,is,underneath,class,loader,registered,loader,class,loader,strong,class,cache,key,set,remove,if,bean,class,is,underneath,class,loader,bean,class,get,class,loader,class,loader,soft,class,cache,key,set,remove,if,bean,class,is,underneath,class,loader,bean,class,get,class,loader,class,loader
CachedIntrospectionResults -> public static void clearClassLoader(@Nullable ClassLoader classLoader);1530188116;Clear the introspection cache for the given ClassLoader, removing the_introspection results for all classes underneath that ClassLoader, and_removing the ClassLoader (and its children) from the acceptance list._@param classLoader the ClassLoader to clear the cache for;public static void clearClassLoader(@Nullable ClassLoader classLoader) {_		acceptedClassLoaders.removeIf(registeredLoader ->_				isUnderneathClassLoader(registeredLoader, classLoader))__		strongClassCache.keySet().removeIf(beanClass ->_				isUnderneathClassLoader(beanClass.getClassLoader(), classLoader))__		softClassCache.keySet().removeIf(beanClass ->_				isUnderneathClassLoader(beanClass.getClassLoader(), classLoader))__	};clear,the,introspection,cache,for,the,given,class,loader,removing,the,introspection,results,for,all,classes,underneath,that,class,loader,and,removing,the,class,loader,and,its,children,from,the,acceptance,list,param,class,loader,the,class,loader,to,clear,the,cache,for;public,static,void,clear,class,loader,nullable,class,loader,class,loader,accepted,class,loaders,remove,if,registered,loader,is,underneath,class,loader,registered,loader,class,loader,strong,class,cache,key,set,remove,if,bean,class,is,underneath,class,loader,bean,class,get,class,loader,class,loader,soft,class,cache,key,set,remove,if,bean,class,is,underneath,class,loader,bean,class,get,class,loader,class,loader
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1328020251;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == null) {_			return false__		}_		if (candidate == parent) {_			return true__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,null,return,false,if,candidate,parent,return,true,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1345800660;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == null) {_			return false__		}_		if (candidate == parent) {_			return true__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,null,return,false,if,candidate,parent,return,true,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1347201928;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == null) {_			return false__		}_		if (candidate == parent) {_			return true__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,null,return,false,if,candidate,parent,return,true,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1347280133;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == null) {_			return false__		}_		if (candidate == parent) {_			return true__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,null,return,false,if,candidate,parent,return,true,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1347311781;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == null) {_			return false__		}_		if (candidate == parent) {_			return true__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,null,return,false,if,candidate,parent,return,true,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1353872607;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == null) {_			return false__		}_		if (candidate == parent) {_			return true__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,null,return,false,if,candidate,parent,return,true,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1355352386;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == null) {_			return false__		}_		if (candidate == parent) {_			return true__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,null,return,false,if,candidate,parent,return,true,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1356735495;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == null) {_			return false__		}_		if (candidate == parent) {_			return true__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,null,return,false,if,candidate,parent,return,true,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1362408075;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1382793514;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1385412762;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1386050100;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1386759526;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1388763574;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1389804304;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1390576922;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1390584131;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1390606047;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1391528714;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1404080175;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1408481454;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1408483722;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1410544072;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1432125256;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1461764340;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1467730834;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent);1469561191;Check whether the given ClassLoader is underneath the given parent,_that is, whether the parent is within the candidate's hierarchy._@param candidate the candidate ClassLoader to check_@param parent the parent ClassLoader to check for;private static boolean isUnderneathClassLoader(ClassLoader candidate, ClassLoader parent) {_		if (candidate == parent) {_			return true__		}_		if (candidate == null) {_			return false__		}_		ClassLoader classLoaderToCheck = candidate__		while (classLoaderToCheck != null) {_			classLoaderToCheck = classLoaderToCheck.getParent()__			if (classLoaderToCheck == parent) {_				return true__			}_		}_		return false__	};check,whether,the,given,class,loader,is,underneath,the,given,parent,that,is,whether,the,parent,is,within,the,candidate,s,hierarchy,param,candidate,the,candidate,class,loader,to,check,param,parent,the,parent,class,loader,to,check,for;private,static,boolean,is,underneath,class,loader,class,loader,candidate,class,loader,parent,if,candidate,parent,return,true,if,candidate,null,return,false,class,loader,class,loader,to,check,candidate,while,class,loader,to,check,null,class,loader,to,check,class,loader,to,check,get,parent,if,class,loader,to,check,parent,return,true,return,false
CachedIntrospectionResults -> private CachedIntrospectionResults(Class beanClass) throws BeansException;1353872607;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class beanClass) throws BeansException;1355352386;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class beanClass) throws BeansException;1356735495;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
CachedIntrospectionResults -> private CachedIntrospectionResults(Class beanClass) throws BeansException;1362408075;Create a new CachedIntrospectionResults instance for the given class._@param beanClass the bean class to analyze_@throws BeansException in case of introspection failure;private CachedIntrospectionResults(Class beanClass) throws BeansException {_		try {_			if (logger.isTraceEnabled()) {_				logger.trace("Getting BeanInfo for class [" + beanClass.getName() + "]")__			}__			BeanInfo beanInfo = null__			for (BeanInfoFactory beanInfoFactory : beanInfoFactories) {_				beanInfo = beanInfoFactory.getBeanInfo(beanClass)__				if (beanInfo != null) {_					break__				}_			}_			if (beanInfo == null) {_				_				beanInfo = Introspector.getBeanInfo(beanClass)__			}_			this.beanInfo = beanInfo___			_			_			_			_			Class classToFlush = beanClass__			do {_				Introspector.flushFromCaches(classToFlush)__				classToFlush = classToFlush.getSuperclass()__			}_			while (classToFlush != null)___			if (logger.isTraceEnabled()) {_				logger.trace("Caching PropertyDescriptors for class [" + beanClass.getName() + "]")__			}_			this.propertyDescriptorCache = new LinkedHashMap<String, PropertyDescriptor>()___			_			PropertyDescriptor[] pds = this.beanInfo.getPropertyDescriptors()__			for (PropertyDescriptor pd : pds) {_				if (Class.class.equals(beanClass) && "classLoader".equals(pd.getName())) {_					_					continue__				}_				if (logger.isTraceEnabled()) {_					logger.trace("Found bean property '" + pd.getName() + "'" +_							(pd.getPropertyType() != null ? " of type [" + pd.getPropertyType().getName() + "]" : "") +_							(pd.getPropertyEditorClass() != null ?_									"_ editor [" + pd.getPropertyEditorClass().getName() + "]" : ""))__				}_				pd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd)__				this.propertyDescriptorCache.put(pd.getName(), pd)__			}_		}_		catch (IntrospectionException ex) {_			throw new FatalBeanException("Failed to obtain BeanInfo for class [" + beanClass.getName() + "]", ex)__		}_	};create,a,new,cached,introspection,results,instance,for,the,given,class,param,bean,class,the,bean,class,to,analyze,throws,beans,exception,in,case,of,introspection,failure;private,cached,introspection,results,class,bean,class,throws,beans,exception,try,if,logger,is,trace,enabled,logger,trace,getting,bean,info,for,class,bean,class,get,name,bean,info,bean,info,null,for,bean,info,factory,bean,info,factory,bean,info,factories,bean,info,bean,info,factory,get,bean,info,bean,class,if,bean,info,null,break,if,bean,info,null,bean,info,introspector,get,bean,info,bean,class,this,bean,info,bean,info,class,class,to,flush,bean,class,do,introspector,flush,from,caches,class,to,flush,class,to,flush,class,to,flush,get,superclass,while,class,to,flush,null,if,logger,is,trace,enabled,logger,trace,caching,property,descriptors,for,class,bean,class,get,name,this,property,descriptor,cache,new,linked,hash,map,string,property,descriptor,property,descriptor,pds,this,bean,info,get,property,descriptors,for,property,descriptor,pd,pds,if,class,class,equals,bean,class,class,loader,equals,pd,get,name,continue,if,logger,is,trace,enabled,logger,trace,found,bean,property,pd,get,name,pd,get,property,type,null,of,type,pd,get,property,type,get,name,pd,get,property,editor,class,null,editor,pd,get,property,editor,class,get,name,pd,build,generic,type,aware,property,descriptor,bean,class,pd,this,property,descriptor,cache,put,pd,get,name,pd,catch,introspection,exception,ex,throw,new,fatal,bean,exception,failed,to,obtain,bean,info,for,class,bean,class,get,name,ex
