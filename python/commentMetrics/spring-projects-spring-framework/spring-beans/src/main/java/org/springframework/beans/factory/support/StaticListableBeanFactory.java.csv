commented;modifiers;parameterAmount;loc;comment;code
true;public;2;3;/**  * Add a new singleton bean.  * Will overwrite any existing instance for the given name.  * @param name the name of the bean  * @param bean the bean instance  */ ;/**  * Add a new singleton bean.  * Will overwrite any existing instance for the given name.  * @param name the name of the bean  * @param bean the bean instance  */ public void addBean(String name, Object bean) {     this.beans.put(name, bean). }
false;public;1;32;;// --------------------------------------------------------------------- // Implementation of BeanFactory interface // --------------------------------------------------------------------- @Override public Object getBean(String name) throws BeansException {     String beanName = BeanFactoryUtils.transformedBeanName(name).     Object bean = this.beans.get(beanName).     if (bean == null) {         throw new NoSuchBeanDefinitionException(beanName, "Defined beans are [" + StringUtils.collectionToCommaDelimitedString(this.beans.keySet()) + "]").     }     // bean factory if the bean isn't a factory     if (BeanFactoryUtils.isFactoryDereference(name) && !(bean instanceof FactoryBean)) {         throw new BeanIsNotAFactoryException(beanName, bean.getClass()).     }     if (bean instanceof FactoryBean && !BeanFactoryUtils.isFactoryDereference(name)) {         try {             Object exposedObject = ((FactoryBean<?>) bean).getObject().             if (exposedObject == null) {                 throw new BeanCreationException(beanName, "FactoryBean exposed null object").             }             return exposedObject.         } catch (Exception ex) {             throw new BeanCreationException(beanName, "FactoryBean threw exception on object creation", ex).         }     } else {         return bean.     } }
false;public;2;9;;@Override @SuppressWarnings("unchecked") public <T> T getBean(String name, @Nullable Class<T> requiredType) throws BeansException {     Object bean = getBean(name).     if (requiredType != null && !requiredType.isInstance(bean)) {         throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()).     }     return (T) bean. }
false;public;2;8;;@Override public Object getBean(String name, Object... args) throws BeansException {     if (!ObjectUtils.isEmpty(args)) {         throw new UnsupportedOperationException("StaticListableBeanFactory does not support explicit bean creation arguments").     }     return getBean(name). }
false;public;1;13;;@Override public <T> T getBean(Class<T> requiredType) throws BeansException {     String[] beanNames = getBeanNamesForType(requiredType).     if (beanNames.length == 1) {         return getBean(beanNames[0], requiredType).     } else if (beanNames.length > 1) {         throw new NoUniqueBeanDefinitionException(requiredType, beanNames).     } else {         throw new NoSuchBeanDefinitionException(requiredType).     } }
false;public;2;8;;@Override public <T> T getBean(Class<T> requiredType, Object... args) throws BeansException {     if (!ObjectUtils.isEmpty(args)) {         throw new UnsupportedOperationException("StaticListableBeanFactory does not support explicit bean creation arguments").     }     return getBean(requiredType). }
false;public;1;4;;@Override public <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType) throws BeansException {     return getBeanProvider(ResolvableType.forRawClass(requiredType)). }
false;public;0;13;;@Override public T getObject() throws BeansException {     String[] beanNames = getBeanNamesForType(requiredType).     if (beanNames.length == 1) {         return (T) getBean(beanNames[0], requiredType).     } else if (beanNames.length > 1) {         throw new NoUniqueBeanDefinitionException(requiredType, beanNames).     } else {         throw new NoSuchBeanDefinitionException(requiredType).     } }
false;public;1;13;;@Override public T getObject(Object... args) throws BeansException {     String[] beanNames = getBeanNamesForType(requiredType).     if (beanNames.length == 1) {         return (T) getBean(beanNames[0], args).     } else if (beanNames.length > 1) {         throw new NoUniqueBeanDefinitionException(requiredType, beanNames).     } else {         throw new NoSuchBeanDefinitionException(requiredType).     } }
false;public;0;14;;@Override @Nullable public T getIfAvailable() throws BeansException {     String[] beanNames = getBeanNamesForType(requiredType).     if (beanNames.length == 1) {         return (T) getBean(beanNames[0]).     } else if (beanNames.length > 1) {         throw new NoUniqueBeanDefinitionException(requiredType, beanNames).     } else {         return null.     } }
false;public;0;11;;@Override @Nullable public T getIfUnique() throws BeansException {     String[] beanNames = getBeanNamesForType(requiredType).     if (beanNames.length == 1) {         return (T) getBean(beanNames[0]).     } else {         return null.     } }
false;public;0;4;;@Override public Stream<T> stream() {     return Arrays.stream(getBeanNamesForType(requiredType)).map(name -> (T) getBean(name)). }
false;public;0;4;;@Override public Stream<T> orderedStream() {     return stream().sorted(OrderComparator.INSTANCE). }
false;public;1;65;;@SuppressWarnings("unchecked") @Override public <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType) {     return new ObjectProvider<T>() {          @Override         public T getObject() throws BeansException {             String[] beanNames = getBeanNamesForType(requiredType).             if (beanNames.length == 1) {                 return (T) getBean(beanNames[0], requiredType).             } else if (beanNames.length > 1) {                 throw new NoUniqueBeanDefinitionException(requiredType, beanNames).             } else {                 throw new NoSuchBeanDefinitionException(requiredType).             }         }          @Override         public T getObject(Object... args) throws BeansException {             String[] beanNames = getBeanNamesForType(requiredType).             if (beanNames.length == 1) {                 return (T) getBean(beanNames[0], args).             } else if (beanNames.length > 1) {                 throw new NoUniqueBeanDefinitionException(requiredType, beanNames).             } else {                 throw new NoSuchBeanDefinitionException(requiredType).             }         }          @Override         @Nullable         public T getIfAvailable() throws BeansException {             String[] beanNames = getBeanNamesForType(requiredType).             if (beanNames.length == 1) {                 return (T) getBean(beanNames[0]).             } else if (beanNames.length > 1) {                 throw new NoUniqueBeanDefinitionException(requiredType, beanNames).             } else {                 return null.             }         }          @Override         @Nullable         public T getIfUnique() throws BeansException {             String[] beanNames = getBeanNamesForType(requiredType).             if (beanNames.length == 1) {                 return (T) getBean(beanNames[0]).             } else {                 return null.             }         }          @Override         public Stream<T> stream() {             return Arrays.stream(getBeanNamesForType(requiredType)).map(name -> (T) getBean(name)).         }          @Override         public Stream<T> orderedStream() {             return stream().sorted(OrderComparator.INSTANCE).         }     }. }
false;public;1;4;;@Override public boolean containsBean(String name) {     return this.beans.containsKey(name). }
false;public;1;6;;@Override public boolean isSingleton(String name) throws NoSuchBeanDefinitionException {     Object bean = getBean(name).     // In case of FactoryBean, return singleton status of created object.     return (bean instanceof FactoryBean && ((FactoryBean<?>) bean).isSingleton()). }
false;public;1;7;;@Override public boolean isPrototype(String name) throws NoSuchBeanDefinitionException {     Object bean = getBean(name).     // In case of FactoryBean, return prototype status of created object.     return ((bean instanceof SmartFactoryBean && ((SmartFactoryBean<?>) bean).isPrototype()) || (bean instanceof FactoryBean && !((FactoryBean<?>) bean).isSingleton())). }
false;public;2;5;;@Override public boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException {     Class<?> type = getType(name).     return (type != null && typeToMatch.isAssignableFrom(type)). }
false;public;2;5;;@Override public boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch) throws NoSuchBeanDefinitionException {     Class<?> type = getType(name).     return (typeToMatch == null || (type != null && typeToMatch.isAssignableFrom(type))). }
false;public;1;16;;@Override public Class<?> getType(String name) throws NoSuchBeanDefinitionException {     String beanName = BeanFactoryUtils.transformedBeanName(name).     Object bean = this.beans.get(beanName).     if (bean == null) {         throw new NoSuchBeanDefinitionException(beanName, "Defined beans are [" + StringUtils.collectionToCommaDelimitedString(this.beans.keySet()) + "]").     }     if (bean instanceof FactoryBean && !BeanFactoryUtils.isFactoryDereference(name)) {         // If it's a FactoryBean, we want to look at what it creates, not the factory class.         return ((FactoryBean<?>) bean).getObjectType().     }     return bean.getClass(). }
false;public;1;4;;@Override public String[] getAliases(String name) {     return new String[0]. }
false;public;1;4;;// --------------------------------------------------------------------- // Implementation of ListableBeanFactory interface // --------------------------------------------------------------------- @Override public boolean containsBeanDefinition(String name) {     return this.beans.containsKey(name). }
false;public;0;4;;@Override public int getBeanDefinitionCount() {     return this.beans.size(). }
false;public;0;4;;@Override public String[] getBeanDefinitionNames() {     return StringUtils.toStringArray(this.beans.keySet()). }
false;public;1;27;;@Override public String[] getBeanNamesForType(@Nullable ResolvableType type) {     boolean isFactoryType = false.     if (type != null) {         Class<?> resolved = type.resolve().         if (resolved != null && FactoryBean.class.isAssignableFrom(resolved)) {             isFactoryType = true.         }     }     List<String> matches = new ArrayList<>().     for (Map.Entry<String, Object> entry : this.beans.entrySet()) {         String name = entry.getKey().         Object beanInstance = entry.getValue().         if (beanInstance instanceof FactoryBean && !isFactoryType) {             Class<?> objectType = ((FactoryBean<?>) beanInstance).getObjectType().             if (objectType != null && (type == null || type.isAssignableFrom(objectType))) {                 matches.add(name).             }         } else {             if (type == null || type.isInstance(beanInstance)) {                 matches.add(name).             }         }     }     return StringUtils.toStringArray(matches). }
false;public;1;4;;@Override public String[] getBeanNamesForType(@Nullable Class<?> type) {     return getBeanNamesForType(ResolvableType.forClass(type)). }
false;public;3;4;;@Override public String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit) {     return getBeanNamesForType(ResolvableType.forClass(type)). }
false;public;1;4;;@Override public <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException {     return getBeansOfType(type, true, true). }
false;public;3;34;;@Override @SuppressWarnings("unchecked") public <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit) throws BeansException {     boolean isFactoryType = (type != null && FactoryBean.class.isAssignableFrom(type)).     Map<String, T> matches = new LinkedHashMap<>().     for (Map.Entry<String, Object> entry : this.beans.entrySet()) {         String beanName = entry.getKey().         Object beanInstance = entry.getValue().         // Is bean a FactoryBean?         if (beanInstance instanceof FactoryBean && !isFactoryType) {             // Match object created by FactoryBean.             FactoryBean<?> factory = (FactoryBean<?>) beanInstance.             Class<?> objectType = factory.getObjectType().             if ((includeNonSingletons || factory.isSingleton()) && objectType != null && (type == null || type.isAssignableFrom(objectType))) {                 matches.put(beanName, getBean(beanName, type)).             }         } else {             if (type == null || type.isInstance(beanInstance)) {                 // Else, return bean instance.                 if (isFactoryType) {                     beanName = FACTORY_BEAN_PREFIX + beanName.                 }                 matches.put(beanName, (T) beanInstance).             }         }     }     return matches. }
false;public;1;10;;@Override public String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType) {     List<String> results = new ArrayList<>().     for (String beanName : this.beans.keySet()) {         if (findAnnotationOnBean(beanName, annotationType) != null) {             results.add(beanName).         }     }     return StringUtils.toStringArray(results). }
false;public;1;12;;@Override public Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) throws BeansException {     Map<String, Object> results = new LinkedHashMap<>().     for (String beanName : this.beans.keySet()) {         if (findAnnotationOnBean(beanName, annotationType) != null) {             results.put(beanName, getBean(beanName)).         }     }     return results. }
false;public;2;8;;@Override @Nullable public <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType) throws NoSuchBeanDefinitionException {     Class<?> beanType = getType(beanName).     return (beanType != null ? AnnotationUtils.findAnnotation(beanType, annotationType) : null). }
