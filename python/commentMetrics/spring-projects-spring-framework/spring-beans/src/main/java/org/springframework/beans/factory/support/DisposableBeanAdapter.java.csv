commented;modifiers;parameterAmount;loc;comment;code
true;private;2;24;/**  * If the current value of the given beanDefinition's "destroyMethodName" property is  * {@link AbstractBeanDefinition#INFER_METHOD}, then attempt to infer a destroy method.  * Candidate methods are currently limited to public, no-arg methods named "close" or  * "shutdown" (whether declared locally or inherited). The given BeanDefinition's  * "destroyMethodName" is updated to be null if no such method is found, otherwise set  * to the name of the inferred method. This constant serves as the default for the  * {@code @Bean#destroyMethod} attribute and the value of the constant may also be  * used in XML within the {@code <bean destroy-method="">} or {@code  * <beans default-destroy-method="">} attributes.  * <p>Also processes the {@link java.io.Closeable} and {@link java.lang.AutoCloseable}  * interfaces, reflectively calling the "close" method on implementing beans as well.  */ ;/**  * If the current value of the given beanDefinition's "destroyMethodName" property is  * {@link AbstractBeanDefinition#INFER_METHOD}, then attempt to infer a destroy method.  * Candidate methods are currently limited to public, no-arg methods named "close" or  * "shutdown" (whether declared locally or inherited). The given BeanDefinition's  * "destroyMethodName" is updated to be null if no such method is found, otherwise set  * to the name of the inferred method. This constant serves as the default for the  * {@code @Bean#destroyMethod} attribute and the value of the constant may also be  * used in XML within the {@code <bean destroy-method="">} or {@code  * <beans default-destroy-method="">} attributes.  * <p>Also processes the {@link java.io.Closeable} and {@link java.lang.AutoCloseable}  * interfaces, reflectively calling the "close" method on implementing beans as well.  */ @Nullable private String inferDestroyMethodIfNecessary(Object bean, RootBeanDefinition beanDefinition) {     String destroyMethodName = beanDefinition.getDestroyMethodName().     if (AbstractBeanDefinition.INFER_METHOD.equals(destroyMethodName) || (destroyMethodName == null && bean instanceof AutoCloseable)) {         // in case of the bean not explicitly implementing DisposableBean         if (!(bean instanceof DisposableBean)) {             try {                 return bean.getClass().getMethod(CLOSE_METHOD_NAME).getName().             } catch (NoSuchMethodException ex) {                 try {                     return bean.getClass().getMethod(SHUTDOWN_METHOD_NAME).getName().                 } catch (NoSuchMethodException ex2) {                 // no candidate destroy method found                 }             }         }         return null.     }     return (StringUtils.hasLength(destroyMethodName) ? destroyMethodName : null). }
true;private;2;16;/**  * Search for all DestructionAwareBeanPostProcessors in the List.  * @param processors the List to search  * @return the filtered List of DestructionAwareBeanPostProcessors  */ ;/**  * Search for all DestructionAwareBeanPostProcessors in the List.  * @param processors the List to search  * @return the filtered List of DestructionAwareBeanPostProcessors  */ @Nullable private List<DestructionAwareBeanPostProcessor> filterPostProcessors(List<BeanPostProcessor> processors, Object bean) {     List<DestructionAwareBeanPostProcessor> filteredPostProcessors = null.     if (!CollectionUtils.isEmpty(processors)) {         filteredPostProcessors = new ArrayList<>(processors.size()).         for (BeanPostProcessor processor : processors) {             if (processor instanceof DestructionAwareBeanPostProcessor) {                 DestructionAwareBeanPostProcessor dabpp = (DestructionAwareBeanPostProcessor) processor.                 if (dabpp.requiresDestruction(bean)) {                     filteredPostProcessors.add(dabpp).                 }             }         }     }     return filteredPostProcessors. }
false;public;0;4;;@Override public void run() {     destroy(). }
false;public;0;44;;@Override public void destroy() {     if (!CollectionUtils.isEmpty(this.beanPostProcessors)) {         for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {             processor.postProcessBeforeDestruction(this.bean, this.beanName).         }     }     if (this.invokeDisposableBean) {         if (logger.isTraceEnabled()) {             logger.trace("Invoking destroy() on bean with name '" + this.beanName + "'").         }         try {             if (System.getSecurityManager() != null) {                 AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {                     ((DisposableBean) this.bean).destroy().                     return null.                 }, this.acc).             } else {                 ((DisposableBean) this.bean).destroy().             }         } catch (Throwable ex) {             String msg = "Invocation of destroy method failed on bean with name '" + this.beanName + "'".             if (logger.isDebugEnabled()) {                 logger.info(msg, ex).             } else {                 logger.info(msg + ": " + ex).             }         }     }     if (this.destroyMethod != null) {         invokeCustomDestroyMethod(this.destroyMethod).     } else if (this.destroyMethodName != null) {         Method methodToCall = determineDestroyMethod(this.destroyMethodName).         if (methodToCall != null) {             invokeCustomDestroyMethod(methodToCall).         }     } }
false;private;1;15;;@Nullable private Method determineDestroyMethod(String name) {     try {         if (System.getSecurityManager() != null) {             return AccessController.doPrivileged((PrivilegedAction<Method>) () -> findDestroyMethod(name)).         } else {             return findDestroyMethod(name).         }     } catch (IllegalArgumentException ex) {         throw new BeanDefinitionValidationException("Could not find unique destroy method on bean with name '" + this.beanName + ": " + ex.getMessage()).     } }
false;private;1;6;;@Nullable private Method findDestroyMethod(String name) {     return (this.nonPublicAccessAllowed ? BeanUtils.findMethodWithMinimalParameters(this.bean.getClass(), name) : BeanUtils.findMethodWithMinimalParameters(this.bean.getClass().getMethods(), name)). }
true;private;1;44;/**  * Invoke the specified custom destroy method on the given bean.  * <p>This implementation invokes a no-arg method if found, else checking  * for a method with a single boolean argument (passing in "true",  * assuming a "force" parameter), else logging an error.  */ ;/**  * Invoke the specified custom destroy method on the given bean.  * <p>This implementation invokes a no-arg method if found, else checking  * for a method with a single boolean argument (passing in "true",  * assuming a "force" parameter), else logging an error.  */ private void invokeCustomDestroyMethod(final Method destroyMethod) {     Class<?>[] paramTypes = destroyMethod.getParameterTypes().     final Object[] args = new Object[paramTypes.length].     if (paramTypes.length == 1) {         args[0] = Boolean.TRUE.     }     if (logger.isTraceEnabled()) {         logger.trace("Invoking destroy method '" + this.destroyMethodName + "' on bean with name '" + this.beanName + "'").     }     try {         if (System.getSecurityManager() != null) {             AccessController.doPrivileged((PrivilegedAction<Object>) () -> {                 ReflectionUtils.makeAccessible(destroyMethod).                 return null.             }).             try {                 AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> destroyMethod.invoke(this.bean, args), this.acc).             } catch (PrivilegedActionException pax) {                 throw (InvocationTargetException) pax.getException().             }         } else {             ReflectionUtils.makeAccessible(destroyMethod).             destroyMethod.invoke(this.bean, args).         }     } catch (InvocationTargetException ex) {         String msg = "Destroy method '" + this.destroyMethodName + "' on bean with name '" + this.beanName + "' threw an exception".         if (logger.isDebugEnabled()) {             logger.info(msg, ex.getTargetException()).         } else {             logger.info(msg + ": " + ex.getTargetException()).         }     } catch (Throwable ex) {         logger.info("Failed to invoke destroy method '" + this.destroyMethodName + "' on bean with name '" + this.beanName + "'", ex).     } }
true;protected;0;13;/**  * Serializes a copy of the state of this class,  * filtering out non-serializable BeanPostProcessors.  */ ;/**  * Serializes a copy of the state of this class,  * filtering out non-serializable BeanPostProcessors.  */ protected Object writeReplace() {     List<DestructionAwareBeanPostProcessor> serializablePostProcessors = null.     if (this.beanPostProcessors != null) {         serializablePostProcessors = new ArrayList<>().         for (DestructionAwareBeanPostProcessor postProcessor : this.beanPostProcessors) {             if (postProcessor instanceof Serializable) {                 serializablePostProcessors.add(postProcessor).             }         }     }     return new DisposableBeanAdapter(this.bean, this.beanName, this.invokeDisposableBean, this.nonPublicAccessAllowed, this.destroyMethodName, serializablePostProcessors). }
true;public,static;2;11;/**  * Check whether the given bean has any kind of destroy method to call.  * @param bean the bean instance  * @param beanDefinition the corresponding bean definition  */ ;/**  * Check whether the given bean has any kind of destroy method to call.  * @param bean the bean instance  * @param beanDefinition the corresponding bean definition  */ public static boolean hasDestroyMethod(Object bean, RootBeanDefinition beanDefinition) {     if (bean instanceof DisposableBean || bean instanceof AutoCloseable) {         return true.     }     String destroyMethodName = beanDefinition.getDestroyMethodName().     if (AbstractBeanDefinition.INFER_METHOD.equals(destroyMethodName)) {         return (ClassUtils.hasMethod(bean.getClass(), CLOSE_METHOD_NAME) || ClassUtils.hasMethod(bean.getClass(), SHUTDOWN_METHOD_NAME)).     }     return StringUtils.hasLength(destroyMethodName). }
true;public,static;2;13;/**  * Check whether the given bean has destruction-aware post-processors applying to it.  * @param bean the bean instance  * @param postProcessors the post-processor candidates  */ ;/**  * Check whether the given bean has destruction-aware post-processors applying to it.  * @param bean the bean instance  * @param postProcessors the post-processor candidates  */ public static boolean hasApplicableProcessors(Object bean, List<BeanPostProcessor> postProcessors) {     if (!CollectionUtils.isEmpty(postProcessors)) {         for (BeanPostProcessor processor : postProcessors) {             if (processor instanceof DestructionAwareBeanPostProcessor) {                 DestructionAwareBeanPostProcessor dabpp = (DestructionAwareBeanPostProcessor) processor.                 if (dabpp.requiresDestruction(bean)) {                     return true.                 }             }         }     }     return false. }
