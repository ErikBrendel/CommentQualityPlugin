commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the {@link BeanWiringInfoResolver} to use.  * <p>The default behavior is to look for a bean with the same name as the class.  * As an alternative, consider using annotation-driven bean wiring.  * @see ClassNameBeanWiringInfoResolver  * @see org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolver  */ ;/**  * Set the {@link BeanWiringInfoResolver} to use.  * <p>The default behavior is to look for a bean with the same name as the class.  * As an alternative, consider using annotation-driven bean wiring.  * @see ClassNameBeanWiringInfoResolver  * @see org.springframework.beans.factory.annotation.AnnotationBeanWiringInfoResolver  */ public void setBeanWiringInfoResolver(BeanWiringInfoResolver beanWiringInfoResolver) {     Assert.notNull(beanWiringInfoResolver, "BeanWiringInfoResolver must not be null").     this.beanWiringInfoResolver = beanWiringInfoResolver. }
true;public;1;11;/**  * Set the {@link BeanFactory} in which this aspect must configure beans.  */ ;/**  * Set the {@link BeanFactory} in which this aspect must configure beans.  */ @Override public void setBeanFactory(BeanFactory beanFactory) {     if (!(beanFactory instanceof ConfigurableListableBeanFactory)) {         throw new IllegalArgumentException("Bean configurer aspect needs to run in a ConfigurableListableBeanFactory: " + beanFactory).     }     this.beanFactory = (ConfigurableListableBeanFactory) beanFactory.     if (this.beanWiringInfoResolver == null) {         this.beanWiringInfoResolver = createDefaultBeanWiringInfoResolver().     } }
true;protected;0;4;/**  * Create the default BeanWiringInfoResolver to be used if none was  * specified explicitly.  * <p>The default implementation builds a {@link ClassNameBeanWiringInfoResolver}.  * @return the default BeanWiringInfoResolver (never {@code null})  */ ;/**  * Create the default BeanWiringInfoResolver to be used if none was  * specified explicitly.  * <p>The default implementation builds a {@link ClassNameBeanWiringInfoResolver}.  * @return the default BeanWiringInfoResolver (never {@code null})  */ @Nullable protected BeanWiringInfoResolver createDefaultBeanWiringInfoResolver() {     return new ClassNameBeanWiringInfoResolver(). }
true;public;0;4;/**  * Check that a {@link BeanFactory} has been set.  */ ;/**  * Check that a {@link BeanFactory} has been set.  */ @Override public void afterPropertiesSet() {     Assert.notNull(this.beanFactory, "BeanFactory must be set"). }
true;public;0;5;/**  * Release references to the {@link BeanFactory} and  * {@link BeanWiringInfoResolver} when the container is destroyed.  */ ;/**  * Release references to the {@link BeanFactory} and  * {@link BeanWiringInfoResolver} when the container is destroyed.  */ @Override public void destroy() {     this.beanFactory = null.     this.beanWiringInfoResolver = null. }
true;public;1;52;/**  * Configure the bean instance.  * <p>Subclasses can override this to provide custom configuration logic.  * Typically called by an aspect, for all bean instances matched by a pointcut.  * @param beanInstance the bean instance to configure (must <b>not</b> be {@code null})  */ ;/**  * Configure the bean instance.  * <p>Subclasses can override this to provide custom configuration logic.  * Typically called by an aspect, for all bean instances matched by a pointcut.  * @param beanInstance the bean instance to configure (must <b>not</b> be {@code null})  */ public void configureBean(Object beanInstance) {     if (this.beanFactory == null) {         if (logger.isDebugEnabled()) {             logger.debug("BeanFactory has not been set on " + ClassUtils.getShortName(getClass()) + ": " + "Make sure this configurer runs in a Spring container. Unable to configure bean of type [" + ClassUtils.getDescriptiveType(beanInstance) + "]. Proceeding without injection.").         }         return.     }     BeanWiringInfoResolver bwiResolver = this.beanWiringInfoResolver.     Assert.state(bwiResolver != null, "No BeanWiringInfoResolver available").     BeanWiringInfo bwi = bwiResolver.resolveWiringInfo(beanInstance).     if (bwi == null) {         // Skip the bean if no wiring info given.         return.     }     ConfigurableListableBeanFactory beanFactory = this.beanFactory.     Assert.state(beanFactory != null, "No BeanFactory available").     try {         String beanName = bwi.getBeanName().         if (bwi.indicatesAutowiring() || (bwi.isDefaultBeanName() && beanName != null && !beanFactory.containsBean(beanName))) {             // Perform autowiring (also applying standard factory / post-processor callbacks).             beanFactory.autowireBeanProperties(beanInstance, bwi.getAutowireMode(), bwi.getDependencyCheck()).             beanFactory.initializeBean(beanInstance, (beanName != null ? beanName : "")).         } else {             // Perform explicit wiring based on the specified bean definition.             beanFactory.configureBean(beanInstance, (beanName != null ? beanName : "")).         }     } catch (BeanCreationException ex) {         Throwable rootCause = ex.getMostSpecificCause().         if (rootCause instanceof BeanCurrentlyInCreationException) {             BeanCreationException bce = (BeanCreationException) rootCause.             String bceBeanName = bce.getBeanName().             if (bceBeanName != null && beanFactory.isCurrentlyInCreation(bceBeanName)) {                 if (logger.isDebugEnabled()) {                     logger.debug("Failed to create target bean '" + bce.getBeanName() + "' while configuring object of type [" + beanInstance.getClass().getName() + "] - probably due to a circular reference. This is a common startup situation " + "and usually not fatal. Proceeding without injection. Original exception: " + ex).                 }                 return.             }         }         throw ex.     } }
