# id;timestamp;commentText;codeText;commentWords;codeWords
TransactionAspectTests -> public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws Exception;1429745617;Note: resolution does not occur. Thus we can't make a class transactional if_it implements a transactionally annotated interface. This behaviour could only_be changed in AbstractFallbackTransactionAttributeSource in Spring proper.;public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws Exception {_		AnnotationTransactionAttributeSource atas = new AnnotationTransactionAttributeSource()__		Method m = ImplementsAnnotatedInterface.class.getMethod("echo", Throwable.class)__		TransactionAttribute ta = atas.getTransactionAttribute(m, ImplementsAnnotatedInterface.class)__		assertNull(ta)__	};note,resolution,does,not,occur,thus,we,can,t,make,a,class,transactional,if,it,implements,a,transactionally,annotated,interface,this,behaviour,could,only,be,changed,in,abstract,fallback,transaction,attribute,source,in,spring,proper;public,void,test,does,not,resolve,tx,annotation,on,method,from,class,implementing,annotated,interface,throws,exception,annotation,transaction,attribute,source,atas,new,annotation,transaction,attribute,source,method,m,implements,annotated,interface,class,get,method,echo,throwable,class,transaction,attribute,ta,atas,get,transaction,attribute,m,implements,annotated,interface,class,assert,null,ta
TransactionAspectTests -> public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws Exception;1443395967;Note: resolution does not occur. Thus we can't make a class transactional if_it implements a transactionally annotated interface. This behaviour could only_be changed in AbstractFallbackTransactionAttributeSource in Spring proper.;public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws Exception {_		AnnotationTransactionAttributeSource atas = new AnnotationTransactionAttributeSource()__		Method m = ImplementsAnnotatedInterface.class.getMethod("echo", Throwable.class)__		TransactionAttribute ta = atas.getTransactionAttribute(m, ImplementsAnnotatedInterface.class)__		assertNull(ta)__	};note,resolution,does,not,occur,thus,we,can,t,make,a,class,transactional,if,it,implements,a,transactionally,annotated,interface,this,behaviour,could,only,be,changed,in,abstract,fallback,transaction,attribute,source,in,spring,proper;public,void,test,does,not,resolve,tx,annotation,on,method,from,class,implementing,annotated,interface,throws,exception,annotation,transaction,attribute,source,atas,new,annotation,transaction,attribute,source,method,m,implements,annotated,interface,class,get,method,echo,throwable,class,transaction,attribute,ta,atas,get,transaction,attribute,m,implements,annotated,interface,class,assert,null,ta
TransactionAspectTests -> @Test 	public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws Exception;1468943457;Note: resolution does not occur. Thus we can't make a class transactional if_it implements a transactionally annotated interface. This behaviour could only_be changed in AbstractFallbackTransactionAttributeSource in Spring proper.;@Test_	public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws Exception {_		AnnotationTransactionAttributeSource atas = new AnnotationTransactionAttributeSource()__		Method m = ImplementsAnnotatedInterface.class.getMethod("echo", Throwable.class)__		TransactionAttribute ta = atas.getTransactionAttribute(m, ImplementsAnnotatedInterface.class)__		assertNull(ta)__	};note,resolution,does,not,occur,thus,we,can,t,make,a,class,transactional,if,it,implements,a,transactionally,annotated,interface,this,behaviour,could,only,be,changed,in,abstract,fallback,transaction,attribute,source,in,spring,proper;test,public,void,test,does,not,resolve,tx,annotation,on,method,from,class,implementing,annotated,interface,throws,exception,annotation,transaction,attribute,source,atas,new,annotation,transaction,attribute,source,method,m,implements,annotated,interface,class,get,method,echo,throwable,class,transaction,attribute,ta,atas,get,transaction,attribute,m,implements,annotated,interface,class,assert,null,ta
TransactionAspectTests -> @Test 	public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws Exception;1488283875;Note: resolution does not occur. Thus we can't make a class transactional if_it implements a transactionally annotated interface. This behavior could only_be changed in AbstractFallbackTransactionAttributeSource in Spring proper._See SPR-14322.;@Test_	public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws Exception {_		AnnotationTransactionAttributeSource atas = new AnnotationTransactionAttributeSource()__		Method method = ImplementsAnnotatedInterface.class.getMethod("echo", Throwable.class)__		TransactionAttribute ta = atas.getTransactionAttribute(method, ImplementsAnnotatedInterface.class)__		assertNull(ta)__	};note,resolution,does,not,occur,thus,we,can,t,make,a,class,transactional,if,it,implements,a,transactionally,annotated,interface,this,behavior,could,only,be,changed,in,abstract,fallback,transaction,attribute,source,in,spring,proper,see,spr,14322;test,public,void,test,does,not,resolve,tx,annotation,on,method,from,class,implementing,annotated,interface,throws,exception,annotation,transaction,attribute,source,atas,new,annotation,transaction,attribute,source,method,method,implements,annotated,interface,class,get,method,echo,throwable,class,transaction,attribute,ta,atas,get,transaction,attribute,method,implements,annotated,interface,class,assert,null,ta
TransactionAspectTests -> public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException;1328020251;Note: resolution does not occur. Thus we can't make a class transactional if_it implements a transactionally annotated interface. This behaviour could only_be changed in AbstractFallbackTransactionAttributeSource in Spring proper._@throws SecurityException_@throws NoSuchMethodException;public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException {_		AnnotationTransactionAttributeSource atas = new AnnotationTransactionAttributeSource()__		Method m = ImplementsAnnotatedInterface.class.getMethod("echo", Throwable.class)__		TransactionAttribute ta = atas.getTransactionAttribute(m, ImplementsAnnotatedInterface.class)__		assertNull(ta)__	};note,resolution,does,not,occur,thus,we,can,t,make,a,class,transactional,if,it,implements,a,transactionally,annotated,interface,this,behaviour,could,only,be,changed,in,abstract,fallback,transaction,attribute,source,in,spring,proper,throws,security,exception,throws,no,such,method,exception;public,void,test,does,not,resolve,tx,annotation,on,method,from,class,implementing,annotated,interface,throws,security,exception,no,such,method,exception,annotation,transaction,attribute,source,atas,new,annotation,transaction,attribute,source,method,m,implements,annotated,interface,class,get,method,echo,throwable,class,transaction,attribute,ta,atas,get,transaction,attribute,m,implements,annotated,interface,class,assert,null,ta
TransactionAspectTests -> public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException;1356735495;Note: resolution does not occur. Thus we can't make a class transactional if_it implements a transactionally annotated interface. This behaviour could only_be changed in AbstractFallbackTransactionAttributeSource in Spring proper._@throws SecurityException_@throws NoSuchMethodException;public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException {_		AnnotationTransactionAttributeSource atas = new AnnotationTransactionAttributeSource()__		Method m = ImplementsAnnotatedInterface.class.getMethod("echo", Throwable.class)__		TransactionAttribute ta = atas.getTransactionAttribute(m, ImplementsAnnotatedInterface.class)__		assertNull(ta)__	};note,resolution,does,not,occur,thus,we,can,t,make,a,class,transactional,if,it,implements,a,transactionally,annotated,interface,this,behaviour,could,only,be,changed,in,abstract,fallback,transaction,attribute,source,in,spring,proper,throws,security,exception,throws,no,such,method,exception;public,void,test,does,not,resolve,tx,annotation,on,method,from,class,implementing,annotated,interface,throws,security,exception,no,such,method,exception,annotation,transaction,attribute,source,atas,new,annotation,transaction,attribute,source,method,m,implements,annotated,interface,class,get,method,echo,throwable,class,transaction,attribute,ta,atas,get,transaction,attribute,m,implements,annotated,interface,class,assert,null,ta
TransactionAspectTests -> public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException;1362408075;Note: resolution does not occur. Thus we can't make a class transactional if_it implements a transactionally annotated interface. This behaviour could only_be changed in AbstractFallbackTransactionAttributeSource in Spring proper._@throws SecurityException_@throws NoSuchMethodException;public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException {_		AnnotationTransactionAttributeSource atas = new AnnotationTransactionAttributeSource()__		Method m = ImplementsAnnotatedInterface.class.getMethod("echo", Throwable.class)__		TransactionAttribute ta = atas.getTransactionAttribute(m, ImplementsAnnotatedInterface.class)__		assertNull(ta)__	};note,resolution,does,not,occur,thus,we,can,t,make,a,class,transactional,if,it,implements,a,transactionally,annotated,interface,this,behaviour,could,only,be,changed,in,abstract,fallback,transaction,attribute,source,in,spring,proper,throws,security,exception,throws,no,such,method,exception;public,void,test,does,not,resolve,tx,annotation,on,method,from,class,implementing,annotated,interface,throws,security,exception,no,such,method,exception,annotation,transaction,attribute,source,atas,new,annotation,transaction,attribute,source,method,m,implements,annotated,interface,class,get,method,echo,throwable,class,transaction,attribute,ta,atas,get,transaction,attribute,m,implements,annotated,interface,class,assert,null,ta
TransactionAspectTests -> public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException;1368482696;Note: resolution does not occur. Thus we can't make a class transactional if_it implements a transactionally annotated interface. This behaviour could only_be changed in AbstractFallbackTransactionAttributeSource in Spring proper._@throws SecurityException_@throws NoSuchMethodException;public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException {_		AnnotationTransactionAttributeSource atas = new AnnotationTransactionAttributeSource()__		Method m = ImplementsAnnotatedInterface.class.getMethod("echo", Throwable.class)__		TransactionAttribute ta = atas.getTransactionAttribute(m, ImplementsAnnotatedInterface.class)__		assertNull(ta)__	};note,resolution,does,not,occur,thus,we,can,t,make,a,class,transactional,if,it,implements,a,transactionally,annotated,interface,this,behaviour,could,only,be,changed,in,abstract,fallback,transaction,attribute,source,in,spring,proper,throws,security,exception,throws,no,such,method,exception;public,void,test,does,not,resolve,tx,annotation,on,method,from,class,implementing,annotated,interface,throws,security,exception,no,such,method,exception,annotation,transaction,attribute,source,atas,new,annotation,transaction,attribute,source,method,m,implements,annotated,interface,class,get,method,echo,throwable,class,transaction,attribute,ta,atas,get,transaction,attribute,m,implements,annotated,interface,class,assert,null,ta
TransactionAspectTests -> public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException;1413848647;Note: resolution does not occur. Thus we can't make a class transactional if_it implements a transactionally annotated interface. This behaviour could only_be changed in AbstractFallbackTransactionAttributeSource in Spring proper._@throws SecurityException_@throws NoSuchMethodException;public void testDoesNotResolveTxAnnotationOnMethodFromClassImplementingAnnotatedInterface() throws SecurityException, NoSuchMethodException {_		AnnotationTransactionAttributeSource atas = new AnnotationTransactionAttributeSource()__		Method m = ImplementsAnnotatedInterface.class.getMethod("echo", Throwable.class)__		TransactionAttribute ta = atas.getTransactionAttribute(m, ImplementsAnnotatedInterface.class)__		assertNull(ta)__	};note,resolution,does,not,occur,thus,we,can,t,make,a,class,transactional,if,it,implements,a,transactionally,annotated,interface,this,behaviour,could,only,be,changed,in,abstract,fallback,transaction,attribute,source,in,spring,proper,throws,security,exception,throws,no,such,method,exception;public,void,test,does,not,resolve,tx,annotation,on,method,from,class,implementing,annotated,interface,throws,security,exception,no,such,method,exception,annotation,transaction,attribute,source,atas,new,annotation,transaction,attribute,source,method,m,implements,annotated,interface,class,get,method,echo,throwable,class,transaction,attribute,ta,atas,get,transaction,attribute,m,implements,annotated,interface,class,assert,null,ta
