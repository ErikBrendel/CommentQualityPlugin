commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void setUp() {     Assume.group(TestGroup.PERFORMANCE).     executor = new CountingExecutor().     AnnotationAsyncExecutionAspect.aspectOf().setExecutor(executor). }
false;public;0;9;;@Test public void asyncMethodGetsRoutedAsynchronously() {     ClassWithoutAsyncAnnotation obj = new ClassWithoutAsyncAnnotation().     obj.incrementAsync().     executor.waitForCompletion().     assertEquals(1, obj.counter).     assertEquals(1, executor.submitStartCounter).     assertEquals(1, executor.submitCompleteCounter). }
false;public;0;10;;@Test public void asyncMethodReturningFutureGetsRoutedAsynchronouslyAndReturnsAFuture() throws InterruptedException, ExecutionException {     ClassWithoutAsyncAnnotation obj = new ClassWithoutAsyncAnnotation().     Future<Integer> future = obj.incrementReturningAFuture().     // No need to executor.waitForCompletion() as future.get() will have the same effect     assertEquals(5, future.get().intValue()).     assertEquals(1, obj.counter).     assertEquals(1, executor.submitStartCounter).     assertEquals(1, executor.submitCompleteCounter). }
false;public;0;8;;@Test public void syncMethodGetsRoutedSynchronously() {     ClassWithoutAsyncAnnotation obj = new ClassWithoutAsyncAnnotation().     obj.increment().     assertEquals(1, obj.counter).     assertEquals(0, executor.submitStartCounter).     assertEquals(0, executor.submitCompleteCounter). }
false;public;0;11;;@Test public void voidMethodInAsyncClassGetsRoutedAsynchronously() {     Assume.group(TestGroup.PERFORMANCE).     ClassWithAsyncAnnotation obj = new ClassWithAsyncAnnotation().     obj.increment().     executor.waitForCompletion().     assertEquals(1, obj.counter).     assertEquals(1, executor.submitStartCounter).     assertEquals(1, executor.submitCompleteCounter). }
false;public;0;9;;@Test public void methodReturningFutureInAsyncClassGetsRoutedAsynchronouslyAndReturnsAFuture() throws InterruptedException, ExecutionException {     ClassWithAsyncAnnotation obj = new ClassWithAsyncAnnotation().     Future<Integer> future = obj.incrementReturningAFuture().     assertEquals(5, future.get().intValue()).     assertEquals(1, obj.counter).     assertEquals(1, executor.submitStartCounter).     assertEquals(1, executor.submitCompleteCounter). }
false;public;0;18;;/* 	@Test 	public void methodReturningNonVoidNonFutureInAsyncClassGetsRoutedSynchronously() { 		ClassWithAsyncAnnotation obj = new ClassWithAsyncAnnotation(). 		int returnValue = obj.return5(). 		assertEquals(5, returnValue). 		assertEquals(0, executor.submitStartCounter). 		assertEquals(0, executor.submitCompleteCounter). 	} 	*/ @Test public void qualifiedAsyncMethodsAreRoutedToCorrectExecutor() throws InterruptedException, ExecutionException {     DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory().     beanFactory.registerBeanDefinition("e1", new RootBeanDefinition(ThreadPoolTaskExecutor.class)).     AnnotationAsyncExecutionAspect.aspectOf().setBeanFactory(beanFactory).     ClassWithQualifiedAsyncMethods obj = new ClassWithQualifiedAsyncMethods().     Future<Thread> defaultThread = obj.defaultWork().     assertThat(defaultThread.get(), not(Thread.currentThread())).     assertThat(defaultThread.get().getName(), not(startsWith("e1-"))).     ListenableFuture<Thread> e1Thread = obj.e1Work().     assertThat(e1Thread.get().getName(), startsWith("e1-")).     CompletableFuture<Thread> e1OtherThread = obj.e1OtherWork().     assertThat(e1OtherThread.get().getName(), startsWith("e1-")). }
false;public;0;16;;@Test public void exceptionHandlerCalled() {     Method m = ReflectionUtils.findMethod(ClassWithException.class, "failWithVoid").     TestableAsyncUncaughtExceptionHandler exceptionHandler = new TestableAsyncUncaughtExceptionHandler().     AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(exceptionHandler).     try {         assertFalse("Handler should not have been called", exceptionHandler.isCalled()).         ClassWithException obj = new ClassWithException().         obj.failWithVoid().         exceptionHandler.await(3000).         exceptionHandler.assertCalledWith(m, UnsupportedOperationException.class).     } finally {         AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(defaultExceptionHandler).     } }
false;public;0;22;;@Test public void exceptionHandlerNeverThrowsUnexpectedException() {     Method m = ReflectionUtils.findMethod(ClassWithException.class, "failWithVoid").     TestableAsyncUncaughtExceptionHandler exceptionHandler = new TestableAsyncUncaughtExceptionHandler(true).     AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(exceptionHandler).     try {         assertFalse("Handler should not have been called", exceptionHandler.isCalled()).         ClassWithException obj = new ClassWithException().         try {             obj.failWithVoid().             exceptionHandler.await(3000).             exceptionHandler.assertCalledWith(m, UnsupportedOperationException.class).         } catch (Exception ex) {             fail("No unexpected exception should have been received but got " + ex.getMessage()).         }     } finally {         AnnotationAsyncExecutionAspect.aspectOf().setExceptionHandler(defaultExceptionHandler).     } }
false;public;1;10;;@Override public <T> Future<T> submit(Callable<T> task) {     submitStartCounter++.     Future<T> future = super.submit(task).     submitCompleteCounter++.     synchronized (this) {         notifyAll().     }     return future. }
false;public,synchronized;0;8;;public synchronized void waitForCompletion() {     try {         wait(WAIT_TIME).     } catch (InterruptedException ex) {         fail("Didn't finish the async job in " + WAIT_TIME + " milliseconds").     } }
false;public;0;3;;@Async public void incrementAsync() {     counter++. }
false;public;0;3;;public void increment() {     counter++. }
false;public;0;4;;@Async public Future<Integer> incrementReturningAFuture() {     counter++.     return new AsyncResult<Integer>(5). }
false;public;0;3;;public void increment() {     counter++. }
false;public;0;4;;// Manually check that there is a warning from the 'declare warning' statement in // AnnotationAsyncExecutionAspect /* 		public int return5() { 			return 5. 		} 		*/ public Future<Integer> incrementReturningAFuture() {     counter++.     return new AsyncResult<Integer>(5). }
false;public;0;4;;@Async public Future<Thread> defaultWork() {     return new AsyncResult<Thread>(Thread.currentThread()). }
false;public;0;4;;@Async("e1") public ListenableFuture<Thread> e1Work() {     return new AsyncResult<Thread>(Thread.currentThread()). }
false;public;0;4;;@Async("e1") public CompletableFuture<Thread> e1OtherWork() {     return CompletableFuture.completedFuture(Thread.currentThread()). }
false;public;0;4;;@Async public void failWithVoid() {     throw new UnsupportedOperationException("failWithVoid"). }
