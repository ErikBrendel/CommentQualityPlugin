commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Assert the ServletResponse content type. The given content type must  * fully match including type, sub-type, and parameters. For checking  * only the type and sub-type see {@link #contentTypeCompatibleWith(String)}.  */ ;/**  * Assert the ServletResponse content type. The given content type must  * fully match including type, sub-type, and parameters. For checking  * only the type and sub-type see {@link #contentTypeCompatibleWith(String)}.  */ public ResultMatcher contentType(String contentType) {     return contentType(MediaType.parseMediaType(contentType)). }
true;public;1;9;/**  * Assert the ServletResponse content type after parsing it as a MediaType.  * The given content type must fully match including type, sub-type, and  * parameters. For checking only the type and sub-type see  * {@link #contentTypeCompatibleWith(MediaType)}.  */ ;/**  * Assert the ServletResponse content type after parsing it as a MediaType.  * The given content type must fully match including type, sub-type, and  * parameters. For checking only the type and sub-type see  * {@link #contentTypeCompatibleWith(MediaType)}.  */ public ResultMatcher contentType(final MediaType contentType) {     return result -> {         String actual = result.getResponse().getContentType().         assertTrue("Content type not set", actual != null).         if (actual != null) {             assertEquals("Content type", contentType, MediaType.parseMediaType(actual)).         }     }. }
true;public;1;3;/**  * Assert the ServletResponse content type is compatible with the given  * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.  */ ;/**  * Assert the ServletResponse content type is compatible with the given  * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.  */ public ResultMatcher contentTypeCompatibleWith(String contentType) {     return contentTypeCompatibleWith(MediaType.parseMediaType(contentType)). }
true;public;1;11;/**  * Assert the ServletResponse content type is compatible with the given  * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.  */ ;/**  * Assert the ServletResponse content type is compatible with the given  * content type as defined by {@link MediaType#isCompatibleWith(MediaType)}.  */ public ResultMatcher contentTypeCompatibleWith(final MediaType contentType) {     return result -> {         String actual = result.getResponse().getContentType().         assertTrue("Content type not set", actual != null).         if (actual != null) {             MediaType actualContentType = MediaType.parseMediaType(actual).             assertTrue("Content type [" + actual + "] is not compatible with [" + contentType + "]", actualContentType.isCompatibleWith(contentType)).         }     }. }
true;public;1;6;/**  * Assert the character encoding in the ServletResponse.  * @see HttpServletResponse#getCharacterEncoding()  */ ;/**  * Assert the character encoding in the ServletResponse.  * @see HttpServletResponse#getCharacterEncoding()  */ public ResultMatcher encoding(final String characterEncoding) {     return result -> {         String actual = result.getResponse().getCharacterEncoding().         assertEquals("Character encoding", characterEncoding, actual).     }. }
true;public;1;3;/**  * Assert the response body content with a Hamcrest {@link Matcher}.  * <pre class="code">  * mockMvc.perform(get("/path"))  *   .andExpect(content().string(containsString("text"))).  * </pre>  */ ;/**  * Assert the response body content with a Hamcrest {@link Matcher}.  * <pre class="code">  * mockMvc.perform(get("/path"))  *   .andExpect(content().string(containsString("text"))).  * </pre>  */ public ResultMatcher string(final Matcher<? super String> matcher) {     return result -> assertThat("Response content", result.getResponse().getContentAsString(), matcher). }
true;public;1;3;/**  * Assert the response body content as a String.  */ ;/**  * Assert the response body content as a String.  */ public ResultMatcher string(final String expectedContent) {     return result -> assertEquals("Response content", expectedContent, result.getResponse().getContentAsString()). }
true;public;1;3;/**  * Assert the response body content as a byte array.  */ ;/**  * Assert the response body content as a byte array.  */ public ResultMatcher bytes(final byte[] expectedContent) {     return result -> assertEquals("Response content", expectedContent, result.getResponse().getContentAsByteArray()). }
true;public;1;6;/**  * Parse the response content and the given string as XML and assert the two  * are "similar" - i.e. they contain the same elements and attributes  * regardless of order.  * <p>Use of this matcher requires the <a  * href="http://xmlunit.sourceforge.net/">XMLUnit</a> library.  * @param xmlContent the expected XML content  * @see MockMvcResultMatchers#xpath(String, Object...)  * @see MockMvcResultMatchers#xpath(String, Map, Object...)  */ ;/**  * Parse the response content and the given string as XML and assert the two  * are "similar" - i.e. they contain the same elements and attributes  * regardless of order.  * <p>Use of this matcher requires the <a  * href="http://xmlunit.sourceforge.net/">XMLUnit</a> library.  * @param xmlContent the expected XML content  * @see MockMvcResultMatchers#xpath(String, Object...)  * @see MockMvcResultMatchers#xpath(String, Map, Object...)  */ public ResultMatcher xml(final String xmlContent) {     return result -> {         String content = result.getResponse().getContentAsString().         this.xmlHelper.assertXmlEqual(xmlContent, content).     }. }
true;public;1;6;/**  * Parse the response content as {@link Node} and apply the given Hamcrest  * {@link Matcher}.  */ ;/**  * Parse the response content as {@link Node} and apply the given Hamcrest  * {@link Matcher}.  */ public ResultMatcher node(final Matcher<? super Node> matcher) {     return result -> {         String content = result.getResponse().getContentAsString().         this.xmlHelper.assertNode(content, matcher).     }. }
true;public;1;6;/**  * Parse the response content as {@link DOMSource} and apply the given  * Hamcrest {@link Matcher}.  * @see <a href="http://code.google.com/p/xml-matchers/">xml-matchers</a>  */ ;/**  * Parse the response content as {@link DOMSource} and apply the given  * Hamcrest {@link Matcher}.  * @see <a href="http://code.google.com/p/xml-matchers/">xml-matchers</a>  */ public ResultMatcher source(final Matcher<? super Source> matcher) {     return result -> {         String content = result.getResponse().getContentAsString().         this.xmlHelper.assertSource(content, matcher).     }. }
true;public;1;3;/**  * Parse the expected and actual strings as JSON and assert the two  * are "similar" - i.e. they contain the same attribute-value pairs  * regardless of formatting with a lenient checking (extensible, and non-strict array  * ordering).  * @param jsonContent the expected JSON content  * @since 4.1  */ ;/**  * Parse the expected and actual strings as JSON and assert the two  * are "similar" - i.e. they contain the same attribute-value pairs  * regardless of formatting with a lenient checking (extensible, and non-strict array  * ordering).  * @param jsonContent the expected JSON content  * @since 4.1  */ public ResultMatcher json(final String jsonContent) {     return json(jsonContent, false). }
true;public;2;6;/**  * Parse the response content and the given string as JSON and assert the two are "similar" -  * i.e. they contain the same attribute-value pairs regardless of formatting.  * <p>Can compare in two modes, depending on {@code strict} parameter value:  * <ul>  * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>  * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>  * </ul>  * <p>Use of this matcher requires the <a  * href="http://jsonassert.skyscreamer.org/">JSONassert</a> library.  * @param jsonContent the expected JSON content  * @param strict enables strict checking  * @since 4.2  */ ;/**  * Parse the response content and the given string as JSON and assert the two are "similar" -  * i.e. they contain the same attribute-value pairs regardless of formatting.  * <p>Can compare in two modes, depending on {@code strict} parameter value:  * <ul>  * <li>{@code true}: strict checking. Not extensible, and strict array ordering.</li>  * <li>{@code false}: lenient checking. Extensible, and non-strict array ordering.</li>  * </ul>  * <p>Use of this matcher requires the <a  * href="http://jsonassert.skyscreamer.org/">JSONassert</a> library.  * @param jsonContent the expected JSON content  * @param strict enables strict checking  * @since 4.2  */ public ResultMatcher json(final String jsonContent, final boolean strict) {     return result -> {         String content = result.getResponse().getContentAsString().         this.jsonHelper.assertJsonEqual(jsonContent, content, strict).     }. }
