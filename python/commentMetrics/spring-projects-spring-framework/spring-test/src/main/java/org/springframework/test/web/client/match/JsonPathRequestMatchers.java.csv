commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.assertValue(request.getBodyAsString(), matcher). }
true;public;1;8;/**  * Evaluate the JSON path expression against the request content and  * assert the resulting value with the given Hamcrest {@link Matcher}.  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert the resulting value with the given Hamcrest {@link Matcher}.  */ public <T> RequestMatcher value(final Matcher<T> matcher) {     return new AbstractJsonPathRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.assertValue(request.getBodyAsString(), matcher).         }     }. }
false;protected;1;5;;@Override protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     String body = request.getBodyAsString().     JsonPathRequestMatchers.this.jsonPathHelper.assertValue(body, matcher, targetType). }
true;public;2;9;/**  * An overloaded variant of {@link #value(Matcher)} that also accepts a  * target type for the resulting value that the matcher can work reliably  * against.  * <p>This can be useful for matching numbers reliably &mdash. for example,  * to coerce an integer into a double.  * @since 4.3.3  */ ;/**  * An overloaded variant of {@link #value(Matcher)} that also accepts a  * target type for the resulting value that the matcher can work reliably  * against.  * <p>This can be useful for matching numbers reliably &mdash. for example,  * to coerce an integer into a double.  * @since 4.3.3  */ public <T> RequestMatcher value(final Matcher<T> matcher, final Class<T> targetType) {     return new AbstractJsonPathRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             String body = request.getBodyAsString().             JsonPathRequestMatchers.this.jsonPathHelper.assertValue(body, matcher, targetType).         }     }. }
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.assertValue(request.getBodyAsString(), expectedValue). }
true;public;1;8;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is equal to the supplied value.  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is equal to the supplied value.  */ public RequestMatcher value(final Object expectedValue) {     return new AbstractJsonPathRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.assertValue(request.getBodyAsString(), expectedValue).         }     }. }
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.exists(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the request content and  * assert that a non-null value exists at the given path.  * <p>If the JSON path expression is not {@linkplain JsonPath#isDefinite  * definite}, this method asserts that the value at the given path is not  * <em>empty</em>.  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that a non-null value exists at the given path.  * <p>If the JSON path expression is not {@linkplain JsonPath#isDefinite  * definite}, this method asserts that the value at the given path is not  * <em>empty</em>.  */ public RequestMatcher exists() {     return new AbstractJsonPathRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.exists(request.getBodyAsString()).         }     }. }
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.doesNotExist(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the request content and  * assert that a value does not exist at the given path.  * <p>If the JSON path expression is not {@linkplain JsonPath#isDefinite  * definite}, this method asserts that the value at the given path is  * <em>empty</em>.  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that a value does not exist at the given path.  * <p>If the JSON path expression is not {@linkplain JsonPath#isDefinite  * definite}, this method asserts that the value at the given path is  * <em>empty</em>.  */ public RequestMatcher doesNotExist() {     return new AbstractJsonPathRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.doesNotExist(request.getBodyAsString()).         }     }. }
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) {     JsonPathRequestMatchers.this.jsonPathHelper.hasJsonPath(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the response content  * and assert that a value, possibly {@code null}, exists.  * <p>If the JSON path expression is not  * {@linkplain JsonPath#isDefinite() definite}, this method asserts  * that the list of values at the given path is not <em>empty</em>.  * @since 5.0.3  * @see #exists()  * @see #isNotEmpty()  */ ;/**  * Evaluate the JSON path expression against the response content  * and assert that a value, possibly {@code null}, exists.  * <p>If the JSON path expression is not  * {@linkplain JsonPath#isDefinite() definite}, this method asserts  * that the list of values at the given path is not <em>empty</em>.  * @since 5.0.3  * @see #exists()  * @see #isNotEmpty()  */ public RequestMatcher hasJsonPath() {     return new AbstractJsonPathRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) {             JsonPathRequestMatchers.this.jsonPathHelper.hasJsonPath(request.getBodyAsString()).         }     }. }
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) {     JsonPathRequestMatchers.this.jsonPathHelper.doesNotHaveJsonPath(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the supplied {@code content}  * and assert that a value, including {@code null} values, does not exist  * at the given path.  * <p>If the JSON path expression is not  * {@linkplain JsonPath#isDefinite() definite}, this method asserts  * that the list of values at the given path is <em>empty</em>.  * @since 5.0.3  * @see #doesNotExist()  * @see #isEmpty()  */ ;/**  * Evaluate the JSON path expression against the supplied {@code content}  * and assert that a value, including {@code null} values, does not exist  * at the given path.  * <p>If the JSON path expression is not  * {@linkplain JsonPath#isDefinite() definite}, this method asserts  * that the list of values at the given path is <em>empty</em>.  * @since 5.0.3  * @see #doesNotExist()  * @see #isEmpty()  */ public RequestMatcher doesNotHaveJsonPath() {     return new AbstractJsonPathRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) {             JsonPathRequestMatchers.this.jsonPathHelper.doesNotHaveJsonPath(request.getBodyAsString()).         }     }. }
false;public;1;4;;@Override public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsEmpty(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the request content and  * assert that an empty value exists at the given path.  * <p>For the semantics of <em>empty</em>, consult the Javadoc for  * {@link org.springframework.util.ObjectUtils#isEmpty(Object)}.  * @since 4.2.1  * @see #isNotEmpty()  * @see #exists()  * @see #doesNotExist()  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that an empty value exists at the given path.  * <p>For the semantics of <em>empty</em>, consult the Javadoc for  * {@link org.springframework.util.ObjectUtils#isEmpty(Object)}.  * @since 4.2.1  * @see #isNotEmpty()  * @see #exists()  * @see #doesNotExist()  */ public RequestMatcher isEmpty() {     return new AbstractJsonPathRequestMatcher() {          @Override         public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsEmpty(request.getBodyAsString()).         }     }. }
false;public;1;4;;@Override public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsNotEmpty(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the request content and  * assert that a non-empty value exists at the given path.  * <p>For the semantics of <em>empty</em>, consult the Javadoc for  * {@link org.springframework.util.ObjectUtils#isEmpty(Object)}.  * @since 4.2.1  * @see #isEmpty()  * @see #exists()  * @see #doesNotExist()  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that a non-empty value exists at the given path.  * <p>For the semantics of <em>empty</em>, consult the Javadoc for  * {@link org.springframework.util.ObjectUtils#isEmpty(Object)}.  * @since 4.2.1  * @see #isEmpty()  * @see #exists()  * @see #doesNotExist()  */ public RequestMatcher isNotEmpty() {     return new AbstractJsonPathRequestMatcher() {          @Override         public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsNotEmpty(request.getBodyAsString()).         }     }. }
false;public;1;4;;@Override public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsString(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is a {@link String}.  * @since 4.2.1  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is a {@link String}.  * @since 4.2.1  */ public RequestMatcher isString() {     return new AbstractJsonPathRequestMatcher() {          @Override         public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsString(request.getBodyAsString()).         }     }. }
false;public;1;4;;@Override public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsBoolean(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is a {@link Boolean}.  * @since 4.2.1  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is a {@link Boolean}.  * @since 4.2.1  */ public RequestMatcher isBoolean() {     return new AbstractJsonPathRequestMatcher() {          @Override         public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsBoolean(request.getBodyAsString()).         }     }. }
false;public;1;4;;@Override public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsNumber(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is a {@link Number}.  * @since 4.2.1  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is a {@link Number}.  * @since 4.2.1  */ public RequestMatcher isNumber() {     return new AbstractJsonPathRequestMatcher() {          @Override         public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsNumber(request.getBodyAsString()).         }     }. }
false;protected;1;4;;@Override protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsArray(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is an array.  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is an array.  */ public RequestMatcher isArray() {     return new AbstractJsonPathRequestMatcher() {          @Override         protected void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsArray(request.getBodyAsString()).         }     }. }
false;public;1;4;;@Override public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {     JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsMap(request.getBodyAsString()). }
true;public;0;8;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is a {@link java.util.Map}.  * @since 4.2.1  */ ;/**  * Evaluate the JSON path expression against the request content and  * assert that the result is a {@link java.util.Map}.  * @since 4.2.1  */ public RequestMatcher isMap() {     return new AbstractJsonPathRequestMatcher() {          @Override         public void matchInternal(MockClientHttpRequest request) throws IOException, ParseException {             JsonPathRequestMatchers.this.jsonPathHelper.assertValueIsMap(request.getBodyAsString()).         }     }. }
false;public,final;1;10;;@Override public final void match(ClientHttpRequest request) throws IOException, AssertionError {     try {         MockClientHttpRequest mockRequest = (MockClientHttpRequest) request.         matchInternal(mockRequest).     } catch (ParseException ex) {         throw new AssertionError("Failed to parse JSON request content", ex).     } }
false;abstract;1;1;;abstract void matchInternal(MockClientHttpRequest request) throws IOException, ParseException.
