# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractExpressionEvaluatingCondition -> protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType, 			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor, boolean enabledOnTrue, 			ExtensionContext context);1472652718;Evaluate the expression configured via the supplied annotation type on_the {@link AnnotatedElement} for the supplied {@link ExtensionContext}.__@param annotationType the type of annotation to process_@param expressionExtractor a function that extracts the expression from_the annotation_@param reasonExtractor a function that extracts the reason from the_annotation_@param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}_should be {@link ConditionEvaluationResult#enabled enabled} if the expression_evaluates to {@code true}_@param context the {@code ExtensionContext}_@return {@link ConditionEvaluationResult#enabled enabled} if the container_or test should be enabled_ otherwise {@link ConditionEvaluationResult#disabled disabled};protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,_			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor, boolean enabledOnTrue,_			ExtensionContext context) {__		AnnotatedElement element = context.getElement().get()__		Optional<A> annotation = findMergedAnnotation(element, annotationType)___		if (!annotation.isPresent()) {_			String reason = String.format("%s is enabled since @%s is not present", element,_					annotationType.getSimpleName())__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return ConditionEvaluationResult.enabled(reason)__		}__		_		String expression = annotation.map(expressionExtractor).map(String::trim).filter(StringUtils::hasLength)_				.orElseThrow(() -> new IllegalStateException(String.format(_						"The expression in @%s on [%s] must not be blank", annotationType.getSimpleName(), element)))__		__		boolean result = evaluateExpression(expression, annotationType, context)___		if (result) {_			String adjective = (enabledOnTrue ? "enabled" : "disabled")__			String reason = annotation.map(reasonExtractor).filter(StringUtils::hasText).orElseGet(_					() -> String.format("%s is %s because @%s(\"%s\") evaluated to true", element, adjective,_						annotationType.getSimpleName(), expression))__			if (logger.isInfoEnabled()) {_				logger.info(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.enabled(reason)_					: ConditionEvaluationResult.disabled(reason))__		}_		else {_			String adjective = (enabledOnTrue ? "disabled" : "enabled")__			String reason = String.format("%s is %s because @%s(\"%s\") did not evaluate to true",_					element, adjective, annotationType.getSimpleName(), expression)__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.disabled(reason)_					: ConditionEvaluationResult.enabled(reason))__		}_	};evaluate,the,expression,configured,via,the,supplied,annotation,type,on,the,link,annotated,element,for,the,supplied,link,extension,context,param,annotation,type,the,type,of,annotation,to,process,param,expression,extractor,a,function,that,extracts,the,expression,from,the,annotation,param,reason,extractor,a,function,that,extracts,the,reason,from,the,annotation,param,enabled,on,true,indicates,whether,the,returned,code,condition,evaluation,result,should,be,link,condition,evaluation,result,enabled,enabled,if,the,expression,evaluates,to,code,true,param,context,the,code,extension,context,return,link,condition,evaluation,result,enabled,enabled,if,the,container,or,test,should,be,enabled,otherwise,link,condition,evaluation,result,disabled,disabled;protected,a,extends,annotation,condition,evaluation,result,evaluate,annotation,class,a,annotation,type,function,a,string,expression,extractor,function,a,string,reason,extractor,boolean,enabled,on,true,extension,context,context,annotated,element,element,context,get,element,get,optional,a,annotation,find,merged,annotation,element,annotation,type,if,annotation,is,present,string,reason,string,format,s,is,enabled,since,s,is,not,present,element,annotation,type,get,simple,name,if,logger,is,debug,enabled,logger,debug,reason,return,condition,evaluation,result,enabled,reason,string,expression,annotation,map,expression,extractor,map,string,trim,filter,string,utils,has,length,or,else,throw,new,illegal,state,exception,string,format,the,expression,in,s,on,s,must,not,be,blank,annotation,type,get,simple,name,element,boolean,result,evaluate,expression,expression,annotation,type,context,if,result,string,adjective,enabled,on,true,enabled,disabled,string,reason,annotation,map,reason,extractor,filter,string,utils,has,text,or,else,get,string,format,s,is,s,because,s,s,evaluated,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,info,enabled,logger,info,reason,return,enabled,on,true,condition,evaluation,result,enabled,reason,condition,evaluation,result,disabled,reason,else,string,adjective,enabled,on,true,disabled,enabled,string,reason,string,format,s,is,s,because,s,s,did,not,evaluate,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,debug,enabled,logger,debug,reason,return,enabled,on,true,condition,evaluation,result,disabled,reason,condition,evaluation,result,enabled,reason
AbstractExpressionEvaluatingCondition -> protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType, 			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor, boolean enabledOnTrue, 			ExtensionContext context);1472669559;Evaluate the expression configured via the supplied annotation type on_the {@link AnnotatedElement} for the supplied {@link ExtensionContext}.__@param annotationType the type of annotation to process_@param expressionExtractor a function that extracts the expression from_the annotation_@param reasonExtractor a function that extracts the reason from the_annotation_@param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}_should be {@link ConditionEvaluationResult#enabled enabled} if the expression_evaluates to {@code true}_@param context the {@code ExtensionContext}_@return {@link ConditionEvaluationResult#enabled enabled} if the container_or test should be enabled_ otherwise {@link ConditionEvaluationResult#disabled disabled};protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,_			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor, boolean enabledOnTrue,_			ExtensionContext context) {__		AnnotatedElement element = context.getElement().get()__		Optional<A> annotation = findMergedAnnotation(element, annotationType)___		if (!annotation.isPresent()) {_			String reason = String.format("%s is enabled since @%s is not present", element,_					annotationType.getSimpleName())__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return ConditionEvaluationResult.enabled(reason)__		}__		_		String expression = annotation.map(expressionExtractor).map(String::trim).filter(StringUtils::hasLength)_				.orElseThrow(() -> new IllegalStateException(String.format(_						"The expression in @%s on [%s] must not be blank", annotationType.getSimpleName(), element)))__		__		boolean evaluatedToTrue = evaluateExpression(expression, annotationType, context)___		if (evaluatedToTrue) {_			String adjective = (enabledOnTrue ? "enabled" : "disabled")__			String reason = annotation.map(reasonExtractor).filter(StringUtils::hasText).orElseGet(_					() -> String.format("%s is %s because @%s(\"%s\") evaluated to true", element, adjective,_						annotationType.getSimpleName(), expression))__			if (logger.isInfoEnabled()) {_				logger.info(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.enabled(reason)_					: ConditionEvaluationResult.disabled(reason))__		}_		else {_			String adjective = (enabledOnTrue ? "disabled" : "enabled")__			String reason = String.format("%s is %s because @%s(\"%s\") did not evaluate to true",_					element, adjective, annotationType.getSimpleName(), expression)__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.disabled(reason)_					: ConditionEvaluationResult.enabled(reason))__		}_	};evaluate,the,expression,configured,via,the,supplied,annotation,type,on,the,link,annotated,element,for,the,supplied,link,extension,context,param,annotation,type,the,type,of,annotation,to,process,param,expression,extractor,a,function,that,extracts,the,expression,from,the,annotation,param,reason,extractor,a,function,that,extracts,the,reason,from,the,annotation,param,enabled,on,true,indicates,whether,the,returned,code,condition,evaluation,result,should,be,link,condition,evaluation,result,enabled,enabled,if,the,expression,evaluates,to,code,true,param,context,the,code,extension,context,return,link,condition,evaluation,result,enabled,enabled,if,the,container,or,test,should,be,enabled,otherwise,link,condition,evaluation,result,disabled,disabled;protected,a,extends,annotation,condition,evaluation,result,evaluate,annotation,class,a,annotation,type,function,a,string,expression,extractor,function,a,string,reason,extractor,boolean,enabled,on,true,extension,context,context,annotated,element,element,context,get,element,get,optional,a,annotation,find,merged,annotation,element,annotation,type,if,annotation,is,present,string,reason,string,format,s,is,enabled,since,s,is,not,present,element,annotation,type,get,simple,name,if,logger,is,debug,enabled,logger,debug,reason,return,condition,evaluation,result,enabled,reason,string,expression,annotation,map,expression,extractor,map,string,trim,filter,string,utils,has,length,or,else,throw,new,illegal,state,exception,string,format,the,expression,in,s,on,s,must,not,be,blank,annotation,type,get,simple,name,element,boolean,evaluated,to,true,evaluate,expression,expression,annotation,type,context,if,evaluated,to,true,string,adjective,enabled,on,true,enabled,disabled,string,reason,annotation,map,reason,extractor,filter,string,utils,has,text,or,else,get,string,format,s,is,s,because,s,s,evaluated,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,info,enabled,logger,info,reason,return,enabled,on,true,condition,evaluation,result,enabled,reason,condition,evaluation,result,disabled,reason,else,string,adjective,enabled,on,true,disabled,enabled,string,reason,string,format,s,is,s,because,s,s,did,not,evaluate,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,debug,enabled,logger,debug,reason,return,enabled,on,true,condition,evaluation,result,disabled,reason,condition,evaluation,result,enabled,reason
AbstractExpressionEvaluatingCondition -> protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType, 			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor, 			Function<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context);1477579952;Evaluate the expression configured via the supplied annotation type on_the {@link AnnotatedElement} for the supplied {@link ExtensionContext}.__@param annotationType the type of annotation to process_@param expressionExtractor a function that extracts the expression from_the annotation_@param reasonExtractor a function that extracts the reason from the_annotation_@param loadContextExtractor a function that extracts the {@code loadContext}_flag from the annotation_@param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}_should be {@link ConditionEvaluationResult#enabled enabled} if the expression_evaluates to {@code true}_@param context the {@code ExtensionContext}_@return {@link ConditionEvaluationResult#enabled enabled} if the container_or test should be enabled_ otherwise {@link ConditionEvaluationResult#disabled disabled};protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,_			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor,_			Function<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context) {__		AnnotatedElement element = context.getElement().get()__		Optional<A> annotation = findMergedAnnotation(element, annotationType)___		if (!annotation.isPresent()) {_			String reason = String.format("%s is enabled since @%s is not present", element,_					annotationType.getSimpleName())__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return ConditionEvaluationResult.enabled(reason)__		}__		_		String expression = annotation.map(expressionExtractor).map(String::trim).filter(StringUtils::hasLength)_				.orElseThrow(() -> new IllegalStateException(String.format(_						"The expression in @%s on [%s] must not be blank", annotationType.getSimpleName(), element)))__		__		boolean loadContext = annotation.map(loadContextExtractor).get()__		boolean evaluatedToTrue = evaluateExpression(expression, loadContext, annotationType, context)___		if (evaluatedToTrue) {_			String adjective = (enabledOnTrue ? "enabled" : "disabled")__			String reason = annotation.map(reasonExtractor).filter(StringUtils::hasText).orElseGet(_					() -> String.format("%s is %s because @%s(\"%s\") evaluated to true", element, adjective,_						annotationType.getSimpleName(), expression))__			if (logger.isInfoEnabled()) {_				logger.info(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.enabled(reason)_					: ConditionEvaluationResult.disabled(reason))__		}_		else {_			String adjective = (enabledOnTrue ? "disabled" : "enabled")__			String reason = String.format("%s is %s because @%s(\"%s\") did not evaluate to true",_					element, adjective, annotationType.getSimpleName(), expression)__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.disabled(reason)_					: ConditionEvaluationResult.enabled(reason))__		}_	};evaluate,the,expression,configured,via,the,supplied,annotation,type,on,the,link,annotated,element,for,the,supplied,link,extension,context,param,annotation,type,the,type,of,annotation,to,process,param,expression,extractor,a,function,that,extracts,the,expression,from,the,annotation,param,reason,extractor,a,function,that,extracts,the,reason,from,the,annotation,param,load,context,extractor,a,function,that,extracts,the,code,load,context,flag,from,the,annotation,param,enabled,on,true,indicates,whether,the,returned,code,condition,evaluation,result,should,be,link,condition,evaluation,result,enabled,enabled,if,the,expression,evaluates,to,code,true,param,context,the,code,extension,context,return,link,condition,evaluation,result,enabled,enabled,if,the,container,or,test,should,be,enabled,otherwise,link,condition,evaluation,result,disabled,disabled;protected,a,extends,annotation,condition,evaluation,result,evaluate,annotation,class,a,annotation,type,function,a,string,expression,extractor,function,a,string,reason,extractor,function,a,boolean,load,context,extractor,boolean,enabled,on,true,extension,context,context,annotated,element,element,context,get,element,get,optional,a,annotation,find,merged,annotation,element,annotation,type,if,annotation,is,present,string,reason,string,format,s,is,enabled,since,s,is,not,present,element,annotation,type,get,simple,name,if,logger,is,debug,enabled,logger,debug,reason,return,condition,evaluation,result,enabled,reason,string,expression,annotation,map,expression,extractor,map,string,trim,filter,string,utils,has,length,or,else,throw,new,illegal,state,exception,string,format,the,expression,in,s,on,s,must,not,be,blank,annotation,type,get,simple,name,element,boolean,load,context,annotation,map,load,context,extractor,get,boolean,evaluated,to,true,evaluate,expression,expression,load,context,annotation,type,context,if,evaluated,to,true,string,adjective,enabled,on,true,enabled,disabled,string,reason,annotation,map,reason,extractor,filter,string,utils,has,text,or,else,get,string,format,s,is,s,because,s,s,evaluated,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,info,enabled,logger,info,reason,return,enabled,on,true,condition,evaluation,result,enabled,reason,condition,evaluation,result,disabled,reason,else,string,adjective,enabled,on,true,disabled,enabled,string,reason,string,format,s,is,s,because,s,s,did,not,evaluate,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,debug,enabled,logger,debug,reason,return,enabled,on,true,condition,evaluation,result,disabled,reason,condition,evaluation,result,enabled,reason
AbstractExpressionEvaluatingCondition -> protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType, 			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor, 			Function<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context);1496955179;Evaluate the expression configured via the supplied annotation type on_the {@link AnnotatedElement} for the supplied {@link ExtensionContext}.__@param annotationType the type of annotation to process_@param expressionExtractor a function that extracts the expression from_the annotation_@param reasonExtractor a function that extracts the reason from the_annotation_@param loadContextExtractor a function that extracts the {@code loadContext}_flag from the annotation_@param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}_should be {@link ConditionEvaluationResult#enabled enabled} if the expression_evaluates to {@code true}_@param context the {@code ExtensionContext}_@return {@link ConditionEvaluationResult#enabled enabled} if the container_or test should be enabled_ otherwise {@link ConditionEvaluationResult#disabled disabled};protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,_			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor,_			Function<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context) {__		AnnotatedElement element = context.getElement().get()__		Optional<A> annotation = findMergedAnnotation(element, annotationType)___		if (!annotation.isPresent()) {_			String reason = String.format("%s is enabled since @%s is not present", element,_					annotationType.getSimpleName())__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return ConditionEvaluationResult.enabled(reason)__		}__		_		String expression = annotation.map(expressionExtractor).map(String::trim).filter(StringUtils::hasLength)_				.orElseThrow(() -> new IllegalStateException(String.format(_						"The expression in @%s on [%s] must not be blank", annotationType.getSimpleName(), element)))__		__		boolean loadContext = annotation.map(loadContextExtractor).get()__		boolean evaluatedToTrue = evaluateExpression(expression, loadContext, annotationType, context)___		if (evaluatedToTrue) {_			String adjective = (enabledOnTrue ? "enabled" : "disabled")__			String reason = annotation.map(reasonExtractor).filter(StringUtils::hasText).orElseGet(_					() -> String.format("%s is %s because @%s(\"%s\") evaluated to true", element, adjective,_						annotationType.getSimpleName(), expression))__			if (logger.isInfoEnabled()) {_				logger.info(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.enabled(reason)_					: ConditionEvaluationResult.disabled(reason))__		}_		else {_			String adjective = (enabledOnTrue ? "disabled" : "enabled")__			String reason = String.format("%s is %s because @%s(\"%s\") did not evaluate to true",_					element, adjective, annotationType.getSimpleName(), expression)__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.disabled(reason)_					: ConditionEvaluationResult.enabled(reason))__		}_	};evaluate,the,expression,configured,via,the,supplied,annotation,type,on,the,link,annotated,element,for,the,supplied,link,extension,context,param,annotation,type,the,type,of,annotation,to,process,param,expression,extractor,a,function,that,extracts,the,expression,from,the,annotation,param,reason,extractor,a,function,that,extracts,the,reason,from,the,annotation,param,load,context,extractor,a,function,that,extracts,the,code,load,context,flag,from,the,annotation,param,enabled,on,true,indicates,whether,the,returned,code,condition,evaluation,result,should,be,link,condition,evaluation,result,enabled,enabled,if,the,expression,evaluates,to,code,true,param,context,the,code,extension,context,return,link,condition,evaluation,result,enabled,enabled,if,the,container,or,test,should,be,enabled,otherwise,link,condition,evaluation,result,disabled,disabled;protected,a,extends,annotation,condition,evaluation,result,evaluate,annotation,class,a,annotation,type,function,a,string,expression,extractor,function,a,string,reason,extractor,function,a,boolean,load,context,extractor,boolean,enabled,on,true,extension,context,context,annotated,element,element,context,get,element,get,optional,a,annotation,find,merged,annotation,element,annotation,type,if,annotation,is,present,string,reason,string,format,s,is,enabled,since,s,is,not,present,element,annotation,type,get,simple,name,if,logger,is,debug,enabled,logger,debug,reason,return,condition,evaluation,result,enabled,reason,string,expression,annotation,map,expression,extractor,map,string,trim,filter,string,utils,has,length,or,else,throw,new,illegal,state,exception,string,format,the,expression,in,s,on,s,must,not,be,blank,annotation,type,get,simple,name,element,boolean,load,context,annotation,map,load,context,extractor,get,boolean,evaluated,to,true,evaluate,expression,expression,load,context,annotation,type,context,if,evaluated,to,true,string,adjective,enabled,on,true,enabled,disabled,string,reason,annotation,map,reason,extractor,filter,string,utils,has,text,or,else,get,string,format,s,is,s,because,s,s,evaluated,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,info,enabled,logger,info,reason,return,enabled,on,true,condition,evaluation,result,enabled,reason,condition,evaluation,result,disabled,reason,else,string,adjective,enabled,on,true,disabled,enabled,string,reason,string,format,s,is,s,because,s,s,did,not,evaluate,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,debug,enabled,logger,debug,reason,return,enabled,on,true,condition,evaluation,result,disabled,reason,condition,evaluation,result,enabled,reason
AbstractExpressionEvaluatingCondition -> protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType, 			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor, 			Function<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context);1499199673;Evaluate the expression configured via the supplied annotation type on_the {@link AnnotatedElement} for the supplied {@link ExtensionContext}.__@param annotationType the type of annotation to process_@param expressionExtractor a function that extracts the expression from_the annotation_@param reasonExtractor a function that extracts the reason from the_annotation_@param loadContextExtractor a function that extracts the {@code loadContext}_flag from the annotation_@param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}_should be {@link ConditionEvaluationResult#enabled enabled} if the expression_evaluates to {@code true}_@param context the {@code ExtensionContext}_@return {@link ConditionEvaluationResult#enabled enabled} if the container_or test should be enabled_ otherwise {@link ConditionEvaluationResult#disabled disabled};protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,_			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor,_			Function<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context) {__		AnnotatedElement element = context.getElement().get()__		Optional<A> annotation = findMergedAnnotation(element, annotationType)___		if (!annotation.isPresent()) {_			String reason = String.format("%s is enabled since @%s is not present", element,_					annotationType.getSimpleName())__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return ConditionEvaluationResult.enabled(reason)__		}__		_		String expression = annotation.map(expressionExtractor).map(String::trim).filter(StringUtils::hasLength)_				.orElseThrow(() -> new IllegalStateException(String.format(_						"The expression in @%s on [%s] must not be blank", annotationType.getSimpleName(), element)))__		__		boolean loadContext = annotation.map(loadContextExtractor).get()__		boolean evaluatedToTrue = evaluateExpression(expression, loadContext, annotationType, context)___		if (evaluatedToTrue) {_			String adjective = (enabledOnTrue ? "enabled" : "disabled")__			String reason = annotation.map(reasonExtractor).filter(StringUtils::hasText).orElseGet(_					() -> String.format("%s is %s because @%s(\"%s\") evaluated to true", element, adjective,_						annotationType.getSimpleName(), expression))__			if (logger.isInfoEnabled()) {_				logger.info(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.enabled(reason)_					: ConditionEvaluationResult.disabled(reason))__		}_		else {_			String adjective = (enabledOnTrue ? "disabled" : "enabled")__			String reason = String.format("%s is %s because @%s(\"%s\") did not evaluate to true",_					element, adjective, annotationType.getSimpleName(), expression)__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.disabled(reason)_					: ConditionEvaluationResult.enabled(reason))__		}_	};evaluate,the,expression,configured,via,the,supplied,annotation,type,on,the,link,annotated,element,for,the,supplied,link,extension,context,param,annotation,type,the,type,of,annotation,to,process,param,expression,extractor,a,function,that,extracts,the,expression,from,the,annotation,param,reason,extractor,a,function,that,extracts,the,reason,from,the,annotation,param,load,context,extractor,a,function,that,extracts,the,code,load,context,flag,from,the,annotation,param,enabled,on,true,indicates,whether,the,returned,code,condition,evaluation,result,should,be,link,condition,evaluation,result,enabled,enabled,if,the,expression,evaluates,to,code,true,param,context,the,code,extension,context,return,link,condition,evaluation,result,enabled,enabled,if,the,container,or,test,should,be,enabled,otherwise,link,condition,evaluation,result,disabled,disabled;protected,a,extends,annotation,condition,evaluation,result,evaluate,annotation,class,a,annotation,type,function,a,string,expression,extractor,function,a,string,reason,extractor,function,a,boolean,load,context,extractor,boolean,enabled,on,true,extension,context,context,annotated,element,element,context,get,element,get,optional,a,annotation,find,merged,annotation,element,annotation,type,if,annotation,is,present,string,reason,string,format,s,is,enabled,since,s,is,not,present,element,annotation,type,get,simple,name,if,logger,is,debug,enabled,logger,debug,reason,return,condition,evaluation,result,enabled,reason,string,expression,annotation,map,expression,extractor,map,string,trim,filter,string,utils,has,length,or,else,throw,new,illegal,state,exception,string,format,the,expression,in,s,on,s,must,not,be,blank,annotation,type,get,simple,name,element,boolean,load,context,annotation,map,load,context,extractor,get,boolean,evaluated,to,true,evaluate,expression,expression,load,context,annotation,type,context,if,evaluated,to,true,string,adjective,enabled,on,true,enabled,disabled,string,reason,annotation,map,reason,extractor,filter,string,utils,has,text,or,else,get,string,format,s,is,s,because,s,s,evaluated,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,info,enabled,logger,info,reason,return,enabled,on,true,condition,evaluation,result,enabled,reason,condition,evaluation,result,disabled,reason,else,string,adjective,enabled,on,true,disabled,enabled,string,reason,string,format,s,is,s,because,s,s,did,not,evaluate,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,debug,enabled,logger,debug,reason,return,enabled,on,true,condition,evaluation,result,disabled,reason,condition,evaluation,result,enabled,reason
AbstractExpressionEvaluatingCondition -> protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType, 			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor, 			Function<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context);1506097334;Evaluate the expression configured via the supplied annotation type on_the {@link AnnotatedElement} for the supplied {@link ExtensionContext}._@param annotationType the type of annotation to process_@param expressionExtractor a function that extracts the expression from_the annotation_@param reasonExtractor a function that extracts the reason from the_annotation_@param loadContextExtractor a function that extracts the {@code loadContext}_flag from the annotation_@param enabledOnTrue indicates whether the returned {@code ConditionEvaluationResult}_should be {@link ConditionEvaluationResult#enabled enabled} if the expression_evaluates to {@code true}_@param context the {@code ExtensionContext}_@return {@link ConditionEvaluationResult#enabled enabled} if the container_or test should be enabled_ otherwise {@link ConditionEvaluationResult#disabled disabled};protected <A extends Annotation> ConditionEvaluationResult evaluateAnnotation(Class<A> annotationType,_			Function<A, String> expressionExtractor, Function<A, String> reasonExtractor,_			Function<A, Boolean> loadContextExtractor, boolean enabledOnTrue, ExtensionContext context) {__		Assert.state(context.getElement().isPresent(), "No AnnotatedElement")__		AnnotatedElement element = context.getElement().get()__		Optional<A> annotation = findMergedAnnotation(element, annotationType)___		if (!annotation.isPresent()) {_			String reason = String.format("%s is enabled since @%s is not present", element,_					annotationType.getSimpleName())__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return ConditionEvaluationResult.enabled(reason)__		}__		String expression = annotation.map(expressionExtractor).map(String::trim).filter(StringUtils::hasLength)_				.orElseThrow(() -> new IllegalStateException(String.format(_						"The expression in @%s on [%s] must not be blank", annotationType.getSimpleName(), element)))___		boolean loadContext = loadContextExtractor.apply(annotation.get())__		boolean evaluatedToTrue = evaluateExpression(expression, loadContext, annotationType, context)___		if (evaluatedToTrue) {_			String adjective = (enabledOnTrue ? "enabled" : "disabled")__			String reason = annotation.map(reasonExtractor).filter(StringUtils::hasText).orElseGet(_					() -> String.format("%s is %s because @%s(\"%s\") evaluated to true", element, adjective,_						annotationType.getSimpleName(), expression))__			if (logger.isInfoEnabled()) {_				logger.info(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.enabled(reason)_					: ConditionEvaluationResult.disabled(reason))__		}_		else {_			String adjective = (enabledOnTrue ? "disabled" : "enabled")__			String reason = String.format("%s is %s because @%s(\"%s\") did not evaluate to true",_					element, adjective, annotationType.getSimpleName(), expression)__			if (logger.isDebugEnabled()) {_				logger.debug(reason)__			}_			return (enabledOnTrue ? ConditionEvaluationResult.disabled(reason) :_					ConditionEvaluationResult.enabled(reason))__		}_	};evaluate,the,expression,configured,via,the,supplied,annotation,type,on,the,link,annotated,element,for,the,supplied,link,extension,context,param,annotation,type,the,type,of,annotation,to,process,param,expression,extractor,a,function,that,extracts,the,expression,from,the,annotation,param,reason,extractor,a,function,that,extracts,the,reason,from,the,annotation,param,load,context,extractor,a,function,that,extracts,the,code,load,context,flag,from,the,annotation,param,enabled,on,true,indicates,whether,the,returned,code,condition,evaluation,result,should,be,link,condition,evaluation,result,enabled,enabled,if,the,expression,evaluates,to,code,true,param,context,the,code,extension,context,return,link,condition,evaluation,result,enabled,enabled,if,the,container,or,test,should,be,enabled,otherwise,link,condition,evaluation,result,disabled,disabled;protected,a,extends,annotation,condition,evaluation,result,evaluate,annotation,class,a,annotation,type,function,a,string,expression,extractor,function,a,string,reason,extractor,function,a,boolean,load,context,extractor,boolean,enabled,on,true,extension,context,context,assert,state,context,get,element,is,present,no,annotated,element,annotated,element,element,context,get,element,get,optional,a,annotation,find,merged,annotation,element,annotation,type,if,annotation,is,present,string,reason,string,format,s,is,enabled,since,s,is,not,present,element,annotation,type,get,simple,name,if,logger,is,debug,enabled,logger,debug,reason,return,condition,evaluation,result,enabled,reason,string,expression,annotation,map,expression,extractor,map,string,trim,filter,string,utils,has,length,or,else,throw,new,illegal,state,exception,string,format,the,expression,in,s,on,s,must,not,be,blank,annotation,type,get,simple,name,element,boolean,load,context,load,context,extractor,apply,annotation,get,boolean,evaluated,to,true,evaluate,expression,expression,load,context,annotation,type,context,if,evaluated,to,true,string,adjective,enabled,on,true,enabled,disabled,string,reason,annotation,map,reason,extractor,filter,string,utils,has,text,or,else,get,string,format,s,is,s,because,s,s,evaluated,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,info,enabled,logger,info,reason,return,enabled,on,true,condition,evaluation,result,enabled,reason,condition,evaluation,result,disabled,reason,else,string,adjective,enabled,on,true,disabled,enabled,string,reason,string,format,s,is,s,because,s,s,did,not,evaluate,to,true,element,adjective,annotation,type,get,simple,name,expression,if,logger,is,debug,enabled,logger,debug,reason,return,enabled,on,true,condition,evaluation,result,disabled,reason,condition,evaluation,result,enabled,reason
