commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public TestContext get() {     return copyTestContext(TestContextManager.this.testContext). }
true;public,final;0;3;/**  * Get the {@link TestContext} managed by this {@code TestContextManager}.  */ ;/**  * Get the {@link TestContext} managed by this {@code TestContextManager}.  */ public final TestContext getTestContext() {     return this.testContextHolder.get(). }
true;public;1;3;/**  * Register the supplied list of {@link TestExecutionListener TestExecutionListeners}  * by appending them to the list of listeners used by this {@code TestContextManager}.  * @see #registerTestExecutionListeners(TestExecutionListener...)  */ ;/**  * Register the supplied list of {@link TestExecutionListener TestExecutionListeners}  * by appending them to the list of listeners used by this {@code TestContextManager}.  * @see #registerTestExecutionListeners(TestExecutionListener...)  */ public void registerTestExecutionListeners(List<TestExecutionListener> testExecutionListeners) {     registerTestExecutionListeners(testExecutionListeners.toArray(new TestExecutionListener[0])). }
true;public;1;8;/**  * Register the supplied array of {@link TestExecutionListener TestExecutionListeners}  * by appending them to the list of listeners used by this {@code TestContextManager}.  */ ;/**  * Register the supplied array of {@link TestExecutionListener TestExecutionListeners}  * by appending them to the list of listeners used by this {@code TestContextManager}.  */ public void registerTestExecutionListeners(TestExecutionListener... testExecutionListeners) {     for (TestExecutionListener listener : testExecutionListeners) {         if (logger.isTraceEnabled()) {             logger.trace("Registering TestExecutionListener: " + listener).         }         this.testExecutionListeners.add(listener).     } }
true;public,final;0;3;/**  * Get the current {@link TestExecutionListener TestExecutionListeners}  * registered for this {@code TestContextManager}.  * <p>Allows for modifications, e.g. adding a listener to the beginning of the list.  * However, make sure to keep the list stable while actually executing tests.  */ ;/**  * Get the current {@link TestExecutionListener TestExecutionListeners}  * registered for this {@code TestContextManager}.  * <p>Allows for modifications, e.g. adding a listener to the beginning of the list.  * However, make sure to keep the list stable while actually executing tests.  */ public final List<TestExecutionListener> getTestExecutionListeners() {     return this.testExecutionListeners. }
true;private;0;5;/**  * Get a copy of the {@link TestExecutionListener TestExecutionListeners}  * registered for this {@code TestContextManager} in reverse order.  */ ;/**  * Get a copy of the {@link TestExecutionListener TestExecutionListeners}  * registered for this {@code TestContextManager} in reverse order.  */ private List<TestExecutionListener> getReversedTestExecutionListeners() {     List<TestExecutionListener> listenersReversed = new ArrayList<>(getTestExecutionListeners()).     Collections.reverse(listenersReversed).     return listenersReversed. }
true;public;0;17;/**  * Hook for pre-processing a test class <em>before</em> execution of any  * tests within the class. Should be called prior to any framework-specific  * <em>before class methods</em> (e.g., methods annotated with JUnit 4's  * {@link org.junit.BeforeClass @BeforeClass}).  * <p>An attempt will be made to give each registered  * {@link TestExecutionListener} a chance to pre-process the test class  * execution. If a listener throws an exception, however, the remaining  * registered listeners will <strong>not</strong> be called.  * @throws Exception if a registered TestExecutionListener throws an  * exception  * @since 3.0  * @see #getTestExecutionListeners()  */ ;/**  * Hook for pre-processing a test class <em>before</em> execution of any  * tests within the class. Should be called prior to any framework-specific  * <em>before class methods</em> (e.g., methods annotated with JUnit 4's  * {@link org.junit.BeforeClass @BeforeClass}).  * <p>An attempt will be made to give each registered  * {@link TestExecutionListener} a chance to pre-process the test class  * execution. If a listener throws an exception, however, the remaining  * registered listeners will <strong>not</strong> be called.  * @throws Exception if a registered TestExecutionListener throws an  * exception  * @since 3.0  * @see #getTestExecutionListeners()  */ public void beforeTestClass() throws Exception {     Class<?> testClass = getTestContext().getTestClass().     if (logger.isTraceEnabled()) {         logger.trace("beforeTestClass(): class [" + testClass.getName() + "]").     }     getTestContext().updateState(null, null, null).     for (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {         try {             testExecutionListener.beforeTestClass(getTestContext()).         } catch (Throwable ex) {             logException(ex, "beforeTestClass", testExecutionListener, testClass).             ReflectionUtils.rethrowException(ex).         }     } }
true;public;1;19;/**  * Hook for preparing a test instance prior to execution of any individual  * test methods, for example for injecting dependencies, etc. Should be  * called immediately after instantiation of the test instance.  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance}.  * <p>An attempt will be made to give each registered  * {@link TestExecutionListener} a chance to prepare the test instance. If a  * listener throws an exception, however, the remaining registered listeners  * will <strong>not</strong> be called.  * @param testInstance the test instance to prepare (never {@code null})  * @throws Exception if a registered TestExecutionListener throws an exception  * @see #getTestExecutionListeners()  */ ;/**  * Hook for preparing a test instance prior to execution of any individual  * test methods, for example for injecting dependencies, etc. Should be  * called immediately after instantiation of the test instance.  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance}.  * <p>An attempt will be made to give each registered  * {@link TestExecutionListener} a chance to prepare the test instance. If a  * listener throws an exception, however, the remaining registered listeners  * will <strong>not</strong> be called.  * @param testInstance the test instance to prepare (never {@code null})  * @throws Exception if a registered TestExecutionListener throws an exception  * @see #getTestExecutionListeners()  */ public void prepareTestInstance(Object testInstance) throws Exception {     if (logger.isTraceEnabled()) {         logger.trace("prepareTestInstance(): instance [" + testInstance + "]").     }     getTestContext().updateState(testInstance, null, null).     for (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {         try {             testExecutionListener.prepareTestInstance(getTestContext()).         } catch (Throwable ex) {             if (logger.isErrorEnabled()) {                 logger.error("Caught exception while allowing TestExecutionListener [" + testExecutionListener + "] to prepare test instance [" + testInstance + "]", ex).             }             ReflectionUtils.rethrowException(ex).         }     } }
true;public;2;13;/**  * Hook for pre-processing a test <em>before</em> execution of <em>before</em>  * lifecycle callbacks of the underlying test framework &mdash. for example,  * setting up test fixtures, starting a transaction, etc.  * <p>This method <strong>must</strong> be called immediately prior to  * framework-specific <em>before</em> lifecycle callbacks (e.g., methods  * annotated with JUnit 4's {@link org.junit.Before @Before}). For historical  * reasons, this method is named {@code beforeTestMethod}. Since the  * introduction of {@link #beforeTestExecution}, a more suitable name for  * this method might be something like {@code beforeTestSetUp} or  * {@code beforeEach}. however, it is unfortunately impossible to rename  * this method due to backward compatibility concerns.  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance} and {@code testMethod}.  * <p>An attempt will be made to give each registered  * {@link TestExecutionListener} a chance to perform its pre-processing.  * If a listener throws an exception, however, the remaining registered  * listeners will <strong>not</strong> be called.  * @param testInstance the current test instance (never {@code null})  * @param testMethod the test method which is about to be executed on the  * test instance  * @throws Exception if a registered TestExecutionListener throws an exception  * @see #afterTestMethod  * @see #beforeTestExecution  * @see #afterTestExecution  * @see #getTestExecutionListeners()  */ ;/**  * Hook for pre-processing a test <em>before</em> execution of <em>before</em>  * lifecycle callbacks of the underlying test framework &mdash. for example,  * setting up test fixtures, starting a transaction, etc.  * <p>This method <strong>must</strong> be called immediately prior to  * framework-specific <em>before</em> lifecycle callbacks (e.g., methods  * annotated with JUnit 4's {@link org.junit.Before @Before}). For historical  * reasons, this method is named {@code beforeTestMethod}. Since the  * introduction of {@link #beforeTestExecution}, a more suitable name for  * this method might be something like {@code beforeTestSetUp} or  * {@code beforeEach}. however, it is unfortunately impossible to rename  * this method due to backward compatibility concerns.  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance} and {@code testMethod}.  * <p>An attempt will be made to give each registered  * {@link TestExecutionListener} a chance to perform its pre-processing.  * If a listener throws an exception, however, the remaining registered  * listeners will <strong>not</strong> be called.  * @param testInstance the current test instance (never {@code null})  * @param testMethod the test method which is about to be executed on the  * test instance  * @throws Exception if a registered TestExecutionListener throws an exception  * @see #afterTestMethod  * @see #beforeTestExecution  * @see #afterTestExecution  * @see #getTestExecutionListeners()  */ public void beforeTestMethod(Object testInstance, Method testMethod) throws Exception {     String callbackName = "beforeTestMethod".     prepareForBeforeCallback(callbackName, testInstance, testMethod).     for (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {         try {             testExecutionListener.beforeTestMethod(getTestContext()).         } catch (Throwable ex) {             handleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod).         }     } }
true;public;2;13;/**  * Hook for pre-processing a test <em>immediately before</em> execution of  * the {@linkplain java.lang.reflect.Method test method} in the supplied  * {@linkplain TestContext test context} &mdash. for example, for timing  * or logging purposes.  * <p>This method <strong>must</strong> be called after framework-specific  * <em>before</em> lifecycle callbacks (e.g., methods annotated with JUnit 4's  * {@link org.junit.Before @Before}).  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance} and {@code testMethod}.  * <p>An attempt will be made to give each registered  * {@link TestExecutionListener} a chance to perform its pre-processing.  * If a listener throws an exception, however, the remaining registered  * listeners will <strong>not</strong> be called.  * @param testInstance the current test instance (never {@code null})  * @param testMethod the test method which is about to be executed on the  * test instance  * @throws Exception if a registered TestExecutionListener throws an exception  * @since 5.0  * @see #beforeTestMethod  * @see #afterTestMethod  * @see #beforeTestExecution  * @see #afterTestExecution  * @see #getTestExecutionListeners()  */ ;/**  * Hook for pre-processing a test <em>immediately before</em> execution of  * the {@linkplain java.lang.reflect.Method test method} in the supplied  * {@linkplain TestContext test context} &mdash. for example, for timing  * or logging purposes.  * <p>This method <strong>must</strong> be called after framework-specific  * <em>before</em> lifecycle callbacks (e.g., methods annotated with JUnit 4's  * {@link org.junit.Before @Before}).  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance} and {@code testMethod}.  * <p>An attempt will be made to give each registered  * {@link TestExecutionListener} a chance to perform its pre-processing.  * If a listener throws an exception, however, the remaining registered  * listeners will <strong>not</strong> be called.  * @param testInstance the current test instance (never {@code null})  * @param testMethod the test method which is about to be executed on the  * test instance  * @throws Exception if a registered TestExecutionListener throws an exception  * @since 5.0  * @see #beforeTestMethod  * @see #afterTestMethod  * @see #beforeTestExecution  * @see #afterTestExecution  * @see #getTestExecutionListeners()  */ public void beforeTestExecution(Object testInstance, Method testMethod) throws Exception {     String callbackName = "beforeTestExecution".     prepareForBeforeCallback(callbackName, testInstance, testMethod).     for (TestExecutionListener testExecutionListener : getTestExecutionListeners()) {         try {             testExecutionListener.beforeTestExecution(getTestContext()).         } catch (Throwable ex) {             handleBeforeException(ex, callbackName, testExecutionListener, testInstance, testMethod).         }     } }
true;public;3;28;/**  * Hook for post-processing a test <em>immediately after</em> execution of  * the {@linkplain java.lang.reflect.Method test method} in the supplied  * {@linkplain TestContext test context} &mdash. for example, for timing  * or logging purposes.  * <p>This method <strong>must</strong> be called before framework-specific  * <em>after</em> lifecycle callbacks (e.g., methods annotated with JUnit 4's  * {@link org.junit.After @After}).  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance}, {@code testMethod}, and {@code exception}.  * <p>Each registered {@link TestExecutionListener} will be given a chance  * to perform its post-processing. If a listener throws an exception, the  * remaining registered listeners will still be called. After all listeners  * have executed, the first caught exception will be rethrown with any  * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in  * the first exception.  * <p>Note that registered listeners will be executed in the opposite  * order in which they were registered.  * @param testInstance the current test instance (never {@code null})  * @param testMethod the test method which has just been executed on the  * test instance  * @param exception the exception that was thrown during execution of the  * test method or by a TestExecutionListener, or {@code null} if none  * was thrown  * @throws Exception if a registered TestExecutionListener throws an exception  * @since 5.0  * @see #beforeTestMethod  * @see #afterTestMethod  * @see #beforeTestExecution  * @see #getTestExecutionListeners()  * @see Throwable#addSuppressed(Throwable)  */ ;/**  * Hook for post-processing a test <em>immediately after</em> execution of  * the {@linkplain java.lang.reflect.Method test method} in the supplied  * {@linkplain TestContext test context} &mdash. for example, for timing  * or logging purposes.  * <p>This method <strong>must</strong> be called before framework-specific  * <em>after</em> lifecycle callbacks (e.g., methods annotated with JUnit 4's  * {@link org.junit.After @After}).  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance}, {@code testMethod}, and {@code exception}.  * <p>Each registered {@link TestExecutionListener} will be given a chance  * to perform its post-processing. If a listener throws an exception, the  * remaining registered listeners will still be called. After all listeners  * have executed, the first caught exception will be rethrown with any  * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in  * the first exception.  * <p>Note that registered listeners will be executed in the opposite  * order in which they were registered.  * @param testInstance the current test instance (never {@code null})  * @param testMethod the test method which has just been executed on the  * test instance  * @param exception the exception that was thrown during execution of the  * test method or by a TestExecutionListener, or {@code null} if none  * was thrown  * @throws Exception if a registered TestExecutionListener throws an exception  * @since 5.0  * @see #beforeTestMethod  * @see #afterTestMethod  * @see #beforeTestExecution  * @see #getTestExecutionListeners()  * @see Throwable#addSuppressed(Throwable)  */ public void afterTestExecution(Object testInstance, Method testMethod, @Nullable Throwable exception) throws Exception {     String callbackName = "afterTestExecution".     prepareForAfterCallback(callbackName, testInstance, testMethod, exception).     Throwable afterTestExecutionException = null.     // "wrapper"-style execution of listeners.     for (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {         try {             testExecutionListener.afterTestExecution(getTestContext()).         } catch (Throwable ex) {             logException(ex, callbackName, testExecutionListener, testInstance, testMethod).             if (afterTestExecutionException == null) {                 afterTestExecutionException = ex.             } else {                 afterTestExecutionException.addSuppressed(ex).             }         }     }     if (afterTestExecutionException != null) {         ReflectionUtils.rethrowException(afterTestExecutionException).     } }
true;public;3;28;/**  * Hook for post-processing a test <em>after</em> execution of <em>after</em>  * lifecycle callbacks of the underlying test framework &mdash. for example,  * tearing down test fixtures, ending a transaction, etc.  * <p>This method <strong>must</strong> be called immediately after  * framework-specific <em>after</em> lifecycle callbacks (e.g., methods  * annotated with JUnit 4's {@link org.junit.After @After}). For historical  * reasons, this method is named {@code afterTestMethod}. Since the  * introduction of {@link #afterTestExecution}, a more suitable name for  * this method might be something like {@code afterTestTearDown} or  * {@code afterEach}. however, it is unfortunately impossible to rename  * this method due to backward compatibility concerns.  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance}, {@code testMethod}, and {@code exception}.  * <p>Each registered {@link TestExecutionListener} will be given a chance  * to perform its post-processing. If a listener throws an exception, the  * remaining registered listeners will still be called. After all listeners  * have executed, the first caught exception will be rethrown with any  * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in  * the first exception.  * <p>Note that registered listeners will be executed in the opposite  * @param testInstance the current test instance (never {@code null})  * @param testMethod the test method which has just been executed on the  * test instance  * @param exception the exception that was thrown during execution of the test  * method or by a TestExecutionListener, or {@code null} if none was thrown  * @throws Exception if a registered TestExecutionListener throws an exception  * @see #beforeTestMethod  * @see #beforeTestExecution  * @see #afterTestExecution  * @see #getTestExecutionListeners()  * @see Throwable#addSuppressed(Throwable)  */ ;/**  * Hook for post-processing a test <em>after</em> execution of <em>after</em>  * lifecycle callbacks of the underlying test framework &mdash. for example,  * tearing down test fixtures, ending a transaction, etc.  * <p>This method <strong>must</strong> be called immediately after  * framework-specific <em>after</em> lifecycle callbacks (e.g., methods  * annotated with JUnit 4's {@link org.junit.After @After}). For historical  * reasons, this method is named {@code afterTestMethod}. Since the  * introduction of {@link #afterTestExecution}, a more suitable name for  * this method might be something like {@code afterTestTearDown} or  * {@code afterEach}. however, it is unfortunately impossible to rename  * this method due to backward compatibility concerns.  * <p>The managed {@link TestContext} will be updated with the supplied  * {@code testInstance}, {@code testMethod}, and {@code exception}.  * <p>Each registered {@link TestExecutionListener} will be given a chance  * to perform its post-processing. If a listener throws an exception, the  * remaining registered listeners will still be called. After all listeners  * have executed, the first caught exception will be rethrown with any  * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in  * the first exception.  * <p>Note that registered listeners will be executed in the opposite  * @param testInstance the current test instance (never {@code null})  * @param testMethod the test method which has just been executed on the  * test instance  * @param exception the exception that was thrown during execution of the test  * method or by a TestExecutionListener, or {@code null} if none was thrown  * @throws Exception if a registered TestExecutionListener throws an exception  * @see #beforeTestMethod  * @see #beforeTestExecution  * @see #afterTestExecution  * @see #getTestExecutionListeners()  * @see Throwable#addSuppressed(Throwable)  */ public void afterTestMethod(Object testInstance, Method testMethod, @Nullable Throwable exception) throws Exception {     String callbackName = "afterTestMethod".     prepareForAfterCallback(callbackName, testInstance, testMethod, exception).     Throwable afterTestMethodException = null.     // "wrapper"-style execution of listeners.     for (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {         try {             testExecutionListener.afterTestMethod(getTestContext()).         } catch (Throwable ex) {             logException(ex, callbackName, testExecutionListener, testInstance, testMethod).             if (afterTestMethodException == null) {                 afterTestMethodException = ex.             } else {                 afterTestMethodException.addSuppressed(ex).             }         }     }     if (afterTestMethodException != null) {         ReflectionUtils.rethrowException(afterTestMethodException).     } }
true;public;0;31;/**  * Hook for post-processing a test class <em>after</em> execution of all  * tests within the class. Should be called after any framework-specific  * <em>after class methods</em> (e.g., methods annotated with JUnit 4's  * {@link org.junit.AfterClass @AfterClass}).  * <p>Each registered {@link TestExecutionListener} will be given a chance  * to perform its post-processing. If a listener throws an exception, the  * remaining registered listeners will still be called. After all listeners  * have executed, the first caught exception will be rethrown with any  * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in  * the first exception.  * <p>Note that registered listeners will be executed in the opposite  * @throws Exception if a registered TestExecutionListener throws an exception  * @since 3.0  * @see #getTestExecutionListeners()  * @see Throwable#addSuppressed(Throwable)  */ ;/**  * Hook for post-processing a test class <em>after</em> execution of all  * tests within the class. Should be called after any framework-specific  * <em>after class methods</em> (e.g., methods annotated with JUnit 4's  * {@link org.junit.AfterClass @AfterClass}).  * <p>Each registered {@link TestExecutionListener} will be given a chance  * to perform its post-processing. If a listener throws an exception, the  * remaining registered listeners will still be called. After all listeners  * have executed, the first caught exception will be rethrown with any  * subsequent exceptions {@linkplain Throwable#addSuppressed suppressed} in  * the first exception.  * <p>Note that registered listeners will be executed in the opposite  * @throws Exception if a registered TestExecutionListener throws an exception  * @since 3.0  * @see #getTestExecutionListeners()  * @see Throwable#addSuppressed(Throwable)  */ public void afterTestClass() throws Exception {     Class<?> testClass = getTestContext().getTestClass().     if (logger.isTraceEnabled()) {         logger.trace("afterTestClass(): class [" + testClass.getName() + "]").     }     getTestContext().updateState(null, null, null).     Throwable afterTestClassException = null.     // "wrapper"-style execution of listeners.     for (TestExecutionListener testExecutionListener : getReversedTestExecutionListeners()) {         try {             testExecutionListener.afterTestClass(getTestContext()).         } catch (Throwable ex) {             logException(ex, "afterTestClass", testExecutionListener, testClass).             if (afterTestClassException == null) {                 afterTestClassException = ex.             } else {                 afterTestClassException.addSuppressed(ex).             }         }     }     this.testContextHolder.remove().     if (afterTestClassException != null) {         ReflectionUtils.rethrowException(afterTestClassException).     } }
false;private;3;6;;private void prepareForBeforeCallback(String callbackName, Object testInstance, Method testMethod) {     if (logger.isTraceEnabled()) {         logger.trace(String.format("%s(): instance [%s], method [%s]", callbackName, testInstance, testMethod)).     }     getTestContext().updateState(testInstance, testMethod, null). }
false;private;4;9;;private void prepareForAfterCallback(String callbackName, Object testInstance, Method testMethod, @Nullable Throwable exception) {     if (logger.isTraceEnabled()) {         logger.trace(String.format("%s(): instance [%s], method [%s], exception [%s]", callbackName, testInstance, testMethod, exception)).     }     getTestContext().updateState(testInstance, testMethod, exception). }
false;private;5;6;;private void handleBeforeException(Throwable ex, String callbackName, TestExecutionListener testExecutionListener, Object testInstance, Method testMethod) throws Exception {     logException(ex, callbackName, testExecutionListener, testInstance, testMethod).     ReflectionUtils.rethrowException(ex). }
false;private;4;9;;private void logException(Throwable ex, String callbackName, TestExecutionListener testExecutionListener, Class<?> testClass) {     if (logger.isWarnEnabled()) {         logger.warn(String.format("Caught exception while invoking '%s' callback on " + "TestExecutionListener [%s] for test class [%s]", callbackName, testExecutionListener, testClass), ex).     } }
false;private;5;9;;private void logException(Throwable ex, String callbackName, TestExecutionListener testExecutionListener, Object testInstance, Method testMethod) {     if (logger.isWarnEnabled()) {         logger.warn(String.format("Caught exception while invoking '%s' callback on " + "TestExecutionListener [%s] for test method [%s] and test instance [%s]", callbackName, testExecutionListener, testMethod, testInstance), ex).     } }
true;private,static;1;21;/**  * Attempt to create a copy of the supplied {@code TestContext} using its  * <em>copy constructor</em>.  */ ;/**  * Attempt to create a copy of the supplied {@code TestContext} using its  * <em>copy constructor</em>.  */ private static TestContext copyTestContext(TestContext testContext) {     Constructor<? extends TestContext> constructor = ClassUtils.getConstructorIfAvailable(testContext.getClass(), testContext.getClass()).     if (constructor != null) {         try {             ReflectionUtils.makeAccessible(constructor).             return constructor.newInstance(testContext).         } catch (Exception ex) {             if (logger.isInfoEnabled()) {                 logger.info(String.format("Failed to invoke copy constructor for [%s]. " + "concurrent test execution is therefore likely not supported.", testContext), ex).             }         }     }     // Fallback to original instance     return testContext. }
