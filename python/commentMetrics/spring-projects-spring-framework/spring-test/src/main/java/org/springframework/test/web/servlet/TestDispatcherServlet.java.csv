commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;28;;@Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {     registerAsyncResultInterceptors(request).     super.service(request, response).     if (request.getAsyncContext() != null) {         MockAsyncContext asyncContext.         if (request.getAsyncContext() instanceof MockAsyncContext) {             asyncContext = (MockAsyncContext) request.getAsyncContext().         } else {             MockHttpServletRequest mockRequest = WebUtils.getNativeRequest(request, MockHttpServletRequest.class).             Assert.notNull(mockRequest, "Expected MockHttpServletRequest").             asyncContext = (MockAsyncContext) mockRequest.getAsyncContext().             Assert.notNull(asyncContext, () -> "Outer request wrapper " + request.getClass().getName() + " has an AsyncContext," + "but it is not a MockAsyncContext, while the nested " + mockRequest.getClass().getName() + " does not have an AsyncContext at all.").         }         CountDownLatch dispatchLatch = new CountDownLatch(1).         asyncContext.addDispatchHandler(dispatchLatch::countDown).         getMvcResult(request).setAsyncDispatchLatch(dispatchLatch).     } }
false;public;3;5;;@Override public <T> void postProcess(NativeWebRequest r, Callable<T> task, Object value) {     // We got the result, must also wait for the dispatch     getMvcResult(request).setAsyncResult(value). }
false;public;3;4;;@Override public <T> void postProcess(NativeWebRequest r, DeferredResult<T> result, Object value) {     getMvcResult(request).setAsyncResult(value). }
false;private;1;19;;private void registerAsyncResultInterceptors(final HttpServletRequest request) {     WebAsyncUtils.getAsyncManager(request).registerCallableInterceptor(KEY, new CallableProcessingInterceptor() {          @Override         public <T> void postProcess(NativeWebRequest r, Callable<T> task, Object value) {             // We got the result, must also wait for the dispatch             getMvcResult(request).setAsyncResult(value).         }     }).     WebAsyncUtils.getAsyncManager(request).registerDeferredResultInterceptor(KEY, new DeferredResultProcessingInterceptor() {          @Override         public <T> void postProcess(NativeWebRequest r, DeferredResult<T> result, Object value) {             getMvcResult(request).setAsyncResult(value).         }     }). }
false;protected;1;3;;protected DefaultMvcResult getMvcResult(ServletRequest request) {     return (DefaultMvcResult) request.getAttribute(MockMvc.MVC_RESULT_ATTRIBUTE). }
false;protected;1;10;;@Override protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {     HandlerExecutionChain chain = super.getHandler(request).     if (chain != null) {         DefaultMvcResult mvcResult = getMvcResult(request).         mvcResult.setHandler(chain.getHandler()).         mvcResult.setInterceptors(chain.getInterceptors()).     }     return chain. }
false;protected;3;8;;@Override protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {     DefaultMvcResult mvcResult = getMvcResult(request).     mvcResult.setModelAndView(mv).     super.render(mv, request, response). }
false;protected;4;13;;@Override protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex) throws Exception {     ModelAndView mav = super.processHandlerException(request, response, handler, ex).     // We got this far, exception was processed..     DefaultMvcResult mvcResult = getMvcResult(request).     mvcResult.setResolvedException(ex).     mvcResult.setModelAndView(mav).     return mav. }
