commented;modifiers;parameterAmount;loc;comment;code
true;public;0;21;/**  * Evaluate the next {@link Statement} in the execution chain (typically an  * instance of {@link RunBeforeTestExecutionCallbacks}), catching any exceptions  * thrown, and then invoke {@link TestContextManager#afterTestExecution} supplying  * the first caught exception (if any).  * <p>If the invocation of {@code afterTestExecution()} throws an exception, that  * exception will also be tracked. Multiple exceptions will be combined into a  * {@link MultipleFailureException}.  */ ;/**  * Evaluate the next {@link Statement} in the execution chain (typically an  * instance of {@link RunBeforeTestExecutionCallbacks}), catching any exceptions  * thrown, and then invoke {@link TestContextManager#afterTestExecution} supplying  * the first caught exception (if any).  * <p>If the invocation of {@code afterTestExecution()} throws an exception, that  * exception will also be tracked. Multiple exceptions will be combined into a  * {@link MultipleFailureException}.  */ @Override public void evaluate() throws Throwable {     Throwable testException = null.     List<Throwable> errors = new ArrayList<>().     try {         this.next.evaluate().     } catch (Throwable ex) {         testException = ex.         errors.add(ex).     }     try {         this.testContextManager.afterTestExecution(this.testInstance, this.testMethod, testException).     } catch (Throwable ex) {         errors.add(ex).     }     MultipleFailureException.assertEmpty(errors). }
