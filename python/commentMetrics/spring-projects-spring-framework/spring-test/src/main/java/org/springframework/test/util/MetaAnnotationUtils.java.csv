commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;6;/**  * Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}  * on the supplied {@link Class}, traversing its annotations, interfaces, and  * superclasses if no annotation can be found on the given class itself.  * <p>This method explicitly handles class-level annotations which are not  * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as  * well as meta-annotations</em>.  * <p>The algorithm operates as follows:  * <ol>  * <li>Search for the annotation on the given class and return a corresponding  * {@code AnnotationDescriptor} if found.  * <li>Recursively search through all annotations that the given class declares.  * <li>Recursively search through all interfaces implemented by the given class.  * <li>Recursively search through the superclass hierarchy of the given class.  * </ol>  * <p>In this context, the term <em>recursively</em> means that the search  * process continues by returning to step #1 with the current annotation,  * interface, or superclass as the class to look for annotations on.  * @param clazz the class to look for annotations on  * @param annotationType the type of annotation to look for  * @return the corresponding annotation descriptor if the annotation was found.  * otherwise {@code null}  * @see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)  * @see #findAnnotationDescriptorForTypes(Class, Class...)  */ ;/**  * Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}  * on the supplied {@link Class}, traversing its annotations, interfaces, and  * superclasses if no annotation can be found on the given class itself.  * <p>This method explicitly handles class-level annotations which are not  * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as  * well as meta-annotations</em>.  * <p>The algorithm operates as follows:  * <ol>  * <li>Search for the annotation on the given class and return a corresponding  * {@code AnnotationDescriptor} if found.  * <li>Recursively search through all annotations that the given class declares.  * <li>Recursively search through all interfaces implemented by the given class.  * <li>Recursively search through the superclass hierarchy of the given class.  * </ol>  * <p>In this context, the term <em>recursively</em> means that the search  * process continues by returning to step #1 with the current annotation,  * interface, or superclass as the class to look for annotations on.  * @param clazz the class to look for annotations on  * @param annotationType the type of annotation to look for  * @return the corresponding annotation descriptor if the annotation was found.  * otherwise {@code null}  * @see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)  * @see #findAnnotationDescriptorForTypes(Class, Class...)  */ @Nullable public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, Class<T> annotationType) {     return findAnnotationDescriptor(clazz, new HashSet<>(), annotationType). }
true;private,static;3;38;/**  * Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},  * avoiding endless recursion by tracking which annotations have already been  * <em>visited</em>.  * @param clazz the class to look for annotations on  * @param visited the set of annotations that have already been visited  * @param annotationType the type of annotation to look for  * @return the corresponding annotation descriptor if the annotation was found.  * otherwise {@code null}  */ ;/**  * Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},  * avoiding endless recursion by tracking which annotations have already been  * <em>visited</em>.  * @param clazz the class to look for annotations on  * @param visited the set of annotations that have already been visited  * @param annotationType the type of annotation to look for  * @return the corresponding annotation descriptor if the annotation was found.  * otherwise {@code null}  */ @Nullable private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(@Nullable Class<?> clazz, Set<Annotation> visited, Class<T> annotationType) {     Assert.notNull(annotationType, "Annotation type must not be null").     if (clazz == null || Object.class == clazz) {         return null.     }     // Declared locally?     if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {         return new AnnotationDescriptor<>(clazz, clazz.getAnnotation(annotationType)).     }     // Declared on a composed annotation (i.e., as a meta-annotation)?     for (Annotation composedAnn : clazz.getDeclaredAnnotations()) {         Class<? extends Annotation> composedType = composedAnn.annotationType().         if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedType.getName()) && visited.add(composedAnn)) {             AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedType, visited, annotationType).             if (descriptor != null) {                 return new AnnotationDescriptor<>(clazz, descriptor.getDeclaringClass(), composedAnn, descriptor.getAnnotation()).             }         }     }     // Declared on interface?     for (Class<?> ifc : clazz.getInterfaces()) {         AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(ifc, visited, annotationType).         if (descriptor != null) {             return new AnnotationDescriptor<>(clazz, descriptor.getDeclaringClass(), descriptor.getComposedAnnotation(), descriptor.getAnnotation()).         }     }     // Declared on a superclass?     return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType). }
true;public,static;2;7;/**  * Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}  * in the inheritance hierarchy of the specified {@code clazz} (including  * the specified {@code clazz} itself) which declares at least one of the  * specified {@code annotationTypes}.  * <p>This method traverses the annotations, interfaces, and superclasses  * of the specified {@code clazz} if no annotation can be found on the given  * class itself.  * <p>This method explicitly handles class-level annotations which are not  * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as  * well as meta-annotations</em>.  * <p>The algorithm operates as follows:  * <ol>  * <li>Search for a local declaration of one of the annotation types on  * the given class and return a corresponding {@code UntypedAnnotationDescriptor}  * if found.  * <li>Recursively search through all annotations that the given class declares.  * <li>Recursively search through all interfaces implemented by the given class.  * <li>Recursively search through the superclass hierarchy of the given class.  * </ol>  * <p>In this context, the term <em>recursively</em> means that the search  * process continues by returning to step #1 with the current annotation,  * interface, or superclass as the class to look for annotations on.  * @param clazz the class to look for annotations on  * @param annotationTypes the types of annotations to look for  * @return the corresponding annotation descriptor if one of the annotations  * was found. otherwise {@code null}  * @see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)  * @see #findAnnotationDescriptor(Class, Class)  */ ;/**  * Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}  * in the inheritance hierarchy of the specified {@code clazz} (including  * the specified {@code clazz} itself) which declares at least one of the  * specified {@code annotationTypes}.  * <p>This method traverses the annotations, interfaces, and superclasses  * of the specified {@code clazz} if no annotation can be found on the given  * class itself.  * <p>This method explicitly handles class-level annotations which are not  * declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as  * well as meta-annotations</em>.  * <p>The algorithm operates as follows:  * <ol>  * <li>Search for a local declaration of one of the annotation types on  * the given class and return a corresponding {@code UntypedAnnotationDescriptor}  * if found.  * <li>Recursively search through all annotations that the given class declares.  * <li>Recursively search through all interfaces implemented by the given class.  * <li>Recursively search through the superclass hierarchy of the given class.  * </ol>  * <p>In this context, the term <em>recursively</em> means that the search  * process continues by returning to step #1 with the current annotation,  * interface, or superclass as the class to look for annotations on.  * @param clazz the class to look for annotations on  * @param annotationTypes the types of annotations to look for  * @return the corresponding annotation descriptor if one of the annotations  * was found. otherwise {@code null}  * @see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)  * @see #findAnnotationDescriptor(Class, Class)  */ @SuppressWarnings("unchecked") @Nullable public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, Class<? extends Annotation>... annotationTypes) {     return findAnnotationDescriptorForTypes(clazz, new HashSet<>(), annotationTypes). }
true;private,static;3;41;/**  * Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},  * avoiding endless recursion by tracking which annotations have already been  * <em>visited</em>.  * @param clazz the class to look for annotations on  * @param visited the set of annotations that have already been visited  * @param annotationTypes the types of annotations to look for  * @return the corresponding annotation descriptor if one of the annotations  * was found. otherwise {@code null}  */ ;/**  * Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},  * avoiding endless recursion by tracking which annotations have already been  * <em>visited</em>.  * @param clazz the class to look for annotations on  * @param visited the set of annotations that have already been visited  * @param annotationTypes the types of annotations to look for  * @return the corresponding annotation descriptor if one of the annotations  * was found. otherwise {@code null}  */ @SuppressWarnings("unchecked") @Nullable private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(@Nullable Class<?> clazz, Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {     assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty").     if (clazz == null || Object.class == clazz) {         return null.     }     // Declared locally?     for (Class<? extends Annotation> annotationType : annotationTypes) {         if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {             return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType)).         }     }     // Declared on a composed annotation (i.e., as a meta-annotation)?     for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {         if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {             UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(composedAnnotation.annotationType(), visited, annotationTypes).             if (descriptor != null) {                 return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation, descriptor.getAnnotation()).             }         }     }     // Declared on interface?     for (Class<?> ifc : clazz.getInterfaces()) {         UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(ifc, visited, annotationTypes).         if (descriptor != null) {             return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), descriptor.getComposedAnnotation(), descriptor.getAnnotation()).         }     }     // Declared on a superclass?     return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes). }
false;private,static;2;10;;private static void assertNonEmptyAnnotationTypeArray(Class<?>[] annotationTypes, String message) {     if (ObjectUtils.isEmpty(annotationTypes)) {         throw new IllegalArgumentException(message).     }     for (Class<?> clazz : annotationTypes) {         if (!Annotation.class.isAssignableFrom(clazz)) {             throw new IllegalArgumentException("Array elements must be of type Annotation").         }     } }
false;public;0;3;;public Class<?> getRootDeclaringClass() {     return this.rootDeclaringClass. }
false;public;0;3;;public Class<?> getDeclaringClass() {     return this.declaringClass. }
false;public;0;3;;public T getAnnotation() {     return this.annotation. }
true;public;0;5;/**  * Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}  * in this descriptor back into an annotation of the target  * {@linkplain #getAnnotationType annotation type}.  * @since 4.2  * @see #getAnnotationAttributes()  * @see #getAnnotationType()  * @see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement)  */ ;/**  * Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}  * in this descriptor back into an annotation of the target  * {@linkplain #getAnnotationType annotation type}.  * @since 4.2  * @see #getAnnotationAttributes()  * @see #getAnnotationType()  * @see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement)  */ @SuppressWarnings("unchecked") public T synthesizeAnnotation() {     return AnnotationUtils.synthesizeAnnotation(getAnnotationAttributes(), (Class<T>) getAnnotationType(), getRootDeclaringClass()). }
false;public;0;3;;public Class<? extends Annotation> getAnnotationType() {     return this.annotation.annotationType(). }
false;public;0;3;;public AnnotationAttributes getAnnotationAttributes() {     return this.annotationAttributes. }
false;public;0;4;;@Nullable public Annotation getComposedAnnotation() {     return this.composedAnnotation. }
false;public;0;4;;@Nullable public Class<? extends Annotation> getComposedAnnotationType() {     return (this.composedAnnotation != null ? this.composedAnnotation.annotationType() : null). }
true;public;0;9;/**  * Provide a textual representation of this {@code AnnotationDescriptor}.  */ ;/**  * Provide a textual representation of this {@code AnnotationDescriptor}.  */ @Override public String toString() {     return new ToStringCreator(this).append("rootDeclaringClass", this.rootDeclaringClass).append("declaringClass", this.declaringClass).append("composedAnnotation", this.composedAnnotation).append("annotation", this.annotation).toString(). }
true;public;0;5;/**  * Throws an {@link UnsupportedOperationException} since the type of annotation  * represented by the {@link #getAnnotationAttributes AnnotationAttributes} in  * an {@code UntypedAnnotationDescriptor} is unknown.  * @since 4.2  */ ;/**  * Throws an {@link UnsupportedOperationException} since the type of annotation  * represented by the {@link #getAnnotationAttributes AnnotationAttributes} in  * an {@code UntypedAnnotationDescriptor} is unknown.  * @since 4.2  */ @Override public Annotation synthesizeAnnotation() {     throw new UnsupportedOperationException("getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor"). }
