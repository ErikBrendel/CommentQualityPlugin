# id;timestamp;commentText;codeText;commentWords;codeWords
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	@Nullable 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(@Nullable Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1496955179;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	@Nullable_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(@Nullable Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_						composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_							composedAnnotation, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(ifc, visited, annotationTypes)__			if (descriptor != null) {_				return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_						descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,nullable,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,nullable,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,ifc,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	@Nullable 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(@Nullable Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1498780456;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	@Nullable_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(@Nullable Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_						composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_							composedAnnotation, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(ifc, visited, annotationTypes)__			if (descriptor != null) {_				return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_						descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,nullable,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,nullable,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,ifc,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	@Nullable 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(@Nullable Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1530174524;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	@Nullable_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(@Nullable Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_						composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_							composedAnnotation, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(ifc, visited, annotationTypes)__			if (descriptor != null) {_				return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_						descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,nullable,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,nullable,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,ifc,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, 			Set<Annotation> visited, Class<T> annotationType);1397082962;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>.__@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,_			Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")___		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),_					visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,clazz,equals,object,class,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, 			Set<Annotation> visited, Class<T> annotationType);1413819738;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,_			Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")___		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),_					visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,clazz,equals,object,class,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, 			Set<Annotation> visited, Class<T> annotationType);1413848647;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,_			Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")___		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),_					visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,clazz,equals,object,class,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, 			Set<Annotation> visited, Class<T> annotationType);1429749861;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,_			Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")___		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),_					visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,clazz,equals,object,class,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, 			Set<Annotation> visited, Class<T> annotationType);1429829748;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,_			Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")___		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),_					visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,clazz,equals,object,class,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, 			Set<Annotation> visited, Class<T> annotationType);1432125256;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,_			Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")___		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),_					visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, 			Set<Annotation> visited, Class<T> annotationType);1432856630;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,_			Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")___		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),_					visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, 			Set<Annotation> visited, Class<T> annotationType);1434234880;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,_			Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")___		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),_					visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz, 			Set<Annotation> visited, Class<T> annotationType);1458754769;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(Class<?> clazz,_			Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")___		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedAnnotation.annotationType(),_					visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1413819738;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations and superclasses_if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1413848647;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations and superclasses_if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1429749861;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations and superclasses_if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1429829748;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations and superclasses_if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1432125256;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations and superclasses_if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1432856630;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations and superclasses_if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1434234880;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations and superclasses_if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1458754769;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations and superclasses_if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1459842161;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations and superclasses_if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1462470884;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations, interfaces, and_superclasses if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<Annotation>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,interfaces,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1467730834;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations, interfaces, and_superclasses if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,interfaces,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,type
MetaAnnotationUtils -> public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1491480437;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations, interfaces, and_superclasses if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,interfaces,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,type
MetaAnnotationUtils -> @Nullable 	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1495868221;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations, interfaces, and_superclasses if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);@Nullable_	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,interfaces,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;nullable,public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,type
MetaAnnotationUtils -> @Nullable 	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1496955179;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations, interfaces, and_superclasses if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);@Nullable_	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,interfaces,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;nullable,public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,type
MetaAnnotationUtils -> @Nullable 	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1498780456;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations, interfaces, and_superclasses if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);@Nullable_	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,interfaces,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;nullable,public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,type
MetaAnnotationUtils -> @Nullable 	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Class<T> annotationType);1530174524;Find the {@link AnnotationDescriptor} for the supplied {@code annotationType}_on the supplied {@link Class}, traversing its annotations, interfaces, and_superclasses if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for the annotation on the given class and return a corresponding_{@code AnnotationDescriptor} if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClass(Class, Class)_@see #findAnnotationDescriptorForTypes(Class, Class...);@Nullable_	public static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Class<T> annotationType) {__		return findAnnotationDescriptor(clazz, new HashSet<>(), annotationType)__	};find,the,link,annotation,descriptor,for,the,supplied,code,annotation,type,on,the,supplied,link,class,traversing,its,annotations,interfaces,and,superclasses,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,the,annotation,on,the,given,class,and,return,a,corresponding,code,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,class,class,see,find,annotation,descriptor,for,types,class,class;nullable,public,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,class,t,annotation,type,return,find,annotation,descriptor,clazz,new,hash,set,annotation,type
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1434234880;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(getAnnotationAttributes(), (Class<T>) getAnnotationType(),_				getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1458754769;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(getAnnotationAttributes(), (Class<T>) getAnnotationType(),_				getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1459842161;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(_					getAnnotationAttributes(), (Class<T>) getAnnotationType(), getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1462470884;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(_					getAnnotationAttributes(), (Class<T>) getAnnotationType(), getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1467730834;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(_					getAnnotationAttributes(), (Class<T>) getAnnotationType(), getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1491480437;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(_					getAnnotationAttributes(), (Class<T>) getAnnotationType(), getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1495868221;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(_					getAnnotationAttributes(), (Class<T>) getAnnotationType(), getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1496955179;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(_					getAnnotationAttributes(), (Class<T>) getAnnotationType(), getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1498780456;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(_					getAnnotationAttributes(), (Class<T>) getAnnotationType(), getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> AnnotationDescriptor -> @SuppressWarnings("unchecked") 		public T synthesizeAnnotation();1530174524;Synthesize the merged {@link #getAnnotationAttributes AnnotationAttributes}_in this descriptor back into an annotation of the target_{@linkplain #getAnnotationType annotation type}._@since 4.2_@see #getAnnotationAttributes()_@see #getAnnotationType()_@see AnnotationUtils#synthesizeAnnotation(java.util.Map, Class, java.lang.reflect.AnnotatedElement);@SuppressWarnings("unchecked")_		public T synthesizeAnnotation() {_			return AnnotationUtils.synthesizeAnnotation(_					getAnnotationAttributes(), (Class<T>) getAnnotationType(), getRootDeclaringClass())__		};synthesize,the,merged,link,get,annotation,attributes,annotation,attributes,in,this,descriptor,back,into,an,annotation,of,the,target,linkplain,get,annotation,type,annotation,type,since,4,2,see,get,annotation,attributes,see,get,annotation,type,see,annotation,utils,synthesize,annotation,java,util,map,class,java,lang,reflect,annotated,element;suppress,warnings,unchecked,public,t,synthesize,annotation,return,annotation,utils,synthesize,annotation,get,annotation,attributes,class,t,get,annotation,type,get,root,declaring,class
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1495868221;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations, interfaces, and superclasses_of the specified {@code clazz} if no annotation can be found on the given_class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	@Nullable_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,interfaces,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,nullable,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1496955179;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations, interfaces, and superclasses_of the specified {@code clazz} if no annotation can be found on the given_class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	@Nullable_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,interfaces,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,nullable,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1498780456;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations, interfaces, and superclasses_of the specified {@code clazz} if no annotation can be found on the given_class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	@Nullable_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,interfaces,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,nullable,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	@Nullable 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1530174524;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations, interfaces, and superclasses_of the specified {@code clazz} if no annotation can be found on the given_class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	@Nullable_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,interfaces,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,nullable,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,types
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1397082962;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_			.append("rootDeclaringClass", rootDeclaringClass)_			.append("declaringClass", declaringClass)_			.append("composedAnnotation", composedAnnotation)_			.append("annotation", annotation)_			.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,root,declaring,class,append,declaring,class,declaring,class,append,composed,annotation,composed,annotation,append,annotation,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1413819738;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1413848647;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1429749861;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1429829748;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1432125256;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1432856630;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1434234880;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1458754769;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1459842161;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1462470884;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1467730834;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1491480437;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1495868221;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1496955179;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1498780456;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> AnnotationDescriptor -> @Override 		public String toString();1530174524;Provide a textual representation of this {@code AnnotationDescriptor}.;@Override_		public String toString() {_			return new ToStringCreator(this)_					.append("rootDeclaringClass", this.rootDeclaringClass)_					.append("declaringClass", this.declaringClass)_					.append("composedAnnotation", this.composedAnnotation)_					.append("annotation", this.annotation)_					.toString()__		};provide,a,textual,representation,of,this,code,annotation,descriptor;override,public,string,to,string,return,new,to,string,creator,this,append,root,declaring,class,this,root,declaring,class,append,declaring,class,this,declaring,class,append,composed,annotation,this,composed,annotation,append,annotation,this,annotation,to,string
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1434234880;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_				"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1458754769;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_					"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1459842161;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_					"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1462470884;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_					"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1467730834;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_					"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1491480437;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_					"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1495868221;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_					"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1496955179;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_					"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1498780456;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_					"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> UntypedAnnotationDescriptor -> @Override 		public Annotation synthesizeAnnotation();1530174524;Throws an {@link UnsupportedOperationException} since the type of annotation_represented by the {@link #getAnnotationAttributes AnnotationAttributes} in_an {@code UntypedAnnotationDescriptor} is unknown._@since 4.2;@Override_		public Annotation synthesizeAnnotation() {_			throw new UnsupportedOperationException(_					"getMergedAnnotation() is unsupported in UntypedAnnotationDescriptor")__		};throws,an,link,unsupported,operation,exception,since,the,type,of,annotation,represented,by,the,link,get,annotation,attributes,annotation,attributes,in,an,code,untyped,annotation,descriptor,is,unknown,since,4,2;override,public,annotation,synthesize,annotation,throw,new,unsupported,operation,exception,get,merged,annotation,is,unsupported,in,untyped,annotation,descriptor
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1397082962;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>.__@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")___		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_					composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,clazz,equals,object,class,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1413819738;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_					composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,clazz,equals,object,class,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1413848647;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_					composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,clazz,equals,object,class,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1429749861;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_					composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,clazz,equals,object,class,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1429829748;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || clazz.equals(Object.class)) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_					composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,clazz,equals,object,class,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1432125256;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_					composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1432856630;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_					composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1434234880;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_					composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_						descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1458754769;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_						composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_							descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1459842161;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_						composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_							descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1462470884;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_						composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_							descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(ifc, visited, annotationTypes)__			if (descriptor != null) {_				return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_					descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,ifc,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1467730834;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_						composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(), composedAnnotation,_							descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(ifc, visited, annotationTypes)__			if (descriptor != null) {_				return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_					descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,ifc,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz, 			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes);1491480437;Perform the search algorithm for {@link #findAnnotationDescriptorForTypes(Class, Class...)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null};@SuppressWarnings("unchecked")_	private static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(Class<?> clazz,_			Set<Annotation> visited, Class<? extends Annotation>... annotationTypes) {__		assertNonEmptyAnnotationTypeArray(annotationTypes, "The list of annotation types must not be empty")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		for (Class<? extends Annotation> annotationType : annotationTypes) {_			if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_				return new UntypedAnnotationDescriptor(clazz, clazz.getAnnotation(annotationType))__			}_		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(_						composedAnnotation.annotationType(), visited, annotationTypes)__				if (descriptor != null) {_					return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_							composedAnnotation, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(ifc, visited, annotationTypes)__			if (descriptor != null) {_				return new UntypedAnnotationDescriptor(clazz, descriptor.getDeclaringClass(),_						descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptorForTypes(clazz.getSuperclass(), visited, annotationTypes)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,for,types,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null;suppress,warnings,unchecked,private,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,set,annotation,visited,class,extends,annotation,annotation,types,assert,non,empty,annotation,type,array,annotation,types,the,list,of,annotation,types,must,not,be,empty,if,clazz,null,object,class,clazz,return,null,for,class,extends,annotation,annotation,type,annotation,types,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,untyped,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,composed,annotation,annotation,type,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,ifc,visited,annotation,types,if,descriptor,null,return,new,untyped,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,for,types,clazz,get,superclass,visited,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1413819738;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations and superclasses of the specified_{@code clazz} if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1413848647;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations and superclasses of the specified_{@code clazz} if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1429749861;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations and superclasses of the specified_{@code clazz} if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1429829748;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations and superclasses of the specified_{@code clazz} if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1432125256;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations and superclasses of the specified_{@code clazz} if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1432856630;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations and superclasses of the specified_{@code clazz} if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1434234880;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations and superclasses of the specified_{@code clazz} if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1458754769;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations and superclasses of the specified_{@code clazz} if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1459842161;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations and superclasses of the specified_{@code clazz} if no annotation can be found on the given class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation or_superclass as the class to look for annotations on._<p>If the supplied {@code clazz} is an interface, only the interface_itself will be checked_ the inheritance hierarchy for interfaces will not_be traversed._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,or,superclass,as,the,class,to,look,for,annotations,on,p,if,the,supplied,code,clazz,is,an,interface,only,the,interface,itself,will,be,checked,the,inheritance,hierarchy,for,interfaces,will,not,be,traversed,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1462470884;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations, interfaces, and superclasses_of the specified {@code clazz} if no annotation can be found on the given_class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<Annotation>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,interfaces,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1467730834;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations, interfaces, and superclasses_of the specified {@code clazz} if no annotation can be found on the given_class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,interfaces,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,types
MetaAnnotationUtils -> @SuppressWarnings("unchecked") 	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes( 			Class<?> clazz, Class<? extends Annotation>... annotationTypes);1491480437;Find the {@link UntypedAnnotationDescriptor} for the first {@link Class}_in the inheritance hierarchy of the specified {@code clazz} (including_the specified {@code clazz} itself) which declares at least one of the_specified {@code annotationTypes}._<p>This method traverses the annotations, interfaces, and superclasses_of the specified {@code clazz} if no annotation can be found on the given_class itself._<p>This method explicitly handles class-level annotations which are not_declared as {@linkplain java.lang.annotation.Inherited inherited} <em>as_well as meta-annotations</em>._<p>The algorithm operates as follows:_<ol>_<li>Search for a local declaration of one of the annotation types on_the given class and return a corresponding {@code UntypedAnnotationDescriptor}_if found._<li>Recursively search through all annotations that the given class declares._<li>Recursively search through all interfaces implemented by the given class._<li>Recursively search through the superclass hierarchy of the given class._</ol>_<p>In this context, the term <em>recursively</em> means that the search_process continues by returning to step #1 with the current annotation,_interface, or superclass as the class to look for annotations on._@param clazz the class to look for annotations on_@param annotationTypes the types of annotations to look for_@return the corresponding annotation descriptor if one of the annotations_was found_ otherwise {@code null}_@see AnnotationUtils#findAnnotationDeclaringClassForTypes(java.util.List, Class)_@see #findAnnotationDescriptor(Class, Class);@SuppressWarnings("unchecked")_	public static UntypedAnnotationDescriptor findAnnotationDescriptorForTypes(_			Class<?> clazz, Class<? extends Annotation>... annotationTypes) {__		return findAnnotationDescriptorForTypes(clazz, new HashSet<>(), annotationTypes)__	};find,the,link,untyped,annotation,descriptor,for,the,first,link,class,in,the,inheritance,hierarchy,of,the,specified,code,clazz,including,the,specified,code,clazz,itself,which,declares,at,least,one,of,the,specified,code,annotation,types,p,this,method,traverses,the,annotations,interfaces,and,superclasses,of,the,specified,code,clazz,if,no,annotation,can,be,found,on,the,given,class,itself,p,this,method,explicitly,handles,class,level,annotations,which,are,not,declared,as,linkplain,java,lang,annotation,inherited,inherited,em,as,well,as,meta,annotations,em,p,the,algorithm,operates,as,follows,ol,li,search,for,a,local,declaration,of,one,of,the,annotation,types,on,the,given,class,and,return,a,corresponding,code,untyped,annotation,descriptor,if,found,li,recursively,search,through,all,annotations,that,the,given,class,declares,li,recursively,search,through,all,interfaces,implemented,by,the,given,class,li,recursively,search,through,the,superclass,hierarchy,of,the,given,class,ol,p,in,this,context,the,term,em,recursively,em,means,that,the,search,process,continues,by,returning,to,step,1,with,the,current,annotation,interface,or,superclass,as,the,class,to,look,for,annotations,on,param,clazz,the,class,to,look,for,annotations,on,param,annotation,types,the,types,of,annotations,to,look,for,return,the,corresponding,annotation,descriptor,if,one,of,the,annotations,was,found,otherwise,code,null,see,annotation,utils,find,annotation,declaring,class,for,types,java,util,list,class,see,find,annotation,descriptor,class,class;suppress,warnings,unchecked,public,static,untyped,annotation,descriptor,find,annotation,descriptor,for,types,class,clazz,class,extends,annotation,annotation,types,return,find,annotation,descriptor,for,types,clazz,new,hash,set,annotation,types
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Set<Annotation> visited, Class<T> annotationType);1459842161;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(_						composedAnnotation.annotationType(), visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(_							clazz, descriptor.getDeclaringClass(), composedAnnotation, descriptor.getAnnotation())__				}_			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Set<Annotation> visited, Class<T> annotationType);1462470884;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<T>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(_						composedAnnotation.annotationType(), visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<T>(_							clazz, descriptor.getDeclaringClass(), composedAnnotation, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(ifc, visited, annotationType)__			if (descriptor != null) {_				return new AnnotationDescriptor<T>(clazz, descriptor.getDeclaringClass(),_					descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,t,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,annotation,descriptor,t,descriptor,find,annotation,descriptor,ifc,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,t,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Set<Annotation> visited, Class<T> annotationType);1467730834;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnnotation : clazz.getDeclaredAnnotations()) {_			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedAnnotation) && visited.add(composedAnnotation)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(_						composedAnnotation.annotationType(), visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<>(_							clazz, descriptor.getDeclaringClass(), composedAnnotation, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(ifc, visited, annotationType)__			if (descriptor != null) {_				return new AnnotationDescriptor<>(clazz, descriptor.getDeclaringClass(),_						descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,annotation,clazz,get,declared,annotations,if,annotation,utils,is,in,java,lang,annotation,package,composed,annotation,visited,add,composed,annotation,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,annotation,annotation,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,annotation,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,annotation,descriptor,t,descriptor,find,annotation,descriptor,ifc,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			Class<?> clazz, Set<Annotation> visited, Class<T> annotationType);1491480437;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			Class<?> clazz, Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnn : clazz.getDeclaredAnnotations()) {_			Class<? extends Annotation> composedType = composedAnn.annotationType()__			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedType.getName()) && visited.add(composedAnn)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedType, visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<>(_							clazz, descriptor.getDeclaringClass(), composedAnn, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(ifc, visited, annotationType)__			if (descriptor != null) {_				return new AnnotationDescriptor<>(clazz, descriptor.getDeclaringClass(),_						descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,ann,clazz,get,declared,annotations,class,extends,annotation,composed,type,composed,ann,annotation,type,if,annotation,utils,is,in,java,lang,annotation,package,composed,type,get,name,visited,add,composed,ann,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,ann,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,annotation,descriptor,t,descriptor,find,annotation,descriptor,ifc,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> @Nullable 	private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			@Nullable Class<?> clazz, Set<Annotation> visited, Class<T> annotationType);1496955179;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};@Nullable_	private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			@Nullable Class<?> clazz, Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnn : clazz.getDeclaredAnnotations()) {_			Class<? extends Annotation> composedType = composedAnn.annotationType()__			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedType.getName()) && visited.add(composedAnn)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedType, visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<>(_							clazz, descriptor.getDeclaringClass(), composedAnn, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(ifc, visited, annotationType)__			if (descriptor != null) {_				return new AnnotationDescriptor<>(clazz, descriptor.getDeclaringClass(),_						descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;nullable,private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,nullable,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,ann,clazz,get,declared,annotations,class,extends,annotation,composed,type,composed,ann,annotation,type,if,annotation,utils,is,in,java,lang,annotation,package,composed,type,get,name,visited,add,composed,ann,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,ann,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,annotation,descriptor,t,descriptor,find,annotation,descriptor,ifc,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> @Nullable 	private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			@Nullable Class<?> clazz, Set<Annotation> visited, Class<T> annotationType);1498780456;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};@Nullable_	private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			@Nullable Class<?> clazz, Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnn : clazz.getDeclaredAnnotations()) {_			Class<? extends Annotation> composedType = composedAnn.annotationType()__			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedType.getName()) && visited.add(composedAnn)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedType, visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<>(_							clazz, descriptor.getDeclaringClass(), composedAnn, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(ifc, visited, annotationType)__			if (descriptor != null) {_				return new AnnotationDescriptor<>(clazz, descriptor.getDeclaringClass(),_						descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;nullable,private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,nullable,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,ann,clazz,get,declared,annotations,class,extends,annotation,composed,type,composed,ann,annotation,type,if,annotation,utils,is,in,java,lang,annotation,package,composed,type,get,name,visited,add,composed,ann,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,ann,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,annotation,descriptor,t,descriptor,find,annotation,descriptor,ifc,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
MetaAnnotationUtils -> @Nullable 	private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor( 			@Nullable Class<?> clazz, Set<Annotation> visited, Class<T> annotationType);1530174524;Perform the search algorithm for {@link #findAnnotationDescriptor(Class, Class)},_avoiding endless recursion by tracking which annotations have already been_<em>visited</em>._@param clazz the class to look for annotations on_@param visited the set of annotations that have already been visited_@param annotationType the type of annotation to look for_@return the corresponding annotation descriptor if the annotation was found__otherwise {@code null};@Nullable_	private static <T extends Annotation> AnnotationDescriptor<T> findAnnotationDescriptor(_			@Nullable Class<?> clazz, Set<Annotation> visited, Class<T> annotationType) {__		Assert.notNull(annotationType, "Annotation type must not be null")__		if (clazz == null || Object.class == clazz) {_			return null__		}__		_		if (AnnotationUtils.isAnnotationDeclaredLocally(annotationType, clazz)) {_			return new AnnotationDescriptor<>(clazz, clazz.getAnnotation(annotationType))__		}__		_		for (Annotation composedAnn : clazz.getDeclaredAnnotations()) {_			Class<? extends Annotation> composedType = composedAnn.annotationType()__			if (!AnnotationUtils.isInJavaLangAnnotationPackage(composedType.getName()) && visited.add(composedAnn)) {_				AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(composedType, visited, annotationType)__				if (descriptor != null) {_					return new AnnotationDescriptor<>(_							clazz, descriptor.getDeclaringClass(), composedAnn, descriptor.getAnnotation())__				}_			}_		}__		_		for (Class<?> ifc : clazz.getInterfaces()) {_			AnnotationDescriptor<T> descriptor = findAnnotationDescriptor(ifc, visited, annotationType)__			if (descriptor != null) {_				return new AnnotationDescriptor<>(clazz, descriptor.getDeclaringClass(),_						descriptor.getComposedAnnotation(), descriptor.getAnnotation())__			}_		}__		_		return findAnnotationDescriptor(clazz.getSuperclass(), visited, annotationType)__	};perform,the,search,algorithm,for,link,find,annotation,descriptor,class,class,avoiding,endless,recursion,by,tracking,which,annotations,have,already,been,em,visited,em,param,clazz,the,class,to,look,for,annotations,on,param,visited,the,set,of,annotations,that,have,already,been,visited,param,annotation,type,the,type,of,annotation,to,look,for,return,the,corresponding,annotation,descriptor,if,the,annotation,was,found,otherwise,code,null;nullable,private,static,t,extends,annotation,annotation,descriptor,t,find,annotation,descriptor,nullable,class,clazz,set,annotation,visited,class,t,annotation,type,assert,not,null,annotation,type,annotation,type,must,not,be,null,if,clazz,null,object,class,clazz,return,null,if,annotation,utils,is,annotation,declared,locally,annotation,type,clazz,return,new,annotation,descriptor,clazz,clazz,get,annotation,annotation,type,for,annotation,composed,ann,clazz,get,declared,annotations,class,extends,annotation,composed,type,composed,ann,annotation,type,if,annotation,utils,is,in,java,lang,annotation,package,composed,type,get,name,visited,add,composed,ann,annotation,descriptor,t,descriptor,find,annotation,descriptor,composed,type,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,composed,ann,descriptor,get,annotation,for,class,ifc,clazz,get,interfaces,annotation,descriptor,t,descriptor,find,annotation,descriptor,ifc,visited,annotation,type,if,descriptor,null,return,new,annotation,descriptor,clazz,descriptor,get,declaring,class,descriptor,get,composed,annotation,descriptor,get,annotation,return,find,annotation,descriptor,clazz,get,superclass,visited,annotation,type
