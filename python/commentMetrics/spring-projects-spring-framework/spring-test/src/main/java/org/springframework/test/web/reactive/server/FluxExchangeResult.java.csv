# id;timestamp;commentText;codeText;commentWords;codeWords
FluxExchangeResult -> public Flux<T> getResponseBody();1487556888;Return the {@code Flux} of elements decoded from the response body.;public Flux<T> getResponseBody() {_		return this.body__	};return,the,code,flux,of,elements,decoded,from,the,response,body;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1487556888;Return the {@code Flux} of elements decoded from the response body.;public Flux<T> getResponseBody() {_		return this.body__	};return,the,code,flux,of,elements,decoded,from,the,response,body;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1487633370;Return the {@code Flux} of elements decoded from the response body.;public Flux<T> getResponseBody() {_		return this.body__	};return,the,code,flux,of,elements,decoded,from,the,response,body;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1487633370;Return the {@code Flux} of elements decoded from the response body.;public Flux<T> getResponseBody() {_		return this.body__	};return,the,code,flux,of,elements,decoded,from,the,response,body;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1489099256;Return the response body as a {@code Flux<T>} of decoded elements.__<p>The response body stream can then be consumed further with the_"reactor-test" {@code StepVerifier} and cancelled when enough elements have been_consumed from the (possibly infinite) stream:__<pre>_FluxExchangeResult<Person> result = this.client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.expectHeader().contentType(TEXT_EVENT_STREAM)_.expectBody(Person.class)_.returnResult()___StepVerifier.create(result.getResponseBody())_.expectNext(new Person("Jane"), new Person("Jason"))_.expectNextCount(4)_.expectNext(new Person("Jay"))_.thenCancel()_.verify()__</pre>;public Flux<T> getResponseBody() {_		return this.body__	};return,the,response,body,as,a,code,flux,t,of,decoded,elements,p,the,response,body,stream,can,then,be,consumed,further,with,the,reactor,test,code,step,verifier,and,cancelled,when,enough,elements,have,been,consumed,from,the,possibly,infinite,stream,pre,flux,exchange,result,person,result,this,client,get,uri,persons,accept,exchange,expect,status,is,ok,expect,header,content,type,expect,body,person,class,return,result,step,verifier,create,result,get,response,body,expect,next,new,person,jane,new,person,jason,expect,next,count,4,expect,next,new,person,jay,then,cancel,verify,pre;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1489423061;Return the response body as a {@code Flux<T>} of decoded elements.__<p>The response body stream can then be consumed further with the_"reactor-test" {@code StepVerifier} and cancelled when enough elements have been_consumed from the (possibly infinite) stream:__<pre>_FluxExchangeResult<Person> result = this.client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.expectHeader().contentType(TEXT_EVENT_STREAM)_.expectBody(Person.class)_.returnResult()___StepVerifier.create(result.getResponseBody())_.expectNext(new Person("Jane"), new Person("Jason"))_.expectNextCount(4)_.expectNext(new Person("Jay"))_.thenCancel()_.verify()__</pre>;public Flux<T> getResponseBody() {_		return this.body__	};return,the,response,body,as,a,code,flux,t,of,decoded,elements,p,the,response,body,stream,can,then,be,consumed,further,with,the,reactor,test,code,step,verifier,and,cancelled,when,enough,elements,have,been,consumed,from,the,possibly,infinite,stream,pre,flux,exchange,result,person,result,this,client,get,uri,persons,accept,exchange,expect,status,is,ok,expect,header,content,type,expect,body,person,class,return,result,step,verifier,create,result,get,response,body,expect,next,new,person,jane,new,person,jason,expect,next,count,4,expect,next,new,person,jay,then,cancel,verify,pre;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1492542679;Return the response body as a {@code Flux<T>} of decoded elements.__<p>The response body stream can then be consumed further with the_"reactor-test" {@code StepVerifier} and cancelled when enough elements have been_consumed from the (possibly infinite) stream:__<pre>_FluxExchangeResult<Person> result = this.client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.expectHeader().contentType(TEXT_EVENT_STREAM)_.expectBody(Person.class)_.returnResult()___StepVerifier.create(result.getResponseBody())_.expectNext(new Person("Jane"), new Person("Jason"))_.expectNextCount(4)_.expectNext(new Person("Jay"))_.thenCancel()_.verify()__</pre>;public Flux<T> getResponseBody() {_		return this.body__	};return,the,response,body,as,a,code,flux,t,of,decoded,elements,p,the,response,body,stream,can,then,be,consumed,further,with,the,reactor,test,code,step,verifier,and,cancelled,when,enough,elements,have,been,consumed,from,the,possibly,infinite,stream,pre,flux,exchange,result,person,result,this,client,get,uri,persons,accept,exchange,expect,status,is,ok,expect,header,content,type,expect,body,person,class,return,result,step,verifier,create,result,get,response,body,expect,next,new,person,jane,new,person,jason,expect,next,count,4,expect,next,new,person,jay,then,cancel,verify,pre;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1498780456;Return the response body as a {@code Flux<T>} of decoded elements.__<p>The response body stream can then be consumed further with the_"reactor-test" {@code StepVerifier} and cancelled when enough elements have been_consumed from the (possibly infinite) stream:__<pre>_FluxExchangeResult<Person> result = this.client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.expectHeader().contentType(TEXT_EVENT_STREAM)_.expectBody(Person.class)_.returnResult()___StepVerifier.create(result.getResponseBody())_.expectNext(new Person("Jane"), new Person("Jason"))_.expectNextCount(4)_.expectNext(new Person("Jay"))_.thenCancel()_.verify()__</pre>;public Flux<T> getResponseBody() {_		return this.body__	};return,the,response,body,as,a,code,flux,t,of,decoded,elements,p,the,response,body,stream,can,then,be,consumed,further,with,the,reactor,test,code,step,verifier,and,cancelled,when,enough,elements,have,been,consumed,from,the,possibly,infinite,stream,pre,flux,exchange,result,person,result,this,client,get,uri,persons,accept,exchange,expect,status,is,ok,expect,header,content,type,expect,body,person,class,return,result,step,verifier,create,result,get,response,body,expect,next,new,person,jane,new,person,jason,expect,next,count,4,expect,next,new,person,jay,then,cancel,verify,pre;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1502974979;Return the response body as a {@code Flux<T>} of decoded elements.__<p>The response body stream can then be consumed further with the_"reactor-test" {@code StepVerifier} and cancelled when enough elements have been_consumed from the (possibly infinite) stream:__<pre>_FluxExchangeResult<Person> result = this.client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.expectHeader().contentType(TEXT_EVENT_STREAM)_.expectBody(Person.class)_.returnResult()___StepVerifier.create(result.getResponseBody())_.expectNext(new Person("Jane"), new Person("Jason"))_.expectNextCount(4)_.expectNext(new Person("Jay"))_.thenCancel()_.verify()__</pre>;public Flux<T> getResponseBody() {_		return this.body__	};return,the,response,body,as,a,code,flux,t,of,decoded,elements,p,the,response,body,stream,can,then,be,consumed,further,with,the,reactor,test,code,step,verifier,and,cancelled,when,enough,elements,have,been,consumed,from,the,possibly,infinite,stream,pre,flux,exchange,result,person,result,this,client,get,uri,persons,accept,exchange,expect,status,is,ok,expect,header,content,type,expect,body,person,class,return,result,step,verifier,create,result,get,response,body,expect,next,new,person,jane,new,person,jason,expect,next,count,4,expect,next,new,person,jay,then,cancel,verify,pre;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1506128642;Return the response body as a {@code Flux<T>} of decoded elements.__<p>The response body stream can then be consumed further with the_"reactor-test" {@code StepVerifier} and cancelled when enough elements have been_consumed from the (possibly infinite) stream:__<pre>_FluxExchangeResult<Person> result = this.client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.expectHeader().contentType(TEXT_EVENT_STREAM)_.expectBody(Person.class)_.returnResult()___StepVerifier.create(result.getResponseBody())_.expectNext(new Person("Jane"), new Person("Jason"))_.expectNextCount(4)_.expectNext(new Person("Jay"))_.thenCancel()_.verify()__</pre>;public Flux<T> getResponseBody() {_		return this.body__	};return,the,response,body,as,a,code,flux,t,of,decoded,elements,p,the,response,body,stream,can,then,be,consumed,further,with,the,reactor,test,code,step,verifier,and,cancelled,when,enough,elements,have,been,consumed,from,the,possibly,infinite,stream,pre,flux,exchange,result,person,result,this,client,get,uri,persons,accept,exchange,expect,status,is,ok,expect,header,content,type,expect,body,person,class,return,result,step,verifier,create,result,get,response,body,expect,next,new,person,jane,new,person,jason,expect,next,count,4,expect,next,new,person,jay,then,cancel,verify,pre;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1530174524;Return the response body as a {@code Flux<T>} of decoded elements.__<p>The response body stream can then be consumed further with the_"reactor-test" {@code StepVerifier} and cancelled when enough elements have been_consumed from the (possibly infinite) stream:__<pre>_FluxExchangeResult&lt_Person&gt_ result = this.client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.expectHeader().contentType(TEXT_EVENT_STREAM)_.expectBody(Person.class)_.returnResult()___StepVerifier.create(result.getResponseBody())_.expectNext(new Person("Jane"), new Person("Jason"))_.expectNextCount(4)_.expectNext(new Person("Jay"))_.thenCancel()_.verify()__</pre>;public Flux<T> getResponseBody() {_		return this.body__	};return,the,response,body,as,a,code,flux,t,of,decoded,elements,p,the,response,body,stream,can,then,be,consumed,further,with,the,reactor,test,code,step,verifier,and,cancelled,when,enough,elements,have,been,consumed,from,the,possibly,infinite,stream,pre,flux,exchange,result,lt,person,gt,result,this,client,get,uri,persons,accept,exchange,expect,status,is,ok,expect,header,content,type,expect,body,person,class,return,result,step,verifier,create,result,get,response,body,expect,next,new,person,jane,new,person,jason,expect,next,count,4,expect,next,new,person,jay,then,cancel,verify,pre;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> public Flux<T> getResponseBody();1539303956;Return the response body as a {@code Flux<T>} of decoded elements.__<p>The response body stream can then be consumed further with the_"reactor-test" {@code StepVerifier} and cancelled when enough elements have been_consumed from the (possibly infinite) stream:__<pre>_FluxExchangeResult&lt_Person&gt_ result = this.client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.expectHeader().contentType(TEXT_EVENT_STREAM)_.expectBody(Person.class)_.returnResult()___StepVerifier.create(result.getResponseBody())_.expectNext(new Person("Jane"), new Person("Jason"))_.expectNextCount(4)_.expectNext(new Person("Jay"))_.thenCancel()_.verify()__</pre>;public Flux<T> getResponseBody() {_		return this.body__	};return,the,response,body,as,a,code,flux,t,of,decoded,elements,p,the,response,body,stream,can,then,be,consumed,further,with,the,reactor,test,code,step,verifier,and,cancelled,when,enough,elements,have,been,consumed,from,the,possibly,infinite,stream,pre,flux,exchange,result,lt,person,gt,result,this,client,get,uri,persons,accept,exchange,expect,status,is,ok,expect,header,content,type,expect,body,person,class,return,result,step,verifier,create,result,get,response,body,expect,next,new,person,jane,new,person,jason,expect,next,count,4,expect,next,new,person,jay,then,cancel,verify,pre;public,flux,t,get,response,body,return,this,body
FluxExchangeResult -> @Override 	@Nullable 	public byte[] getResponseBodyContent();1502974979;{@inheritDoc}_<p><strong>Note:</strong> this method should typically be called after_the response has been consumed in full via {@link #getResponseBody()}._Calling it first will cause the response {@code Flux<T>} to be consumed_via {@code getResponseBody.ignoreElements()}.;@Override_	@Nullable_	public byte[] getResponseBodyContent() {_		return this.body.ignoreElements()_				.timeout(this.timeout, Mono.error(TIMEOUT_ERROR))_				.then(Mono.defer(() -> Mono.justOrEmpty(super.getResponseBodyContent())))_				.block()__	};inherit,doc,p,strong,note,strong,this,method,should,typically,be,called,after,the,response,has,been,consumed,in,full,via,link,get,response,body,calling,it,first,will,cause,the,response,code,flux,t,to,be,consumed,via,code,get,response,body,ignore,elements;override,nullable,public,byte,get,response,body,content,return,this,body,ignore,elements,timeout,this,timeout,mono,error,then,mono,defer,mono,just,or,empty,super,get,response,body,content,block
FluxExchangeResult -> @Override 	@Nullable 	public byte[] getResponseBodyContent();1506128642;{@inheritDoc}_<p><strong>Note:</strong> this method should typically be called after_the response has been consumed in full via {@link #getResponseBody()}._Calling it first will cause the response {@code Flux<T>} to be consumed_via {@code getResponseBody.ignoreElements()}.;@Override_	@Nullable_	public byte[] getResponseBodyContent() {_		return this.body.ignoreElements()_				.timeout(this.timeout, Mono.error(TIMEOUT_ERROR))_				.then(Mono.defer(() -> Mono.justOrEmpty(super.getResponseBodyContent())))_				.block()__	};inherit,doc,p,strong,note,strong,this,method,should,typically,be,called,after,the,response,has,been,consumed,in,full,via,link,get,response,body,calling,it,first,will,cause,the,response,code,flux,t,to,be,consumed,via,code,get,response,body,ignore,elements;override,nullable,public,byte,get,response,body,content,return,this,body,ignore,elements,timeout,this,timeout,mono,error,then,mono,defer,mono,just,or,empty,super,get,response,body,content,block
FluxExchangeResult -> @Override 	@Nullable 	public byte[] getResponseBodyContent();1530174524;{@inheritDoc}_<p><strong>Note:</strong> this method should typically be called after_the response has been consumed in full via {@link #getResponseBody()}._Calling it first will cause the response {@code Flux<T>} to be consumed_via {@code getResponseBody.ignoreElements()}.;@Override_	@Nullable_	public byte[] getResponseBodyContent() {_		return this.body.ignoreElements()_				.timeout(this.timeout, Mono.error(TIMEOUT_ERROR))_				.then(Mono.defer(() -> Mono.justOrEmpty(super.getResponseBodyContent())))_				.block()__	};inherit,doc,p,strong,note,strong,this,method,should,typically,be,called,after,the,response,has,been,consumed,in,full,via,link,get,response,body,calling,it,first,will,cause,the,response,code,flux,t,to,be,consumed,via,code,get,response,body,ignore,elements;override,nullable,public,byte,get,response,body,content,return,this,body,ignore,elements,timeout,this,timeout,mono,error,then,mono,defer,mono,just,or,empty,super,get,response,body,content,block
FluxExchangeResult -> public void consumeWith(Consumer<FluxExchangeResult<T>> consumer);1506128642;Invoke the given consumer within {@link #assertWithDiagnostics(Runnable)}_passing {@code "this"} instance to it. This method allows the following,_without leaving the {@code WebTestClient} chain of calls:_<pre class="code">_client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.returnResult()_.consumeWith(result -> assertThat(...)__</pre>_@param consumer consumer for {@code "this"} instance;public void consumeWith(Consumer<FluxExchangeResult<T>> consumer) {_		assertWithDiagnostics(() -> consumer.accept(this))__	};invoke,the,given,consumer,within,link,assert,with,diagnostics,runnable,passing,code,this,instance,to,it,this,method,allows,the,following,without,leaving,the,code,web,test,client,chain,of,calls,pre,class,code,client,get,uri,persons,accept,exchange,expect,status,is,ok,return,result,consume,with,result,assert,that,pre,param,consumer,consumer,for,code,this,instance;public,void,consume,with,consumer,flux,exchange,result,t,consumer,assert,with,diagnostics,consumer,accept,this
FluxExchangeResult -> public void consumeWith(Consumer<FluxExchangeResult<T>> consumer);1530174524;Invoke the given consumer within {@link #assertWithDiagnostics(Runnable)}_passing {@code "this"} instance to it. This method allows the following,_without leaving the {@code WebTestClient} chain of calls:_<pre class="code">_client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.returnResult()_.consumeWith(result -> assertThat(...)__</pre>_@param consumer consumer for {@code "this"} instance;public void consumeWith(Consumer<FluxExchangeResult<T>> consumer) {_		assertWithDiagnostics(() -> consumer.accept(this))__	};invoke,the,given,consumer,within,link,assert,with,diagnostics,runnable,passing,code,this,instance,to,it,this,method,allows,the,following,without,leaving,the,code,web,test,client,chain,of,calls,pre,class,code,client,get,uri,persons,accept,exchange,expect,status,is,ok,return,result,consume,with,result,assert,that,pre,param,consumer,consumer,for,code,this,instance;public,void,consume,with,consumer,flux,exchange,result,t,consumer,assert,with,diagnostics,consumer,accept,this
FluxExchangeResult -> public void consumeWith(Consumer<FluxExchangeResult<T>> consumer);1539303956;Invoke the given consumer within {@link #assertWithDiagnostics(Runnable)}_passing {@code "this"} instance to it. This method allows the following,_without leaving the {@code WebTestClient} chain of calls:_<pre class="code">_client.get()_.uri("/persons")_.accept(TEXT_EVENT_STREAM)_.exchange()_.expectStatus().isOk()_.returnResult()_.consumeWith(result -> assertThat(...)__</pre>_@param consumer consumer for {@code "this"} instance;public void consumeWith(Consumer<FluxExchangeResult<T>> consumer) {_		assertWithDiagnostics(() -> consumer.accept(this))__	};invoke,the,given,consumer,within,link,assert,with,diagnostics,runnable,passing,code,this,instance,to,it,this,method,allows,the,following,without,leaving,the,code,web,test,client,chain,of,calls,pre,class,code,client,get,uri,persons,accept,exchange,expect,status,is,ok,return,result,consume,with,result,assert,that,pre,param,consumer,consumer,for,code,this,instance;public,void,consume,with,consumer,flux,exchange,result,t,consumer,assert,with,diagnostics,consumer,accept,this
FluxExchangeResult -> @Override 	public byte[] getResponseBodyContent();1489099256;{@inheritDoc}_<p><strong>Note:</strong> this method should typically be called after_the response has been consumed in full via {@link #getResponseBody()}._Calling it first will cause the response {@code Flux<T>} to be consumed_via {@code getResponseBody.ignoreElements()}.;@Override_	public byte[] getResponseBodyContent() {_		return this.body.ignoreElements()_				.timeout(this.timeout, Mono.error(TIMEOUT_ERROR))_				.then(() -> Mono.just(super.getResponseBodyContent()))_				.block()__	};inherit,doc,p,strong,note,strong,this,method,should,typically,be,called,after,the,response,has,been,consumed,in,full,via,link,get,response,body,calling,it,first,will,cause,the,response,code,flux,t,to,be,consumed,via,code,get,response,body,ignore,elements;override,public,byte,get,response,body,content,return,this,body,ignore,elements,timeout,this,timeout,mono,error,then,mono,just,super,get,response,body,content,block
FluxExchangeResult -> @Override 	public byte[] getResponseBodyContent();1489423061;{@inheritDoc}_<p><strong>Note:</strong> this method should typically be called after_the response has been consumed in full via {@link #getResponseBody()}._Calling it first will cause the response {@code Flux<T>} to be consumed_via {@code getResponseBody.ignoreElements()}.;@Override_	public byte[] getResponseBodyContent() {_		return this.body.ignoreElements()_				.timeout(this.timeout, Mono.error(TIMEOUT_ERROR))_				.then(() -> Mono.just(super.getResponseBodyContent()))_				.block()__	};inherit,doc,p,strong,note,strong,this,method,should,typically,be,called,after,the,response,has,been,consumed,in,full,via,link,get,response,body,calling,it,first,will,cause,the,response,code,flux,t,to,be,consumed,via,code,get,response,body,ignore,elements;override,public,byte,get,response,body,content,return,this,body,ignore,elements,timeout,this,timeout,mono,error,then,mono,just,super,get,response,body,content,block
FluxExchangeResult -> @Override 	public byte[] getResponseBodyContent();1492542679;{@inheritDoc}_<p><strong>Note:</strong> this method should typically be called after_the response has been consumed in full via {@link #getResponseBody()}._Calling it first will cause the response {@code Flux<T>} to be consumed_via {@code getResponseBody.ignoreElements()}.;@Override_	public byte[] getResponseBodyContent() {_		return this.body.ignoreElements()_				.timeout(this.timeout, Mono.error(TIMEOUT_ERROR))_				.then(Mono.defer(() -> Mono.just(super.getResponseBodyContent())))_				.block()__	};inherit,doc,p,strong,note,strong,this,method,should,typically,be,called,after,the,response,has,been,consumed,in,full,via,link,get,response,body,calling,it,first,will,cause,the,response,code,flux,t,to,be,consumed,via,code,get,response,body,ignore,elements;override,public,byte,get,response,body,content,return,this,body,ignore,elements,timeout,this,timeout,mono,error,then,mono,defer,mono,just,super,get,response,body,content,block
FluxExchangeResult -> @Override 	public byte[] getResponseBodyContent();1498780456;{@inheritDoc}_<p><strong>Note:</strong> this method should typically be called after_the response has been consumed in full via {@link #getResponseBody()}._Calling it first will cause the response {@code Flux<T>} to be consumed_via {@code getResponseBody.ignoreElements()}.;@Override_	public byte[] getResponseBodyContent() {_		return this.body.ignoreElements()_				.timeout(this.timeout, Mono.error(TIMEOUT_ERROR))_				.then(Mono.defer(() -> Mono.justOrEmpty(super.getResponseBodyContent())))_				.block()__	};inherit,doc,p,strong,note,strong,this,method,should,typically,be,called,after,the,response,has,been,consumed,in,full,via,link,get,response,body,calling,it,first,will,cause,the,response,code,flux,t,to,be,consumed,via,code,get,response,body,ignore,elements;override,public,byte,get,response,body,content,return,this,body,ignore,elements,timeout,this,timeout,mono,error,then,mono,defer,mono,just,or,empty,super,get,response,body,content,block
