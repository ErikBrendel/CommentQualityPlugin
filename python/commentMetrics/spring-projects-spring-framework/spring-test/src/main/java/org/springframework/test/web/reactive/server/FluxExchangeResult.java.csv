commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the response body as a {@code Flux<T>} of decoded elements.  *  * <p>The response body stream can then be consumed further with the  * "reactor-test" {@code StepVerifier} and cancelled when enough elements have been  * consumed from the (possibly infinite) stream:  *  * <pre>  * FluxExchangeResult&lt.Person&gt. result = this.client.get()  * 	.uri("/persons")  * 	.accept(TEXT_EVENT_STREAM)  * 	.exchange()  * 	.expectStatus().isOk()  * 	.expectHeader().contentType(TEXT_EVENT_STREAM)  * 	.expectBody(Person.class)  * 	.returnResult().  *  * StepVerifier.create(result.getResponseBody())  * 	.expectNext(new Person("Jane"), new Person("Jason"))  * 	.expectNextCount(4)  * 	.expectNext(new Person("Jay"))  * 	.thenCancel()  * 	.verify().  * </pre>  */ ;/**  * Return the response body as a {@code Flux<T>} of decoded elements.  *  * <p>The response body stream can then be consumed further with the  * "reactor-test" {@code StepVerifier} and cancelled when enough elements have been  * consumed from the (possibly infinite) stream:  *  * <pre>  * FluxExchangeResult&lt.Person&gt. result = this.client.get()  * 	.uri("/persons")  * 	.accept(TEXT_EVENT_STREAM)  * 	.exchange()  * 	.expectStatus().isOk()  * 	.expectHeader().contentType(TEXT_EVENT_STREAM)  * 	.expectBody(Person.class)  * 	.returnResult().  *  * StepVerifier.create(result.getResponseBody())  * 	.expectNext(new Person("Jane"), new Person("Jason"))  * 	.expectNextCount(4)  * 	.expectNext(new Person("Jay"))  * 	.thenCancel()  * 	.verify().  * </pre>  */ public Flux<T> getResponseBody() {     return this.body. }
true;public;1;3;/**  *  Invoke the given consumer within {@link #assertWithDiagnostics(Runnable)}  *  passing {@code "this"} instance to it. This method allows the following,  *  without leaving the {@code WebTestClient} chain of calls:  *  <pre class="code">  * 	client.get()  *  		.uri("/persons")  *  		.accept(TEXT_EVENT_STREAM)  *  		.exchange()  *  		.expectStatus().isOk()  * 	 	.returnResult()  * 	 	.consumeWith(result -> assertThat(...).  *  </pre>  *  @param consumer consumer for {@code "this"} instance  */ ;/**  *  Invoke the given consumer within {@link #assertWithDiagnostics(Runnable)}  *  passing {@code "this"} instance to it. This method allows the following,  *  without leaving the {@code WebTestClient} chain of calls:  *  <pre class="code">  * 	client.get()  *  		.uri("/persons")  *  		.accept(TEXT_EVENT_STREAM)  *  		.exchange()  *  		.expectStatus().isOk()  * 	 	.returnResult()  * 	 	.consumeWith(result -> assertThat(...).  *  </pre>  *  @param consumer consumer for {@code "this"} instance  */ public void consumeWith(Consumer<FluxExchangeResult<T>> consumer) {     assertWithDiagnostics(() -> consumer.accept(this)). }
