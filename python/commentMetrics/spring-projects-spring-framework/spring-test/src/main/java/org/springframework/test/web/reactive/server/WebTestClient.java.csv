commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Prepare an HTTP GET request.  * @return a spec for specifying the target URL  */ ;/**  * Prepare an HTTP GET request.  * @return a spec for specifying the target URL  */ RequestHeadersUriSpec<?> get().
true;;0;1;/**  * Prepare an HTTP HEAD request.  * @return a spec for specifying the target URL  */ ;/**  * Prepare an HTTP HEAD request.  * @return a spec for specifying the target URL  */ RequestHeadersUriSpec<?> head().
true;;0;1;/**  * Prepare an HTTP POST request.  * @return a spec for specifying the target URL  */ ;/**  * Prepare an HTTP POST request.  * @return a spec for specifying the target URL  */ RequestBodyUriSpec post().
true;;0;1;/**  * Prepare an HTTP PUT request.  * @return a spec for specifying the target URL  */ ;/**  * Prepare an HTTP PUT request.  * @return a spec for specifying the target URL  */ RequestBodyUriSpec put().
true;;0;1;/**  * Prepare an HTTP PATCH request.  * @return a spec for specifying the target URL  */ ;/**  * Prepare an HTTP PATCH request.  * @return a spec for specifying the target URL  */ RequestBodyUriSpec patch().
true;;0;1;/**  * Prepare an HTTP DELETE request.  * @return a spec for specifying the target URL  */ ;/**  * Prepare an HTTP DELETE request.  * @return a spec for specifying the target URL  */ RequestHeadersUriSpec<?> delete().
true;;0;1;/**  * Prepare an HTTP OPTIONS request.  * @return a spec for specifying the target URL  */ ;/**  * Prepare an HTTP OPTIONS request.  * @return a spec for specifying the target URL  */ RequestHeadersUriSpec<?> options().
true;;1;1;/**  * Prepare a request for the specified {@code HttpMethod}.  * @return a spec for specifying the target URL  */ ;/**  * Prepare a request for the specified {@code HttpMethod}.  * @return a spec for specifying the target URL  */ RequestBodyUriSpec method(HttpMethod method).
true;;0;1;/**  * Return a builder to mutate properties of this web test client.  */ ;/**  * Return a builder to mutate properties of this web test client.  */ Builder mutate().
true;;1;1;/**  * Mutate the {@link WebTestClient}, apply the given configurer, and build  * a new instance. Essentially a shortcut for:  * <pre>  * mutate().apply(configurer).build().  * </pre>  * @param configurer the configurer to apply  * @return the mutated test client  */ ;/**  * Mutate the {@link WebTestClient}, apply the given configurer, and build  * a new instance. Essentially a shortcut for:  * <pre>  * mutate().apply(configurer).build().  * </pre>  * @param configurer the configurer to apply  * @return the mutated test client  */ WebTestClient mutateWith(WebTestClientConfigurer configurer).
true;static;1;3;/**  * Use this server setup to test one `@Controller` at a time.  * This option loads the default configuration of  * {@link org.springframework.web.reactive.config.EnableWebFlux @EnableWebFlux}.  * There are builder methods to customize the Java config. The resulting  * WebFlux application will be tested without an HTTP server using a mock  * request and response.  * @param controllers one or more controller instances to tests  * (specified {@code Class} will be turned into instance)  * @return chained API to customize server and client config. use  * {@link MockServerSpec#configureClient()} to transition to client config  */ ;// Static factory methods /**  * Use this server setup to test one `@Controller` at a time.  * This option loads the default configuration of  * {@link org.springframework.web.reactive.config.EnableWebFlux @EnableWebFlux}.  * There are builder methods to customize the Java config. The resulting  * WebFlux application will be tested without an HTTP server using a mock  * request and response.  * @param controllers one or more controller instances to tests  * (specified {@code Class} will be turned into instance)  * @return chained API to customize server and client config. use  * {@link MockServerSpec#configureClient()} to transition to client config  */ static ControllerSpec bindToController(Object... controllers) {     return new DefaultControllerSpec(controllers). }
true;static;1;3;/**  * Use this option to set up a server from a {@link RouterFunction}.  * Internally the provided configuration is passed to  * {@code RouterFunctions#toWebHandler}. The resulting WebFlux application  * will be tested without an HTTP server using a mock request and response.  * @param routerFunction the RouterFunction to test  * @return chained API to customize server and client config. use  * {@link MockServerSpec#configureClient()} to transition to client config  */ ;/**  * Use this option to set up a server from a {@link RouterFunction}.  * Internally the provided configuration is passed to  * {@code RouterFunctions#toWebHandler}. The resulting WebFlux application  * will be tested without an HTTP server using a mock request and response.  * @param routerFunction the RouterFunction to test  * @return chained API to customize server and client config. use  * {@link MockServerSpec#configureClient()} to transition to client config  */ static RouterFunctionSpec bindToRouterFunction(RouterFunction<?> routerFunction) {     return new DefaultRouterFunctionSpec(routerFunction). }
true;static;1;3;/**  * Use this option to setup a server from the Spring configuration of your  * application, or some subset of it. Internally the provided configuration  * is passed to {@code WebHttpHandlerBuilder} to set up the request  * processing chain. The resulting WebFlux application will be tested  * without an HTTP server using a mock request and response.  * <p>Consider using the TestContext framework and  * {@link org.springframework.test.context.ContextConfiguration @ContextConfiguration}  * in order to efficiently load and inject the Spring configuration into the  * test class.  * @param applicationContext the Spring context  * @return chained API to customize server and client config. use  * {@link MockServerSpec#configureClient()} to transition to client config  */ ;/**  * Use this option to setup a server from the Spring configuration of your  * application, or some subset of it. Internally the provided configuration  * is passed to {@code WebHttpHandlerBuilder} to set up the request  * processing chain. The resulting WebFlux application will be tested  * without an HTTP server using a mock request and response.  * <p>Consider using the TestContext framework and  * {@link org.springframework.test.context.ContextConfiguration @ContextConfiguration}  * in order to efficiently load and inject the Spring configuration into the  * test class.  * @param applicationContext the Spring context  * @return chained API to customize server and client config. use  * {@link MockServerSpec#configureClient()} to transition to client config  */ static MockServerSpec<?> bindToApplicationContext(ApplicationContext applicationContext) {     return new ApplicationContextSpec(applicationContext). }
true;static;1;3;/**  * Integration testing with a "mock" server targeting the given WebHandler.  * @param webHandler the handler to test  * @return chained API to customize server and client config. use  * {@link MockServerSpec#configureClient()} to transition to client config  */ ;/**  * Integration testing with a "mock" server targeting the given WebHandler.  * @param webHandler the handler to test  * @return chained API to customize server and client config. use  * {@link MockServerSpec#configureClient()} to transition to client config  */ static MockServerSpec<?> bindToWebHandler(WebHandler webHandler) {     return new DefaultMockServerSpec(webHandler). }
true;static;0;3;/**  * This server setup option allows you to connect to a running server via  * Reactor Netty.  * <p><pre class="code">  * WebTestClient client = WebTestClient.bindToServer()  *         .baseUrl("http://localhost:8080")  *         .build().  * </pre>  * @return chained API to customize client config  */ ;/**  * This server setup option allows you to connect to a running server via  * Reactor Netty.  * <p><pre class="code">  * WebTestClient client = WebTestClient.bindToServer()  *         .baseUrl("http://localhost:8080")  *         .build().  * </pre>  * @return chained API to customize client config  */ static Builder bindToServer() {     return new DefaultWebTestClientBuilder(). }
true;static;1;3;/**  * A variant of {@link #bindToServer()} with a pre-configured connector.  * <p><pre class="code">  * WebTestClient client = WebTestClient.bindToServer()  *         .baseUrl("http://localhost:8080")  *         .build().  * </pre>  * @return chained API to customize client config  * @since 5.0.2  */ ;/**  * A variant of {@link #bindToServer()} with a pre-configured connector.  * <p><pre class="code">  * WebTestClient client = WebTestClient.bindToServer()  *         .baseUrl("http://localhost:8080")  *         .build().  * </pre>  * @return chained API to customize client config  * @since 5.0.2  */ static Builder bindToServer(ClientHttpConnector connector) {     return new DefaultWebTestClientBuilder(connector). }
true;;1;1;/**  * Register {@link WebFilter} instances to add to the mock server.  * @param filter one or more filters  */ ;/**  * Register {@link WebFilter} instances to add to the mock server.  * @param filter one or more filters  */ <T extends B> T webFilter(WebFilter... filter).
true;;1;1;/**  * Provide a session manager instance for the mock server.  * <p>By default an instance of  * {@link org.springframework.web.server.session.DefaultWebSessionManager  * DefaultWebSessionManager} is used.  * @param sessionManager the session manager to use  */ ;/**  * Provide a session manager instance for the mock server.  * <p>By default an instance of  * {@link org.springframework.web.server.session.DefaultWebSessionManager  * DefaultWebSessionManager} is used.  * @param sessionManager the session manager to use  */ <T extends B> T webSessionManager(WebSessionManager sessionManager).
true;;1;1;/**  * Shortcut for pre-packaged customizations to the mock server setup.  * @param configurer the configurer to apply  */ ;/**  * Shortcut for pre-packaged customizations to the mock server setup.  * @param configurer the configurer to apply  */ <T extends B> T apply(MockServerConfigurer configurer).
true;;0;1;/**  * Proceed to configure and build the test client.  */ ;/**  * Proceed to configure and build the test client.  */ Builder configureClient().
true;;0;1;/**  * Shortcut to build the test client.  */ ;/**  * Shortcut to build the test client.  */ WebTestClient build().
true;;1;1;/**  * Register one or more {@link org.springframework.web.bind.annotation.ControllerAdvice}  * instances to be used in tests (specified {@code Class} will be turned into instance).  */ ;/**  * Register one or more {@link org.springframework.web.bind.annotation.ControllerAdvice}  * instances to be used in tests (specified {@code Class} will be turned into instance).  */ ControllerSpec controllerAdvice(Object... controllerAdvice).
true;;1;1;/**  * Customize content type resolution.  * @see WebFluxConfigurer#configureContentTypeResolver  */ ;/**  * Customize content type resolution.  * @see WebFluxConfigurer#configureContentTypeResolver  */ ControllerSpec contentTypeResolver(Consumer<RequestedContentTypeResolverBuilder> consumer).
true;;1;1;/**  * Configure CORS support.  * @see WebFluxConfigurer#addCorsMappings  */ ;/**  * Configure CORS support.  * @see WebFluxConfigurer#addCorsMappings  */ ControllerSpec corsMappings(Consumer<CorsRegistry> consumer).
true;;1;1;/**  * Configure path matching options.  * @see WebFluxConfigurer#configurePathMatching  */ ;/**  * Configure path matching options.  * @see WebFluxConfigurer#configurePathMatching  */ ControllerSpec pathMatching(Consumer<PathMatchConfigurer> consumer).
true;;1;1;/**  * Configure resolvers for custom controller method arguments.  * @see WebFluxConfigurer#configureHttpMessageCodecs  */ ;/**  * Configure resolvers for custom controller method arguments.  * @see WebFluxConfigurer#configureHttpMessageCodecs  */ ControllerSpec argumentResolvers(Consumer<ArgumentResolverConfigurer> configurer).
true;;1;1;/**  * Configure custom HTTP message readers and writers or override built-in ones.  * @see WebFluxConfigurer#configureHttpMessageCodecs  */ ;/**  * Configure custom HTTP message readers and writers or override built-in ones.  * @see WebFluxConfigurer#configureHttpMessageCodecs  */ ControllerSpec httpMessageCodecs(Consumer<ServerCodecConfigurer> configurer).
true;;1;1;/**  * Register formatters and converters to use for type conversion.  * @see WebFluxConfigurer#addFormatters  */ ;/**  * Register formatters and converters to use for type conversion.  * @see WebFluxConfigurer#addFormatters  */ ControllerSpec formatters(Consumer<FormatterRegistry> consumer).
true;;1;1;/**  * Configure a global Validator.  * @see WebFluxConfigurer#getValidator()  */ ;/**  * Configure a global Validator.  * @see WebFluxConfigurer#getValidator()  */ ControllerSpec validator(Validator validator).
true;;1;1;/**  * Configure view resolution.  * @see WebFluxConfigurer#configureViewResolvers  */ ;/**  * Configure view resolution.  * @see WebFluxConfigurer#configureViewResolvers  */ ControllerSpec viewResolvers(Consumer<ViewResolverRegistry> consumer).
true;;1;1;/**  * Configure handler strategies.  */ ;/**  * Configure handler strategies.  */ RouterFunctionSpec handlerStrategies(HandlerStrategies handlerStrategies).
true;;1;1;/**  * Configure a base URI as described in  * {@link org.springframework.web.reactive.function.client.WebClient#create(String)  * WebClient.create(String)}.  */ ;/**  * Configure a base URI as described in  * {@link org.springframework.web.reactive.function.client.WebClient#create(String)  * WebClient.create(String)}.  */ Builder baseUrl(String baseUrl).
true;;1;1;/**  * Provide a pre-configured {@link UriBuilderFactory} instance as an  * alternative to and effectively overriding {@link #baseUrl(String)}.  */ ;/**  * Provide a pre-configured {@link UriBuilderFactory} instance as an  * alternative to and effectively overriding {@link #baseUrl(String)}.  */ Builder uriBuilderFactory(UriBuilderFactory uriBuilderFactory).
true;;2;1;/**  * Add the given header to all requests that haven't added it.  * @param headerName the header name  * @param headerValues the header values  */ ;/**  * Add the given header to all requests that haven't added it.  * @param headerName the header name  * @param headerValues the header values  */ Builder defaultHeader(String headerName, String... headerValues).
true;;1;1;/**  * Manipulate the default headers with the given consumer. The  * headers provided to the consumer are "live", so that the consumer can be used to  * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,  * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other  * {@link HttpHeaders} methods.  * @param headersConsumer a function that consumes the {@code HttpHeaders}  * @return this builder  */ ;/**  * Manipulate the default headers with the given consumer. The  * headers provided to the consumer are "live", so that the consumer can be used to  * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,  * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other  * {@link HttpHeaders} methods.  * @param headersConsumer a function that consumes the {@code HttpHeaders}  * @return this builder  */ Builder defaultHeaders(Consumer<HttpHeaders> headersConsumer).
true;;2;1;/**  * Add the given header to all requests that haven't added it.  * @param cookieName the cookie name  * @param cookieValues the cookie values  */ ;/**  * Add the given header to all requests that haven't added it.  * @param cookieName the cookie name  * @param cookieValues the cookie values  */ Builder defaultCookie(String cookieName, String... cookieValues).
true;;1;1;/**  * Manipulate the default cookies with the given consumer. The  * map provided to the consumer is "live", so that the consumer can be used to  * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,  * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other  * {@link MultiValueMap} methods.  * @param cookiesConsumer a function that consumes the cookies map  * @return this builder  */ ;/**  * Manipulate the default cookies with the given consumer. The  * map provided to the consumer is "live", so that the consumer can be used to  * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,  * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other  * {@link MultiValueMap} methods.  * @param cookiesConsumer a function that consumes the cookies map  * @return this builder  */ Builder defaultCookies(Consumer<MultiValueMap<String, String>> cookiesConsumer).
true;;1;1;/**  * Add the given filter to the filter chain.  * @param filter the filter to be added to the chain  */ ;/**  * Add the given filter to the filter chain.  * @param filter the filter to be added to the chain  */ Builder filter(ExchangeFilterFunction filter).
true;;1;1;/**  * Manipulate the filters with the given consumer. The  * list provided to the consumer is "live", so that the consumer can be used to remove  * filters, change ordering, etc.  * @param filtersConsumer a function that consumes the filter list  * @return this builder  */ ;/**  * Manipulate the filters with the given consumer. The  * list provided to the consumer is "live", so that the consumer can be used to remove  * filters, change ordering, etc.  * @param filtersConsumer a function that consumes the filter list  * @return this builder  */ Builder filters(Consumer<List<ExchangeFilterFunction>> filtersConsumer).
true;;1;1;/**  * Configure the {@link ExchangeStrategies} to use.  * <p>By default {@link ExchangeStrategies#withDefaults()} is used.  * @param strategies the strategies to use  */ ;/**  * Configure the {@link ExchangeStrategies} to use.  * <p>By default {@link ExchangeStrategies#withDefaults()} is used.  * @param strategies the strategies to use  */ Builder exchangeStrategies(ExchangeStrategies strategies).
true;;1;1;/**  * Max amount of time to wait for responses.  * <p>By default 5 seconds.  * @param timeout the response timeout value  */ ;/**  * Max amount of time to wait for responses.  * <p>By default 5 seconds.  * @param timeout the response timeout value  */ Builder responseTimeout(Duration timeout).
true;;1;1;/**  * Apply the given configurer to this builder instance.  * <p>This can be useful for applying pre-packaged customizations.  * @param configurer the configurer to apply  */ ;/**  * Apply the given configurer to this builder instance.  * <p>This can be useful for applying pre-packaged customizations.  * @param configurer the configurer to apply  */ Builder apply(WebTestClientConfigurer configurer).
true;;0;1;/**  * Build the {@link WebTestClient} instance.  */ ;/**  * Build the {@link WebTestClient} instance.  */ WebTestClient build().
true;;1;1;/**  * Specify the URI using an absolute, fully constructed {@link URI}.  * @return spec to add headers or perform the exchange  */ ;/**  * Specify the URI using an absolute, fully constructed {@link URI}.  * @return spec to add headers or perform the exchange  */ S uri(URI uri).
true;;2;1;/**  * Specify the URI for the request using a URI template and URI variables.  * If a {@link UriBuilderFactory} was configured for the client (e.g.  * with a base URI) it will be used to expand the URI template.  * @return spec to add headers or perform the exchange  */ ;/**  * Specify the URI for the request using a URI template and URI variables.  * If a {@link UriBuilderFactory} was configured for the client (e.g.  * with a base URI) it will be used to expand the URI template.  * @return spec to add headers or perform the exchange  */ S uri(String uri, Object... uriVariables).
true;;2;1;/**  * Specify the URI for the request using a URI template and URI variables.  * If a {@link UriBuilderFactory} was configured for the client (e.g.  * with a base URI) it will be used to expand the URI template.  * @return spec to add headers or perform the exchange  */ ;/**  * Specify the URI for the request using a URI template and URI variables.  * If a {@link UriBuilderFactory} was configured for the client (e.g.  * with a base URI) it will be used to expand the URI template.  * @return spec to add headers or perform the exchange  */ S uri(String uri, Map<String, ?> uriVariables).
true;;1;1;/**  * Build the URI for the request with a {@link UriBuilder} obtained  * through the {@link UriBuilderFactory} configured for this client.  * @return spec to add headers or perform the exchange  */ ;/**  * Build the URI for the request with a {@link UriBuilder} obtained  * through the {@link UriBuilderFactory} configured for this client.  * @return spec to add headers or perform the exchange  */ S uri(Function<UriBuilder, URI> uriFunction).
true;;1;1;/**  * Set the list of acceptable {@linkplain MediaType media types}, as  * specified by the {@code Accept} header.  * @param acceptableMediaTypes the acceptable media types  * @return the same instance  */ ;/**  * Set the list of acceptable {@linkplain MediaType media types}, as  * specified by the {@code Accept} header.  * @param acceptableMediaTypes the acceptable media types  * @return the same instance  */ S accept(MediaType... acceptableMediaTypes).
true;;1;1;/**  * Set the list of acceptable {@linkplain Charset charsets}, as specified  * by the {@code Accept-Charset} header.  * @param acceptableCharsets the acceptable charsets  * @return the same instance  */ ;/**  * Set the list of acceptable {@linkplain Charset charsets}, as specified  * by the {@code Accept-Charset} header.  * @param acceptableCharsets the acceptable charsets  * @return the same instance  */ S acceptCharset(Charset... acceptableCharsets).
true;;2;1;/**  * Add a cookie with the given name and value.  * @param name the cookie name  * @param value the cookie value  * @return the same instance  */ ;/**  * Add a cookie with the given name and value.  * @param name the cookie name  * @param value the cookie value  * @return the same instance  */ S cookie(String name, String value).
true;;1;1;/**  * Manipulate this request's cookies with the given consumer. The  * map provided to the consumer is "live", so that the consumer can be used to  * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,  * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other  * {@link MultiValueMap} methods.  * @param cookiesConsumer a function that consumes the cookies map  * @return this builder  */ ;/**  * Manipulate this request's cookies with the given consumer. The  * map provided to the consumer is "live", so that the consumer can be used to  * {@linkplain MultiValueMap#set(Object, Object) overwrite} existing header values,  * {@linkplain MultiValueMap#remove(Object) remove} values, or use any of the other  * {@link MultiValueMap} methods.  * @param cookiesConsumer a function that consumes the cookies map  * @return this builder  */ S cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer).
true;;1;1;/**  * Set the value of the {@code If-Modified-Since} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  * @param ifModifiedSince the new value of the header  * @return the same instance  */ ;/**  * Set the value of the {@code If-Modified-Since} header.  * <p>The date should be specified as the number of milliseconds since  * January 1, 1970 GMT.  * @param ifModifiedSince the new value of the header  * @return the same instance  */ S ifModifiedSince(ZonedDateTime ifModifiedSince).
true;;1;1;/**  * Set the values of the {@code If-None-Match} header.  * @param ifNoneMatches the new value of the header  * @return the same instance  */ ;/**  * Set the values of the {@code If-None-Match} header.  * @param ifNoneMatches the new value of the header  * @return the same instance  */ S ifNoneMatch(String... ifNoneMatches).
true;;2;1;/**  * Add the given, single header value under the given name.  * @param headerName  the header name  * @param headerValues the header value(s)  * @return the same instance  */ ;/**  * Add the given, single header value under the given name.  * @param headerName  the header name  * @param headerValues the header value(s)  * @return the same instance  */ S header(String headerName, String... headerValues).
true;;1;1;/**  * Manipulate the request's headers with the given consumer. The  * headers provided to the consumer are "live", so that the consumer can be used to  * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,  * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other  * {@link HttpHeaders} methods.  * @param headersConsumer a function that consumes the {@code HttpHeaders}  * @return this builder  */ ;/**  * Manipulate the request's headers with the given consumer. The  * headers provided to the consumer are "live", so that the consumer can be used to  * {@linkplain HttpHeaders#set(String, String) overwrite} existing header values,  * {@linkplain HttpHeaders#remove(Object) remove} values, or use any of the other  * {@link HttpHeaders} methods.  * @param headersConsumer a function that consumes the {@code HttpHeaders}  * @return this builder  */ S headers(Consumer<HttpHeaders> headersConsumer).
true;;2;1;/**  * Set the attribute with the given name to the given value.  * @param name the name of the attribute to add  * @param value the value of the attribute to add  * @return this builder  */ ;/**  * Set the attribute with the given name to the given value.  * @param name the name of the attribute to add  * @param value the value of the attribute to add  * @return this builder  */ S attribute(String name, Object value).
true;;1;1;/**  * Manipulate the request attributes with the given consumer. The attributes provided to  * the consumer are "live", so that the consumer can be used to inspect attributes,  * remove attributes, or use any of the other map-provided methods.  * @param attributesConsumer a function that consumes the attributes  * @return this builder  */ ;/**  * Manipulate the request attributes with the given consumer. The attributes provided to  * the consumer are "live", so that the consumer can be used to inspect attributes,  * remove attributes, or use any of the other map-provided methods.  * @param attributesConsumer a function that consumes the attributes  * @return this builder  */ S attributes(Consumer<Map<String, Object>> attributesConsumer).
true;;0;1;/**  * Perform the exchange without a request body.  * @return spec for decoding the response  */ ;/**  * Perform the exchange without a request body.  * @return spec for decoding the response  */ ResponseSpec exchange().
true;;1;1;/**  * Set the length of the body in bytes, as specified by the  * {@code Content-Length} header.  * @param contentLength the content length  * @return the same instance  * @see HttpHeaders#setContentLength(long)  */ ;/**  * Set the length of the body in bytes, as specified by the  * {@code Content-Length} header.  * @param contentLength the content length  * @return the same instance  * @see HttpHeaders#setContentLength(long)  */ RequestBodySpec contentLength(long contentLength).
true;;1;1;/**  * Set the {@linkplain MediaType media type} of the body, as specified  * by the {@code Content-Type} header.  * @param contentType the content type  * @return the same instance  * @see HttpHeaders#setContentType(MediaType)  */ ;/**  * Set the {@linkplain MediaType media type} of the body, as specified  * by the {@code Content-Type} header.  * @param contentType the content type  * @return the same instance  * @see HttpHeaders#setContentType(MediaType)  */ RequestBodySpec contentType(MediaType contentType).
true;;1;1;/**  * Set the body of the request to the given {@code BodyInserter}.  * @param inserter the inserter  * @return spec for decoding the response  * @see org.springframework.web.reactive.function.BodyInserters  */ ;/**  * Set the body of the request to the given {@code BodyInserter}.  * @param inserter the inserter  * @return spec for decoding the response  * @see org.springframework.web.reactive.function.BodyInserters  */ RequestHeadersSpec<?> body(BodyInserter<?, ? super ClientHttpRequest> inserter).
true;;2;1;/**  * Set the body of the request to the given asynchronous {@code Publisher}.  * @param publisher the request body data  * @param elementClass the class of elements contained in the publisher  * @param <T> the type of the elements contained in the publisher  * @param <S> the type of the {@code Publisher}  * @return spec for decoding the response  */ ;/**  * Set the body of the request to the given asynchronous {@code Publisher}.  * @param publisher the request body data  * @param elementClass the class of elements contained in the publisher  * @param <T> the type of the elements contained in the publisher  * @param <S> the type of the {@code Publisher}  * @return spec for decoding the response  */ <T, S extends Publisher<T>> RequestHeadersSpec<?> body(S publisher, Class<T> elementClass).
true;;1;1;/**  * Set the body of the request to the given synchronous {@code Object} and  * perform the request.  * <p>This method is a convenient shortcut for:  * <pre class="code">  * .body(BodyInserters.fromObject(object))  * </pre>  * <p>The body can be a  * {@link org.springframework.util.MultiValueMap MultiValueMap} to create  * a multipart request. The values in the {@code MultiValueMap} can be  * any Object representing the body of the part, or an  * {@link org.springframework.http.HttpEntity HttpEntity} representing a  * part with body and headers. The {@code MultiValueMap} can be built  * conveniently using  * @param body the {@code Object} to write to the request  * @return a {@code Mono} with the response  */ ;/**  * Set the body of the request to the given synchronous {@code Object} and  * perform the request.  * <p>This method is a convenient shortcut for:  * <pre class="code">  * .body(BodyInserters.fromObject(object))  * </pre>  * <p>The body can be a  * {@link org.springframework.util.MultiValueMap MultiValueMap} to create  * a multipart request. The values in the {@code MultiValueMap} can be  * any Object representing the body of the part, or an  * {@link org.springframework.http.HttpEntity HttpEntity} representing a  * part with body and headers. The {@code MultiValueMap} can be built  * conveniently using  * @param body the {@code Object} to write to the request  * @return a {@code Mono} with the response  */ RequestHeadersSpec<?> syncBody(Object body).
true;;0;1;/**  * Assertions on the response status.  */ ;/**  * Assertions on the response status.  */ StatusAssertions expectStatus().
true;;0;1;/**  * Assertions on the headers of the response.  */ ;/**  * Assertions on the headers of the response.  */ HeaderAssertions expectHeader().
true;;1;1;/**  * Consume and decode the response body to a single object of type  * {@code <B>} and then apply assertions.  * @param bodyType the expected body type  */ ;/**  * Consume and decode the response body to a single object of type  * {@code <B>} and then apply assertions.  * @param bodyType the expected body type  */ <B> BodySpec<B, ?> expectBody(Class<B> bodyType).
true;;1;1;/**  * Alternative to {@link #expectBody(Class)} that accepts information  * about a target type with generics.  */ ;/**  * Alternative to {@link #expectBody(Class)} that accepts information  * about a target type with generics.  */ <B> BodySpec<B, ?> expectBody(ParameterizedTypeReference<B> bodyType).
true;;1;1;/**  * Consume and decode the response body to {@code List<E>} and then apply  * List-specific assertions.  * @param elementType the expected List element type  */ ;/**  * Consume and decode the response body to {@code List<E>} and then apply  * List-specific assertions.  * @param elementType the expected List element type  */ <E> ListBodySpec<E> expectBodyList(Class<E> elementType).
true;;1;1;/**  * Alternative to {@link #expectBodyList(Class)} that accepts information  * about a target type with generics.  */ ;/**  * Alternative to {@link #expectBodyList(Class)} that accepts information  * about a target type with generics.  */ <E> ListBodySpec<E> expectBodyList(ParameterizedTypeReference<E> elementType).
true;;0;1;/**  * Consume and decode the response body to {@code byte[]} and then apply  * assertions on the raw content (e.g. isEmpty, JSONPath, etc.)  */ ;/**  * Consume and decode the response body to {@code byte[]} and then apply  * assertions on the raw content (e.g. isEmpty, JSONPath, etc.)  */ BodyContentSpec expectBody().
true;;1;1;/**  * Exit the chained API and consume the response body externally. This  * is useful for testing infinite streams (e.g. SSE) where you need to  * to assert decoded objects as they come and then cancel at some point  * when test objectives are met. Consider using {@code StepVerifier}  * from {@literal "reactor-test"} to assert the {@code Flux<T>} stream  * of decoded objects.  *  * <p><strong>Note:</strong> Do not use this option for cases where there  * is no content (e.g. 204, 4xx) or you're not interested in the content.  * For such cases you can use {@code expectBody().isEmpty()} or  * {@code expectBody(Void.class)} which ensures that resources are  * released regardless of whether the response has content or not.  */ ;/**  * Exit the chained API and consume the response body externally. This  * is useful for testing infinite streams (e.g. SSE) where you need to  * to assert decoded objects as they come and then cancel at some point  * when test objectives are met. Consider using {@code StepVerifier}  * from {@literal "reactor-test"} to assert the {@code Flux<T>} stream  * of decoded objects.  *  * <p><strong>Note:</strong> Do not use this option for cases where there  * is no content (e.g. 204, 4xx) or you're not interested in the content.  * For such cases you can use {@code expectBody().isEmpty()} or  * {@code expectBody(Void.class)} which ensures that resources are  * released regardless of whether the response has content or not.  */ <T> FluxExchangeResult<T> returnResult(Class<T> elementType).
true;;1;1;/**  * Alternative to {@link #returnResult(Class)} that accepts information  * about a target type with generics.  */ ;/**  * Alternative to {@link #returnResult(Class)} that accepts information  * about a target type with generics.  */ <T> FluxExchangeResult<T> returnResult(ParameterizedTypeReference<T> elementType).
true;;1;1;/**  * Assert the extracted body is equal to the given value.  */ ;/**  * Assert the extracted body is equal to the given value.  */ <T extends S> T isEqualTo(B expected).
true;;1;1;/**  * Assert the extracted body with a {@link Matcher}.  * @since 5.1  */ ;/**  * Assert the extracted body with a {@link Matcher}.  * @since 5.1  */ <T extends S> T value(Matcher<B> matcher).
true;;2;1;/**  * Transform the extracted the body with a function, e.g. extracting a  * property, and assert the mapped value with a {@link Matcher}.  * @since 5.1  */ ;/**  * Transform the extracted the body with a function, e.g. extracting a  * property, and assert the mapped value with a {@link Matcher}.  * @since 5.1  */ <T extends S, R> T value(Function<B, R> bodyMapper, Matcher<R> matcher).
true;;1;1;/**  * Assert the extracted body with a {@link Matcher}.  * @since 5.1  */ ;/**  * Assert the extracted body with a {@link Matcher}.  * @since 5.1  */ <T extends S> T value(Consumer<B> consumer).
true;;1;1;/**  * Assert the exchange result with the given {@link Consumer}.  */ ;/**  * Assert the exchange result with the given {@link Consumer}.  */ <T extends S> T consumeWith(Consumer<EntityExchangeResult<B>> consumer).
true;;0;1;/**  * Exit the chained API and return an {@code ExchangeResult} with the  * decoded response content.  */ ;/**  * Exit the chained API and return an {@code ExchangeResult} with the  * decoded response content.  */ EntityExchangeResult<B> returnResult().
true;;1;1;/**  * Assert the extracted list of values is of the given size.  * @param size the expected size  */ ;/**  * Assert the extracted list of values is of the given size.  * @param size the expected size  */ ListBodySpec<E> hasSize(int size).
true;;1;2;/**  * Assert the extracted list of values contains the given elements.  * @param elements the elements to check  */ ;/**  * Assert the extracted list of values contains the given elements.  * @param elements the elements to check  */ @SuppressWarnings("unchecked") ListBodySpec<E> contains(E... elements).
true;;1;2;/**  * Assert the extracted list of values doesn't contain the given elements.  * @param elements the elements to check  */ ;/**  * Assert the extracted list of values doesn't contain the given elements.  * @param elements the elements to check  */ @SuppressWarnings("unchecked") ListBodySpec<E> doesNotContain(E... elements).
true;;0;1;/**  * Assert the response body is empty and return the exchange result.  */ ;/**  * Assert the response body is empty and return the exchange result.  */ EntityExchangeResult<Void> isEmpty().
true;;1;1;/**  * Parse the expected and actual response content as JSON and perform a  * "lenient" comparison verifying the same attribute-value pairs.  * <p>Use of this option requires the  * <a href="http://jsonassert.skyscreamer.org/">JSONassert</a> library  * on to be on the classpath.  * @param expectedJson the expected JSON content.  */ ;/**  * Parse the expected and actual response content as JSON and perform a  * "lenient" comparison verifying the same attribute-value pairs.  * <p>Use of this option requires the  * <a href="http://jsonassert.skyscreamer.org/">JSONassert</a> library  * on to be on the classpath.  * @param expectedJson the expected JSON content.  */ BodyContentSpec json(String expectedJson).
true;;1;1;/**  * Parse expected and actual response content as XML and assert that  * the two are "similar", i.e. they contain the same elements and  * attributes regardless of order.  * <p>Use of this method requires the  * <a href="https://github.com/xmlunit/xmlunit">XMLUnit</a> library on  * the classpath.  * @param expectedXml the expected JSON content.  * @since 5.1  * @see org.springframework.test.util.XmlExpectationsHelper#assertXmlEqual(String, String)  */ ;/**  * Parse expected and actual response content as XML and assert that  * the two are "similar", i.e. they contain the same elements and  * attributes regardless of order.  * <p>Use of this method requires the  * <a href="https://github.com/xmlunit/xmlunit">XMLUnit</a> library on  * the classpath.  * @param expectedXml the expected JSON content.  * @since 5.1  * @see org.springframework.test.util.XmlExpectationsHelper#assertXmlEqual(String, String)  */ BodyContentSpec xml(String expectedXml).
true;;2;1;/**  * Access to response body assertions using a  * <a href="https://github.com/jayway/JsonPath">JsonPath</a> expression  * to inspect a specific subset of the body.  * <p>The JSON path expression can be a parameterized string using  * formatting specifiers as defined in {@link String#format}.  * @param expression the JsonPath expression  * @param args arguments to parameterize the expression  */ ;/**  * Access to response body assertions using a  * <a href="https://github.com/jayway/JsonPath">JsonPath</a> expression  * to inspect a specific subset of the body.  * <p>The JSON path expression can be a parameterized string using  * formatting specifiers as defined in {@link String#format}.  * @param expression the JsonPath expression  * @param args arguments to parameterize the expression  */ JsonPathAssertions jsonPath(String expression, Object... args).
true;default;2;3;/**  * Access to response body assertions using an XPath expression to  * inspect a specific subset of the body.  * <p>The XPath expression can be a parameterized string using  * formatting specifiers as defined in {@link String#format}.  * @param expression the XPath expression  * @param args arguments to parameterize the expression  * @since 5.1  * @see #xpath(String, Map, Object...)  */ ;/**  * Access to response body assertions using an XPath expression to  * inspect a specific subset of the body.  * <p>The XPath expression can be a parameterized string using  * formatting specifiers as defined in {@link String#format}.  * @param expression the XPath expression  * @param args arguments to parameterize the expression  * @since 5.1  * @see #xpath(String, Map, Object...)  */ default XpathAssertions xpath(String expression, Object... args) {     return xpath(expression, null, args). }
true;;3;1;/**  * Access to response body assertions with specific namespaces using an  * XPath expression to inspect a specific subset of the body.  * <p>The XPath expression can be a parameterized string using  * formatting specifiers as defined in {@link String#format}.  * @param expression the XPath expression  * @param namespaces namespaces to use  * @param args arguments to parameterize the expression  * @since 5.1  */ ;/**  * Access to response body assertions with specific namespaces using an  * XPath expression to inspect a specific subset of the body.  * <p>The XPath expression can be a parameterized string using  * formatting specifiers as defined in {@link String#format}.  * @param expression the XPath expression  * @param namespaces namespaces to use  * @param args arguments to parameterize the expression  * @since 5.1  */ XpathAssertions xpath(String expression, @Nullable Map<String, String> namespaces, Object... args).
true;;1;1;/**  * Assert the response body content with the given {@link Consumer}.  * @param consumer the consumer for the response body. the input  * {@code byte[]} may be {@code null} if there was no response body.  */ ;/**  * Assert the response body content with the given {@link Consumer}.  * @param consumer the consumer for the response body. the input  * {@code byte[]} may be {@code null} if there was no response body.  */ BodyContentSpec consumeWith(Consumer<EntityExchangeResult<byte[]>> consumer).
true;;0;1;/**  * Exit the chained API and return an {@code ExchangeResult} with the  * raw response content.  */ ;/**  * Exit the chained API and return an {@code ExchangeResult} with the  * raw response content.  */ EntityExchangeResult<byte[]> returnResult().
