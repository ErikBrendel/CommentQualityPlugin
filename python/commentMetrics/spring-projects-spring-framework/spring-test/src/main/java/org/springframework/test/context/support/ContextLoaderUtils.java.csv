# id;timestamp;commentText;codeText;commentWords;codeWords
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1397082962;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_				contextConfiguration, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass,_			contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1397084183;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_				contextConfiguration, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass,_			contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1398153432;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_				contextConfiguration, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass,_			contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1413848647;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_				contextConfiguration, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass,_			contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1432856630;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_				contextConfiguration, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass,_			contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1434234880;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_				contextConfiguration, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass,_			contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1449505825;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_					contextConfiguration, declaringClass.getName()))__		}_		ContextConfigurationAttributes attributes =_				new ContextConfigurationAttributes(declaringClass, contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1458754760;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_					contextConfiguration, declaringClass.getName()))__		}_		ContextConfigurationAttributes attributes =_				new ContextConfigurationAttributes(declaringClass, contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1459174667;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_					contextConfiguration, declaringClass.getName()))__		}_		ContextConfigurationAttributes attributes =_				new ContextConfigurationAttributes(declaringClass, contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1467730834;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_					contextConfiguration, declaringClass.getName()))__		}_		ContextConfigurationAttributes attributes =_				new ContextConfigurationAttributes(declaringClass, contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1468334463;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_					contextConfiguration, declaringClass.getName()))__		}_		ContextConfigurationAttributes attributes =_				new ContextConfigurationAttributes(declaringClass, contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1496955179;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_					contextConfiguration, declaringClass.getName()))__		}_		ContextConfigurationAttributes attributes =_				new ContextConfigurationAttributes(declaringClass, contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1530174524;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link ContextConfiguration} annotation and_declaring class and then adding the attributes to the supplied list.;private static void convertContextConfigToConfigAttributesAndAddToList(ContextConfiguration contextConfiguration,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {__		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration [%s] for declaring class [%s].",_					contextConfiguration, declaringClass.getName()))__		}_		ContextConfigurationAttributes attributes =_				new ContextConfigurationAttributes(declaringClass, contextConfiguration)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,context,configuration,annotation,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list;private,static,void,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,context,configuration,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,s,for,declaring,class,s,context,configuration,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,context,configuration,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1397082962;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method.__@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_ or if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@throws IllegalStateException if no class in the class hierarchy declares_{@code @ContextHierarchy}.__@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")__		Assert.state(findAnnotation(testClass, ContextHierarchy.class) != null, "@ContextHierarchy must be present")___		final Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		final Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		final List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>()___		UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(testClass, contextConfigType,_			contextHierarchyType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_			contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))___		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration "_						+ "and @ContextHierarchy. Only one of these annotations may be declared on a test class "_						+ "or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			final List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>()___			if (contextConfigDeclaredLocally) {_				convertAnnotationAttributesToConfigAttributesAndAddToList(descriptor.getAnnotationAttributes(),_					rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, rootDeclaringClass,_						configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration "_						+ "nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)___			descriptor = findAnnotationDescriptorForTypes(rootDeclaringClass.getSuperclass(), contextConfigType,_				contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,or,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,throws,illegal,state,exception,if,no,class,in,the,class,hierarchy,declares,code,context,hierarchy,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,assert,state,find,annotation,test,class,context,hierarchy,class,null,context,hierarchy,must,be,present,final,class,context,configuration,context,config,type,context,configuration,class,final,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,final,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,list,context,configuration,attributes,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,final,list,context,configuration,attributes,config,attributes,list,new,array,list,context,configuration,attributes,if,context,config,declared,locally,convert,annotation,attributes,to,config,attributes,and,add,to,list,descriptor,get,annotation,attributes,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,descriptor,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1397084183;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method.__@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_ or if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@throws IllegalStateException if no class in the class hierarchy declares_{@code @ContextHierarchy}.__@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")__		Assert.state(findAnnotation(testClass, ContextHierarchy.class) != null, "@ContextHierarchy must be present")___		final Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		final Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		final List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>()___		UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(testClass, contextConfigType,_			contextHierarchyType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_			contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))___		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration "_						+ "and @ContextHierarchy. Only one of these annotations may be declared on a test class "_						+ "or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			final List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>()___			if (contextConfigDeclaredLocally) {_				convertAnnotationAttributesToConfigAttributesAndAddToList(descriptor.getAnnotationAttributes(),_					rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, rootDeclaringClass,_						configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration "_						+ "nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)___			descriptor = findAnnotationDescriptorForTypes(rootDeclaringClass.getSuperclass(), contextConfigType,_				contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,or,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,throws,illegal,state,exception,if,no,class,in,the,class,hierarchy,declares,code,context,hierarchy,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,assert,state,find,annotation,test,class,context,hierarchy,class,null,context,hierarchy,must,be,present,final,class,context,configuration,context,config,type,context,configuration,class,final,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,final,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,list,context,configuration,attributes,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,final,list,context,configuration,attributes,config,attributes,list,new,array,list,context,configuration,attributes,if,context,config,declared,locally,convert,annotation,attributes,to,config,attributes,and,add,to,list,descriptor,get,annotation,attributes,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,descriptor,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1398153432;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method.__@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_ or if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@throws IllegalStateException if no class in the class hierarchy declares_{@code @ContextHierarchy}.__@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")__		Assert.state(findAnnotation(testClass, ContextHierarchy.class) != null, "@ContextHierarchy must be present")___		final Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		final Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		final List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>()___		UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(testClass, contextConfigType,_			contextHierarchyType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_			contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))___		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration "_						+ "and @ContextHierarchy. Only one of these annotations may be declared on a test class "_						+ "or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			final List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>()___			if (contextConfigDeclaredLocally) {_				convertAnnotationAttributesToConfigAttributesAndAddToList(descriptor.getAnnotationAttributes(),_					rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, rootDeclaringClass,_						configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration "_						+ "nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)___			descriptor = findAnnotationDescriptorForTypes(rootDeclaringClass.getSuperclass(), contextConfigType,_				contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,or,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,throws,illegal,state,exception,if,no,class,in,the,class,hierarchy,declares,code,context,hierarchy,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,assert,state,find,annotation,test,class,context,hierarchy,class,null,context,hierarchy,must,be,present,final,class,context,configuration,context,config,type,context,configuration,class,final,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,final,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,list,context,configuration,attributes,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,final,list,context,configuration,attributes,config,attributes,list,new,array,list,context,configuration,attributes,if,context,config,declared,locally,convert,annotation,attributes,to,config,attributes,and,add,to,list,descriptor,get,annotation,attributes,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,descriptor,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1413848647;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method.__@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_ or if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@throws IllegalStateException if no class in the class hierarchy declares_{@code @ContextHierarchy}.__@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")__		Assert.state(findAnnotation(testClass, ContextHierarchy.class) != null, "@ContextHierarchy must be present")___		final Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		final Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		final List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>()___		UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(testClass, contextConfigType,_			contextHierarchyType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_			contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))___		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration "_						+ "and @ContextHierarchy. Only one of these annotations may be declared on a test class "_						+ "or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			final List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>()___			if (contextConfigDeclaredLocally) {_				convertAnnotationAttributesToConfigAttributesAndAddToList(descriptor.getAnnotationAttributes(),_					rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, rootDeclaringClass,_						configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration "_						+ "nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)___			descriptor = findAnnotationDescriptorForTypes(rootDeclaringClass.getSuperclass(), contextConfigType,_				contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,or,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,throws,illegal,state,exception,if,no,class,in,the,class,hierarchy,declares,code,context,hierarchy,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,assert,state,find,annotation,test,class,context,hierarchy,class,null,context,hierarchy,must,be,present,final,class,context,configuration,context,config,type,context,configuration,class,final,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,final,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,list,context,configuration,attributes,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,final,list,context,configuration,attributes,config,attributes,list,new,array,list,context,configuration,attributes,if,context,config,declared,locally,convert,annotation,attributes,to,config,attributes,and,add,to,list,descriptor,get,annotation,attributes,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,descriptor,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1432856630;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method.__@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_ or if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@throws IllegalStateException if no class in the class hierarchy declares_{@code @ContextHierarchy}.__@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")__		Assert.state(findAnnotation(testClass, ContextHierarchy.class) != null, "@ContextHierarchy must be present")___		final Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		final Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		final List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>()___		UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(testClass, contextConfigType,_			contextHierarchyType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_			contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))___		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration "_						+ "and @ContextHierarchy. Only one of these annotations may be declared on a test class "_						+ "or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			final List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>()___			if (contextConfigDeclaredLocally) {_				convertContextConfigToConfigAttributesAndAddToList(_					(ContextConfiguration) descriptor.getMergedAnnotation(), rootDeclaringClass,_					configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, rootDeclaringClass,_						configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration "_						+ "nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)___			descriptor = findAnnotationDescriptorForTypes(rootDeclaringClass.getSuperclass(), contextConfigType,_				contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,or,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,throws,illegal,state,exception,if,no,class,in,the,class,hierarchy,declares,code,context,hierarchy,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,assert,state,find,annotation,test,class,context,hierarchy,class,null,context,hierarchy,must,be,present,final,class,context,configuration,context,config,type,context,configuration,class,final,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,final,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,list,context,configuration,attributes,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,final,list,context,configuration,attributes,config,attributes,list,new,array,list,context,configuration,attributes,if,context,config,declared,locally,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,descriptor,get,merged,annotation,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,descriptor,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1434234880;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method.__@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_ or if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@throws IllegalStateException if no class in the class hierarchy declares_{@code @ContextHierarchy}.__@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")__		Assert.state(findAnnotation(testClass, ContextHierarchy.class) != null, "@ContextHierarchy must be present")___		final Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		final Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		final List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>()___		UntypedAnnotationDescriptor descriptor = findAnnotationDescriptorForTypes(testClass, contextConfigType,_			contextHierarchyType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_			contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))___		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration "_						+ "and @ContextHierarchy. Only one of these annotations may be declared on a test class "_						+ "or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			final List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>()___			if (contextConfigDeclaredLocally) {_				ContextConfiguration contextConfiguration = AnnotationUtils.synthesizeAnnotation(_					descriptor.getAnnotationAttributes(), ContextConfiguration.class,_					descriptor.getRootDeclaringClass())__				convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, rootDeclaringClass,_					configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(contextConfiguration, rootDeclaringClass,_						configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration "_						+ "nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)___			descriptor = findAnnotationDescriptorForTypes(rootDeclaringClass.getSuperclass(), contextConfigType,_				contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,or,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,throws,illegal,state,exception,if,no,class,in,the,class,hierarchy,declares,code,context,hierarchy,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,assert,state,find,annotation,test,class,context,hierarchy,class,null,context,hierarchy,must,be,present,final,class,context,configuration,context,config,type,context,configuration,class,final,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,final,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,list,context,configuration,attributes,untyped,annotation,descriptor,descriptor,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,final,list,context,configuration,attributes,config,attributes,list,new,array,list,context,configuration,attributes,if,context,config,declared,locally,context,configuration,context,configuration,annotation,utils,synthesize,annotation,descriptor,get,annotation,attributes,context,configuration,class,descriptor,get,root,declaring,class,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,descriptor,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1449505825;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method._@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_ or if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@throws IllegalStateException if no class in the class hierarchy declares_{@code @ContextHierarchy}._@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")__		Assert.state(findAnnotation(testClass, ContextHierarchy.class) != null, "@ContextHierarchy must be present")___		final Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		final Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		final List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>()___		UntypedAnnotationDescriptor desc =_				findAnnotationDescriptorForTypes(testClass, contextConfigType, contextHierarchyType)__		if (desc == null) {_			throw new IllegalArgumentException(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_					contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))__		}__		while (desc != null) {_			Class<?> rootDeclaringClass = desc.getRootDeclaringClass()__			Class<?> declaringClass = desc.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration " +_						"and @ContextHierarchy. Only one of these annotations may be declared on a test class " +_						"or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			final List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>()___			if (contextConfigDeclaredLocally) {_				ContextConfiguration contextConfiguration = AnnotationUtils.synthesizeAnnotation(_						desc.getAnnotationAttributes(), ContextConfiguration.class, desc.getRootDeclaringClass())__				convertContextConfigToConfigAttributesAndAddToList(_						contextConfiguration, rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(_							contextConfiguration, rootDeclaringClass, configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration " +_						"nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)__			desc = findAnnotationDescriptorForTypes(_					rootDeclaringClass.getSuperclass(), contextConfigType, contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,or,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,throws,illegal,state,exception,if,no,class,in,the,class,hierarchy,declares,code,context,hierarchy,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,assert,state,find,annotation,test,class,context,hierarchy,class,null,context,hierarchy,must,be,present,final,class,context,configuration,context,config,type,context,configuration,class,final,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,final,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,list,context,configuration,attributes,untyped,annotation,descriptor,desc,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,if,desc,null,throw,new,illegal,argument,exception,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,desc,null,class,root,declaring,class,desc,get,root,declaring,class,class,declaring,class,desc,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,final,list,context,configuration,attributes,config,attributes,list,new,array,list,context,configuration,attributes,if,context,config,declared,locally,context,configuration,context,configuration,annotation,utils,synthesize,annotation,desc,get,annotation,attributes,context,configuration,class,desc,get,root,declaring,class,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,desc,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1458754760;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method._@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_ or if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@throws IllegalStateException if no class in the class hierarchy declares_{@code @ContextHierarchy}._@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>()___		UntypedAnnotationDescriptor desc =_				findAnnotationDescriptorForTypes(testClass, contextConfigType, contextHierarchyType)__		if (desc == null) {_			throw new IllegalArgumentException(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_					contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))__		}__		while (desc != null) {_			Class<?> rootDeclaringClass = desc.getRootDeclaringClass()__			Class<?> declaringClass = desc.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration " +_						"and @ContextHierarchy. Only one of these annotations may be declared on a test class " +_						"or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>()___			if (contextConfigDeclaredLocally) {_				ContextConfiguration contextConfiguration = AnnotationUtils.synthesizeAnnotation(_						desc.getAnnotationAttributes(), ContextConfiguration.class, desc.getRootDeclaringClass())__				convertContextConfigToConfigAttributesAndAddToList(_						contextConfiguration, rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(_							contextConfiguration, rootDeclaringClass, configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration " +_						"nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)__			desc = findAnnotationDescriptorForTypes(_					rootDeclaringClass.getSuperclass(), contextConfigType, contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,or,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,throws,illegal,state,exception,if,no,class,in,the,class,hierarchy,declares,code,context,hierarchy,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,class,context,configuration,context,config,type,context,configuration,class,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,list,context,configuration,attributes,untyped,annotation,descriptor,desc,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,if,desc,null,throw,new,illegal,argument,exception,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,desc,null,class,root,declaring,class,desc,get,root,declaring,class,class,declaring,class,desc,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,list,context,configuration,attributes,config,attributes,list,new,array,list,context,configuration,attributes,if,context,config,declared,locally,context,configuration,context,configuration,annotation,utils,synthesize,annotation,desc,get,annotation,attributes,context,configuration,class,desc,get,root,declaring,class,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,desc,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1459174667;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method._@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ or if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_@throws IllegalStateException if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<List<ContextConfigurationAttributes>>()___		UntypedAnnotationDescriptor desc =_				findAnnotationDescriptorForTypes(testClass, contextConfigType, contextHierarchyType)__		if (desc == null) {_			throw new IllegalArgumentException(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_					contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))__		}__		while (desc != null) {_			Class<?> rootDeclaringClass = desc.getRootDeclaringClass()__			Class<?> declaringClass = desc.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration " +_						"and @ContextHierarchy. Only one of these annotations may be declared on a test class " +_						"or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			List<ContextConfigurationAttributes> configAttributesList = new ArrayList<ContextConfigurationAttributes>()___			if (contextConfigDeclaredLocally) {_				ContextConfiguration contextConfiguration = AnnotationUtils.synthesizeAnnotation(_						desc.getAnnotationAttributes(), ContextConfiguration.class, desc.getRootDeclaringClass())__				convertContextConfigToConfigAttributesAndAddToList(_						contextConfiguration, rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(_							contextConfiguration, rootDeclaringClass, configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration " +_						"nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)__			desc = findAnnotationDescriptorForTypes(_					rootDeclaringClass.getSuperclass(), contextConfigType, contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,throws,illegal,state,exception,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,class,context,configuration,context,config,type,context,configuration,class,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,list,context,configuration,attributes,untyped,annotation,descriptor,desc,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,if,desc,null,throw,new,illegal,argument,exception,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,desc,null,class,root,declaring,class,desc,get,root,declaring,class,class,declaring,class,desc,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,list,context,configuration,attributes,config,attributes,list,new,array,list,context,configuration,attributes,if,context,config,declared,locally,context,configuration,context,configuration,annotation,utils,synthesize,annotation,desc,get,annotation,attributes,context,configuration,class,desc,get,root,declaring,class,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,desc,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1467730834;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method._@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ or if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_@throws IllegalStateException if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<>()___		UntypedAnnotationDescriptor desc =_				findAnnotationDescriptorForTypes(testClass, contextConfigType, contextHierarchyType)__		if (desc == null) {_			throw new IllegalArgumentException(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_					contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))__		}__		while (desc != null) {_			Class<?> rootDeclaringClass = desc.getRootDeclaringClass()__			Class<?> declaringClass = desc.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration " +_						"and @ContextHierarchy. Only one of these annotations may be declared on a test class " +_						"or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			List<ContextConfigurationAttributes> configAttributesList = new ArrayList<>()___			if (contextConfigDeclaredLocally) {_				ContextConfiguration contextConfiguration = AnnotationUtils.synthesizeAnnotation(_						desc.getAnnotationAttributes(), ContextConfiguration.class, desc.getRootDeclaringClass())__				convertContextConfigToConfigAttributesAndAddToList(_						contextConfiguration, rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(_							contextConfiguration, rootDeclaringClass, configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration " +_						"nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)__			desc = findAnnotationDescriptorForTypes(_					rootDeclaringClass.getSuperclass(), contextConfigType, contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,throws,illegal,state,exception,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,class,context,configuration,context,config,type,context,configuration,class,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,untyped,annotation,descriptor,desc,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,if,desc,null,throw,new,illegal,argument,exception,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,desc,null,class,root,declaring,class,desc,get,root,declaring,class,class,declaring,class,desc,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,list,context,configuration,attributes,config,attributes,list,new,array,list,if,context,config,declared,locally,context,configuration,context,configuration,annotation,utils,synthesize,annotation,desc,get,annotation,attributes,context,configuration,class,desc,get,root,declaring,class,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,desc,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1468334463;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method._@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ or if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_@throws IllegalStateException if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<>()___		UntypedAnnotationDescriptor desc =_				findAnnotationDescriptorForTypes(testClass, contextConfigType, contextHierarchyType)__		Assert.notNull(desc, () -> String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_					contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))___		while (desc != null) {_			Class<?> rootDeclaringClass = desc.getRootDeclaringClass()__			Class<?> declaringClass = desc.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration " +_						"and @ContextHierarchy. Only one of these annotations may be declared on a test class " +_						"or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			List<ContextConfigurationAttributes> configAttributesList = new ArrayList<>()___			if (contextConfigDeclaredLocally) {_				ContextConfiguration contextConfiguration = AnnotationUtils.synthesizeAnnotation(_						desc.getAnnotationAttributes(), ContextConfiguration.class, desc.getRootDeclaringClass())__				convertContextConfigToConfigAttributesAndAddToList(_						contextConfiguration, rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_					convertContextConfigToConfigAttributesAndAddToList(_							contextConfiguration, rootDeclaringClass, configAttributesList)__				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration " +_						"nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)__			desc = findAnnotationDescriptorForTypes(_					rootDeclaringClass.getSuperclass(), contextConfigType, contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,throws,illegal,state,exception,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,class,context,configuration,context,config,type,context,configuration,class,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,untyped,annotation,descriptor,desc,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,assert,not,null,desc,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,desc,null,class,root,declaring,class,desc,get,root,declaring,class,class,declaring,class,desc,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,list,context,configuration,attributes,config,attributes,list,new,array,list,if,context,config,declared,locally,context,configuration,context,configuration,annotation,utils,synthesize,annotation,desc,get,annotation,attributes,context,configuration,class,desc,get,root,declaring,class,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,desc,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1496955179;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method._@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ or if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_@throws IllegalStateException if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<>()___		UntypedAnnotationDescriptor desc =_				findAnnotationDescriptorForTypes(testClass, contextConfigType, contextHierarchyType)__		Assert.notNull(desc, () -> String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_					contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))___		while (desc != null) {_			Class<?> rootDeclaringClass = desc.getRootDeclaringClass()__			Class<?> declaringClass = desc.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration " +_						"and @ContextHierarchy. Only one of these annotations may be declared on a test class " +_						"or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			List<ContextConfigurationAttributes> configAttributesList = new ArrayList<>()___			if (contextConfigDeclaredLocally) {_				ContextConfiguration contextConfiguration = AnnotationUtils.synthesizeAnnotation(_						desc.getAnnotationAttributes(), ContextConfiguration.class, desc.getRootDeclaringClass())__				convertContextConfigToConfigAttributesAndAddToList(_						contextConfiguration, rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				if (contextHierarchy != null) {_					for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_						convertContextConfigToConfigAttributesAndAddToList(_								contextConfiguration, rootDeclaringClass, configAttributesList)__					}_				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration " +_						"nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)__			desc = findAnnotationDescriptorForTypes(_					rootDeclaringClass.getSuperclass(), contextConfigType, contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,throws,illegal,state,exception,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,class,context,configuration,context,config,type,context,configuration,class,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,untyped,annotation,descriptor,desc,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,assert,not,null,desc,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,desc,null,class,root,declaring,class,desc,get,root,declaring,class,class,declaring,class,desc,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,list,context,configuration,attributes,config,attributes,list,new,array,list,if,context,config,declared,locally,context,configuration,context,configuration,annotation,utils,synthesize,annotation,desc,get,annotation,attributes,context,configuration,class,desc,get,root,declaring,class,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,if,context,hierarchy,null,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,desc,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> @SuppressWarnings("unchecked") 	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass);1530174524;Resolve the list of lists of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses, taking into account context hierarchies declared via_{@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>The outer list represents a top-down ordering of context configuration_attributes, where each element in the list represents the context configuration_declared on a given test class in the class hierarchy. Each nested list_contains the context configuration attributes declared either via a single_instance of {@code @ContextConfiguration} on the particular class or via_multiple instances of {@code @ContextConfiguration} declared within a_single {@code @ContextHierarchy} instance on the particular class._Furthermore, each nested list maintains the order in which_{@code @ContextConfiguration} instances are declared._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the nested lists returned by this method._@param testClass the class for which to resolve the context hierarchy attributes_(must not be {@code null})_@return the list of lists of configuration attributes for the specified class__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null}_ or if_neither {@code @ContextConfiguration} nor {@code @ContextHierarchy} is_<em>present</em> on the supplied class_@throws IllegalStateException if a test class or composed annotation_in the class hierarchy declares both {@code @ContextConfiguration} and_{@code @ContextHierarchy} as top-level annotations._@since 3.2.2_@see #buildContextHierarchyMap(Class)_@see #resolveContextConfigurationAttributes(Class);@SuppressWarnings("unchecked")_	static List<List<ContextConfigurationAttributes>> resolveContextHierarchyAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		Class<ContextConfiguration> contextConfigType = ContextConfiguration.class__		Class<ContextHierarchy> contextHierarchyType = ContextHierarchy.class__		List<List<ContextConfigurationAttributes>> hierarchyAttributes = new ArrayList<>()___		UntypedAnnotationDescriptor desc =_				findAnnotationDescriptorForTypes(testClass, contextConfigType, contextHierarchyType)__		Assert.notNull(desc, () -> String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] or [%s] and test class [%s]",_					contextConfigType.getName(), contextHierarchyType.getName(), testClass.getName()))___		while (desc != null) {_			Class<?> rootDeclaringClass = desc.getRootDeclaringClass()__			Class<?> declaringClass = desc.getDeclaringClass()___			boolean contextConfigDeclaredLocally = isAnnotationDeclaredLocally(contextConfigType, declaringClass)__			boolean contextHierarchyDeclaredLocally = isAnnotationDeclaredLocally(contextHierarchyType, declaringClass)___			if (contextConfigDeclaredLocally && contextHierarchyDeclaredLocally) {_				String msg = String.format("Class [%s] has been configured with both @ContextConfiguration " +_						"and @ContextHierarchy. Only one of these annotations may be declared on a test class " +_						"or composed annotation.", declaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			List<ContextConfigurationAttributes> configAttributesList = new ArrayList<>()___			if (contextConfigDeclaredLocally) {_				ContextConfiguration contextConfiguration = AnnotationUtils.synthesizeAnnotation(_						desc.getAnnotationAttributes(), ContextConfiguration.class, desc.getRootDeclaringClass())__				convertContextConfigToConfigAttributesAndAddToList(_						contextConfiguration, rootDeclaringClass, configAttributesList)__			}_			else if (contextHierarchyDeclaredLocally) {_				ContextHierarchy contextHierarchy = getAnnotation(declaringClass, contextHierarchyType)__				if (contextHierarchy != null) {_					for (ContextConfiguration contextConfiguration : contextHierarchy.value()) {_						convertContextConfigToConfigAttributesAndAddToList(_								contextConfiguration, rootDeclaringClass, configAttributesList)__					}_				}_			}_			else {_				_				String msg = String.format("Test class [%s] has been configured with neither @ContextConfiguration " +_						"nor @ContextHierarchy as a class-level annotation.", rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			hierarchyAttributes.add(0, configAttributesList)__			desc = findAnnotationDescriptorForTypes(_					rootDeclaringClass.getSuperclass(), contextConfigType, contextHierarchyType)__		}__		return hierarchyAttributes__	};resolve,the,list,of,lists,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,the,outer,list,represents,a,top,down,ordering,of,context,configuration,attributes,where,each,element,in,the,list,represents,the,context,configuration,declared,on,a,given,test,class,in,the,class,hierarchy,each,nested,list,contains,the,context,configuration,attributes,declared,either,via,a,single,instance,of,code,context,configuration,on,the,particular,class,or,via,multiple,instances,of,code,context,configuration,declared,within,a,single,code,context,hierarchy,instance,on,the,particular,class,furthermore,each,nested,list,maintains,the,order,in,which,code,context,configuration,instances,are,declared,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,nested,lists,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,attributes,must,not,be,code,null,return,the,list,of,lists,of,configuration,attributes,for,the,specified,class,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,neither,code,context,configuration,nor,code,context,hierarchy,is,em,present,em,on,the,supplied,class,throws,illegal,state,exception,if,a,test,class,or,composed,annotation,in,the,class,hierarchy,declares,both,code,context,configuration,and,code,context,hierarchy,as,top,level,annotations,since,3,2,2,see,build,context,hierarchy,map,class,see,resolve,context,configuration,attributes,class;suppress,warnings,unchecked,static,list,list,context,configuration,attributes,resolve,context,hierarchy,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,class,context,configuration,context,config,type,context,configuration,class,class,context,hierarchy,context,hierarchy,type,context,hierarchy,class,list,list,context,configuration,attributes,hierarchy,attributes,new,array,list,untyped,annotation,descriptor,desc,find,annotation,descriptor,for,types,test,class,context,config,type,context,hierarchy,type,assert,not,null,desc,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,or,s,and,test,class,s,context,config,type,get,name,context,hierarchy,type,get,name,test,class,get,name,while,desc,null,class,root,declaring,class,desc,get,root,declaring,class,class,declaring,class,desc,get,declaring,class,boolean,context,config,declared,locally,is,annotation,declared,locally,context,config,type,declaring,class,boolean,context,hierarchy,declared,locally,is,annotation,declared,locally,context,hierarchy,type,declaring,class,if,context,config,declared,locally,context,hierarchy,declared,locally,string,msg,string,format,class,s,has,been,configured,with,both,context,configuration,and,context,hierarchy,only,one,of,these,annotations,may,be,declared,on,a,test,class,or,composed,annotation,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,list,context,configuration,attributes,config,attributes,list,new,array,list,if,context,config,declared,locally,context,configuration,context,configuration,annotation,utils,synthesize,annotation,desc,get,annotation,attributes,context,configuration,class,desc,get,root,declaring,class,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,if,context,hierarchy,declared,locally,context,hierarchy,context,hierarchy,get,annotation,declaring,class,context,hierarchy,type,if,context,hierarchy,null,for,context,configuration,context,configuration,context,hierarchy,value,convert,context,config,to,config,attributes,and,add,to,list,context,configuration,root,declaring,class,config,attributes,list,else,string,msg,string,format,test,class,s,has,been,configured,with,neither,context,configuration,nor,context,hierarchy,as,a,class,level,annotation,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,hierarchy,attributes,add,0,config,attributes,list,desc,find,annotation,descriptor,for,types,root,declaring,class,get,superclass,context,config,type,context,hierarchy,type,return,hierarchy,attributes
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1397082962;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method.__@param testClass the class for which to resolve the configuration attributes (must_not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<ContextConfigurationAttributes> attributesList = new ArrayList<ContextConfigurationAttributes>()___		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_			annotationType.getName(), testClass.getName()))___		while (descriptor != null) {_			convertAnnotationAttributesToConfigAttributesAndAddToList(descriptor.getAnnotationAttributes(),_				descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,context,configuration,attributes,attributes,list,new,array,list,context,configuration,attributes,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,annotation,attributes,to,config,attributes,and,add,to,list,descriptor,get,annotation,attributes,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1397084183;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method.__@param testClass the class for which to resolve the configuration attributes (must_not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<ContextConfigurationAttributes> attributesList = new ArrayList<ContextConfigurationAttributes>()___		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_			annotationType.getName(), testClass.getName()))___		while (descriptor != null) {_			convertAnnotationAttributesToConfigAttributesAndAddToList(descriptor.getAnnotationAttributes(),_				descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,context,configuration,attributes,attributes,list,new,array,list,context,configuration,attributes,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,annotation,attributes,to,config,attributes,and,add,to,list,descriptor,get,annotation,attributes,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1398153432;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method.__@param testClass the class for which to resolve the configuration attributes (must_not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<ContextConfigurationAttributes> attributesList = new ArrayList<ContextConfigurationAttributes>()___		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_			annotationType.getName(), testClass.getName()))___		while (descriptor != null) {_			convertAnnotationAttributesToConfigAttributesAndAddToList(descriptor.getAnnotationAttributes(),_				descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,context,configuration,attributes,attributes,list,new,array,list,context,configuration,attributes,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,annotation,attributes,to,config,attributes,and,add,to,list,descriptor,get,annotation,attributes,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1413848647;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method.__@param testClass the class for which to resolve the configuration attributes (must_not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<ContextConfigurationAttributes> attributesList = new ArrayList<ContextConfigurationAttributes>()___		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_			annotationType.getName(), testClass.getName()))___		while (descriptor != null) {_			convertAnnotationAttributesToConfigAttributesAndAddToList(descriptor.getAnnotationAttributes(),_				descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,context,configuration,attributes,attributes,list,new,array,list,context,configuration,attributes,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,annotation,attributes,to,config,attributes,and,add,to,list,descriptor,get,annotation,attributes,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1432856630;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method.__@param testClass the class for which to resolve the configuration attributes (must_not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<ContextConfigurationAttributes> attributesList = new ArrayList<ContextConfigurationAttributes>()___		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_			annotationType.getName(), testClass.getName()))___		while (descriptor != null) {_			convertContextConfigToConfigAttributesAndAddToList(descriptor.getMergedAnnotation(),_				descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,context,configuration,attributes,attributes,list,new,array,list,context,configuration,attributes,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,context,config,to,config,attributes,and,add,to,list,descriptor,get,merged,annotation,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1434234880;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses.__<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method.__@param testClass the class for which to resolve the configuration attributes (must_not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<ContextConfigurationAttributes> attributesList = new ArrayList<ContextConfigurationAttributes>()___		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		Assert.notNull(descriptor, String.format(_			"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_			annotationType.getName(), testClass.getName()))___		while (descriptor != null) {_			convertContextConfigToConfigAttributesAndAddToList(descriptor.synthesizeAnnotation(),_				descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,context,configuration,attributes,attributes,list,new,array,list,context,configuration,attributes,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,context,config,to,config,attributes,and,add,to,list,descriptor,synthesize,annotation,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1449505825;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method._@param testClass the class for which to resolve the configuration attributes_(must not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		List<ContextConfigurationAttributes> attributesList = new ArrayList<ContextConfigurationAttributes>()__		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		if (descriptor == null) {_			throw new IllegalArgumentException(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			convertContextConfigToConfigAttributesAndAddToList(descriptor.synthesizeAnnotation(),_					descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,list,context,configuration,attributes,attributes,list,new,array,list,context,configuration,attributes,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,throw,new,illegal,argument,exception,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,context,config,to,config,attributes,and,add,to,list,descriptor,synthesize,annotation,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1458754760;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method._@param testClass the class for which to resolve the configuration attributes_(must not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		List<ContextConfigurationAttributes> attributesList = new ArrayList<ContextConfigurationAttributes>()__		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		if (descriptor == null) {_			throw new IllegalArgumentException(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			convertContextConfigToConfigAttributesAndAddToList(descriptor.synthesizeAnnotation(),_					descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,list,context,configuration,attributes,attributes,list,new,array,list,context,configuration,attributes,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,throw,new,illegal,argument,exception,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,context,config,to,config,attributes,and,add,to,list,descriptor,synthesize,annotation,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1459174667;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method._@param testClass the class for which to resolve the configuration attributes_(must not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		List<ContextConfigurationAttributes> attributesList = new ArrayList<ContextConfigurationAttributes>()__		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		if (descriptor == null) {_			throw new IllegalArgumentException(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			convertContextConfigToConfigAttributesAndAddToList(descriptor.synthesizeAnnotation(),_					descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,list,context,configuration,attributes,attributes,list,new,array,list,context,configuration,attributes,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,throw,new,illegal,argument,exception,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,context,config,to,config,attributes,and,add,to,list,descriptor,synthesize,annotation,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1467730834;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method._@param testClass the class for which to resolve the configuration attributes_(must not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		List<ContextConfigurationAttributes> attributesList = new ArrayList<>()__		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		if (descriptor == null) {_			throw new IllegalArgumentException(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			convertContextConfigToConfigAttributesAndAddToList(descriptor.synthesizeAnnotation(),_					descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,list,context,configuration,attributes,attributes,list,new,array,list,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,throw,new,illegal,argument,exception,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,context,config,to,config,attributes,and,add,to,list,descriptor,synthesize,annotation,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1468334463;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method._@param testClass the class for which to resolve the configuration attributes_(must not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		List<ContextConfigurationAttributes> attributesList = new ArrayList<>()__		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		Assert.notNull(descriptor, () -> String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))___		while (descriptor != null) {_			convertContextConfigToConfigAttributesAndAddToList(descriptor.synthesizeAnnotation(),_					descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,list,context,configuration,attributes,attributes,list,new,array,list,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,context,config,to,config,attributes,and,add,to,list,descriptor,synthesize,annotation,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1496955179;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method._@param testClass the class for which to resolve the configuration attributes_(must not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		List<ContextConfigurationAttributes> attributesList = new ArrayList<>()__		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		Assert.notNull(descriptor, () -> String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))___		while (descriptor != null) {_			convertContextConfigToConfigAttributesAndAddToList(descriptor.synthesizeAnnotation(),_					descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,list,context,configuration,attributes,attributes,list,new,array,list,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,context,config,to,config,attributes,and,add,to,list,descriptor,synthesize,annotation,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass);1530174524;Resolve the list of {@linkplain ContextConfigurationAttributes context_configuration attributes} for the supplied {@linkplain Class test class} and its_superclasses._<p>Note that the {@link ContextConfiguration#inheritLocations inheritLocations} and_{@link ContextConfiguration#inheritInitializers() inheritInitializers} flags of_{@link ContextConfiguration @ContextConfiguration} will <strong>not</strong>_be taken into consideration. If these flags need to be honored, that must be_handled manually when traversing the list returned by this method._@param testClass the class for which to resolve the configuration attributes_(must not be {@code null})_@return the list of configuration attributes for the specified class, ordered_<em>bottom-up</em> (i.e., as if we were traversing up the class hierarchy)__never {@code null}_@throws IllegalArgumentException if the supplied class is {@code null} or if_{@code @ContextConfiguration} is not <em>present</em> on the supplied class;static List<ContextConfigurationAttributes> resolveContextConfigurationAttributes(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		List<ContextConfigurationAttributes> attributesList = new ArrayList<>()__		Class<ContextConfiguration> annotationType = ContextConfiguration.class___		AnnotationDescriptor<ContextConfiguration> descriptor = findAnnotationDescriptor(testClass, annotationType)__		Assert.notNull(descriptor, () -> String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))___		while (descriptor != null) {_			convertContextConfigToConfigAttributesAndAddToList(descriptor.synthesizeAnnotation(),_					descriptor.getRootDeclaringClass(), attributesList)__			descriptor = findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType)__		}__		return attributesList__	};resolve,the,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,the,supplied,linkplain,class,test,class,and,its,superclasses,p,note,that,the,link,context,configuration,inherit,locations,inherit,locations,and,link,context,configuration,inherit,initializers,inherit,initializers,flags,of,link,context,configuration,context,configuration,will,strong,not,strong,be,taken,into,consideration,if,these,flags,need,to,be,honored,that,must,be,handled,manually,when,traversing,the,list,returned,by,this,method,param,test,class,the,class,for,which,to,resolve,the,configuration,attributes,must,not,be,code,null,return,the,list,of,configuration,attributes,for,the,specified,class,ordered,em,bottom,up,em,i,e,as,if,we,were,traversing,up,the,class,hierarchy,never,code,null,throws,illegal,argument,exception,if,the,supplied,class,is,code,null,or,if,code,context,configuration,is,not,em,present,em,on,the,supplied,class;static,list,context,configuration,attributes,resolve,context,configuration,attributes,class,test,class,assert,not,null,test,class,class,must,not,be,null,list,context,configuration,attributes,attributes,list,new,array,list,class,context,configuration,annotation,type,context,configuration,class,annotation,descriptor,context,configuration,descriptor,find,annotation,descriptor,test,class,annotation,type,assert,not,null,descriptor,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,convert,context,config,to,config,attributes,and,add,to,list,descriptor,synthesize,annotation,descriptor,get,root,declaring,class,attributes,list,descriptor,find,annotation,descriptor,descriptor,get,root,declaring,class,get,superclass,annotation,type,return,attributes,list
ContextLoaderUtils -> private static void convertAnnotationAttributesToConfigAttributesAndAddToList(AnnotationAttributes annAttrs, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1397082962;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link AnnotationAttributes} and declaring_class and then adding the attributes to the supplied list._@since 4.0;private static void convertAnnotationAttributesToConfigAttributesAndAddToList(AnnotationAttributes annAttrs,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration attributes [%s] for declaring class [%s].",_				annAttrs, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass, annAttrs)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,annotation,attributes,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list,since,4,0;private,static,void,convert,annotation,attributes,to,config,attributes,and,add,to,list,annotation,attributes,ann,attrs,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,ann,attrs,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertAnnotationAttributesToConfigAttributesAndAddToList(AnnotationAttributes annAttrs, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1397084183;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link AnnotationAttributes} and declaring_class and then adding the attributes to the supplied list._@since 4.0;private static void convertAnnotationAttributesToConfigAttributesAndAddToList(AnnotationAttributes annAttrs,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration attributes [%s] for declaring class [%s].",_				annAttrs, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass, annAttrs)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,annotation,attributes,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list,since,4,0;private,static,void,convert,annotation,attributes,to,config,attributes,and,add,to,list,annotation,attributes,ann,attrs,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,ann,attrs,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertAnnotationAttributesToConfigAttributesAndAddToList(AnnotationAttributes annAttrs, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1398153432;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link AnnotationAttributes} and declaring_class and then adding the attributes to the supplied list._@since 4.0;private static void convertAnnotationAttributesToConfigAttributesAndAddToList(AnnotationAttributes annAttrs,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration attributes [%s] for declaring class [%s].",_				annAttrs, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass, annAttrs)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,annotation,attributes,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list,since,4,0;private,static,void,convert,annotation,attributes,to,config,attributes,and,add,to,list,annotation,attributes,ann,attrs,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,ann,attrs,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> private static void convertAnnotationAttributesToConfigAttributesAndAddToList(AnnotationAttributes annAttrs, 			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList);1413848647;Convenience method for creating a {@link ContextConfigurationAttributes}_instance from the supplied {@link AnnotationAttributes} and declaring_class and then adding the attributes to the supplied list._@since 4.0;private static void convertAnnotationAttributesToConfigAttributesAndAddToList(AnnotationAttributes annAttrs,_			Class<?> declaringClass, final List<ContextConfigurationAttributes> attributesList) {_		if (logger.isTraceEnabled()) {_			logger.trace(String.format("Retrieved @ContextConfiguration attributes [%s] for declaring class [%s].",_				annAttrs, declaringClass.getName()))__		}__		ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(declaringClass, annAttrs)__		if (logger.isTraceEnabled()) {_			logger.trace("Resolved context configuration attributes: " + attributes)__		}_		attributesList.add(attributes)__	};convenience,method,for,creating,a,link,context,configuration,attributes,instance,from,the,supplied,link,annotation,attributes,and,declaring,class,and,then,adding,the,attributes,to,the,supplied,list,since,4,0;private,static,void,convert,annotation,attributes,to,config,attributes,and,add,to,list,annotation,attributes,ann,attrs,class,declaring,class,final,list,context,configuration,attributes,attributes,list,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,context,configuration,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,context,configuration,attributes,attributes,new,context,configuration,attributes,declaring,class,ann,attrs,if,logger,is,trace,enabled,logger,trace,resolved,context,configuration,attributes,attributes,attributes,list,add,attributes
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1397082962;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level.__<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}.__@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy.__@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<ContextConfigurationAttributes>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<List<ContextConfigurationAttributes>>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via "_					+ "@ContextHierarchy in test class [%s] and its superclasses must "_					+ "define unique contexts per hierarchy level.", testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,string,list,context,configuration,attributes,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,context,configuration,attributes,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,list,context,configuration,attributes,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1397084183;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level.__<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}.__@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy.__@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<ContextConfigurationAttributes>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<List<ContextConfigurationAttributes>>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via "_					+ "@ContextHierarchy in test class [%s] and its superclasses must "_					+ "define unique contexts per hierarchy level.", testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,string,list,context,configuration,attributes,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,context,configuration,attributes,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,list,context,configuration,attributes,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1398153432;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level.__<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}.__@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy.__@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<ContextConfigurationAttributes>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<List<ContextConfigurationAttributes>>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via "_					+ "@ContextHierarchy in test class [%s] and its superclasses must "_					+ "define unique contexts per hierarchy level.", testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,string,list,context,configuration,attributes,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,context,configuration,attributes,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,list,context,configuration,attributes,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1413848647;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level.__<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}.__@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy.__@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<ContextConfigurationAttributes>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<List<ContextConfigurationAttributes>>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via "_					+ "@ContextHierarchy in test class [%s] and its superclasses must "_					+ "define unique contexts per hierarchy level.", testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,string,list,context,configuration,attributes,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,context,configuration,attributes,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,list,context,configuration,attributes,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1432856630;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level.__<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}.__@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy.__@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<ContextConfigurationAttributes>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<List<ContextConfigurationAttributes>>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via "_					+ "@ContextHierarchy in test class [%s] and its superclasses must "_					+ "define unique contexts per hierarchy level.", testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,string,list,context,configuration,attributes,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,context,configuration,attributes,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,list,context,configuration,attributes,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1434234880;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}.__<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level.__<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}.__@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy.__@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<ContextConfigurationAttributes>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<List<ContextConfigurationAttributes>>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via "_					+ "@ContextHierarchy in test class [%s] and its superclasses must "_					+ "define unique contexts per hierarchy level.", testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,string,list,context,configuration,attributes,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,context,configuration,attributes,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,list,context,configuration,attributes,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1449505825;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level._<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}._@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy._@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<ContextConfigurationAttributes>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<List<ContextConfigurationAttributes>>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via @ContextHierarchy in " +_					"test class [%s] and its superclasses must define unique contexts per hierarchy level.",_					testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,string,list,context,configuration,attributes,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,context,configuration,attributes,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,list,context,configuration,attributes,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1458754760;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level._<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}._@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy._@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<ContextConfigurationAttributes>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<List<ContextConfigurationAttributes>>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via @ContextHierarchy in " +_					"test class [%s] and its superclasses must define unique contexts per hierarchy level.",_					testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,string,list,context,configuration,attributes,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,context,configuration,attributes,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,list,context,configuration,attributes,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1459174667;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level._<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}._@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy._@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<String, List<ContextConfigurationAttributes>>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<ContextConfigurationAttributes>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<List<ContextConfigurationAttributes>>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via @ContextHierarchy in " +_					"test class [%s] and its superclasses must define unique contexts per hierarchy level.",_					testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,string,list,context,configuration,attributes,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,context,configuration,attributes,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,list,context,configuration,attributes,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1467730834;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level._<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}._@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy._@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via @ContextHierarchy in " +_					"test class [%s] and its superclasses must define unique contexts per hierarchy level.",_					testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1468334463;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level._<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}._@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy._@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via @ContextHierarchy in " +_					"test class [%s] and its superclasses must define unique contexts per hierarchy level.",_					testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1496955179;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level._<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}._@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy._@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via @ContextHierarchy in " +_					"test class [%s] and its superclasses must define unique contexts per hierarchy level.",_					testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
ContextLoaderUtils -> static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass);1530174524;Build a <em>context hierarchy map</em> for the supplied {@linkplain Class_test class} and its superclasses, taking into account context hierarchies_declared via {@link ContextHierarchy @ContextHierarchy} and_{@link ContextConfiguration @ContextConfiguration}._<p>Each value in the map represents the consolidated list of {@linkplain_ContextConfigurationAttributes context configuration attributes} for a_given level in the context hierarchy (potentially across the test class_hierarchy), keyed by the {@link ContextConfiguration#name() name} of the_context hierarchy level._<p>If a given level in the context hierarchy does not have an explicit_name (i.e., configured via {@link ContextConfiguration#name}), a name will_be generated for that hierarchy level by appending the numerical level to_the {@link #GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX}._@param testClass the class for which to resolve the context hierarchy map_(must not be {@code null})_@return a map of context configuration attributes for the context hierarchy,_keyed by context hierarchy level name_ never {@code null}_@throws IllegalArgumentException if the lists of context configuration_attributes for each level in the {@code @ContextHierarchy} do not define_unique context configuration within the overall hierarchy._@since 3.2.2_@see #resolveContextHierarchyAttributes(Class);static Map<String, List<ContextConfigurationAttributes>> buildContextHierarchyMap(Class<?> testClass) {_		final Map<String, List<ContextConfigurationAttributes>> map = new LinkedHashMap<>()__		int hierarchyLevel = 1___		for (List<ContextConfigurationAttributes> configAttributesList : resolveContextHierarchyAttributes(testClass)) {_			for (ContextConfigurationAttributes configAttributes : configAttributesList) {_				String name = configAttributes.getName()___				_				if (!StringUtils.hasText(name)) {_					name = GENERATED_CONTEXT_HIERARCHY_LEVEL_PREFIX + hierarchyLevel__				}__				_				if (!map.containsKey(name)) {_					hierarchyLevel++__					map.put(name, new ArrayList<>())__				}__				map.get(name).add(configAttributes)__			}_		}__		_		Set<List<ContextConfigurationAttributes>> set = new HashSet<>(map.values())__		if (set.size() != map.size()) {_			String msg = String.format("The @ContextConfiguration elements configured via @ContextHierarchy in " +_					"test class [%s] and its superclasses must define unique contexts per hierarchy level.",_					testClass.getName())__			logger.error(msg)__			throw new IllegalStateException(msg)__		}__		return map__	};build,a,em,context,hierarchy,map,em,for,the,supplied,linkplain,class,test,class,and,its,superclasses,taking,into,account,context,hierarchies,declared,via,link,context,hierarchy,context,hierarchy,and,link,context,configuration,context,configuration,p,each,value,in,the,map,represents,the,consolidated,list,of,linkplain,context,configuration,attributes,context,configuration,attributes,for,a,given,level,in,the,context,hierarchy,potentially,across,the,test,class,hierarchy,keyed,by,the,link,context,configuration,name,name,of,the,context,hierarchy,level,p,if,a,given,level,in,the,context,hierarchy,does,not,have,an,explicit,name,i,e,configured,via,link,context,configuration,name,a,name,will,be,generated,for,that,hierarchy,level,by,appending,the,numerical,level,to,the,link,param,test,class,the,class,for,which,to,resolve,the,context,hierarchy,map,must,not,be,code,null,return,a,map,of,context,configuration,attributes,for,the,context,hierarchy,keyed,by,context,hierarchy,level,name,never,code,null,throws,illegal,argument,exception,if,the,lists,of,context,configuration,attributes,for,each,level,in,the,code,context,hierarchy,do,not,define,unique,context,configuration,within,the,overall,hierarchy,since,3,2,2,see,resolve,context,hierarchy,attributes,class;static,map,string,list,context,configuration,attributes,build,context,hierarchy,map,class,test,class,final,map,string,list,context,configuration,attributes,map,new,linked,hash,map,int,hierarchy,level,1,for,list,context,configuration,attributes,config,attributes,list,resolve,context,hierarchy,attributes,test,class,for,context,configuration,attributes,config,attributes,config,attributes,list,string,name,config,attributes,get,name,if,string,utils,has,text,name,name,hierarchy,level,if,map,contains,key,name,hierarchy,level,map,put,name,new,array,list,map,get,name,add,config,attributes,set,list,context,configuration,attributes,set,new,hash,set,map,values,if,set,size,map,size,string,msg,string,format,the,context,configuration,elements,configured,via,context,hierarchy,in,test,class,s,and,its,superclasses,must,define,unique,contexts,per,hierarchy,level,test,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,return,map
