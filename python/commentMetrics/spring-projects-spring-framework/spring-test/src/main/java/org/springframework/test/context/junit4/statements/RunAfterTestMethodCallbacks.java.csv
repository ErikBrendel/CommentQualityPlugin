commented;modifiers;parameterAmount;loc;comment;code
true;public;0;21;/**  * Evaluate the next {@link Statement} in the execution chain (typically an instance of  * {@link org.junit.internal.runners.statements.RunAfters RunAfters}), catching any  * exceptions thrown, and then invoke  * {@link TestContextManager#afterTestMethod(Object, Method, Throwable)} supplying the  * first caught exception (if any).  * <p>If the invocation of {@code afterTestMethod()} throws an exception, that  * exception will also be tracked. Multiple exceptions will be combined into a  * {@link MultipleFailureException}.  */ ;/**  * Evaluate the next {@link Statement} in the execution chain (typically an instance of  * {@link org.junit.internal.runners.statements.RunAfters RunAfters}), catching any  * exceptions thrown, and then invoke  * {@link TestContextManager#afterTestMethod(Object, Method, Throwable)} supplying the  * first caught exception (if any).  * <p>If the invocation of {@code afterTestMethod()} throws an exception, that  * exception will also be tracked. Multiple exceptions will be combined into a  * {@link MultipleFailureException}.  */ @Override public void evaluate() throws Throwable {     Throwable testException = null.     List<Throwable> errors = new ArrayList<>().     try {         this.next.evaluate().     } catch (Throwable ex) {         testException = ex.         errors.add(ex).     }     try {         this.testContextManager.afterTestMethod(this.testInstance, this.testMethod, testException).     } catch (Throwable ex) {         errors.add(ex).     }     MultipleFailureException.assertEmpty(errors). }
