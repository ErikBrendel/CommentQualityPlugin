commented;modifiers;parameterAmount;loc;comment;code
false;public;3;22;;@Override public Mono<ClientHttpResponse> connect(HttpMethod method, URI uri, Function<? super ClientHttpRequest, Mono<Void>> requestCallback) {     AtomicReference<WiretapClientHttpRequest> requestRef = new AtomicReference<>().     return this.delegate.connect(method, uri, request -> {         WiretapClientHttpRequest wrapped = new WiretapClientHttpRequest(request).         requestRef.set(wrapped).         return requestCallback.apply(wrapped).     }).map(response -> {         WiretapClientHttpRequest wrappedRequest = requestRef.get().         String header = WebTestClient.WEBTESTCLIENT_REQUEST_ID.         String requestId = wrappedRequest.getHeaders().getFirst(header).         Assert.state(requestId != null, () -> "No \"" + header + "\" header").         WiretapClientHttpResponse wrappedResponse = new WiretapClientHttpResponse(response).         this.exchanges.put(requestId, new Info(wrappedRequest, wrappedResponse)).         return wrappedResponse.     }). }
true;public;1;8;/**  * Retrieve the {@link Info} for the given "request-id" header value.  */ ;/**  * Retrieve the {@link Info} for the given "request-id" header value.  */ public Info claimRequest(String requestId) {     Info info = this.exchanges.remove(requestId).     Assert.state(info != null, () -> {         String header = WebTestClient.WEBTESTCLIENT_REQUEST_ID.         return "No match for " + header + "=" + requestId.     }).     return info. }
false;public;2;4;;public ExchangeResult createExchangeResult(Duration timeout, @Nullable String uriTemplate) {     return new ExchangeResult(this.request, this.response, this.request.getRecorder().getContent(), this.response.getRecorder().getContent(), timeout, uriTemplate). }
false;public;0;4;;public Publisher<? extends DataBuffer> getPublisherToUse() {     Assert.notNull(this.publisher, "Publisher not in use.").     return this.publisher. }
false;public;0;4;;public Publisher<? extends Publisher<? extends DataBuffer>> getNestedPublisherToUse() {     Assert.notNull(this.publisherNested, "Nested publisher not in use.").     return this.publisherNested. }
false;public;0;19;;public Mono<byte[]> getContent() {     return Mono.defer(() -> {         if (this.content.isTerminated()) {             return this.content.         }         if (!this.hasContentConsumer) {             // Couple of possible cases:             // 1. Mock server never consumed request body (e.g. error before read)             // 2. FluxExchangeResult: getResponseBodyContent called before getResponseBody             // noinspection ConstantConditions             (this.publisher != null ? this.publisher : this.publisherNested).onErrorMap(ex -> new IllegalStateException("Content has not been consumed, and " + "an error was raised while attempting to produce it.", ex)).subscribe().         }         return this.content.     }). }
false;private;1;5;;private void handleOnError(Throwable ex) {     if (!this.content.isTerminated()) {         this.content.onError(ex).     } }
false;private;0;7;;private void handleOnComplete() {     if (!this.content.isTerminated()) {         byte[] bytes = new byte[this.buffer.readableByteCount()].         this.buffer.read(bytes).         this.content.onNext(bytes).     } }
false;public;0;4;;public WiretapRecorder getRecorder() {     Assert.notNull(this.recorder, "No WiretapRecorder: was the client request written?").     return this.recorder. }
false;public;1;5;;@Override public Mono<Void> writeWith(Publisher<? extends DataBuffer> publisher) {     this.recorder = new WiretapRecorder(publisher, null).     return super.writeWith(this.recorder.getPublisherToUse()). }
false;public;1;5;;@Override public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> publisher) {     this.recorder = new WiretapRecorder(null, publisher).     return super.writeAndFlushWith(this.recorder.getNestedPublisherToUse()). }
false;public;0;5;;@Override public Mono<Void> setComplete() {     this.recorder = new WiretapRecorder(null, null).     return super.setComplete(). }
false;public;0;3;;public WiretapRecorder getRecorder() {     return this.recorder. }
false;public;0;5;;@Override @SuppressWarnings("ConstantConditions") public Flux<DataBuffer> getBody() {     return Flux.from(this.recorder.getPublisherToUse()). }
