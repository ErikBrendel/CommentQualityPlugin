commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;3;/**  * Return a read-only list of the expectations.  */ ;/**  * Return a read-only list of the expectations.  */ protected List<RequestExpectation> getExpectations() {     return Collections.unmodifiableList(this.expectations). }
true;protected;0;3;/**  * Return a read-only list of requests executed so far.  */ ;/**  * Return a read-only list of requests executed so far.  */ protected List<ClientHttpRequest> getRequests() {     return Collections.unmodifiableList(this.requests). }
false;public;2;7;;@Override public ResponseActions expectRequest(ExpectedCount count, RequestMatcher matcher) {     Assert.state(this.requests.isEmpty(), "Cannot add more expectations after actual requests are made").     RequestExpectation expectation = new DefaultRequestExpectation(count, matcher).     this.expectations.add(expectation).     return expectation. }
false;public;1;24;;@SuppressWarnings("deprecation") @Override public ClientHttpResponse validateRequest(ClientHttpRequest request) throws IOException {     RequestExpectation expectation = null.     synchronized (this.requests) {         if (this.requests.isEmpty()) {             afterExpectationsDeclared().         }         try {             // Try this first for backwards compatibility             ClientHttpResponse response = validateRequestInternal(request).             if (response != null) {                 return response.             } else {                 expectation = matchRequest(request).             }         } finally {             this.requests.add(request).         }     }     return expectation.createResponse(request). }
true;protected;0;2;/**  * Invoked at the time of the first actual request, which effectively means  * the expectations declaration phase is over.  */ ;/**  * Invoked at the time of the first actual request, which effectively means  * the expectations declaration phase is over.  */ protected void afterExpectationsDeclared() { }
true;protected;1;5;/**  * Subclasses must implement the actual validation of the request  * matching to declared expectations.  * @deprecated as of 5.0.3, subclasses should implement {@link #matchRequest(ClientHttpRequest)}  * instead and return only the matched expectation, leaving the call to create the response  * as a separate step (to be invoked by this class).  */ ;/**  * Subclasses must implement the actual validation of the request  * matching to declared expectations.  * @deprecated as of 5.0.3, subclasses should implement {@link #matchRequest(ClientHttpRequest)}  * instead and return only the matched expectation, leaving the call to create the response  * as a separate step (to be invoked by this class).  */ @Deprecated @Nullable protected ClientHttpResponse validateRequestInternal(ClientHttpRequest request) throws IOException {     return null. }
true;protected;1;4;/**  * As of 5.0.3 subclasses should implement this method instead of  * {@link #validateRequestInternal(ClientHttpRequest)} in order to match the  * request to an expectation, leaving the call to create the response as a separate step  * (to be invoked by this class).  * @param request the current request  * @return the matched expectation with its request count updated via  * {@link RequestExpectation#incrementAndValidate()}.  * @since 5.0.3  */ ;/**  * As of 5.0.3 subclasses should implement this method instead of  * {@link #validateRequestInternal(ClientHttpRequest)} in order to match the  * request to an expectation, leaving the call to create the response as a separate step  * (to be invoked by this class).  * @param request the current request  * @return the matched expectation with its request count updated via  * {@link RequestExpectation#incrementAndValidate()}.  * @since 5.0.3  */ protected RequestExpectation matchRequest(ClientHttpRequest request) throws IOException {     throw new UnsupportedOperationException("It looks like neither the deprecated \"validateRequestInternal\"" + "nor its replacement (this method) are implemented."). }
false;public;0;16;;@Override public void verify() {     if (this.expectations.isEmpty()) {         return.     }     int count = 0.     for (RequestExpectation expectation : this.expectations) {         if (!expectation.isSatisfied()) {             count++.         }     }     if (count > 0) {         String message = "Further request(s) expected leaving " + count + " unsatisfied expectation(s).\n".         throw new AssertionError(message + getRequestDetails()).     } }
true;protected;0;14;/**  * Return details of executed requests.  */ ;/**  * Return details of executed requests.  */ protected String getRequestDetails() {     StringBuilder sb = new StringBuilder().     sb.append(this.requests.size()).append(" request(s) executed").     if (!this.requests.isEmpty()) {         sb.append(":\n").         for (ClientHttpRequest request : this.requests) {             sb.append(request.toString()).append("\n").         }     } else {         sb.append(".\n").     }     return sb.toString(). }
true;protected;1;6;/**  * Return an {@code AssertionError} that a sub-class can raise for an  * unexpected request.  */ ;/**  * Return an {@code AssertionError} that a sub-class can raise for an  * unexpected request.  */ protected AssertionError createUnexpectedRequestError(ClientHttpRequest request) {     HttpMethod method = request.getMethod().     URI uri = request.getURI().     String message = "No further requests expected: HTTP " + method + " " + uri + "\n".     return new AssertionError(message + getRequestDetails()). }
false;public;0;5;;@Override public void reset() {     this.expectations.clear().     this.requests.clear(). }
false;public;1;3;;public void addAllExpectations(Collection<RequestExpectation> expectations) {     this.expectations.addAll(expectations). }
false;public;0;3;;public Set<RequestExpectation> getExpectations() {     return this.expectations. }
true;public;1;13;/**  * Return a matching expectation, or {@code null} if none match.  */ ;/**  * Return a matching expectation, or {@code null} if none match.  */ @Nullable public RequestExpectation findExpectation(ClientHttpRequest request) throws IOException {     for (RequestExpectation expectation : this.expectations) {         try {             expectation.match(request).             return expectation.         } catch (AssertionError error) {         // We're looking to find a match or return null..         }     }     return null. }
true;public;1;4;/**  * Invoke this for an expectation that has been matched.  * <p>The count of the given expectation is incremented, then it is  * either stored if remainingCount > 0 or removed otherwise.  */ ;/**  * Invoke this for an expectation that has been matched.  * <p>The count of the given expectation is incremented, then it is  * either stored if remainingCount > 0 or removed otherwise.  */ public void update(RequestExpectation expectation) {     expectation.incrementAndValidate().     updateInternal(expectation). }
false;private;1;8;;private void updateInternal(RequestExpectation expectation) {     if (expectation.hasRemainingCount()) {         this.expectations.add(expectation).     } else {         this.expectations.remove(expectation).     } }
true;public;1;4;/**  * Add expectations to this group.  * @deprecated as of 5.0.3, if favor of {@link #addAllExpectations}  */ ;/**  * Add expectations to this group.  * @deprecated as of 5.0.3, if favor of {@link #addAllExpectations}  */ @Deprecated public void updateAll(Collection<RequestExpectation> expectations) {     expectations.forEach(this::updateInternal). }
true;public;0;3;/**  * Reset all expectations for this group.  */ ;/**  * Reset all expectations for this group.  */ public void reset() {     this.expectations.clear(). }
