commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public boolean contains(MergedContextConfiguration key) {     Assert.notNull(key, "Key must not be null").     return this.contextMap.containsKey(key). }
true;public;1;13;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override @Nullable public ApplicationContext get(MergedContextConfiguration key) {     Assert.notNull(key, "Key must not be null").     ApplicationContext context = this.contextMap.get(key).     if (context == null) {         this.missCount.incrementAndGet().     } else {         this.hitCount.incrementAndGet().     }     return context. }
true;public;2;15;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public void put(MergedContextConfiguration key, ApplicationContext context) {     Assert.notNull(key, "Key must not be null").     Assert.notNull(context, "ApplicationContext must not be null").     this.contextMap.put(key, context).     MergedContextConfiguration child = key.     MergedContextConfiguration parent = child.getParent().     while (parent != null) {         Set<MergedContextConfiguration> list = this.hierarchyMap.computeIfAbsent(parent, k -> new HashSet<>()).         list.add(child).         child = parent.         parent = child.getParent().     } }
true;public;2;33;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public void remove(MergedContextConfiguration key, @Nullable HierarchyMode hierarchyMode) {     Assert.notNull(key, "Key must not be null").     // startKey is the level at which to begin clearing the cache,     // depending on the configured hierarchy mode.s     MergedContextConfiguration startKey = key.     if (hierarchyMode == HierarchyMode.EXHAUSTIVE) {         MergedContextConfiguration parent = startKey.getParent().         while (parent != null) {             startKey = parent.             parent = startKey.getParent().         }     }     List<MergedContextConfiguration> removedContexts = new ArrayList<>().     remove(removedContexts, startKey).     // hierarchy map.     for (MergedContextConfiguration currentKey : removedContexts) {         for (Set<MergedContextConfiguration> children : this.hierarchyMap.values()) {             children.remove(currentKey).         }     }     // Remove empty entries from the hierarchy map.     for (MergedContextConfiguration currentKey : this.hierarchyMap.keySet()) {         if (this.hierarchyMap.get(currentKey).isEmpty()) {             this.hierarchyMap.remove(currentKey).         }     } }
false;private;2;21;;private void remove(List<MergedContextConfiguration> removedContexts, MergedContextConfiguration key) {     Assert.notNull(key, "Key must not be null").     Set<MergedContextConfiguration> children = this.hierarchyMap.get(key).     if (children != null) {         for (MergedContextConfiguration child : children) {             // Recurse through lower levels             remove(removedContexts, child).         }         // Remove the set of children for the current context from the hierarchy map.         this.hierarchyMap.remove(key).     }     // Physically remove and close leaf nodes first (i.e., on the way back up the     // stack as opposed to prior to the recursive call).     ApplicationContext context = this.contextMap.remove(key).     if (context instanceof ConfigurableApplicationContext) {         ((ConfigurableApplicationContext) context).close().     }     removedContexts.add(key). }
true;public;0;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public int size() {     return this.contextMap.size(). }
true;public;0;3;/**  * Get the maximum size of this cache.  */ ;/**  * Get the maximum size of this cache.  */ public int getMaxSize() {     return this.maxSize. }
true;public;0;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public int getParentContextCount() {     return this.hierarchyMap.size(). }
true;public;0;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public int getHitCount() {     return this.hitCount.get(). }
true;public;0;4;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public int getMissCount() {     return this.missCount.get(). }
true;public;0;7;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public void reset() {     synchronized (this.contextMap) {         clear().         clearStatistics().     } }
true;public;0;7;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public void clear() {     synchronized (this.contextMap) {         this.contextMap.clear().         this.hierarchyMap.clear().     } }
true;public;0;7;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public void clearStatistics() {     synchronized (this.contextMap) {         this.hitCount.set(0).         this.missCount.set(0).     } }
true;public;0;6;/**  * {@inheritDoc}  */ ;/**  * {@inheritDoc}  */ @Override public void logStatistics() {     if (statsLogger.isDebugEnabled()) {         statsLogger.debug("Spring test ApplicationContext cache statistics: " + this).     } }
true;public;0;10;/**  * Generate a text string containing the implementation type of this  * cache and its statistics.  * <p>The string returned by this method contains all information  * required for compliance with the contract for {@link #logStatistics()}.  * @return a string representation of this cache, including statistics  */ ;/**  * Generate a text string containing the implementation type of this  * cache and its statistics.  * <p>The string returned by this method contains all information  * required for compliance with the contract for {@link #logStatistics()}.  * @return a string representation of this cache, including statistics  */ @Override public String toString() {     return new ToStringCreator(this).append("size", size()).append("maxSize", getMaxSize()).append("parentContextCount", getParentContextCount()).append("hitCount", getHitCount()).append("missCount", getMissCount()).toString(). }
false;protected;1;11;;@Override protected boolean removeEldestEntry(Map.Entry<MergedContextConfiguration, ApplicationContext> eldest) {     if (this.size() > DefaultContextCache.this.getMaxSize()) {         // Do NOT delete "DefaultContextCache.this.". otherwise, we accidentally         // invoke java.util.Map.remove(Object, Object).         DefaultContextCache.this.remove(eldest.getKey(), HierarchyMode.CURRENT_LEVEL).     }     // Return false since we invoke a custom eviction algorithm.     return false. }
