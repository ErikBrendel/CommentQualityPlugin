# id;timestamp;commentText;codeText;commentWords;codeWords
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1397082962;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			AnnotationAttributes annAttrs = descriptor.getAnnotationAttributes()__			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles attributes [%s] for declaring class [%s].",_					annAttrs, declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annAttrs.getClass("resolver")__			if (!ActiveProfilesResolver.class.equals(resolverClass)) {_				String msg = String.format("Configuration error for test class [%s]: %s cannot be used "_						+ "in conjunction with custom resolver [%s].", rootDeclaringClass.getName(),_					getClass().getSimpleName(), resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			String[] profiles = annAttrs.getStringArray("profiles")__			String[] valueProfiles = annAttrs.getStringArray("value")__			boolean valueDeclared = !ObjectUtils.isEmpty(valueProfiles)__			boolean profilesDeclared = !ObjectUtils.isEmpty(profiles)___			if (valueDeclared && profilesDeclared) {_				String msg = String.format("Class [%s] has been configured with @ActiveProfiles' 'value' [%s] "_						+ "and 'profiles' [%s] attributes. Only one declaration of active bean "_						+ "definition profiles is permitted per @ActiveProfiles annotation.", declaringClass.getName(),_					ObjectUtils.nullSafeToString(valueProfiles), ObjectUtils.nullSafeToString(profiles))__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			if (valueDeclared) {_				profiles = valueProfiles__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,annotation,attributes,ann,attrs,descriptor,get,annotation,attributes,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,ann,attrs,get,class,resolver,if,active,profiles,resolver,class,equals,resolver,class,string,msg,string,format,configuration,error,for,test,class,s,s,cannot,be,used,in,conjunction,with,custom,resolver,s,root,declaring,class,get,name,get,class,get,simple,name,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,string,profiles,ann,attrs,get,string,array,profiles,string,value,profiles,ann,attrs,get,string,array,value,boolean,value,declared,object,utils,is,empty,value,profiles,boolean,profiles,declared,object,utils,is,empty,profiles,if,value,declared,profiles,declared,string,msg,string,format,class,s,has,been,configured,with,active,profiles,value,s,and,profiles,s,attributes,only,one,declaration,of,active,bean,definition,profiles,is,permitted,per,active,profiles,annotation,declaring,class,get,name,object,utils,null,safe,to,string,value,profiles,object,utils,null,safe,to,string,profiles,logger,error,msg,throw,new,illegal,state,exception,msg,if,value,declared,profiles,value,profiles,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1398153432;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			AnnotationAttributes annAttrs = descriptor.getAnnotationAttributes()__			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles attributes [%s] for declaring class [%s].",_					annAttrs, declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annAttrs.getClass("resolver")__			if (!ActiveProfilesResolver.class.equals(resolverClass)) {_				String msg = String.format("Configuration error for test class [%s]: %s cannot be used "_						+ "in conjunction with custom resolver [%s].", rootDeclaringClass.getName(),_					getClass().getSimpleName(), resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			String[] profiles = annAttrs.getStringArray("profiles")__			String[] valueProfiles = annAttrs.getStringArray("value")__			boolean valueDeclared = !ObjectUtils.isEmpty(valueProfiles)__			boolean profilesDeclared = !ObjectUtils.isEmpty(profiles)___			if (valueDeclared && profilesDeclared) {_				String msg = String.format("Class [%s] has been configured with @ActiveProfiles' 'value' [%s] "_						+ "and 'profiles' [%s] attributes. Only one declaration of active bean "_						+ "definition profiles is permitted per @ActiveProfiles annotation.", declaringClass.getName(),_					ObjectUtils.nullSafeToString(valueProfiles), ObjectUtils.nullSafeToString(profiles))__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			if (valueDeclared) {_				profiles = valueProfiles__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,annotation,attributes,ann,attrs,descriptor,get,annotation,attributes,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,ann,attrs,get,class,resolver,if,active,profiles,resolver,class,equals,resolver,class,string,msg,string,format,configuration,error,for,test,class,s,s,cannot,be,used,in,conjunction,with,custom,resolver,s,root,declaring,class,get,name,get,class,get,simple,name,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,string,profiles,ann,attrs,get,string,array,profiles,string,value,profiles,ann,attrs,get,string,array,value,boolean,value,declared,object,utils,is,empty,value,profiles,boolean,profiles,declared,object,utils,is,empty,profiles,if,value,declared,profiles,declared,string,msg,string,format,class,s,has,been,configured,with,active,profiles,value,s,and,profiles,s,attributes,only,one,declaration,of,active,bean,definition,profiles,is,permitted,per,active,profiles,annotation,declaring,class,get,name,object,utils,null,safe,to,string,value,profiles,object,utils,null,safe,to,string,profiles,logger,error,msg,throw,new,illegal,state,exception,msg,if,value,declared,profiles,value,profiles,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1413848647;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			AnnotationAttributes annAttrs = descriptor.getAnnotationAttributes()__			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles attributes [%s] for declaring class [%s].",_					annAttrs, declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annAttrs.getClass("resolver")__			if (!ActiveProfilesResolver.class.equals(resolverClass)) {_				String msg = String.format("Configuration error for test class [%s]: %s cannot be used "_						+ "in conjunction with custom resolver [%s].", rootDeclaringClass.getName(),_					getClass().getSimpleName(), resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			String[] profiles = annAttrs.getStringArray("profiles")__			String[] valueProfiles = annAttrs.getStringArray("value")__			boolean valueDeclared = !ObjectUtils.isEmpty(valueProfiles)__			boolean profilesDeclared = !ObjectUtils.isEmpty(profiles)___			if (valueDeclared && profilesDeclared) {_				String msg = String.format("Class [%s] has been configured with @ActiveProfiles' 'value' [%s] "_						+ "and 'profiles' [%s] attributes. Only one declaration of active bean "_						+ "definition profiles is permitted per @ActiveProfiles annotation.", declaringClass.getName(),_					ObjectUtils.nullSafeToString(valueProfiles), ObjectUtils.nullSafeToString(profiles))__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			if (valueDeclared) {_				profiles = valueProfiles__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,annotation,attributes,ann,attrs,descriptor,get,annotation,attributes,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,ann,attrs,get,class,resolver,if,active,profiles,resolver,class,equals,resolver,class,string,msg,string,format,configuration,error,for,test,class,s,s,cannot,be,used,in,conjunction,with,custom,resolver,s,root,declaring,class,get,name,get,class,get,simple,name,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,string,profiles,ann,attrs,get,string,array,profiles,string,value,profiles,ann,attrs,get,string,array,value,boolean,value,declared,object,utils,is,empty,value,profiles,boolean,profiles,declared,object,utils,is,empty,profiles,if,value,declared,profiles,declared,string,msg,string,format,class,s,has,been,configured,with,active,profiles,value,s,and,profiles,s,attributes,only,one,declaration,of,active,bean,definition,profiles,is,permitted,per,active,profiles,annotation,declaring,class,get,name,object,utils,null,safe,to,string,value,profiles,object,utils,null,safe,to,string,profiles,logger,error,msg,throw,new,illegal,state,exception,msg,if,value,declared,profiles,value,profiles,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1420918608;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> declaringClass = descriptor.getDeclaringClass()___			AnnotationAttributes annAttrs = descriptor.getAnnotationAttributes()__			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles attributes [%s] for declaring class [%s].",_					annAttrs, declaringClass.getName()))__			}__			String[] profiles = annAttrs.getStringArray("profiles")__			String[] valueProfiles = annAttrs.getStringArray("value")__			boolean valueDeclared = !ObjectUtils.isEmpty(valueProfiles)__			boolean profilesDeclared = !ObjectUtils.isEmpty(profiles)___			if (valueDeclared && profilesDeclared) {_				String msg = String.format("Class [%s] has been configured with @ActiveProfiles' 'value' [%s] "_						+ "and 'profiles' [%s] attributes. Only one declaration of active bean "_						+ "definition profiles is permitted per @ActiveProfiles annotation.", declaringClass.getName(),_					ObjectUtils.nullSafeToString(valueProfiles), ObjectUtils.nullSafeToString(profiles))__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			if (valueDeclared) {_				profiles = valueProfiles__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,declaring,class,descriptor,get,declaring,class,annotation,attributes,ann,attrs,descriptor,get,annotation,attributes,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,string,profiles,ann,attrs,get,string,array,profiles,string,value,profiles,ann,attrs,get,string,array,value,boolean,value,declared,object,utils,is,empty,value,profiles,boolean,profiles,declared,object,utils,is,empty,profiles,if,value,declared,profiles,declared,string,msg,string,format,class,s,has,been,configured,with,active,profiles,value,s,and,profiles,s,attributes,only,one,declaration,of,active,bean,definition,profiles,is,permitted,per,active,profiles,annotation,declaring,class,get,name,object,utils,null,safe,to,string,value,profiles,object,utils,null,safe,to,string,profiles,logger,error,msg,throw,new,illegal,state,exception,msg,if,value,declared,profiles,value,profiles,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1432246071;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> declaringClass = descriptor.getDeclaringClass()___			AnnotationAttributes annAttrs = descriptor.getAnnotationAttributes()__			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles attributes [%s] for declaring class [%s].",_					annAttrs, declaringClass.getName()))__			}__			for (String profile : annAttrs.getStringArray("profiles")) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,declaring,class,descriptor,get,declaring,class,annotation,attributes,ann,attrs,descriptor,get,annotation,attributes,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,for,string,profile,ann,attrs,get,string,array,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1432856630;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.getMergedAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			for (String profile : annotation.profiles()) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,get,merged,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,for,string,profile,annotation,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1434234880;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			for (String profile : annotation.profiles()) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,for,string,profile,annotation,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1434374706;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new LinkedHashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			for (String profile : annotation.profiles()) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,linked,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,for,string,profile,annotation,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1467730834;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new LinkedHashSet<>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			for (String profile : annotation.profiles()) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,linked,hash,set,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,for,string,profile,annotation,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1497341594;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new LinkedHashSet<>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			for (String profile : annotation.profiles()) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,linked,hash,set,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,for,string,profile,annotation,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
DefaultActiveProfilesResolver -> @Override 	public String[] resolve(Class<?> testClass);1530174524;Resolve the <em>bean definition profiles</em> for the given {@linkplain_Class test class} based on profiles configured declaratively via_{@link ActiveProfiles#profiles} or {@link ActiveProfiles#value}._@param testClass the test class for which the profiles should be resolved__never {@code null}_@return the list of bean definition profiles to use when loading the_{@code ApplicationContext}_ never {@code null};@Override_	public String[] resolve(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new LinkedHashSet<>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = findAnnotationDescriptor(testClass, annotationType)___		if (descriptor == null) {_			if (logger.isDebugEnabled()) {_				logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__			}_		}_		else {_			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			for (String profile : annotation.profiles()) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,the,em,bean,definition,profiles,em,for,the,given,linkplain,class,test,class,based,on,profiles,configured,declaratively,via,link,active,profiles,profiles,or,link,active,profiles,value,param,test,class,the,test,class,for,which,the,profiles,should,be,resolved,never,code,null,return,the,list,of,bean,definition,profiles,to,use,when,loading,the,code,application,context,never,code,null;override,public,string,resolve,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,linked,hash,set,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,if,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,else,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,for,string,profile,annotation,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
