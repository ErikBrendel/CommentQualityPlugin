commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;9;;private static XPathExpression compileXpathExpression(String expression, @Nullable Map<String, String> namespaces) throws XPathExpressionException {     SimpleNamespaceContext namespaceContext = new SimpleNamespaceContext().     namespaceContext.setBindings(namespaces != null ? namespaces : Collections.emptyMap()).     XPath xpath = XPathFactory.newInstance().newXPath().     xpath.setNamespaceContext(namespaceContext).     return xpath.compile(expression). }
true;protected;0;3;/**  * Return the compiled XPath expression.  */ ;/**  * Return the compiled XPath expression.  */ protected XPathExpression getXpathExpression() {     return this.xpathExpression. }
true;public;3;6;/**  * Parse the content, evaluate the XPath expression as a {@link Node},  * and assert it with the given {@code Matcher<Node>}.  */ ;/**  * Parse the content, evaluate the XPath expression as a {@link Node},  * and assert it with the given {@code Matcher<Node>}.  */ public void assertNode(byte[] content, @Nullable String encoding, final Matcher<? super Node> matcher) throws Exception {     Node node = evaluateXpath(content, encoding, Node.class).     MatcherAssert.assertThat("XPath " + this.expression, node, matcher). }
true;public;2;4;/**  * Apply the XPath expression and assert the resulting content exists.  * @throws Exception if content parsing or expression evaluation fails  */ ;/**  * Apply the XPath expression and assert the resulting content exists.  * @throws Exception if content parsing or expression evaluation fails  */ public void exists(byte[] content, @Nullable String encoding) throws Exception {     Node node = evaluateXpath(content, encoding, Node.class).     AssertionErrors.assertTrue("XPath " + this.expression + " does not exist", node != null). }
true;public;2;4;/**  * Apply the XPath expression and assert the resulting content does not exist.  * @throws Exception if content parsing or expression evaluation fails  */ ;/**  * Apply the XPath expression and assert the resulting content does not exist.  * @throws Exception if content parsing or expression evaluation fails  */ public void doesNotExist(byte[] content, @Nullable String encoding) throws Exception {     Node node = evaluateXpath(content, encoding, Node.class).     AssertionErrors.assertTrue("XPath " + this.expression + " exists", node == null). }
true;public;3;7;/**  * Apply the XPath expression and assert the resulting content with the  * given Hamcrest matcher.  * @throws Exception if content parsing or expression evaluation fails  */ ;/**  * Apply the XPath expression and assert the resulting content with the  * given Hamcrest matcher.  * @throws Exception if content parsing or expression evaluation fails  */ public void assertNodeCount(byte[] content, @Nullable String encoding, Matcher<Integer> matcher) throws Exception {     NodeList nodeList = evaluateXpath(content, encoding, NodeList.class).     String reason = "nodeCount for XPath " + this.expression.     MatcherAssert.assertThat(reason, nodeList != null ? nodeList.getLength() : 0, matcher). }
true;public;3;5;/**  * Apply the XPath expression and assert the resulting content as an integer.  * @throws Exception if content parsing or expression evaluation fails  */ ;/**  * Apply the XPath expression and assert the resulting content as an integer.  * @throws Exception if content parsing or expression evaluation fails  */ public void assertNodeCount(byte[] content, @Nullable String encoding, int expectedCount) throws Exception {     NodeList nodeList = evaluateXpath(content, encoding, NodeList.class).     AssertionErrors.assertEquals("nodeCount for XPath " + this.expression, expectedCount, (nodeList != null ? nodeList.getLength() : 0)). }
true;public;3;6;/**  * Apply the XPath expression and assert the resulting content with the  * given Hamcrest matcher.  * @throws Exception if content parsing or expression evaluation fails  */ ;/**  * Apply the XPath expression and assert the resulting content with the  * given Hamcrest matcher.  * @throws Exception if content parsing or expression evaluation fails  */ public void assertString(byte[] content, @Nullable String encoding, Matcher<? super String> matcher) throws Exception {     String actual = evaluateXpath(content, encoding, String.class).     MatcherAssert.assertThat("XPath " + this.expression, actual, matcher). }
true;public;3;4;/**  * Apply the XPath expression and assert the resulting content as a String.  * @throws Exception if content parsing or expression evaluation fails  */ ;/**  * Apply the XPath expression and assert the resulting content as a String.  * @throws Exception if content parsing or expression evaluation fails  */ public void assertString(byte[] content, @Nullable String encoding, String expectedValue) throws Exception {     String actual = evaluateXpath(content, encoding, String.class).     AssertionErrors.assertEquals("XPath " + this.expression, expectedValue, actual). }
true;public;3;4;/**  * Apply the XPath expression and assert the resulting content with the  * given Hamcrest matcher.  * @throws Exception if content parsing or expression evaluation fails  */ ;/**  * Apply the XPath expression and assert the resulting content with the  * given Hamcrest matcher.  * @throws Exception if content parsing or expression evaluation fails  */ public void assertNumber(byte[] content, @Nullable String encoding, Matcher<? super Double> matcher) throws Exception {     Double actual = evaluateXpath(content, encoding, Double.class).     MatcherAssert.assertThat("XPath " + this.expression, actual, matcher). }
true;public;3;4;/**  * Apply the XPath expression and assert the resulting content as a Double.  * @throws Exception if content parsing or expression evaluation fails  */ ;/**  * Apply the XPath expression and assert the resulting content as a Double.  * @throws Exception if content parsing or expression evaluation fails  */ public void assertNumber(byte[] content, @Nullable String encoding, Double expectedValue) throws Exception {     Double actual = evaluateXpath(content, encoding, Double.class).     AssertionErrors.assertEquals("XPath " + this.expression, expectedValue, actual). }
true;public;3;4;/**  * Apply the XPath expression and assert the resulting content as a Boolean.  * @throws Exception if content parsing or expression evaluation fails  */ ;/**  * Apply the XPath expression and assert the resulting content as a Boolean.  * @throws Exception if content parsing or expression evaluation fails  */ public void assertBoolean(byte[] content, @Nullable String encoding, boolean expectedValue) throws Exception {     String actual = evaluateXpath(content, encoding, String.class).     AssertionErrors.assertEquals("XPath " + this.expression, expectedValue, Boolean.parseBoolean(actual)). }
true;public;3;5;/**  * Evaluate the XPath and return the resulting value.  * @param content the content to evaluate against  * @param encoding the encoding to use (optionally)  * @param targetClass the target class, one of Number, String, Boolean,  * org.w3c.Node, or NodeList  * @throws Exception if content parsing or expression evaluation fails  * @since 5.1  */ ;/**  * Evaluate the XPath and return the resulting value.  * @param content the content to evaluate against  * @param encoding the encoding to use (optionally)  * @param targetClass the target class, one of Number, String, Boolean,  * org.w3c.Node, or NodeList  * @throws Exception if content parsing or expression evaluation fails  * @since 5.1  */ @Nullable public <T> T evaluateXpath(byte[] content, @Nullable String encoding, Class<T> targetClass) throws Exception {     Document document = parseXmlByteArray(content, encoding).     return evaluateXpath(document, toQName(targetClass), targetClass). }
true;protected;2;10;/**  * Parse the given XML content to a {@link Document}.  * @param xml the content to parse  * @param encoding optional content encoding, if provided as metadata (e.g. in HTTP headers)  * @return the parsed document  */ ;/**  * Parse the given XML content to a {@link Document}.  * @param xml the content to parse  * @param encoding optional content encoding, if provided as metadata (e.g. in HTTP headers)  * @return the parsed document  */ protected Document parseXmlByteArray(byte[] xml, @Nullable String encoding) throws Exception {     DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance().     factory.setNamespaceAware(this.hasNamespaces).     DocumentBuilder documentBuilder = factory.newDocumentBuilder().     InputSource inputSource = new InputSource(new ByteArrayInputStream(xml)).     if (StringUtils.hasText(encoding)) {         inputSource.setEncoding(encoding).     }     return documentBuilder.parse(inputSource). }
true;protected;3;7;/**  * Apply the XPath expression to given document.  * @throws XPathExpressionException if expression evaluation failed  */ ;/**  * Apply the XPath expression to given document.  * @throws XPathExpressionException if expression evaluation failed  */ @SuppressWarnings("unchecked") @Nullable protected <T> T evaluateXpath(Document document, QName evaluationType, Class<T> expectedClass) throws XPathExpressionException {     return (T) getXpathExpression().evaluate(document, evaluationType). }
false;private;1;23;;private <T> QName toQName(Class<T> expectedClass) {     QName evaluationType.     if (Number.class.isAssignableFrom(expectedClass)) {         evaluationType = XPathConstants.NUMBER.     } else if (CharSequence.class.isAssignableFrom(expectedClass)) {         evaluationType = XPathConstants.STRING.     } else if (Boolean.class.isAssignableFrom(expectedClass)) {         evaluationType = XPathConstants.BOOLEAN.     } else if (Node.class.isAssignableFrom(expectedClass)) {         evaluationType = XPathConstants.NODE.     } else if (NodeList.class.isAssignableFrom(expectedClass)) {         evaluationType = XPathConstants.NODESET.     } else {         throw new IllegalArgumentException("Unexpected target class " + expectedClass + ". " + "Supported: numbers, strings, boolean, and org.w3c.Node and NodeList").     }     return evaluationType. }
