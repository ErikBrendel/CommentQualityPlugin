commented;modifiers;parameterAmount;loc;comment;code
true;public;0;19;/**  * Evaluate the next {@link Statement} in the execution chain (typically an instance of  * {@link org.junit.internal.runners.statements.RunAfters RunAfters}), catching any  * exceptions thrown, and then invoke {@link TestContextManager#afterTestClass()}.  * <p>If the invocation of {@code afterTestClass()} throws an exception, it will also  * be tracked. Multiple exceptions will be combined into a {@link MultipleFailureException}.  */ ;/**  * Evaluate the next {@link Statement} in the execution chain (typically an instance of  * {@link org.junit.internal.runners.statements.RunAfters RunAfters}), catching any  * exceptions thrown, and then invoke {@link TestContextManager#afterTestClass()}.  * <p>If the invocation of {@code afterTestClass()} throws an exception, it will also  * be tracked. Multiple exceptions will be combined into a {@link MultipleFailureException}.  */ @Override public void evaluate() throws Throwable {     List<Throwable> errors = new ArrayList<>().     try {         this.next.evaluate().     } catch (Throwable ex) {         errors.add(ex).     }     try {         this.testContextManager.afterTestClass().     } catch (Throwable ex) {         errors.add(ex).     }     MultipleFailureException.assertEmpty(errors). }
