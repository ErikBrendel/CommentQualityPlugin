# id;timestamp;commentText;codeText;commentWords;codeWords
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1397082962;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}.__<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses.__@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(testClass,_			annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_				"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_				annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			AnnotationAttributes annAttrs = descriptor.getAnnotationAttributes()__			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles attributes [%s] for declaring class [%s].",_					annAttrs, declaringClass.getName()))__			}_			validateActiveProfilesConfiguration(declaringClass, annAttrs)___			Class<? extends ActiveProfilesResolver> resolverClass = annAttrs.getClass("resolver")__			if (ActiveProfilesResolver.class.equals(resolverClass)) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver = null__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception e) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of "_						+ "type [%s] for test class [%s].", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, e)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_					"ActiveProfilesResolver [%s] returned a null array of bean definition profiles.",_					resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}__			descriptor = annAttrs.getBoolean("inheritProfiles") ? MetaAnnotationUtils.findAnnotationDescriptor(_				rootDeclaringClass.getSuperclass(), annotationType) : null__		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,annotation,attributes,ann,attrs,descriptor,get,annotation,attributes,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,validate,active,profiles,configuration,declaring,class,ann,attrs,class,extends,active,profiles,resolver,resolver,class,ann,attrs,get,class,resolver,if,active,profiles,resolver,class,equals,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,null,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,e,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,e,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,descriptor,ann,attrs,get,boolean,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1413848647;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}.__<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses.__@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(testClass,_			annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_				"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_				annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			AnnotationAttributes annAttrs = descriptor.getAnnotationAttributes()__			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles attributes [%s] for declaring class [%s].",_					annAttrs, declaringClass.getName()))__			}_			validateActiveProfilesConfiguration(declaringClass, annAttrs)___			Class<? extends ActiveProfilesResolver> resolverClass = annAttrs.getClass("resolver")__			if (ActiveProfilesResolver.class.equals(resolverClass)) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver = null__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception e) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of "_						+ "type [%s] for test class [%s].", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, e)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_					"ActiveProfilesResolver [%s] returned a null array of bean definition profiles.",_					resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}__			descriptor = annAttrs.getBoolean("inheritProfiles") ? MetaAnnotationUtils.findAnnotationDescriptor(_				rootDeclaringClass.getSuperclass(), annotationType) : null__		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,annotation,attributes,ann,attrs,descriptor,get,annotation,attributes,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,validate,active,profiles,configuration,declaring,class,ann,attrs,class,extends,active,profiles,resolver,resolver,class,ann,attrs,get,class,resolver,if,active,profiles,resolver,class,equals,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,null,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,e,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,e,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,descriptor,ann,attrs,get,boolean,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1432125256;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}.__<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses.__@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(testClass,_			annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_				"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_				annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			AnnotationAttributes annAttrs = descriptor.getAnnotationAttributes()__			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles attributes [%s] for declaring class [%s].",_					annAttrs, declaringClass.getName()))__			}_			validateActiveProfilesConfiguration(declaringClass, annAttrs)___			Class<? extends ActiveProfilesResolver> resolverClass = annAttrs.getClass("resolver")__			if (ActiveProfilesResolver.class == resolverClass) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver = null__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception e) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of "_						+ "type [%s] for test class [%s].", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, e)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_					"ActiveProfilesResolver [%s] returned a null array of bean definition profiles.",_					resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}__			descriptor = annAttrs.getBoolean("inheritProfiles") ? MetaAnnotationUtils.findAnnotationDescriptor(_				rootDeclaringClass.getSuperclass(), annotationType) : null__		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,annotation,attributes,ann,attrs,descriptor,get,annotation,attributes,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,validate,active,profiles,configuration,declaring,class,ann,attrs,class,extends,active,profiles,resolver,resolver,class,ann,attrs,get,class,resolver,if,active,profiles,resolver,class,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,null,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,e,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,e,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,descriptor,ann,attrs,get,boolean,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1432246071;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}.__<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses.__@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(testClass,_			annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_				"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_				annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()___			AnnotationAttributes annAttrs = descriptor.getAnnotationAttributes()__			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles attributes [%s] for declaring class [%s].",_					annAttrs, declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annAttrs.getClass("resolver")__			if (ActiveProfilesResolver.class == resolverClass) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver = null__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception e) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of "_						+ "type [%s] for test class [%s].", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, e)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_					"ActiveProfilesResolver [%s] returned a null array of bean definition profiles.",_					resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}__			descriptor = annAttrs.getBoolean("inheritProfiles") ? MetaAnnotationUtils.findAnnotationDescriptor(_				rootDeclaringClass.getSuperclass(), annotationType) : null__		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,annotation,attributes,ann,attrs,descriptor,get,annotation,attributes,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,attributes,s,for,declaring,class,s,ann,attrs,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,ann,attrs,get,class,resolver,if,active,profiles,resolver,class,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,null,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,e,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,e,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,descriptor,ann,attrs,get,boolean,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1432856630;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}.__<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses.__@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(testClass,_			annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_				"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_				annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.getMergedAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annotation.resolver()__			if (ActiveProfilesResolver.class == resolverClass) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver = null__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception e) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of "_						+ "type [%s] for test class [%s].", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, e)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_					"ActiveProfilesResolver [%s] returned a null array of bean definition profiles.",_					resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}__			descriptor = (annotation.inheritProfiles() ? MetaAnnotationUtils.findAnnotationDescriptor(_				rootDeclaringClass.getSuperclass(), annotationType) : null)__		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,get,merged,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,annotation,resolver,if,active,profiles,resolver,class,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,null,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,e,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,e,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,descriptor,annotation,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1434234880;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}.__<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses.__@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final Set<String> activeProfiles = new HashSet<String>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(testClass,_			annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_				"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_				annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annotation.resolver()__			if (ActiveProfilesResolver.class == resolverClass) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver = null__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception e) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of "_						+ "type [%s] for test class [%s].", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, e)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_					"ActiveProfilesResolver [%s] returned a null array of bean definition profiles.",_					resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}__			descriptor = (annotation.inheritProfiles() ? MetaAnnotationUtils.findAnnotationDescriptor(_				rootDeclaringClass.getSuperclass(), annotationType) : null)__		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,set,string,active,profiles,new,hash,set,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,annotation,resolver,if,active,profiles,resolver,class,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,null,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,e,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,e,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,descriptor,annotation,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1434374706;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}.__<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses.__@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<String[]> profileArrays = new ArrayList<String[]>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(testClass,_			annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_				"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_				annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annotation.resolver()__			if (ActiveProfilesResolver.class == resolverClass) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver = null__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception e) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of "_						+ "type [%s] for test class [%s].", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, e)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_					"ActiveProfilesResolver [%s] returned a null array of bean definition profiles.",_					resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			profileArrays.add(profiles)___			descriptor = (annotation.inheritProfiles() ? MetaAnnotationUtils.findAnnotationDescriptor(_				rootDeclaringClass.getSuperclass(), annotationType) : null)__		}__		_		Collections.reverse(profileArrays)___		final Set<String> activeProfiles = new LinkedHashSet<String>()__		for (String[] profiles : profileArrays) {_			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,string,profile,arrays,new,array,list,string,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,annotation,resolver,if,active,profiles,resolver,class,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,null,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,e,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,e,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,profile,arrays,add,profiles,descriptor,annotation,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,collections,reverse,profile,arrays,final,set,string,active,profiles,new,linked,hash,set,string,for,string,profiles,profile,arrays,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1467730834;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}.__<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses.__@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<String[]> profileArrays = new ArrayList<>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor = MetaAnnotationUtils.findAnnotationDescriptor(testClass,_			annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_				"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_				annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].", annotation,_					declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annotation.resolver()__			if (ActiveProfilesResolver.class == resolverClass) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver = null__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception e) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of "_						+ "type [%s] for test class [%s].", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, e)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_					"ActiveProfilesResolver [%s] returned a null array of bean definition profiles.",_					resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			profileArrays.add(profiles)___			descriptor = (annotation.inheritProfiles() ? MetaAnnotationUtils.findAnnotationDescriptor(_				rootDeclaringClass.getSuperclass(), annotationType) : null)__		}__		_		Collections.reverse(profileArrays)___		final Set<String> activeProfiles = new LinkedHashSet<>()__		for (String[] profiles : profileArrays) {_			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,string,profile,arrays,new,array,list,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,annotation,resolver,if,active,profiles,resolver,class,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,null,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,e,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,e,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,profile,arrays,add,profiles,descriptor,annotation,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,collections,reverse,profile,arrays,final,set,string,active,profiles,new,linked,hash,set,for,string,profiles,profile,arrays,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1470831642;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}._<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses._@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<String[]> profileArrays = new ArrayList<>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor =_				MetaAnnotationUtils.findAnnotationDescriptor(testClass, annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s].",_						annotation, declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annotation.resolver()__			if (ActiveProfilesResolver.class == resolverClass) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception ex) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of type [%s] " +_						"for test class [%s].", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, ex)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_						"ActiveProfilesResolver [%s] returned a null array of bean definition profiles.",_						resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			profileArrays.add(profiles)___			descriptor = (annotation.inheritProfiles() ? MetaAnnotationUtils.findAnnotationDescriptor(_					rootDeclaringClass.getSuperclass(), annotationType) : null)__		}__		_		Collections.reverse(profileArrays)___		final Set<String> activeProfiles = new LinkedHashSet<>()__		for (String[] profiles : profileArrays) {_			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,string,profile,arrays,new,array,list,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,annotation,resolver,if,active,profiles,resolver,class,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,ex,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,ex,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,profile,arrays,add,profiles,descriptor,annotation,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,collections,reverse,profile,arrays,final,set,string,active,profiles,new,linked,hash,set,for,string,profiles,profile,arrays,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1470840141;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}._<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses._@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<String[]> profileArrays = new ArrayList<>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor =_				MetaAnnotationUtils.findAnnotationDescriptor(testClass, annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s]",_						annotation, declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annotation.resolver()__			if (ActiveProfilesResolver.class == resolverClass) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception ex) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of type [%s] " +_						"for test class [%s]", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, ex)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (profiles == null) {_				String msg = String.format(_						"ActiveProfilesResolver [%s] returned a null array of bean definition profiles",_						resolverClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg)__			}__			profileArrays.add(profiles)___			descriptor = (annotation.inheritProfiles() ? MetaAnnotationUtils.findAnnotationDescriptor(_					rootDeclaringClass.getSuperclass(), annotationType) : null)__		}__		_		Collections.reverse(profileArrays)___		final Set<String> activeProfiles = new LinkedHashSet<>()__		for (String[] profiles : profileArrays) {_			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,string,profile,arrays,new,array,list,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,annotation,resolver,if,active,profiles,resolver,class,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,ex,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,ex,string,profiles,resolver,resolve,root,declaring,class,if,profiles,null,string,msg,string,format,active,profiles,resolver,s,returned,a,null,array,of,bean,definition,profiles,resolver,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,profile,arrays,add,profiles,descriptor,annotation,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,collections,reverse,profile,arrays,final,set,string,active,profiles,new,linked,hash,set,for,string,profiles,profile,arrays,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
ActiveProfilesUtils -> static String[] resolveActiveProfiles(Class<?> testClass);1496955179;Resolve <em>active bean definition profiles</em> for the supplied {@link Class}._<p>Note that the {@link ActiveProfiles#inheritProfiles inheritProfiles} flag of_{@link ActiveProfiles @ActiveProfiles} will be taken into consideration._Specifically, if the {@code inheritProfiles} flag is set to {@code true}, profiles_defined in the test class will be merged with those defined in superclasses._@param testClass the class for which to resolve the active profiles (must not be_{@code null})_@return the set of active profiles for the specified class, including active_profiles from superclasses if appropriate (never {@code null})_@see ActiveProfiles_@see ActiveProfilesResolver_@see org.springframework.context.annotation.Profile;static String[] resolveActiveProfiles(Class<?> testClass) {_		Assert.notNull(testClass, "Class must not be null")___		final List<String[]> profileArrays = new ArrayList<>()___		Class<ActiveProfiles> annotationType = ActiveProfiles.class__		AnnotationDescriptor<ActiveProfiles> descriptor =_				MetaAnnotationUtils.findAnnotationDescriptor(testClass, annotationType)__		if (descriptor == null && logger.isDebugEnabled()) {_			logger.debug(String.format(_					"Could not find an 'annotation declaring class' for annotation type [%s] and class [%s]",_					annotationType.getName(), testClass.getName()))__		}__		while (descriptor != null) {_			Class<?> rootDeclaringClass = descriptor.getRootDeclaringClass()__			Class<?> declaringClass = descriptor.getDeclaringClass()__			ActiveProfiles annotation = descriptor.synthesizeAnnotation()___			if (logger.isTraceEnabled()) {_				logger.trace(String.format("Retrieved @ActiveProfiles [%s] for declaring class [%s]",_						annotation, declaringClass.getName()))__			}__			Class<? extends ActiveProfilesResolver> resolverClass = annotation.resolver()__			if (ActiveProfilesResolver.class == resolverClass) {_				resolverClass = DefaultActiveProfilesResolver.class__			}__			ActiveProfilesResolver resolver__			try {_				resolver = BeanUtils.instantiateClass(resolverClass, ActiveProfilesResolver.class)__			}_			catch (Exception ex) {_				String msg = String.format("Could not instantiate ActiveProfilesResolver of type [%s] " +_						"for test class [%s]", resolverClass.getName(), rootDeclaringClass.getName())__				logger.error(msg)__				throw new IllegalStateException(msg, ex)__			}__			String[] profiles = resolver.resolve(rootDeclaringClass)__			if (!ObjectUtils.isEmpty(profiles)) {_				profileArrays.add(profiles)__			}__			descriptor = (annotation.inheritProfiles() ? MetaAnnotationUtils.findAnnotationDescriptor(_					rootDeclaringClass.getSuperclass(), annotationType) : null)__		}__		_		Collections.reverse(profileArrays)___		final Set<String> activeProfiles = new LinkedHashSet<>()__		for (String[] profiles : profileArrays) {_			for (String profile : profiles) {_				if (StringUtils.hasText(profile)) {_					activeProfiles.add(profile.trim())__				}_			}_		}__		return StringUtils.toStringArray(activeProfiles)__	};resolve,em,active,bean,definition,profiles,em,for,the,supplied,link,class,p,note,that,the,link,active,profiles,inherit,profiles,inherit,profiles,flag,of,link,active,profiles,active,profiles,will,be,taken,into,consideration,specifically,if,the,code,inherit,profiles,flag,is,set,to,code,true,profiles,defined,in,the,test,class,will,be,merged,with,those,defined,in,superclasses,param,test,class,the,class,for,which,to,resolve,the,active,profiles,must,not,be,code,null,return,the,set,of,active,profiles,for,the,specified,class,including,active,profiles,from,superclasses,if,appropriate,never,code,null,see,active,profiles,see,active,profiles,resolver,see,org,springframework,context,annotation,profile;static,string,resolve,active,profiles,class,test,class,assert,not,null,test,class,class,must,not,be,null,final,list,string,profile,arrays,new,array,list,class,active,profiles,annotation,type,active,profiles,class,annotation,descriptor,active,profiles,descriptor,meta,annotation,utils,find,annotation,descriptor,test,class,annotation,type,if,descriptor,null,logger,is,debug,enabled,logger,debug,string,format,could,not,find,an,annotation,declaring,class,for,annotation,type,s,and,class,s,annotation,type,get,name,test,class,get,name,while,descriptor,null,class,root,declaring,class,descriptor,get,root,declaring,class,class,declaring,class,descriptor,get,declaring,class,active,profiles,annotation,descriptor,synthesize,annotation,if,logger,is,trace,enabled,logger,trace,string,format,retrieved,active,profiles,s,for,declaring,class,s,annotation,declaring,class,get,name,class,extends,active,profiles,resolver,resolver,class,annotation,resolver,if,active,profiles,resolver,class,resolver,class,resolver,class,default,active,profiles,resolver,class,active,profiles,resolver,resolver,try,resolver,bean,utils,instantiate,class,resolver,class,active,profiles,resolver,class,catch,exception,ex,string,msg,string,format,could,not,instantiate,active,profiles,resolver,of,type,s,for,test,class,s,resolver,class,get,name,root,declaring,class,get,name,logger,error,msg,throw,new,illegal,state,exception,msg,ex,string,profiles,resolver,resolve,root,declaring,class,if,object,utils,is,empty,profiles,profile,arrays,add,profiles,descriptor,annotation,inherit,profiles,meta,annotation,utils,find,annotation,descriptor,root,declaring,class,get,superclass,annotation,type,null,collections,reverse,profile,arrays,final,set,string,active,profiles,new,linked,hash,set,for,string,profiles,profile,arrays,for,string,profile,profiles,if,string,utils,has,text,profile,active,profiles,add,profile,trim,return,string,utils,to,string,array,active,profiles
